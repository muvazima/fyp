@&#MAIN-TITLE@&#A Branch-and-Price algorithm for stable workforce assignments with hierarchical skills

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A real-life problem of finding stable workforce assignments is studied.


                        
                        
                           
                           A new and compact IP model is developed.


                        
                        
                           
                           The problem is reformulated as an IP model with set packing structure, and Column Generation is employed.


                        
                        
                           
                           The pricing problem amounts to finding a team with replacement weight coefficients in objective


                        
                        
                           
                           Stability is used in reducing the problem size after branching decisions.


                        
                        
                           
                           The Branch-and-Price has significantly increased the instance size that can be solved within a given time limit.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Workforce assignment with hierarchical skills

Stable assignments

Column generation

Branch-and-Price

@&#ABSTRACT@&#


               
               
                  This paper deals with assigning hierarchically skilled technicians to jobs by considering preferences. We investigate stability definitions in multi-skill workforce assignments stemming from the notion of blocking pairs as stated in the Marriage model of Gale–Shapley. We propose a Branch-and-Price approach to find a stable workforce assignment in which no technician and job pair can be better off by replacing an already assigned technician in current team of the job. As base for our exact algorithm, we give a reformulation of the problem which constructs a stable assignment by selecting teams from a base set. Then, the pricing problem accounts finding a team to a job. We provide details of the algorithm and show its efficiency by means of a computational study. We also show that checking stability becomes NP-hard, if replacing groups of technicians is considered in defining stability.
               
            

@&#INTRODUCTION@&#

Skill management becomes a critical task as specialization in production and management increases. Besides the efficient use of available skills, satisfying the preferences of employees is necessary to provide good working conditions. A recent literature review of van den, Belin, de Bruecker, Demeulemeester, and de Boeck (2013) concludes that companies more and more consider employee preferences to satisfy the workforce and to allow them flexibly manage their personal lives. Especially, if the skill distribution among available workers as well as the skill requirements of jobs are heterogeneous, a systematic approach becomes more crucial.

In this paper, we consider the problem of assigning technicians to jobs. In our assignment problem, jobs require certain skills at hierarchical skill levels, and they can be performed if and only if the cumulative skills of assigned technicians are at least the required ones. Jobs represent the workload of one workday, that may attract technician due to their starting times, geographic location, working conditions and so on. Technicians also have different personalities besides their skill levels, working in a team more effectively, easily getting stressed, and so on. Due to aforementioned reasons, some jobs may be preferred more than others by a technician and vice versa. Preferences of both technicians and jobs are assumed to be strict and complete.

According to the notion of stability considered in this paper, a technician-job assignment is stable if there is no technician-job pair such that they are better off by replacing the technician with another one in the current team of the job. This stable workforce assignment problem is introduced by Fırat, Hurkens, and Laugier (2012), and called Stable Technician-Job Assignment Problem, shortly the STJAP. The authors show that a special case of the STJAP is NP-complete by a reduction to the 3-dimensional Matching Problem.

Our contribution in this field follows two directions building upon the foundation laid in Fırat et al. (2012). First, we consider a natural generalization of the problem setting presented by the authors. Our main result here is that the problem to check stability of a given feasible assignment is strongly NP-hard. This is in contrast to the classic result regarding many-to-one matchings where stability regarding groups of technicians is implied by stability regarding individual technicians in the absence of skill requirements, see (Roth & Sotomayor, 1990). Second, we present a new formulation of the STJAP. We then reformulate it in order to employ Branch-and-Price (B&P) method. In our computational study, we describe a benchmark algorithm, additional to directly solving the Integer Programming (IP) model, and compare performances of all methods by gradually increasing the size of generated problem instances. The results show that the B&P algorithm clearly outperforms the benchmark algorithms.

This paper is organized as follows. In Section 2, we propose a new IP model for stable workforce assignments and consider a more general version of the problem. Related literature is reviewed briefly in Section 3. In Section 4 the B&P procedure is outlined. We evaluate our algorithm in Section 5 and conclude the paper in Section 6.

In this section we detail all concepts incorporated. We, then, pick up the problem definition from Fırat et al. (2012) in Section 2.1 and introduce a more general setting in Section 2.2.

In our workforce assignment problem, skills are categorized as skill domains in 
                                 
                                    S
                                    =
                                    {
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    |
                                    S
                                    |
                                    }
                                    ,
                                 
                               and the degree of expertise within each domain is interpreted by hierarchical skill levels in 
                                 
                                    L
                                    =
                                    {
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    |
                                    L
                                    |
                                    }
                                 
                              . We assume that possessing a skill (l, s) ∈ L × S implies possessing lower level skills (l′, s) for l′ < l.

We are given a set T of technicians. Each technician t ∈ T has skills Skt
                               ∈ {0, 1}|L| × |S| such that 
                                 
                                    S
                                    
                                       k
                                       t
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    ≤
                                    S
                                    
                                       k
                                       t
                                       
                                          (
                                          
                                             l
                                             ′
                                          
                                          ,
                                          s
                                          )
                                       
                                    
                                 
                               for l′ ≤ l in every s ∈ S. For example, in an instance with 
                                 
                                    |
                                    L
                                    |
                                    =
                                    3
                                    ,
                                 
                              
                              
                                 
                                    |
                                    S
                                    |
                                    =
                                    4
                                    ,
                                 
                               skills of technician t may be

                                 
                                    
                                       
                                          S
                                          
                                             k
                                             t
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              where t is expert in domain 1 due to 
                                 
                                    S
                                    
                                       k
                                       
                                          t
                                       
                                       
                                          (
                                          3
                                          ,
                                          1
                                          )
                                       
                                    
                                    =
                                    1
                                 
                              . He qualifies to level 2 in domain 3, but not qualified in domains 2 and 4. In fact, expressing skills of technicians by skill vectors could be a more compact way, however matrices are more convenient to formulate our problem. Technicians can use their skills simultaneously in all domains while processing a job, see (Fırat et al., 2012).

We are given a set J of jobs, each having skill requirements 
                                 
                                    R
                                    Q
                                    ∈
                                    
                                       
                                          {
                                          
                                             {
                                             0
                                             }
                                          
                                          ∪
                                          
                                             Z
                                             +
                                          
                                          }
                                       
                                       
                                          |
                                          L
                                          |
                                          ×
                                          |
                                          S
                                          |
                                       
                                    
                                 
                              . In order to perform job j ∈ J, for every skill (l, s) at least 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                 
                               technicians should be qualified in a team. Besides cumulatively expressing skill requirements by RQ (s.t. 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          
                                             l
                                             ′
                                          
                                          ,
                                          s
                                          )
                                       
                                    
                                    ≥
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                 
                               for each l′ ≤ l), they may also be expressed explicitly as

                                 
                                    (1)
                                    
                                       
                                          R
                                          
                                             Q
                                             
                                                j
                                             
                                             
                                                *
                                                (
                                                l
                                                ,
                                                s
                                                )
                                             
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         R
                                                         
                                                            Q
                                                            
                                                               j
                                                            
                                                            
                                                               (
                                                               l
                                                               ,
                                                               s
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            l
                                                            =
                                                            |
                                                            L
                                                            |
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         R
                                                         
                                                            Q
                                                            
                                                               j
                                                            
                                                            
                                                               (
                                                               l
                                                               ,
                                                               s
                                                               )
                                                            
                                                         
                                                         −
                                                         R
                                                         
                                                            Q
                                                            
                                                               j
                                                            
                                                            
                                                               (
                                                               l
                                                               +
                                                               1
                                                               ,
                                                               s
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            l
                                                            <
                                                            |
                                                            L
                                                            |
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          ∀
                                          s
                                          ∈
                                          
                                             |
                                             S
                                             |
                                          
                                          .
                                       
                                    
                                 
                              
                           

Given explicit skill requirements 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       *
                                    
                                 
                               for job j, cumulative skill requirements are 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          ℓ
                                          =
                                          l
                                       
                                       
                                          |
                                          L
                                          |
                                       
                                    
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          *
                                          (
                                          ℓ
                                          ,
                                          s
                                          )
                                       
                                    
                                    ,
                                 
                               for all (l, s). For example, in an instance with 
                                 
                                    |
                                    L
                                    |
                                    =
                                    3
                                 
                               and 
                                 
                                    |
                                    S
                                    |
                                    =
                                    4
                                    ,
                                 
                               cumulative and explicit skill requirements of job j may be

                                 
                                    
                                       
                                          R
                                          
                                             Q
                                             j
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   
                                                      5
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      4
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      3
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                             )
                                          
                                          ⇔
                                          R
                                          
                                             Q
                                             
                                                j
                                             
                                             *
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           

Given job j ∈ J and technician t ∈ T, the set N(j, t) of contributing skills includes skill (l, s) if and only if 
                                 
                                    S
                                    
                                       k
                                       
                                          t
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    =
                                    1
                                 
                               and 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          *
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    >
                                    0
                                 
                              . For the above examples of t and j we have 
                                 
                                    N
                                    (
                                    j
                                    ,
                                    t
                                    )
                                    =
                                    {
                                    (
                                    1
                                    ,
                                    1
                                    )
                                    ,
                                    (
                                    2
                                    ,
                                    1
                                    )
                                    ,
                                    (
                                    3
                                    ,
                                    1
                                    )
                                    ,
                                    (
                                    1
                                    ,
                                    3
                                    )
                                    ,
                                    (
                                    2
                                    ,
                                    3
                                    )
                                    }
                                 
                              .

Technicians (jobs) have a strict preference ordering over jobs (technicians). We denote j > 
                                 t
                              
                              j′ if technician t prefers job j to j′. Similarly, t > 
                                 j
                              
                              t′ means that job j prefers technician t to t′. Also, we assume that preferences are complete.

A workforce assignment μ matches technicians to jobs such that every technician is assigned to at most one job. The team of job j, denoted by μ(j), is the set of technicians assigned to job j under assignment μ. Similarly, μ(t) denotes the job technician t is assigned under μ. Team μ(j) has cumulative skills 
                                 
                                    S
                                    
                                       k
                                       
                                          μ
                                          (
                                          j
                                          )
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          μ
                                          (
                                          j
                                          )
                                       
                                    
                                    S
                                    
                                       k
                                       t
                                    
                                 
                              . A pair of a job and a team, assigned to each other, is referred to as job-team-assignment (JTA) in the following. We denote the JTA of job j under μ as (j, μ(j)).

An explicitly required skill (l, s) of job j, i.e. 
                                 
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          *
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    >
                                    0
                                    ,
                                 
                               is critical with respect to team μ(j), if it is tightly satisfied, i.e. 
                                 
                                    S
                                    
                                       k
                                       
                                          μ
                                          (
                                          j
                                          )
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    =
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                 
                              . The set of critical skills of JTA (j, μ(j)) is denoted by Cr(j, μ(j)).

A JTA (j, μ(j)) is skill-feasible if 
                                 
                                    S
                                    
                                       k
                                       
                                          μ
                                          (
                                          j
                                          )
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    ≥
                                    R
                                    
                                       Q
                                       
                                          j
                                       
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                 
                               for each (l, s). We say a technician t in μ(j) is idle if t does not contribute any critical skill of μ(j). Finally, team μ(j) is called proper if it is skill-feasible and if it has no idle technician.

                                 Definition 1
                                 Assignment μ is feasible, if every job in J is assigned to a proper team.

We say technician t can replace technician t′ in μ(j) if

                                 
                                    •
                                    
                                       t′ ∈ μ(j) while 
                                          
                                             t
                                             ∉
                                             μ
                                             (
                                             j
                                             )
                                             ,
                                          
                                       
                                    


                                       t possesses all critical skills t′ contributes, i.e. Cr(j, μ(j)) ∩ N(j, t′)⊆N(j, t).

Additionally, we generalize replacements to sets of technicians. We say T′ can replace T′′ in the team of job j if T′′⊆μ(j), 
                                 
                                    μ
                                    
                                       (
                                       j
                                       )
                                    
                                    ∩
                                    
                                       T
                                       ′
                                    
                                    =
                                    ∅
                                    ,
                                 
                               and (j, (μ(j)∖T′′) ∪ T′) is a proper JTA.

We pick up a definition of stability from Fırat et al. (2012) which is inspired from the notion of stability definition in the Marriage problem of Gale and Shapley (1962): A marriage is called “stable” if and only if there is no man-woman pair such that they prefer each other to their current partners. Such a pair is said to block the marriage, hence is called blocking pair. Given a feasible assignment μ, we say triple (t′, j, t) blocks μ if

                           
                              •
                              
                                 j > 
                                    t
                                 
                                 μ(t),


                                 t can replace t′ in μ(j) such that t > 
                                    j
                                 
                                 t′.

A feasible assignment μ is stable if and only if no triple blocks it.

NP-completeness of finding a feasible workforce assignment is proven by Fırat et al. (2012) with a reduction from 3-Dimensional Matching problem. This implies that STJAP is NP-complete as well.

Next, we formulate the STJAP as an IP model which is compact in the sense of having less decision variables and less constraints compared to the IP model proposed in the literature. We will detail this after presenting our IP model.

                           
                              •
                              Binary decision variable θtj
                                  indicates that technician t is assigned to job j,

Binary decision variable 
                                    
                                       ξ
                                       j
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                  indicates if skill (l, s) is critical with respect to the team of job j.

Inequalities (3) ensure that skill requirements of jobs are satisfied by the assigned technicians as 
                           
                              
                                 ∑
                                 
                                    t
                                    ∈
                                    T
                                 
                              
                              S
                              
                                 k
                                 
                                    t
                                 
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              
                                 θ
                                 
                                    t
                                    j
                                 
                              
                              −
                              R
                              
                                 Q
                                 j
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                           
                         needs to be non-negative. Moreover, 
                           
                              ξ
                              j
                              
                                 (
                                 l
                                 ,
                                 s
                                 )
                              
                           
                         is set to 1 if the requirement is fulfilled tightly and 
                           
                              ξ
                              j
                              
                                 (
                                 l
                                 ,
                                 s
                                 )
                              
                           
                         is set to 0 if the requirement is fulfilled with slack. Constraints (4) allow each technician to be in at most one team. Concluding, constraints (3) and (4) ensure an assignment with a skill-feasible JTA for each job.

Inequalities (5) state that if t is assigned to j, then there has to be at least one critical skill of the JTA of j among the skills t is contributing for j. Hence, constraints (3) to (5) ensure a feasible assignment.

Finally, stability is ensured by inequalities (6). For each triple (t′, j, t) which may block an assignment since t > 
                           j
                        
                        t′ at least one of the following must hold: (i) t′ is not assigned to j, (ii) t is assigned to j or to a job t prefers to j, or (iii) there is a critical skill of j’s JTA that is contributed by t′ and cannot be contributed by t.

The IP model by Fırat et al. (2012) compares to the one developed above as follows. It has the same binary variables representing assignments and critical skills, namely θ and ξ, but it has two more sets of binary variables which are not necessary in the model above. Moreover, our model employs a number of constraints which is significantly lower than the number of constraints in the model by Fırat et al. (2012). To sum up, our IP model uses less constraints and a (strict) subset of the binary variables of the IP model of Fırat et al. (2012).

We generalize the notion of stability considered in Section 2.1. Note that according to Definition 2 an assignment μ is considered stable if there is no pair of technicians t and t′ such that t can replace t′ in the team of job μ(t′). Note that in this case μ may be rather bad with regard to preferences and it may very well be that replacing multiple technicians in the team of job j by other technicians simultaneously yields a proper JTA for j. Hence, we generalize the stability definition as given in Section 2.1 to account for simultaneous replacements of multiple technicians.

Given a feasible assignment μ we say that triplet (T′′, j, T′) blocks μ if

                           
                              •
                              
                                 
                                    
                                       j
                                       
                                          >
                                          
                                             t
                                             ′
                                          
                                       
                                       μ
                                       
                                          (
                                          
                                             t
                                             ′
                                          
                                          )
                                       
                                    
                                  for each t′ ∈ T′,


                                 t′ > 
                                    j
                                 
                                 t′′ for each t′ ∈ T′ and t′′ ∈ T′′, and


                                 T′ can replace T′′ in the team of job j.

A feasible assignment μ is stable with regard to sets of technicians if and only if no triplet (T′′, j, T′) blocks it.

Note that we chose a very restrictive definition of blocking triplets. Arguably, there are many others that can be considered reasonable. However, we will first proof our main result in this section and discuss afterwards how this result carries over to alternative definitions of blocking triplets.

                           Theorem 4
                           
                              Deciding whether a feasible assignment is stable with regard to sets of technicians is strongly NP-hard for
                              
                                 
                                    |
                                    J
                                    |
                                    =
                                    2
                                 
                               
                              and
                              
                                 
                                    |
                                    L
                                    |
                                    =
                                    1
                                 
                              
                              .
                           

We prove the theorem by reduction from Exact Cover by 3-Sets (X3C) which is well-known to be NP-complete in the strong sense (Garey & Johnson, 1979) and is restated in the following.

X3C:

Given a set 
                                 
                                    X
                                    =
                                    {
                                    1
                                    ,
                                    …
                                    ,
                                    3
                                    q
                                    }
                                 
                               and a collection C of 3-element subsets of X. Can we find a subset C′ of C where every element of X occurs in exactly one member of C′?

Given an instance I of X3C we construct an instance I′ of STJAP-setS as follows.

                                 
                                    •
                                    We consider set 
                                          
                                             S
                                             =
                                             {
                                             1
                                             ,
                                             …
                                             ,
                                             3
                                             q
                                             }
                                          
                                        of skill domains corresponding to elements in X and a single skill level only, that is 
                                          
                                             |
                                             L
                                             |
                                             =
                                             1
                                          
                                       .

We have 
                                          
                                             |
                                             J
                                             |
                                             =
                                             2
                                          
                                        jobs j and j′. Job j has a requirement of two technicians for each skill, that is 
                                          
                                             R
                                             
                                                Q
                                                j
                                                
                                                   (
                                                   1
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             =
                                             2
                                          
                                        for each s ∈ S. Job j′ has requirement 
                                          
                                             R
                                             
                                                Q
                                                
                                                   
                                                      j
                                                      ′
                                                   
                                                
                                                
                                                   (
                                                   1
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             =
                                             
                                                n
                                                s
                                             
                                          
                                        for each s ∈ S where ns
                                        is the number of times the sth
                                        element of X is contained in an element of C.

We consider a set 
                                          
                                             T
                                             =
                                             {
                                             1
                                             ,
                                             …
                                             ,
                                             |
                                             C
                                             |
                                             +
                                             1
                                             +
                                             3
                                             q
                                             }
                                          
                                        of technicians. Technician 
                                          
                                             t
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             |
                                             C
                                             |
                                          
                                        corresponds to the tth element in C and has skill (1, s) if and only if the element in X corresponding to s is in the tth element of C. Technician 
                                          
                                             |
                                             C
                                             |
                                             +
                                             1
                                          
                                        has skill (1, s) for each s ∈ S. Finally, technician 
                                          
                                             t
                                             =
                                             |
                                             C
                                             |
                                             +
                                             2
                                             ,
                                             …
                                             ,
                                             |
                                             C
                                             |
                                             +
                                             1
                                             +
                                             3
                                             q
                                          
                                        has skill 
                                          
                                             (
                                             1
                                             ,
                                             t
                                             −
                                             |
                                             C
                                             |
                                             −
                                             1
                                             )
                                          
                                        only.

Job j′ prefers each technician in 
                                          
                                             {
                                             1
                                             ,
                                             …
                                             ,
                                             |
                                             C
                                             |
                                             }
                                          
                                        to all other technicians. Job j prefers each technician in 
                                          
                                             {
                                             |
                                             C
                                             |
                                             +
                                             2
                                             ,
                                             …
                                             ,
                                             |
                                             C
                                             |
                                             +
                                             1
                                             +
                                             3
                                             q
                                             }
                                          
                                        to all other technicians. Furthermore, j prefers each technician to technician 
                                          
                                             |
                                             C
                                             |
                                             +
                                             1
                                          
                                       . Each technician prefers j to j′. As long as the above is fulfilled the specific preferences can be set arbitrarily.

Now, consider an assignment μ assigning technicians 
                                 
                                    1
                                    ,
                                    …
                                    ,
                                    |
                                    C
                                    |
                                 
                               to job j′ and technicians 
                                 
                                    |
                                    C
                                    |
                                    +
                                    1
                                    ,
                                    …
                                    ,
                                    |
                                    C
                                    |
                                    +
                                    1
                                    +
                                    3
                                    q
                                 
                               to job j. Clearly, I′ can be constructed in pseudo-polynomial time. It is furthermore easy to verify that μ is a feasible assignment. We claim that the answer to I′ is no if and only if the answer to I is yes.

First, assume there is a subset C′ of C where every element of X occurs in exactly one member of C′. Then, we can remove technician 
                                 
                                    |
                                    C
                                    |
                                    +
                                    1
                                 
                               from the team of j and replace it by the technicians corresponding to C′. Clearly, C′ can replace 
                                 
                                    {
                                    |
                                    C
                                    |
                                    +
                                    1
                                    }
                                 
                               since the resulting JTA is proper. Furthermore, technicians in C′ prefer j to j′ and j prefers each technician in C′ to technician 
                                 
                                    |
                                    C
                                    |
                                    +
                                    1
                                 
                              . Hence, μ is not stable.

Second, if μ is not stable, then j must give raise for instability since j′ has its most preferred technicians assigned. Hence, in a replacement j′ could not receive technicians it prefers over those it loses unless it does not lose any technician. Then, however the resulting JTA is not proper since there must be idle technicians. A similar argument yields that in a replacement j cannot lose a technician in 
                                 
                                    {
                                    |
                                    C
                                    |
                                    +
                                    2
                                    ,
                                    …
                                    ,
                                    |
                                    C
                                    |
                                    +
                                    1
                                    +
                                    3
                                    q
                                    }
                                 
                               since it prefers them to any other technician. If it does not lose any technician at all, there will be idle technicians in the resulting JTA. Hence, if μ is not stable, then technician 
                                 
                                    |
                                    C
                                    |
                                    +
                                    1
                                 
                               in the team of j is replaced. Furthermore, we can conclude that 
                                 
                                    |
                                    C
                                    |
                                    +
                                    1
                                 
                               must be replaced by a set of technicians T′ corresponding to a yes-certificate of I. If at least one skill is not covered by T′, then the resulting JTA is not skill-feasible. If at least one skill is covered more than once by T′, then the resulting JTA is not proper since at least one of technicians 
                                 
                                    |
                                    C
                                    |
                                    +
                                    2
                                    ,
                                    …
                                    ,
                                    |
                                    C
                                    |
                                    +
                                    1
                                    +
                                    3
                                    q
                                 
                               is idle.□

In order to support an intuitive understanding of the proof we outline an example instance of X3C and the reduction in the following. Consider instance I specified by 
                           
                              X
                              =
                              {
                              1
                              ,
                              2
                              ,
                              3
                              ,
                              4
                              ,
                              5
                              ,
                              6
                              }
                           
                         and 
                           
                              C
                              =
                              {
                              {
                              1
                              ,
                              2
                              ,
                              3
                              }
                              ,
                              {
                              2
                              ,
                              3
                              ,
                              4
                              }
                              ,
                              {
                              1
                              ,
                              2
                              ,
                              5
                              }
                              ,
                              {
                              1
                              ,
                              5
                              ,
                              6
                              }
                              }
                           
                        . It is not hard to see that the answer to I is yes since in 
                           
                              
                                 C
                                 ′
                              
                              =
                              
                                 {
                                 
                                    {
                                    2
                                    ,
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                    {
                                    1
                                    ,
                                    5
                                    ,
                                    6
                                    }
                                 
                                 }
                              
                           
                         every element of X occurs in exactly one triple. Now, we construct 
                           
                              S
                              =
                              {
                              1
                              ,
                              …
                              ,
                              6
                              }
                           
                         and set 
                           
                              R
                              
                                 Q
                                 j
                                 
                                    (
                                    1
                                    ,
                                    s
                                    )
                                 
                              
                              =
                              2
                           
                         for each s ∈ S and 
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    1
                                    )
                                 
                              
                              =
                              3
                              ,
                           
                        
                        
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    2
                                    )
                                 
                              
                              =
                              3
                              ,
                           
                        
                        
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    3
                                    )
                                 
                              
                              =
                              2
                              ,
                           
                        
                        
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    4
                                    )
                                 
                              
                              =
                              1
                              ,
                           
                        
                        
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    5
                                    )
                                 
                              
                              =
                              2
                              ,
                           
                         and 
                           
                              R
                              
                                 Q
                                 
                                    
                                       j
                                       ′
                                    
                                 
                                 
                                    (
                                    1
                                    ,
                                    6
                                    )
                                 
                              
                              =
                              1
                           
                        . Furthermore, we have 
                           
                              T
                              =
                              {
                              1
                              ,
                              …
                              ,
                              11
                              }
                           
                         with technicians 1, 2, 3, and 4 corresponding to {1, 2, 3}, {2, 3, 4}, {1, 2, 5}, and {1, 5, 6}, respectively, and having the corresponding skill sets. Hence, a team consisting of technicians 1 to 4 assigned to j′ is a proper JTA. Technician 
                           
                              |
                              C
                              |
                              +
                              1
                              =
                              5
                           
                         has each skill and the remaining technicians 6 to 11 have skill 1 to 6 only, respectively. So, a team consisting of technicians 5 to 11 assigned to j is a proper JTA, as well. Now, only job j would be willing to replace a technician and j is willing to replaceonly technician 5. However, the set of technicians received in exchange need to have each skill exactly once for the resulting JTA to be proper. Hence, the given assignment is not stable if and only if there is a subset of technicians in 
                           
                              {
                              1
                              ,
                              …
                              ,
                              4
                              }
                           
                         having each skill exactly once. The set {2, 4} is such a set.

Now we shall come back to the admittedly very restrictive definition of blocking triplets introduced above. Here, a triplet (T′′, j, T′) qualifies as blocking only if job j prefers each technician t′, t′ ∈ T′, to each technician t′′, t′′ ∈ T′′.

Note that the proof of Theorem 4 relies on the fact that technician 
                           
                              |
                              C
                              |
                              +
                              1
                           
                         is replaced in the team of j. Given the preference structure constructed for I′ this would be the case for various definitions of blocking triplets. In fact, we yield the same result for example for the alternative definitions where a triplet (T′′, j, T′) qualifies as blocking only

                           
                              •
                              if job j prefers each of a majority of technicians in T′ to each of a majority of technicians in T′′ or

if job j prefers at least one technician in T′ to each technician in T′′.

Clearly, each of these alternative definitions leads to a generalization of the definition in Section 2.1.

We would like to emphasize that Theorem 4 implies a substantial difference between stable workforce assignment as considered in the paper at hand and classic stable many-to-one assignments. As stated in Roth and Sotomayor (1990), e.g., in many-to-one assignments stability with regard to individuals (technicians in our setting) implies stability with regard to groups of individuals under the mild assumption of responsive preferences. It is not hard to see that stability of workforce assignment μ (with regard to individual technicians) does not imply stability of μ with regard to sets of technicians. In fact, while determining stability of a given feasible assignment μ can be done in polynomial time (simply by checking for each (t′, j, t) whether it blocks μ) determining stability of a given feasible assignment with regard to sets of technicians is strongly NP-hard. Therefore, we treat the more restricted version of the problem, namely STJAP, in the remainder of the paper following a bottom-up approach and leaving STJAP-sets for future work.

@&#RELATED WORK@&#

For each of the fields addressed in Sections 3.1 to 3.3 there is a huge body of literature. Therefore, we restrict ourselves to fundamental concepts extended or employed in this paper.

In assignments we have generally two sets, E and F, and members of different sets are matched. In the context of stability, usually preferences of each member of E (F) over members of F (E) and - possibly - 2
                           F
                         (2
                           E
                        ) are given.

There are three prominent notions of stability in the context of assignments, see (Sotomayor, 1999). An assignment is pairwise-stable if there is no pair (e, f) ∈ E × F which is not matched in the assignment such that matching e and f (and possibly dissolving some matches they are currently involved in) results in preferred sets of matches for both, e and f. An assignment is said to be core-wise stable if there is no (E′, F′) with E′ ⊆ E and F′ ⊆ F such that there is an assignment of E′ and F′ which implies a preferred set of matches for each member of E′ ∪ F′. Similarly, an assignment is said to be strong core-wise stable if there is no (E′, F′) with E′⊆E and F′⊆F such that there is an assignment of E′ and F′ which implies a weakly preferred set of matches for each member of E′ ∪ F′. Finally, an assignment is said to be set-wise stable if there is no (E′, F′) with E′⊆E and F′⊆F such that introducing some new matches in E′ × F′ (and possibly dissolving some matches members of E′ ∪ F′ are currently involved in) results in a preferred set of matches for each member of E′ ∪ F′. Note that a set-wise stable assignment is both, pair-wise stable and core-wise stable.

In one-to-one assignments the number of matches a member of E ∪ F is involved in is at most one. Gale and Shapley (1962) proved that there always exists a set of pairwise-stable marriages by proposing an algorithm so-called “Proposal-Disposal algorithm”. Besides Gale–Shapley’s algorithm, a combinatorial approach has been developed by Vande Vate (1989) who described the convex hull of stable marriages with a set linear inequalities, and showed that stable marriages can be found by employing linear optimization algorithms. The basic problem setting of Gale and Shapley (1962) is extended in several ways. For instance, the Marriage problem with incomplete preferences and ties in preferences is considered in Iwama, Manlove, Miyazaki, and Morita (1999). For an overview we refer to Iwama and Miyazaki (2008).

In many-to-one assignments the number of matches a member of F is involved in is at most one. This generalization of one-to-one assignments is referred to as University Admissions problem, also. Roth and Sotomayor (1990) proved that pairwise stability is equivalent to set-wise stability when preferences are responsive. Also, under mild assumptions for preferences set-wise stability is equivalent to corewise-stability, see (Roth, 1984). Gale and Sotomayor (1985) show two basic properties of stable many-to-one assignments; (1) if an applicant is admitted in a stable assignment, then she/he is admitted in each stable assignment, and (2) each university admits the same number of applicants in all stable assignments. By these results, finding one stable admission is enough to see if all universities can fill their quotas in all stable admissions. Based on this fact Fırat et al. (2012) reduced the STJAP with a single skill domain, i.e. 
                           
                              |
                              S
                              |
                              =
                              1
                              ,
                           
                         to the University Admissions problem with Filled Quotas. A combinatorial approach to find pairwise-stable many-to-one assignments with strict preferences is developed by Baïou and Balinski (2000) that is a cutting plane algorithm employing the Ellipsoid Method.

In general assignments, as shown in Sotomayor (1999), the strong connection between the three types of stability is lost. This is true in our setting as well. We think of the definitions of stability outlined in Sections 2.1 and 2.2 as somewhat related to strong core-wise stability. Note that E and F correspond to the set of jobs and the set of technicians, respectively. Now, asking whether there is (E′, F′) is restricted to 
                           
                              
                                 |
                              
                              
                                 E
                                 ′
                              
                              
                                 |
                                 =
                                 1
                              
                           
                         in Section 2.2. In Section 2.1 we furthermore restrict F′ to contain at most one new job.

In a recent literature review about workforce planning, De Bruecker, Van den Bergh, and Belin (2015) mention that planning of workforce with hierarchical skills is one of the most difficult problems that managers face in companies. The authors also emphasize that different skills that technicians may possess should be taken into account besides their preferences. Considering employee preferences is accepted as a part of the effort to cope with personnel shortages by Bard and Purnomo H. (2005) in order to achieve higher morale, a more attractive work environment, increased flexibility to deal with personal matters, and higher retention rates.

In personal scheduling, especially in nurse rostering, worker preferences are requests to work specific shifts or to be given specific days off, and by other rules such as the number of working hours, shift sequence patterns or even nurse to patient ratios, see (Brunner, Bard, & Köhler, 2013) for details. The preference type introduced in Fırat et al. (2012) can be seen as an aggregated choice of players over the opposite set of players, e.g. a nurse may determine a preference ordering over shifts with respect to day time or the hospital where it will be conducted. Burke, De Causmaecker, Vanden Berghe, and Van Landeghem (2004) specify the necessary properties of an automated schedule generation as flexibility, considering personal preferences, patient satisfaction, and human effort. To the best our knowledge, Fırat et al. (2012) firstly consider worker preferences (over jobs) while processing a task requiring hierarchical skills, and analyze the complexity of finding stable workforce assignments. The authors present an IP model to find stable assignments, and conclude that stable assignments for small problem instance sizes can constructed by solving the proposed IP model.

Column Generation (CG) was first introduced independently by Gilmore and Gomory (1961) and Dantzig and Wolfe (1960). A common and efficient way to tackle complex problems is to reformulate them with set covering, set partitioning, or set packing structure in which the combinatorial objects are non-trivial items, like teams of jobs in scheduling, routes of vehicles in vehicle routing, and so on. These reformulations have in general exponential number of variables, and it is not realistic to construct all of them at the beginning. CG is a method to solve these reformulations by starting with a (possibly empty) subset of variables, and iteratively adding variables that are promising to improve the current objective value. The problem of finding promising variables is called pricing sub-problem. The optimality is proven when no promising variable exists.

CG is used in a wide range of applications in Operations Research, like machine scheduling (van den et al., 2005), traveling salesman problem (Desrosiers, Soumis, & Desrochers, 1984), vehicle routing problem (Desrochers, Desrosiers, & Solomon, 1991; Sol, 1995), airline crew scheduling (Borndörfer, Schelten, Schlechte, & Steffen, 2005), and resource-constrained project scheduling (Brucker & Knust, 2003). We refer to Desrosiers, Lübbecke, Desaulniers, Desrosiers, and M.Solomon (2005) for an involved introduction to the CG.

Branch-and-Bound search is a standard method to solve NP-hard problems. B&P refers to a Branch-and-Bound algorithm where the subproblem corresponding to the nodes are solved by using CG. We refer to Barnhart, Johnson, Nemhauser, Savelsbergh, and Vance (1998) for an introduction to this technique. In the last two decades, B&P has been employed in numerous papers concerning various fields of application, e.g. machine scheduling in Bard and Rojanasoonthon (2006), lot sizing in Degraeve and Jans (2007), vehicle routing in Feillet (2010), rostering in Brunner, Bard, and Kolisch (2011), and sports league scheduling in Briskorn and Drexl (2009).

In this section, we present a B&P algorithm to solve STJAP efficiently. Recall that triple (t′, j, t) can qualify as blocking triple only if t > 
                        j
                     
                     t′ which is independent from the assignment under consideration. Consequently, we use such triples, namely potentially blocking triples, as central components of our models and the B&P algorithm. We use B to denote the set of potentially blocking triples.

In the following we present a model reformulation suited for B&P, that is a model for the master problem and a model for the pricing problem, in Section 4.1. Furthermore, we detail the branching strategy and the bounding used in Section 4.2.

The basic idea is to have a model formulation where each variable corresponds to a proper JTA. The problem, then, is to choose a set of proper JTAs such that the chosen JTAs constitute a stable assignment. The pricing problem is to generate promising JTAs to be added to this model. In the following we first present the master problem formulation and the pricing problem formulation afterwards.

Our master model has only one type of binary decision variable, that is 
                           
                              x
                              
                                 τ
                                 j
                              
                           
                         indicating whether proper JTA (j, τj
                        ) with team τj
                         assigned to job j is selected. We denote by 
                           
                              T
                              j
                           
                         the set of proper JTAs of job j. Parameter 
                           
                              γ
                              
                                 
                                    t
                                    ′
                                 
                                 ,
                                 t
                              
                              
                                 τ
                                 j
                              
                           
                         equals 1 if t can replace t′ in τj
                        , 0 otherwise.

                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                             
                                                (
                                                M
                                                P
                                                )
                                             
                                             
                                             
                                             Min
                                             
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         τ
                                                         j
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      j
                                                   
                                                
                                             
                                             
                                                w
                                                
                                                   τ
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                             subject
                                             
                                             to
                                             
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         τ
                                                         j
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      j
                                                   
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                             
                                             =
                                             1
                                          
                                       
                                       
                                          
                                             
                                             ∀
                                             j
                                             ∈
                                             J
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         τ
                                                         j
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      j
                                                   
                                                   ,
                                                   t
                                                   ∈
                                                   
                                                      τ
                                                      j
                                                   
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                             
                                             ≤
                                             1
                                          
                                       
                                       
                                          
                                             
                                             ∀
                                             t
                                             ∈
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   
                                                      j
                                                      ′
                                                   
                                                   ∈
                                                   J
                                                   ,
                                                   
                                                      j
                                                      ′
                                                   
                                                   
                                                      >
                                                      t
                                                   
                                                   j
                                                
                                             
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      
                                                         j
                                                         ′
                                                      
                                                      ,
                                                      
                                                         τ
                                                         
                                                            j
                                                            ′
                                                         
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      
                                                         j
                                                         ′
                                                      
                                                   
                                                   ,
                                                   t
                                                   ∈
                                                   
                                                      τ
                                                      
                                                         j
                                                         ′
                                                      
                                                   
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   
                                                      j
                                                      ′
                                                   
                                                
                                             
                                             −
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         τ
                                                         j
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      j
                                                   
                                                
                                             
                                             
                                                γ
                                                
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   t
                                                
                                                
                                                   τ
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                             
                                             ≥
                                             0
                                          
                                       
                                       
                                          
                                             
                                             ∀
                                             (
                                             
                                                t
                                                ′
                                             
                                             ,
                                             j
                                             ,
                                             t
                                             )
                                             ∈
                                             B
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                          
                                       
                                       
                                          
                                             
                                             ∀
                                             j
                                             ∈
                                             J
                                             ,
                                             
                                                (
                                                j
                                                ,
                                                
                                                   τ
                                                   j
                                                
                                                )
                                             
                                             ∈
                                             
                                                T
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The master problem formulation is given by (9) to (13). Constraints (10) and (11) ensure a feasible assignment. Constraints (12) prevent blocking triples. In order to have a formally feasible solution to start the CG process we introduce an artificial column at the beginning. This column has a value of 1 in each row and, hence, selecting this artificial column only is a formally feasible solution to MP. Of course, this column has to be replaced by non-artificial JTAs in the course of the CG process. In order to drive the mechanism to do so we introduce cost 1 for the artificial column and cost 
                           
                              
                                 w
                                 
                                    τ
                                    j
                                 
                              
                              =
                              0
                           
                         for non-artificial JTA (j, τj
                        ) and formulate the objective to minimize total cost of chosen JTAs.

The number of variables in MP is exponential in the instance size and, hence, incorporating all of them is not an option. Instead, we solve the LP relaxation of MP with a restricted number of variables, also called Restricted Master Problem (RMP), using CG. Starting with a subset of JTAs we find the optimum solution. Then, based on this optimum solution we generate more JTAs having negative reduced cost, add them and resolve RMP. This procedure iterates until no JTA with negative reduced cost exists.

Given an optimal solution x
                        * to RMP, dual variables (π
                        *, α
                        *, β
                        *) are associated with constraints (10) to (12) in the respective order. Then, the reduced cost of any proper JTA 
                           
                              
                                 (
                                 j
                                 ,
                                 
                                    τ
                                    j
                                 
                                 )
                              
                              ∈
                              
                                 T
                                 j
                              
                           
                         is given as

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                w
                                                
                                                   τ
                                                   j
                                                
                                             
                                             ¯
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             −
                                             
                                                π
                                                
                                                   j
                                                
                                                *
                                             
                                             +
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   
                                                      τ
                                                      j
                                                   
                                                
                                             
                                             
                                                w
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                             +
                                             
                                                ∑
                                                
                                                   (
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   j
                                                   ,
                                                   t
                                                   )
                                                   ∈
                                                   B
                                                
                                             
                                             
                                                γ
                                                
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   t
                                                
                                                
                                                   τ
                                                   j
                                                
                                             
                                             
                                                β
                                                
                                                   (
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   j
                                                   ,
                                                   t
                                                   )
                                                
                                                *
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

with

                           
                              
                                 
                                    
                                       w
                                       
                                          j
                                          ,
                                          t
                                       
                                    
                                    =
                                    −
                                    
                                       α
                                       
                                          t
                                       
                                       *
                                    
                                    −
                                    
                                       ∑
                                       
                                          
                                             (
                                             
                                                t
                                                ′
                                             
                                             ,
                                             
                                                j
                                                ′
                                             
                                             ,
                                             t
                                             )
                                          
                                          ∈
                                          B
                                          ,
                                          
                                             j
                                             ′
                                          
                                          
                                             <
                                             t
                                          
                                          j
                                       
                                    
                                    
                                       β
                                       
                                          (
                                          
                                             t
                                             ′
                                          
                                          ,
                                          
                                             j
                                             ′
                                          
                                          ,
                                          t
                                          )
                                       
                                       *
                                    
                                    .
                                 
                              
                           
                        
                     

Naturally, the problem to find a JTA with minimum reduced cost decomposes into job-dependent problems to find the team for a certain job such that the resulting JTA has minimum reduced cost. We formulate this problem, namely PPj
                        , as a Mixed Integer Programming (MIP) model using binary variable y
                        
                           j,t
                         indicating whether t is selected for the team or not. Moreover, binary decision variable c
                        (l,s) for each skill (l,s) indicates whether a skill is critical for the selected team. Finally, the continuous variable 
                           
                              κ
                              
                                 (
                                 
                                    t
                                    ′
                                 
                                 ,
                                 j
                                 ,
                                 t
                                 )
                              
                           
                         becomes 1 if t can replace t′ in the team of j and 0 otherwise (see Table 1
                         for an overview of notation).


                        
                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             
                                                (
                                                P
                                                
                                                   P
                                                   j
                                                
                                                )
                                             
                                             
                                             min
                                             −
                                             
                                                π
                                                
                                                   j
                                                
                                                *
                                             
                                             +
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   T
                                                
                                             
                                             
                                                (
                                                
                                                   w
                                                   
                                                      j
                                                      ,
                                                      t
                                                   
                                                
                                                
                                                   y
                                                   
                                                      j
                                                      ,
                                                      t
                                                   
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      (
                                                      
                                                         t
                                                         ′
                                                      
                                                      ,
                                                      j
                                                      ,
                                                      t
                                                      )
                                                      ∈
                                                      B
                                                   
                                                
                                                
                                                   β
                                                   
                                                      (
                                                      
                                                         t
                                                         ′
                                                      
                                                      ,
                                                      j
                                                      ,
                                                      t
                                                      )
                                                   
                                                   *
                                                
                                                
                                                   κ
                                                   
                                                      (
                                                      
                                                         t
                                                         ′
                                                      
                                                      ,
                                                      j
                                                      ,
                                                      t
                                                      )
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        subject to:

                           
                              (15)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                (
                                                1
                                                −
                                                
                                                   c
                                                   
                                                      (
                                                      l
                                                      ,
                                                      s
                                                      )
                                                   
                                                
                                                )
                                             
                                             ≤
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   T
                                                
                                             
                                             S
                                             
                                                k
                                                
                                                   t
                                                
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                             −
                                             R
                                             
                                                Q
                                                j
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             ≤
                                             
                                             
                                                |
                                                T
                                                |
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   c
                                                   
                                                      (
                                                      l
                                                      ,
                                                      s
                                                      )
                                                   
                                                
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             ∀
                                             
                                                (
                                                l
                                                ,
                                                s
                                                )
                                             
                                             :
                                             R
                                             
                                                Q
                                                j
                                                
                                                   *
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             >
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                   ∈
                                                   N
                                                   (
                                                   j
                                                   ,
                                                   t
                                                   )
                                                
                                             
                                             
                                                c
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             ≥
                                          
                                       
                                       
                                          
                                             
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                             ,
                                             
                                             
                                             
                                             
                                             
                                             
                                             ∀
                                             t
                                             ∈
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   
                                                      t
                                                      ′
                                                   
                                                
                                             
                                             −
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                             −
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      l
                                                      ,
                                                      s
                                                      )
                                                   
                                                   ∈
                                                   N
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         t
                                                         ′
                                                      
                                                      )
                                                   
                                                   ∖
                                                   N
                                                   
                                                      (
                                                      j
                                                      ,
                                                      t
                                                      )
                                                   
                                                
                                             
                                             
                                                c
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             ≤
                                          
                                       
                                       
                                          
                                             
                                             
                                                κ
                                                
                                                   (
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   j
                                                   ,
                                                   t
                                                   )
                                                
                                             
                                             ,
                                             
                                             
                                             
                                             
                                             ∀
                                             
                                                (
                                                
                                                   t
                                                   ′
                                                
                                                ,
                                                j
                                                ,
                                                t
                                                )
                                             
                                             ∈
                                             B
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             κ
                                             
                                                (
                                                
                                                   t
                                                   ′
                                                
                                                ,
                                                j
                                                ,
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          
                                             ≥
                                             0
                                             ,
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             ∀
                                             (
                                             
                                                t
                                                ′
                                             
                                             ,
                                             j
                                             ,
                                             t
                                             )
                                             ∈
                                             B
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             
                                                c
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             ,
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                             ∈
                                          
                                       
                                       
                                          
                                             
                                             {
                                             0
                                             ,
                                             1
                                             }
                                             ,
                                             
                                             
                                             
                                             
                                             
                                             
                                             ∀
                                             (
                                             l
                                             ,
                                             s
                                             )
                                             ∈
                                             L
                                             ×
                                             S
                                             ,
                                             t
                                             ∈
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (14) represents the goal to minimize reduced cost. Note that 
                           
                              −
                              
                                 π
                                 
                                    j
                                 
                                 *
                              
                           
                         is a constant in PPj
                        . Constraints (15) and (16) ensure that the JTA is proper besides determining the critical skills. Finally, inequalities (17) are used to determine the values of κ variables. Note that 
                           
                              κ
                              
                                 (
                                 t
                                 ,
                                 j
                                 ,
                                 
                                    t
                                    ′
                                 
                                 )
                              
                           
                         is defined to be continuous in constraints (18). However, in optimum solutions 
                           
                              κ
                              
                                 (
                                 
                                    t
                                    ′
                                 
                                 ,
                                 j
                                 ,
                                 t
                                 )
                              
                           
                         takes the smallest value not violating (17) or (18) since 
                           
                              β
                              
                                 (
                                 t
                                 ,
                                 j
                                 ,
                                 
                                    t
                                    ′
                                 
                                 )
                              
                              *
                           
                         is non-negative. Constraint (17) imposes a lower bound of 1 or a non-positive value on 
                           
                              κ
                              
                                 (
                                 
                                    t
                                    ′
                                 
                                 ,
                                 j
                                 ,
                                 t
                                 )
                              
                           
                         and, therefore, 
                           
                              κ
                              
                                 (
                                 
                                    t
                                    ′
                                 
                                 ,
                                 j
                                 ,
                                 t
                                 )
                              
                           
                         takes value 0 or 1.

Note that in an optimum solution the team of j is not necessarily assembled from the most preferred technicians. However, the implications on stability of the resulting assignment when choosing less preferred technicians is reflected by 
                           
                              
                                 β
                                 
                                    (
                                    
                                       t
                                       ′
                                    
                                    ,
                                    j
                                    ,
                                    t
                                    )
                                 
                                 *
                              
                              
                                 κ
                                 
                                    (
                                    
                                       t
                                       ′
                                    
                                    ,
                                    j
                                    ,
                                    t
                                    )
                                 
                              
                           
                        .

It is not hard to see that the pricing problem is NP-hard, since it generalizes the Set Covering Problem, see (Garey & Johnson, 1979).

Bounding is rather trivial in our case. To obtain an arbitrary stable assignment we aim at finding a feasible solution to MP with total cost of zero. Since proper JTAs have cost of zero and the artificial variable has cost 1, we can prune the sub-tree corresponding to a node in which the optimum objective value is strictly positive. Then, no stable assignment can be found in the corresponding sub-tree.

Branching is done by splitting the search space into two parts by “fix technician t to job j” and “ban technician t from job j”. This branching strategy bears the advantage that it can be implemented rather easily by fixing variables in the pricing problems. “Fix technician t to job j” can be applied by fixing 
                              
                                 
                                    y
                                    
                                       j
                                       ,
                                       t
                                    
                                 
                                 =
                                 1
                              
                            and 
                              
                                 
                                    y
                                    
                                       
                                          j
                                          ′
                                       
                                       ,
                                       t
                                    
                                 
                                 =
                                 0
                              
                            for each j′ ≠ j. “Ban technician t from job j” is implemented by fixing 
                              
                                 
                                    y
                                    
                                       j
                                       ,
                                       t
                                    
                                 
                                 =
                                 0
                              
                           .

In the remainder of this section, we outline how a technician-job pair is selected for branching and how we modify both models depending on the branching decisions in order to reduce run times.

Given an optimum solution x
                              * to the LP relaxation of MP in the current node a pair (t, j) of technician and job is a candidate for branching if (t, j) has not been branched on. For such a candidate pair (t, j), we consider

                                 
                                    •
                                    the assignment value according to x
                                       *, that is 
                                          
                                             
                                                Y
                                                
                                                   (
                                                   t
                                                   ,
                                                   j
                                                   )
                                                
                                             
                                             =
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      j
                                                      ,
                                                      
                                                         τ
                                                         j
                                                      
                                                      )
                                                   
                                                   ∈
                                                   
                                                      T
                                                      j
                                                   
                                                   ,
                                                   t
                                                   ∈
                                                   
                                                      τ
                                                      j
                                                   
                                                
                                             
                                             
                                                x
                                                
                                                   τ
                                                   j
                                                
                                                *
                                             
                                             ,
                                          
                                        and

the number k
                                       (t,j) of triples in B that cannot block any assignment if t is fixed to j
                                    

The score Y
                              (t,j)
                              k
                              (t,j) reflects the attractiveness of assigning t to j. Ultimately, the candidate pair with highest score is chosen for branching.

Aside from the mere implementation of the branching decision we take two other types of modification of the models into account.

                                 
                                    1.
                                    Branching decisions leave some potentially blocking triples harmless in the resulting subproblem.

                                          
                                             •
                                             If we “fix technician t to job j”, then no triple (t′, j, t) ∈ B, and (t′, j′, t) ∈ B with j′ < 
                                                   t
                                                
                                                j can block an assignment.

If we “ban technician t from job j”, then no triple (t, j, t′) ∈ B can block a corresponding assignment.

Consequently, these potentially blocking triples are dropped from B which reduces the numbers of constraints and variables to be considered.

Moreover, consider a triple (t′, j, t) ∈ B such that t prefers job j most among the jobs he is not banned from. Since any team of j in which t can replace t′ leads to instability, we take two actions in order to avoid constructing such JTAs in the pricing problem PPj
                                       : First, we fix 
                                          
                                             
                                                κ
                                                
                                                   (
                                                   
                                                      t
                                                      ′
                                                   
                                                   ,
                                                   j
                                                   ,
                                                   t
                                                   )
                                                
                                             
                                             =
                                             0
                                          
                                        in PPj
                                       . Second, if t possesses all contributing skills of t′ to j, i.e. 
                                          
                                             N
                                             
                                                (
                                                j
                                                ,
                                                
                                                   t
                                                   ′
                                                
                                                )
                                             
                                             
                                             ∖
                                             
                                             N
                                             
                                                (
                                                j
                                                ,
                                                t
                                                )
                                             
                                             =
                                             ∅
                                             ,
                                          
                                        we add the constraint 
                                          
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   
                                                      t
                                                      ′
                                                   
                                                
                                             
                                             ≤
                                             
                                                y
                                                
                                                   j
                                                   ,
                                                   t
                                                
                                             
                                          
                                        to PPj
                                       .

In our experimentation, we compare three methods to solve STJAP.

                           
                              •
                              B&P: Branch-and-Price approach presented in Section 4.

MOD: Finding stable workforce assignments by solving the IP model of linear inequalities (3)–(8). In preliminary tests using this IP proved to be more efficient than using the IP presented in Fırat et al. (2012).

SEP: Finding stable workforce assignments by Separation. First, an assignment is found by solving the IP model (3)–(5) and (7) and (8) without stability constraints associated with potentially blocking triples (6). We then check the set of potentially blocking triples for actually blocking triples. If there are any blocking triples in the assignment, stability cuts of these blocking triples are added. This procedure is repeated until either a stable assignment is found or it is proven that there is none.

We restrict our experimentation to instances that allow a feasible assignment since our focus is on stability. We derive those instances from France Telecom (FT) scheduling problem instances (described in Dutot, Laugier, and Bustos (2006) and studied by Fırat and Hurkens (2012)). The FT scheduling problem asks for a feasible (workforce) assignment for each of a sequence of workdays. Given such a schedule (derived by the method presented in Fırat & Hurkens (2012)) we have a set of technicians (with skills) employed at each workday and a set of jobs (with skill requirements) done at each workday. It remains to detail how this data is enriched by preferences.

We derive a value for each skill which is defined as the ratio of the demand for that skill to the number of technicians possessing that skill. Formally, it is given by

                           
                              (20)
                              
                                 
                                    
                                       ν
                                       
                                          (
                                          l
                                          ,
                                          s
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             R
                                             
                                                Q
                                                
                                                   j
                                                
                                                
                                                   *
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   T
                                                
                                             
                                             S
                                             
                                                k
                                                
                                                   t
                                                
                                                
                                                   (
                                                   l
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                             −
                                             
                                                ∑
                                                
                                                   
                                                      l
                                                      ′
                                                   
                                                   >
                                                   l
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             R
                                             
                                                Q
                                                
                                                   j
                                                
                                                
                                                   *
                                                   (
                                                   
                                                      l
                                                      ′
                                                   
                                                   ,
                                                   s
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                    
                                       (
                                       l
                                       ,
                                       s
                                       )
                                    
                                    ∈
                                    
                                       L
                                       ×
                                       S
                                    
                                    .
                                 
                              
                           
                        In (20), the numerator gives the demand for (l, s) straightforwardly. The denominator gives the capacity for skill (l, s) or higher level of domain s reduced by the demand for higher levels of s.

Using values of skills a score is derived for each technician and each job. The score of a job is the sum of values of the skills required by that job, that is 
                           
                              
                                 ∑
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              
                                 ν
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              R
                              
                                 Q
                                 j
                                 
                                    *
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              ,
                           
                         and the score of a technician is the sum of values of the skills he is qualified for, that is 
                           
                              
                                 ∑
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              
                                 ν
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                              S
                              
                                 k
                                 t
                                 
                                    (
                                    l
                                    ,
                                    s
                                    )
                                 
                              
                           
                        . Then, we consider a unique preference ordering of jobs and a unique preference ordering of technicians, both in non-increasing order of their scores.

We generate three groups of instances, each containing instances with similar size. The instance sizes increase from Group 1 to Group 3. Details are outlined in Table 2
                        . The first two columns, with labels “Set” and “#”, list the name of used FT scheduling instance (see (Dutot et al., 2006)) and the number of instances in the corresponding set, respectively. The following columns, that are labeled with “|T|”, “|J|”, “|S|”, and “|L|”, list the range of numbers of technicians, jobs, skill domains and skill levels, respectively.

@&#RESULTS@&#

We implemented all methods in JAVA, and used CPLEX 12.1 to solve all IP and MIP models. The experimentation is conducted using a computer with Intel Core 2 Duo 2.7 gigahertz Processor, and 8 gigabyte RAM. A time limit is determined for every instance group. If an algorithm cannot solve an instance within the specified time limit, then it is marked as unsolved. In a series of experiments the time limits for every instance group are increased in order to observe how this effects the percentage of solved instances for benchmark algorithms. We report the results in two ways. First, we outline the percentage of solved instance for the three benchmark algorithms in Section 5.3.1 and, second, we provide performance profiles in Section 5.3.2 following the idea of Dolan and More (2002).


                           Figs. 1
                           –3
                            show the percentage of solved instances in Group 1, 2, and 3, respectively, for the three benchmark algorithms depending on the actual time limit.

As shown in Fig. 1, SEP solves a higher fraction of instances of Group 1 for the smallest time limits and is slightly superior to B&P. The reason of this may be that the number of triples is not high in small-size instances. Hence, we do not need many iterations applying triple cuts in order to reach a stable assignment or prove that there is none. We can see however, that allowing higher run times B&P is competitive or even superior to SEP and MOD.

The results for instances of Group 2 show that B&P solves more than 90 percent of the instances within 40 seconds, whereas the other two methods have significantly lower success rates. For example, in instance set “X7” B&P solves around 95 percent of instances within 20 seconds, but the percentages are 26 percent and 16 percent for SEP and MOD respectively. Still, we see that SEP is clearly superior to MOD. B&P outperforms SEP, in particular, for small run time limits as opposed to Group 1. This may be due to larger instances needing more cuts generated by SEP. So, the IP has to be solved more often with an increasing number of constraints even.

Since MOD could solve only few instances of Group 3, we decided to show the results of SEP and B&P only for this instance group. The percentages in Fig. 3 show that B&P solves a high ratio of instances in Group 3 within a minute. However, SEP can solve less than 20 percent of the instances.


                           Dolan and More (2002) propose performance profiles to compare benchmark algorithms. Given a set 
                              I
                            of problem instances, performance of a set 
                              A
                            algorithms is found by computing performance ratio r
                           
                              i,a
                            for each instance i and algorithm a as

                              
                                 
                                    
                                       
                                          r
                                          
                                             i
                                             ,
                                             a
                                          
                                       
                                       =
                                       
                                          
                                             t
                                             
                                                i
                                                ,
                                                a
                                             
                                          
                                          
                                             min
                                             {
                                             
                                                t
                                                
                                                   i
                                                   ,
                                                   a
                                                
                                             
                                             ∣
                                             a
                                             ∈
                                             A
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        

where t
                           
                              i, a
                            is the runtime required by a to solve i. We set a time limit of the maximum time limit employed in Section 5.3.1 for the respective group. If a cannot solve i within this time limit, we set t
                           
                              i, a
                            to the time limit. The overall performance ρa
                           (t) of an algorithm on a set of instances is defined as

                              
                                 
                                    
                                       
                                          ρ
                                          a
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       =
                                       
                                          1
                                          
                                             |
                                             I
                                             |
                                          
                                       
                                       
                                          |
                                          
                                             {
                                             i
                                             ∈
                                             I
                                             ∣
                                             
                                                r
                                                
                                                   i
                                                   ,
                                                   a
                                                
                                             
                                             ≤
                                             t
                                             }
                                          
                                          |
                                       
                                       .
                                    
                                 
                              
                           
                        

So, we can interpret ρa
                           (t) as the probability that algorithm a solving an arbitrary instance 
                              
                                 i
                                 ∈
                                 I
                              
                            has a runtime within a factor of 
                              
                                 t
                                 ∈
                                 R
                              
                            compared to the runtime of the fastest algorithm in 
                              A
                           . Consequently, the value of ρa
                           (1) is the probability that the algorithm a will be among the fastest algorithms for arbitrary 
                              
                                 i
                                 ∈
                                 I
                              
                           .

In Figs. 4
                           
                           –6
                            performance profiles of the three benchmark algorithms are given for all instance groups. For Group 1, profiles of SEP and B&P are similar with 
                              
                                 
                                    ρ
                                    
                                       B
                                       &
                                       P
                                    
                                 
                                 
                                    (
                                    1
                                    )
                                 
                                 =
                                 0.72
                              
                            and 
                              
                                 
                                    ρ
                                    SEP
                                 
                                 
                                    (
                                    1
                                    )
                                 
                                 =
                                 0.75
                              
                           . Both are clearly superior to MOD. Regarding Group 2, B&P with 
                              
                                 
                                    ρ
                                    
                                       B
                                       &
                                       P
                                    
                                 
                                 
                                    (
                                    1
                                    )
                                 
                                 =
                                 0.78
                              
                            dominates SEP which in turn dominates MOD. The domination of B&P becomes even more clear for Group 3 with 
                              
                                 
                                    ρ
                                    
                                       B
                                       &
                                       P
                                    
                                 
                                 
                                    (
                                    1
                                    )
                                 
                                 =
                                 0.93
                              
                           .

In this paper we extend the work of Fırat et al. (2012) into two directions. First, we consider a stronger notion of stability compared to the one introduced by the authors. We show, that the problem becomes significantly harder to tackle since checking stability for a given feasible assignment is strongly NP-hard. Second, we develop a new IP model and a B&P approach to the STJAP with hierarchical skill levels. The IP model is more compact than the existing one and we employ the concept of potentially blocking triples to formulate it. Potentially blocking triples play an important role in the model formulations used in the B&P approach also. The pricing problem in the CG procedure is to find a suitable team for a job while the master problem is to choose a set of JTAs constituting a stable assignment. The pricing problem is NP-Hard in the strong sense which is why we solve it using CPLEX. As outlined in Section 4.2, the proposed B&P approach achieves significant computational efficiency by propagating the additional information yielded by branching decisions. Again, potentially blocking triples are substantial for the propagation techniques used. Computational experimentation in Section 5 shows that more than 80 percent of the problem instances with 
                        
                           75
                           −
                           90
                        
                      technicians, and 
                        
                           35
                           −
                           40
                        
                      jobs are solved in one minute, while Fırat et al. (2012) report that problem instances with 20 technicians and 15 jobs are solved in 10 minutes. This improvement may partially due to a more up to date hardware used in the paper at hand. Nevertheless it is still obvious that the B&P approach outperforms CPLEX as can be seen in the computational study where a more compact IP model is used.

There are several interesting questions to be considered in future research. First, technicians may have preferences over each other analogous to the Stable Roommate problem, that is each technician prefers working with some technicians to working with other technicians. Stability, then, would need to cover how happy technicians are with their teams. Second, extensions of STJAP with respect to the existing preferences may be considered, e.g. ties in preferences and incomplete preferences. Third, preferences may be determined based on real world settings. Preference structures may depend on the industry sector, cultural differences of people and so on. Finally, STJAP-sets as defined in Section 2.2 may be tackled. Here, it will be particularly interesting whether the B&P approach developed in the paper at hand can be adopted.

@&#ACKNOWLEDGMENTS@&#

This research has been supported by France Telecom under the project TOOS_R2O with reference number PJ00002062.

@&#REFERENCES@&#

