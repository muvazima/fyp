@&#MAIN-TITLE@&#Slice representation of range data for head pose estimation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a new slice representation model of range data for head pose estimation.


                        
                        
                           
                           We design two slice feature descriptors, namely LSD and LSO.


                        
                        
                           
                           Slice depth integral image is designed for real-time LSD features extraction.


                        
                        
                           
                           Slice coordinates integral image is designed for real-time LSO features extraction.


                        
                        
                           
                           An automatic head pose estimation system is presented using a Kinect sensor.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Head pose estimation

Slice representation

Random forests

Range data

Kinect

@&#ABSTRACT@&#


               
               
                  Visual estimation of head pose is desirable for computer vision applications such as face recognition, human computer interaction, and affective computing. However, accurate estimation of head pose in uncontrolled environment is still a grand challenge. This paper proposes a novel feature representation model for accurate pose estimation. In this model, a range image is divided into a set of simple slices that contain abundant geometric cues can be used to accurately describe the poses of a subject. This model provides a general framework for designing new features for head pose estimation. According to this model, design of a new feature model for describing a slice, then a new set of features is generated by combining all slices for describing range images. Due to the huge number of slices that can be generated from single range image, even a simple description model of slice can achieve robust performance. With the guide of this model, two novel range image representation models, which are Local Slice Depth (LSD) and Local Slice Orientation (LSO), are designed. LSD can be used for coarse estimation of head poses, while LSO can achieve accurate results. Moreover, in order to evaluate the performance of proposed representation model, an automatic head pose estimation method is implemented using a Kinect sensor. Firstly both color and range images captured by a Kinect sensor are used to localize and segment the facial region from background. Secondly, two novel integral images, namely slice depth integral image and slice coordinates integral image, are proposed to achieve real-time feature extraction. Finally, random forests are used to learn a stable relationship between slice feature descriptors and head pose parameters. Experiments on both low-quality depth data set Biwi and high-quality depth data set ETH demonstrate state-of-the-art performance of our method.
               
            

@&#INTRODUCTION@&#

Vision based head pose estimation refers to establish a transformation from image data to high-level head pose parameters [1]. Due to the important role of the head playing in human’s life, automatic estimation of head pose is essential for many applications such as face recognition [2], driver-attentiveness monitoring [3] and human–computer interaction [4]. Driven by its wide applications, head pose estimation has drawn great attention from academia, and a variety of techniques have been reported in the literature. However, accurate and efficient estimation of head pose is still a grand challenge in computer vision. It is difficult to establish a stable relationship between the complex and variable face patterns and head poses because of both internal factors such as expression variations and environmental variations such as illumination changes.

There are mainly two types of data used for head pose estimation, which are RGB image and range image. In the past, most head pose estimation methods in the literature are based on RGB images [1] because of the wide availability of cheap RGB image sensors. Recently, with the availability of affordable range cameras such as Kinect sensor and AUSU Xtion, range data based head pose estimation methods are emerged [5–11]. Comparing with RGB image based methods, range image based methods mainly own three advantages.
                        
                           •
                           Firstly, range data is a 3D physical representation of face pattern, which has directly geometric relation to head pose. So it is expected to establish a more stable relationship between range data and head pose. However, estimation of 3D head pose from RGB images is an ill-posed problem. So it is a much more challenging problem to precisely model the relationship between RGB face images and head poses. Therefore a large portion of RGB image based head pose estimation methods can only provide coarsely quantized pose angles for yaw or pitch, e.g. a number of discrete quantities such as −30°, 0°, 30°, rather than a precise and continuous description of all three pose angle parameters.

Secondly, it is easier to segment the region of interest and localize the position of head area from range images.

Thirdly, range images are illumination invariant but RGB image based head pose estimation methods are sensitive to environmental illumination changes.

In practice, range image based method has achieved great success. Breitenstein et al. [12] developed the first real-time head pose estimation system based on high quality depth sensor and GPU computer, which is robustness against large pose changes, facial variations and partial occlusions. Fanelli et al. [5,7,8] used random forests to learn the mapping function from local depth information to head pose parameters. Fanelli’s methods achieve real time performance without relying on any specific facial features and can handle large pose changes and partial occlusions. Padeleris et al. [11] presented an accurate head pose estimation method by constructing a personalized 3D face model based on range images.

Although great progress has been achieved in range data based head pose estimation, state-of-the art methods ignored the importance of feature representation and used original range data or simple and low level features of range images for head pose estimation [5,7,8,11,12]. We argue that well developed high-level feature descriptors can improve the performance of head pose estimation. Firstly, there does not exist an explicit relationship between facial range data and head pose parameters. Thus discriminant feature set is necessary to better model the head pose. Secondly, estimation of head pose with original range data is sensitive to noise and robust feature set is needed. Thirdly, detailed description of depth information is better than holistic representation. Local features achieve much better performance in computer vision. Thus local features of range data are desirable for head pose estimation. Fourthly, compact feature representation is more efficient in storage, transmission and feature matching.

The objective of this paper is to propose an effective feature representation of range data for head pose estimation. Our early work has been presented in [6,9]. In this paper, we attempt to demonstrate the importance of feature representation for head pose estimation and inspire new and advanced range feature representations. A novel slice representation model is proposed. The basic idea of our model is to segment range data along depth axis to get a number of 3D slice sequences and then local depth and orientation features are derived on the patches of each slice. To the best of our knowledge, this is the first time applying slice technique on range image. Such a slice representation can encode the local geometric features of range data which are useful for head pose estimation.

In summary, the main contributions of this paper are threefold. Firstly, a novel slice representation model of range data is proposed to improve the performance of head pose estimation. This model provides a general framework for developing new features of range images. Secondly, two slice feature descriptors, namely Local Slice Depth (LSD) and Local Slice Orientation (LSO) are developed to achieve robust head pose estimation. To the best of our knowledge, this is the first attempt to use high-level and detailed range feature representation for head pose estimation. Our work will inspire more ideas on local feature description of range data. Thirdly, a complete system for automatic head pose estimation is presented based on the proposed slice representation using a Kinect sensor. In this system, a simple preprocessing method is developed for localizing and segmenting the region of interest for head pose estimation by utilizing both color and range images captured by a Kinect sensor. And two novel integral images, namely slice depth integral image and slice coordinates integral image, are designed for real-time feature extraction.

The rest of this paper is organized as follows. In Section 2, the advances of head pose estimation methods are reviewed. In Section 3, slice pattern representation of range data is proposed, and two sets of slice based features, which are local slice depth and local slice orientation, are presented. Section 4 introduces how slice pattern representation is used to perform head pose estimation using a Kinect sensor. Section 5 reports the experimental results on publicly available databases. Finally, Section 6 concludes this paper.

@&#RELATED WORK@&#

The head pose estimation methods proposed before 2008 has been reviewed in [1] by Murphy-Chutorian. In this section, we review recent progress of head pose estimation, which are coarsely classified into two categories.

Due to the availability of affordable range cameras, research of head pose estimation based on range images becomes a hot topic. Breitenstein et al. [12] developed the first real-time head pose estimation system using a stereo enhanced structured-light camera [13] with the assistance of GPU computer. The core algorithm follows a “hypothesis then validation” strategy. Firstly a geometric descriptor is used to generate nose candidates and pose hypotheses. These hypotheses are then all evaluated by matching the input data with a set of reference pose range images. Finally, the pose of the reference image with the smallest matching error is output as the final result. The advantage of this method is robust against large pose changes, facial variations and partial occlusions. However such robustness is achieved by a large number of reference pose range images, which should be prepared in advance. In addition, this method needs high computational cost which prevents its application on normal computing platforms.

The similar idea of [12] was implemented by Padeleris using a Kinect sensor in [11]. The main difference is that [11] requires the user to take a frontal view as the reference pose range image at the initial step. The 3D face model of a new coming candidate is then constructed and projected to different hypotheses according to the reference range image. Finally, the hypotheses are evaluated to find the most similar transformation. Padeleris’ method can achieve high accuracy in head pose estimation based on user specific reference template. However, it is less convenient in real-world applications since it needs user cooperation to get a frontal view template. More importantly, this method can not be directly used for unenrolled subjects. And reference template based head pose estimation [11,12] is inefficient for real-time applications unless high-performance computing systems such as GPU are available.

Random forest is a desirable tool for processing depth information. The typical application would be Shotton’s work [14,15], which achieves high performance for human pose recognition. Random forest also has successful application in head pose estimation. Fanelli et al. [5] used random forest to learn the mapping function from the raw depth value to head pose parameters by constructing a synthetic data of 50,000 images as training samples. This method achieves real time performance without relying on any specific facial features and can handle large pose changes and partial occlusions. In our previous work [9], random forest is used to model the relationship between high level range image features and head pose parameters. Hadfield and Bowden [16] presented a generalized pose estimation method using range images as data and random forest as regression model. It can estimate the pose parameters of both hand and head.

All the methods described above are based on single range image. Kondori et al. [10] proposed a method that estimates head poses from a sequence of range images. It regards time-varying depth map as a function of X, Y and t. The constraint equation of depth rate is then designed for recovering the six degrees of freedom of head motion by minimizing the least-squares error of the difference between the measured rate of change of depth at a point and the rate predicted by the depth rate constraint equation. This method can achieve real-time performance. However, quantitative evaluation of the method is not presented.

Although range image based methods have become the hot topic and achieved amazing performance, RGB image based method is still the most widely used solution for head pose estimation because of the popularity of cheap RGB cameras in PC, mobile, CCTV surveillance, etc.

Recently, manifold learning techniques have drawn great attention. Foytik and Asari [17] proposed a two-layer framework for piecewise head pose estimation based on linear manifold. In layer 1, linear discriminant analysis (LDA) is used to perform coarse pose estimation with the aim of localizing the given observation to a specific region of the pose manifold. In layer 2, canonical correlation analysis (CCA) is chosen to form the basis of the linear transform for fine pose estimation. Lu and Tan [18] proposed an ordinary preserving manifold analysis approach to seek a low-dimensional subspace for head pose and age estimation. Huang et al. [19] proposed a supervised local subspace learning method to learn a local linear model, which is robust to over-fitting. BenAbdelkader [20] utilized neighborhood preserving embedding (NPE) and locality preserving projection (LPP) to perform head pose estimation. Liu et al. [21] proposed a manifold embedding head pose estimation method based on distance metric learning (DML). In [21], the authors first learned a Mahalanobis distance metric to make the images closer for subjects with similar manifold. The learned Mahalanobis distance is then used to seek subjects to construct an optimal embedding. Generally, this type of methods can achieve good accuracy, while they are time consuming and can not meet real time requirement.

Designing robust features and then learning the transformation from designed features to head pose parameters is one of the most popular solutions for head pose estimation. Ma et al. [22] proposed a set of novel features, namely local biologically inspired features, by combing biologically inspired features and local binary pattern features. Ho and Chellappa [23] utilized dense SIFT descriptors as the robust representation for head pose estimation. In [23], random projection is used to reduce the dimension of the concatenated descriptor vector for efficient processing, and the combination of support vector machine and support vector regression is used to learn the mapping function. Haj et al. [24] presented a partial least squares (PLS) based method, which utilizes 3-level pyramid histogram of oriented gradients as feature representation. Murphy-Chutorian and Trivedi [3] extracted localized gradient orientation (LGO) histograms from the normalized face images and used Support Vector Regression (SVR) for head pose estimation. Huang et al. [25] proposed to use Gabor as feature representation and random forests as the classification technique.

A range image contains depth information related to the distance from the surfaces of scene objects to the camera. Therefore a range image of human head can be regarded as a 3D surface, shown in Fig. 1
                     (a). Using two planes to cut the 3D surface of the head, illustrated in Fig. 1(b), we can get a slice shown as Fig. 1(c). In this example, XOY is the 2D plane of the range image, and axis-z indicates depth value of each pixel within XOY plane, 
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        
                      and 
                        
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        
                      are the cutting planes which are perpendicular to axis-z, l is the depth value of plane-
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        
                     , and d is the distance between plane-
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        
                      and plane-
                        
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        
                     . Projecting the slice of Fig. 1(c) into XOY plane, we can get the slice area of a range image shown as Fig. 1(d), which can be formulated as:
                        
                           (1)
                           
                              
                                 
                                    S
                                 
                                 
                                    ω
                                 
                              
                              (
                              I
                              )
                              =
                              {
                              (
                              x
                              ,
                              y
                              )
                              |
                              l
                              ⩽
                              
                                 
                                    dv
                                 
                                 
                                    I
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                              ⩽
                              l
                              +
                              d
                              }
                           
                        
                     where 
                        
                           
                              
                                 S
                              
                              
                                 ω
                              
                           
                           (
                           I
                           )
                        
                      is the slice of range image I, 
                        
                           ω
                           =
                           (
                           l
                           ,
                           d
                           )
                        
                      denotes the slicing parameters and 
                        
                           
                              
                                 dv
                              
                              
                                 I
                              
                           
                           (
                           x
                           ,
                           y
                           )
                        
                      denotes the depth value of pixel (x,
                     y). In this paper, the depth values of range image I are normalized into the range of [0,255]. Therefore, 
                        
                           
                              
                                 dv
                              
                              
                                 I
                              
                           
                           (
                           x
                           ,
                           y
                           )
                           ∈
                           [
                           0
                           ,
                           255
                           ]
                        
                     . Physically, slice area 
                        
                           
                              
                                 S
                              
                              
                                 ω
                              
                           
                           (
                           I
                           )
                        
                      represents a set of points on head surface, whose depth value is in the range of 
                        
                           [
                           l
                           ,
                           l
                           +
                           d
                           ]
                        
                     .

In practice, it is a good choice to represent slice area as an image. For a given range image I and slicing parameters 
                        
                           ω
                           (
                           l
                           ,
                           d
                           )
                        
                     , the slice image 
                        
                           
                              
                                 Sim
                              
                              
                                 ω
                              
                           
                           (
                           I
                           )
                        
                      can be formulated as:
                        
                           (2)
                           
                              
                                 
                                    Sim
                                 
                                 
                                    ω
                                 
                              
                              (
                              I
                              )
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      Sim
                                                   
                                                
                                                (
                                                x
                                                ,
                                                y
                                                )
                                                =
                                                
                                                   
                                                      dv
                                                   
                                                   
                                                      I
                                                   
                                                
                                                (
                                                x
                                                ,
                                                y
                                                )
                                             
                                             
                                                if
                                                
                                                (
                                                x
                                                ,
                                                y
                                                )
                                                ∈
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      ω
                                                   
                                                
                                                (
                                                I
                                                )
                                             
                                          
                                          
                                             
                                                255
                                             
                                             
                                                else
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

A large number of 3D slices can be obtained by changing the parameters l and d. The richness of slice patterns provides a great flexibility to develop distinctive and robust slice feature sets for head pose estimation. We argue that slice representation of range data is advantageous for head pose estimation for the following reasons.
                        
                           •
                           The slice representation of range data provides discriminating visual cues for head pose estimation. Fig. 2
                               shows some slice samples of range images, which are cited from the dataset of [7] and preprocessed with the algorithm described in Section 4. The three range images shown in Fig. 2(a) come from the same person with different poses, and the three range images shown in Fig. 2(b) come from different persons with the same pose. In Fig. 2(a), we can see that the geometric shapes of the slices generated from different range images with the same slicing parameters are significantly different. And in Fig. 2(b), the geometric shapes of the slices generated from different range images are similar to each other. This demonstrates that the detailed slice information has potential discriminating power for head pose estimation.

The slice representation model of range data provides a flexible framework for designing new features of range images. Generally, it is difficult to design a simple model to accurately describe a range image. In this model, a range image is divided into a series of slices, shown as Fig. 2. If we can design a new simple model for representing a slice, then new features are generated by combining the features extracted from all slices.

The slice representation of range data is robust against noise. The slice patterns can be regarded as a local feature representation of range data. If the range data is polluted by some noise, such a local representation is more robust. In addition, we can obtain a large number of slice patterns, so the noise can only affect a small part of the slice pattern representations.

The slice representation of range data is computationally efficient. The computational cost to segment a slice from facial range data for feature extraction is ignorable.

Machine learning techniques can be used to select the most effective slices for head pose estimation. The slice patterns with different parameters l and d characterize facial pose features in different aspects. So we have the flexibility to only choose the most effective slice feature sets to improve the performance of traditional head pose estimation methods based on the whole range data.

In general, the slice pattern provides a new data format for designing of range image features. In this paper, two simple models are designed for representing the slices of a range image. In further, two sets of novel features, namely Local Slice Depth (LSD) and Local Slice Orientation (LSO), are proposed for range image representation.

The basic idea of local slice depth is to encode the relative depth information of local slice patches, as shown in Fig. 3
                        . Given a slice shown in Fig. 3(a), it is divided into m
                        *
                        n patches, where the parameters m and n are larger than 2 to achieve a detailed feature representation. The pixels within each patch can be partitioned into two sets which are facial region ϕ and non-facial region φ. Facial region consists of the pixels whose pixel value belongs to [0,254], and the non-facial region consists of the pixels whose pixel value is equal to 255. The average depth value of a patch 
                           
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                         is defined as
                           
                              (3)
                              
                                 ad
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                  
                                                                  
                                                                     k
                                                                     ∈
                                                                     ϕ
                                                                     (
                                                                     p
                                                                     )
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  d
                                                               
                                                               
                                                                  k
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   N
                                                   (
                                                   ϕ
                                                   )
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   ⩾
                                                   α
                                                
                                             
                                             
                                                
                                                   255
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   <
                                                   α
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              ϕ
                              (
                              p
                              )
                           
                         is the set of pixels in facial region, k is a pixel in 
                           
                              ϕ
                              (
                              p
                              )
                           
                        , 
                           
                              
                                 
                                    d
                                 
                                 
                                    k
                                 
                              
                           
                         is the depth value of pixel 
                           
                              k
                              ,
                              
                              N
                              (
                              ϕ
                              )
                           
                         is the number of pixels within facial region, 
                           
                              N
                              (
                              ϕ
                              )
                           
                         is the number of pixels within non-facial region, and α is the threshold value.

For the patches that are not located at the edge of a slice image, the block-based local pattern can be defined as follows.
                           
                              (4)
                              
                                 BLP
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 [
                                 
                                    
                                       a
                                    
                                    
                                       1
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       2
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       3
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       4
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       5
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       6
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       7
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       8
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ]
                              
                           
                        where 
                           
                              BLP
                              (
                              i
                              ,
                              j
                              )
                           
                         is a vector indicating the block-based local pattern of the patch 
                           
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ,
                              
                              
                                 
                                    a
                                 
                                 
                                    0
                                 
                              
                           
                         is the average depth value of patch 
                           
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                    -
                                    8
                                 
                              
                           
                         are the average depth values of the neighbor patches of 
                           
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        . In detail, 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    -
                                    1
                                    ,
                                    j
                                    -
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    2
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                    -
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    3
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    +
                                    1
                                    ,
                                    j
                                    -
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    4
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    -
                                    1
                                    ,
                                    j
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    5
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    +
                                    1
                                    ,
                                    j
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    6
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    -
                                    1
                                    ,
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    7
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    a
                                 
                                 
                                    8
                                 
                              
                              =
                              ad
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    +
                                    1
                                    ,
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                        .

The block-based local pattern features 
                           
                              
                                 
                                    F
                                 
                                 
                                    blp
                                 
                              
                              (
                              m
                              ,
                              n
                              )
                           
                         of a specific partition (m,n) are defined as a combination of local pattern features for all patches, which can be formulated as follows.
                           
                              (5)
                              
                                 
                                    
                                       F
                                    
                                    
                                       blp
                                    
                                 
                                 (
                                 m
                                 ,
                                 n
                                 )
                                 =
                                 BLP
                                 (
                                 2
                                 ,
                                 2
                                 )
                                 ∥
                                 BLP
                                 (
                                 2
                                 ,
                                 3
                                 )
                                 ∥
                                 …
                                 ∥
                                 BLP
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∥
                                 …
                                 ∥
                                 BLP
                                 (
                                 m
                                 -
                                 1
                                 ,
                                 n
                                 -
                                 1
                                 )
                              
                           
                        where 
                           
                              2
                              ⩽
                              i
                              ⩽
                              m
                              -
                              1
                              ,
                              
                              2
                              ⩽
                              j
                              ⩽
                              n
                              -
                              1
                           
                        , symbol 
                           
                              ∥
                           
                         represents concatenation of two vectors. Thus the local slice depth features 
                           
                              
                                 
                                    F
                                 
                                 
                                    lsd
                                 
                              
                              (
                              m
                              ,
                              n
                              )
                           
                         of a slice can be defined as
                           
                              (6)
                              
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                                 (
                                 ω
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 =
                                 
                                    
                                       F
                                    
                                    
                                       blp
                                    
                                 
                                 (
                                 3
                                 ,
                                 3
                                 )
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       blp
                                    
                                 
                                 (
                                 3
                                 ,
                                 4
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       blp
                                    
                                 
                                 (
                                 m
                                 ,
                                 n
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       blp
                                    
                                 
                                 (
                                 M
                                 ,
                                 N
                                 )
                              
                           
                        where ω is the slicing parameters, M and N are the maximal values of m and 
                           
                              n
                              ,
                              
                              3
                              ⩽
                              m
                              ⩽
                              M
                              ,
                              
                              3
                              ⩽
                              n
                              ⩽
                              N
                           
                        . Finally, the local slice depth features of a range image I can be defined as
                           
                              (7)
                              
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                                 (
                                 M
                                 ,
                                 N
                                 )
                                 =
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 …
                              
                           
                        
                     

Local slice orientation aims to characterize the relative orientation information of local slice patches taking the nose-tip as the reference point, as illustrated in Fig. 4
                        . Given a slice shown in Fig. 4(a), it is evenly divided into m
                        *
                        n patches, where the parameters m and n are larger than 1 to achieve a detailed feature representation. The orientation of a local slice patch is defined as the 3D vector of its centroid coordinates taking the nose-tip as the origin. The centroid coordinates of a patch 
                           
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                         are used to represent the spatial location of this patch, which is defined as
                           
                              (8)
                              
                                 C
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 )
                                 =
                                 (
                                 x
                                 ,
                                 y
                                 ,
                                 z
                                 )
                              
                           
                        where
                           
                              (9)
                              
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       x
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     y
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               )
                                                               ∈
                                                               ϕ
                                                               (
                                                               p
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                   
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   ⩾
                                                   α
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   <
                                                   α
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       y
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     y
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               )
                                                               ∈
                                                               ϕ
                                                               (
                                                               p
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               y
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                   
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   ⩾
                                                   α
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   if
                                                   
                                                   
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                      
                                                      
                                                         N
                                                         (
                                                         ϕ
                                                         )
                                                         +
                                                         N
                                                         (
                                                         φ
                                                         )
                                                      
                                                   
                                                   <
                                                   α
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       z
                                    
                                 
                                 =
                                 adv
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 )
                              
                           
                        
                        
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    k
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              )
                           
                         is a pixel of 
                           
                              ϕ
                              (
                              p
                              )
                           
                        , and 
                           
                              adv
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              )
                           
                         is the average depth value of 
                           
                              ϕ
                              (
                              p
                              )
                           
                        . The block-based slice orientation of a patch can be defined as follows.
                           
                              (12)
                              
                                 BSO
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 (
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       x
                                    
                                 
                                 -
                                 
                                    
                                       n
                                    
                                    
                                       x
                                    
                                 
                                 ,
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       y
                                    
                                 
                                 -
                                 
                                    
                                       n
                                    
                                    
                                       y
                                    
                                 
                                 ,
                                 C
                                 
                                    
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       z
                                    
                                 
                                 -
                                 
                                    
                                       n
                                    
                                    
                                       z
                                    
                                 
                                 )
                              
                           
                        where 
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    x
                                 
                              
                              ,
                              
                                 
                                    n
                                 
                                 
                                    y
                                 
                              
                              ,
                              
                                 
                                    n
                                 
                                 
                                    z
                                 
                              
                              )
                           
                         is the coordinates of nose-tip.

The block-based slice orientation features 
                           
                              
                                 
                                    F
                                 
                                 
                                    bso
                                 
                              
                              (
                              m
                              ,
                              n
                              )
                           
                         of a specific partition (m,
                        n) are defined as a combination of slice orientation for all patches, which can be formulated as follows.
                           
                              (13)
                              
                                 
                                    
                                       F
                                    
                                    
                                       bso
                                    
                                 
                                 (
                                 m
                                 ,
                                 n
                                 )
                                 =
                                 BSO
                                 (
                                 1
                                 ,
                                 1
                                 )
                                 ∥
                                 BSO
                                 (
                                 1
                                 ,
                                 2
                                 )
                                 ∥
                                 …
                                 ∥
                                 BSO
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∥
                                 …
                                 ∥
                                 BSO
                                 (
                                 m
                                 ,
                                 n
                                 )
                              
                           
                        where 
                           
                              1
                              ⩽
                              i
                              ⩽
                              m
                              ,
                              
                              1
                              ⩽
                              j
                              ⩽
                              n
                           
                        . Thus the local slice orientation features 
                           
                              
                                 
                                    F
                                 
                                 
                                    lso
                                 
                              
                              (
                              m
                              ,
                              n
                              )
                           
                         of a slice can be defined as
                           
                              (14)
                              
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                                 (
                                 ω
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 =
                                 
                                    
                                       F
                                    
                                    
                                       bso
                                    
                                 
                                 (
                                 1
                                 ,
                                 1
                                 )
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       bso
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       bso
                                    
                                 
                                 (
                                 m
                                 ,
                                 n
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       bso
                                    
                                 
                                 (
                                 M
                                 ,
                                 N
                                 )
                              
                           
                        where ω is the slicing parameters, M and N are the maximal values of m and 
                           
                              n
                              ,
                              
                              1
                              ⩽
                              m
                              ⩽
                              M
                              ,
                              
                              1
                              ⩽
                              n
                              ⩽
                              N
                           
                        . Finally, the local slice depth features of a range image I can be defined as
                           
                              (15)
                              
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                                 (
                                 M
                                 ,
                                 N
                                 )
                                 =
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 …
                                 ∥
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 M
                                 ,
                                 N
                                 )
                                 ∥
                                 …
                              
                           
                        
                     

Head pose estimation is a typical pattern recognition problem, which usually follows the process of preprocessing, feature extraction, and classification (or regression). In this section, we introduce how slice pattern representation is used to estimate a person’s head pose parameters from a single range image captured by a Kinect sensor.

The main functionality of image preprocessing is to segment facial area from a range image. In this section, we provided a simple preprocessing method for the data captured by a Kinect sensor. It combines both depth and color information for facial region segmentation following a coarse-to-fine strategy. Firstly head region is coarsely localized using range data. Secondly, facial region is refined by removing the noise of hair and clothes from head region with the color information.

The basic idea of coarse head localization is illustrated in Fig. 5
                           . Human body is usually the frontal region in range data and the pixel in a range image indicates the depth value of its corresponding physical object. So it is easy to firstly segment the human body area from background using a simple thresholding technique (see Fig. 5(a)). Secondly, the position of head area can be coarsely localized using projecting histogram based on the assumption that the head is upright at the imaging time. All pixels of the human body are projected along vertical and horizontal directions respectively to get two histograms 
                              
                                 Histo
                                 _
                                 row
                                 (
                                 I
                                 )
                              
                            and 
                              
                                 Histo
                                 _
                                 col
                                 (
                                 I
                                 )
                              
                           , which are shown as Fig. 5(b and c). And then the coordinates of the head top center 
                              
                                 P
                                 (
                                 
                                    
                                       r
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       ∗
                                    
                                 
                                 )
                              
                            can be estimated as follows.
                              
                                 (16)
                                 
                                    
                                       
                                          r
                                       
                                       
                                          ∗
                                       
                                    
                                    =
                                    
                                       
                                          
                                             arg
                                             min
                                          
                                          
                                             r
                                          
                                       
                                    
                                    {
                                    Histo
                                    _
                                    row
                                    
                                       
                                          |
                                       
                                       
                                          r
                                       
                                    
                                    (
                                    I
                                    )
                                    >
                                    0
                                    )
                                 
                              
                           
                           
                              
                                 (17)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    =
                                    
                                       
                                          
                                             arg
                                             max
                                          
                                          
                                             c
                                          
                                       
                                    
                                    (
                                    Histo
                                    _
                                    col
                                    
                                       
                                          |
                                       
                                       
                                          c
                                       
                                    
                                    (
                                    I
                                    )
                                    )
                                 
                              
                           
                        

After getting the position of a head’s top center, the head region can be defined as 
                              
                                 R
                                 (
                                 
                                    
                                       c
                                    
                                    
                                       ∗
                                    
                                 
                                 -
                                 w
                                 /
                                 2
                                 ,
                                 
                                    
                                       r
                                    
                                    
                                       ∗
                                    
                                 
                                 -
                                 h
                                 /
                                 2
                                 ,
                                 w
                                 ,
                                 h
                                 )
                              
                           , where w is the width of rectangle R and h is the height of rectangle R. Both w and h are set as fixed value.

In localized head images, there are mainly two types of noise which are hair noise and clothes noise, as shown in Fig. 6
                           . Removal of both types of noise from range images is a difficult problem, whereas it is an easy task in color images. The color features between facial skin and noisy regions such as hair and clothes are significantly different, so it is a good idea to use skin tone detection algorithm for noise removal. Fig. 6(e–h) demonstrate the results of skin tone detection for fine segmentation of facial region. We employ an existing skin detection algorithm [26] for this purpose.

The main operation of extracting LSD and LSO features from a slice is to calculate the average depth value and geometric center of all patches. Applying the idea of integral image, we can achieve real-time feature extraction.

In this subsection, we propose two novel integral images, namely slice depth integral image and slice coordinates integral image, to achieve real-time feature extraction.

Slice depth integral images, which consist of depth integral image 
                              
                                 
                                    
                                       I
                                    
                                    
                                       integral
                                    
                                 
                                 [
                                 255
                                 ]
                              
                            and count integral image 
                              
                                 
                                    
                                       cout
                                    
                                    
                                       integral
                                    
                                 
                                 [
                                 255
                                 ]
                              
                           , are designed for LSD feature extraction. The detail algorithm for generating slice depth integral image is presented in Algorithm 1. With the assistance of slice depth integral image, LSD features can be quickly extracted from a slice.
                              Algorithm 1
                              Algorithm for generating slice depth integral images 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   Require:
                                                
                                             
                                             
                                                
                                                   Range image of face: I
                                                
                                             
                                             
                                                
                                                   Ensure:
                                                
                                             
                                             
                                                
                                                   Slice depth integral images: 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                      
                                                   
                                                
                                             
                                             
                                                1: 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         =
                                                         0
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         =
                                                         0
                                                      
                                                   ;
                                             
                                             
                                                2: for 
                                                   i
                                                   =1 to WIDTH (I) do
                                                
                                             
                                             
                                                3: 
                                                   for 
                                                   j
                                                   =1 to HEIGHT (I) do
                                                
                                             
                                             
                                                4: 
                                                   v
                                                   =IMAGE-ELEM (I,
                                                   i,
                                                   j);
                                             
                                             
                                                5: 
                                                   if 
                                                   v
                                                   <255 then
                                                
                                             
                                             
                                                6: 
                                                   IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   +v;
                                             
                                             
                                                7: 
                                                   
                                                   for 
                                                   k
                                                   =0 to 255 do
                                                
                                             
                                             
                                                8: 
                                                   
                                                   if 
                                                   
                                                      
                                                         k
                                                         !
                                                         =
                                                         v
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                9: 
                                                   
                                                   IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         k
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         k
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         k
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         k
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   ;
                                             
                                             
                                                10: 
                                                   
                                                   end if
                                                
                                             
                                             
                                                11: 
                                                   
                                                   end for
                                                
                                             
                                             
                                                12: 
                                                   end if
                                                
                                             
                                             
                                                13: 
                                                   end for
                                                
                                             
                                             
                                                14: end for
                                                
                                             
                                             
                                                15: for 
                                                   i
                                                   =1 to 254 do
                                                
                                             
                                             
                                                16: 
                                                   
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         ]
                                                         +
                                                         =
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         -
                                                         1
                                                         ]
                                                      
                                                   ;
                                             
                                             
                                                17: 
                                                   
                                                      
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         ]
                                                         +
                                                         =
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         -
                                                         1
                                                         ]
                                                      
                                                   ;
                                             
                                             
                                                18: end for
                                                
                                             
                                             
                                                19: return 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                      
                                                   ;
                                             
                                          
                                       
                                    
                                 
                              

Similarly, slice coordinates integral images, which consist of x-coordinate integral image 
                              
                                 
                                    
                                       I
                                    
                                    
                                       integral
                                    
                                    
                                       x
                                    
                                 
                                 [
                                 255
                                 ]
                              
                           , y-coordinate integral image 
                              
                                 
                                    
                                       I
                                    
                                    
                                       integral
                                    
                                    
                                       y
                                    
                                 
                                 [
                                 255
                                 ]
                              
                            and count integral image 
                              
                                 
                                    
                                       cout
                                    
                                    
                                       integral
                                    
                                 
                                 [
                                 255
                                 ]
                              
                           , are designed for LSO feature extraction. The detail algorithm for generating slice depth integral image is presented in Algorithm 2. With the assistance of slice depth integral image, LSO features can be quickly extracted from a slice.

Nose tip is used by local slice orientation, hence nose tip detection should be the pre-step of LSO feature extraction. Fortunately, Kinect face tracking SDK can provide the position of nose tip in real-time. In this paper, we only focus on slice representation of range data. So we suppose that nose tip is detected before extracting LSO features.
                              Algorithm 2
                              Algorithm for generating slice coordinates integral images 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   Require:
                                                
                                             
                                             
                                                
                                                   Range image of face: I
                                                
                                             
                                             
                                                
                                                   Ensure:
                                                
                                             
                                             
                                                
                                                   Slice coordinates integral images: 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                      
                                                   
                                                
                                             
                                             
                                                1: 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         =
                                                         0
                                                         ,
                                                         
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         =
                                                         0
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         =
                                                         0
                                                      
                                                   ;
                                             
                                             
                                                2: for 
                                                   i
                                                   =1 to WIDTH (I) do
                                                
                                             
                                             
                                                3: 
                                                   for 
                                                   j
                                                   =1 to HEIGHT (I) do
                                                
                                             
                                             
                                                4: 
                                                   v = ELEM (I,
                                                   i,
                                                   j);
                                             
                                             
                                                5: 
                                                   if 
                                                   v
                                                   <255 then
                                                
                                             
                                             
                                                6: 
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   +i;
                                             
                                             
                                                7: 
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −IMAGE-ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   +j;
                                             
                                             
                                                8: 
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   +1;
                                             
                                             
                                                9: 
                                                   
                                                   for 
                                                   k
                                                   =0 to 255 do
                                                
                                             
                                             
                                                10: 
                                                   
                                                   if 
                                                   
                                                      
                                                         k
                                                         !
                                                         =
                                                         v
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                11: 
                                                   
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   ;
                                             
                                             
                                                12: 
                                                   
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   ;
                                             
                                             
                                                13: 
                                                   
                                                   ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   =ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   +ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   
                                                   −ELEM
                                                      
                                                         (
                                                         
                                                            
                                                               count
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         v
                                                         ]
                                                         ,
                                                         i
                                                         -
                                                         1
                                                         ,
                                                         j
                                                         -
                                                         1
                                                         )
                                                      
                                                   ;
                                             
                                             
                                                14: 
                                                   
                                                   end if
                                                
                                             
                                             
                                                15: 
                                                   
                                                   end for
                                                
                                             
                                             
                                                16: 
                                                   end if
                                                
                                             
                                             
                                                17: 
                                                   end for
                                                
                                             
                                             
                                                18: end for
                                                
                                             
                                             
                                                19: for 
                                                   i
                                                   =1 to 254 do
                                                
                                             
                                             
                                                20: 
                                                   
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         i
                                                         ]
                                                         +
                                                         =
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         i
                                                         -
                                                         1
                                                         ]
                                                      
                                                   ;
                                             
                                             
                                                21: 
                                                   
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         i
                                                         ]
                                                         +
                                                         =
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         i
                                                         -
                                                         1
                                                         ]
                                                      
                                                   ;
                                             
                                             
                                                22: 
                                                   
                                                      
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         ]
                                                         +
                                                         =
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         i
                                                         -
                                                         1
                                                         ]
                                                      
                                                   ;
                                             
                                             
                                                23: end for
                                                
                                             
                                             
                                                24: return 
                                                      
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               I
                                                            
                                                            
                                                               integral
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                         ,
                                                         
                                                         
                                                            
                                                               cout
                                                            
                                                            
                                                               integral
                                                            
                                                         
                                                         [
                                                         255
                                                         ]
                                                      
                                                   ;
                                             
                                          
                                       
                                    
                                 
                              

Given a set of local slice features, a mapping function is necessary to model the relationship between local slice features and head poses. Random regression forests are used to learn such a mapping function.

As a bagging based classifier, random forests have a number of advantages. Firstly, random forests can achieve high accuracy in machine learning, with a comparable accuracy with Adaboost. And it is more robust than Adaboost in terms of generalization capability. Furthermore, random forests can be implemented efficiently on GPU due to its parallel structure. A forest consists of a number of parallel decision trees. Each tree can be trained or used for prediction task separately. Within each tree, there are two types of nodes: split node and leaf node. A split node is always corresponding to a binary test, which directs samples towards the left or right child. The binary test can be defined as:
                           
                              (18)
                              
                                 
                                    
                                       F
                                    
                                    
                                       
                                          
                                             lsd
                                             ,
                                             lso
                                          
                                       
                                    
                                 
                                 (
                                 I
                                 )
                                 
                                    
                                       |
                                    
                                    
                                       j
                                    
                                 
                                 >
                                 τ
                              
                           
                        where τ is the threshold of the binary test, I is a head range image, lsd represents local slice depth features, lso represents local slice orientation features, and j represents the jth feature of 
                           
                              
                                 
                                    F
                                 
                                 
                                    lsd
                                 
                              
                           
                         or 
                           
                              
                                 
                                    F
                                 
                                 
                                    lso
                                 
                              
                           
                        . A leaf node can be regarded as a cluster of samples that can be described by a simple model. During training process, the samples falling in a leaf node are averaged to get the model’s parameters, and the parameters are stored in this leaf node. The binary test of split nodes and the distribution parameters of leaf nodes are generated during training process. During testing process, according to the result of binary test, the new coming sample goes down from the root of decision trees till leaf nodes are reached. Finally, the average result of each tree is used to predict the result. Fig. 7
                         graphically illustrates how head pose parameters are estimated within a decision tree using local slice depth features.

Human head can be modeled as a disembodied rigid object [1], which can be characterized by pitch, roll and yaw angles. Thus training samples can be represented as a vector set 
                              
                                 {
                                 
                                    
                                       I
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                       ,
                                       lso
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 }
                              
                           . 
                              
                                 
                                    
                                       F
                                    
                                    
                                       lsd
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       F
                                    
                                    
                                       lso
                                    
                                 
                              
                            correspond to the local slice depth features and local slice orientation features of sample i respectively, 
                              
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 (
                                 α
                                 ,
                                 β
                                 ,
                                 γ
                                 )
                              
                            are the annotated parameters of head poses. To build a decision tree, a subset of training samples is randomly selected firstly according to the framework of random forests [27]. Secondly, a subset of features is randomly selected to generate a set of splitting candidates, namely the binary tests 
                              
                                 φ
                                 =
                                 (
                                 ω
                                 ,
                                 M
                                 ,
                                 N
                                 ,
                                 j
                                 ,
                                 τ
                                 )
                              
                           , according to Eq. (17), where ω, M and N are feature parameters, j represents the jth dimension feature selected from local slice depth feature vector or local slice orientation feature vector, and τ is the threshold of binary test. Finally, the decision tree is built recursively starting from the root node with the following two steps:
                              
                                 1.
                                 For the sample set D reaching a node, if the number of these samples is less than a fixed threshold η or the depth of the tree reaches the maximum value λ, then it is represented as a leaf node. Otherwise the sample set D is pre-split into two subsets 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                L
                                             
                                          
                                       
                                     and 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                R
                                             
                                          
                                       
                                     using each binary test 
                                       
                                          φ
                                          (
                                          ω
                                          ,
                                          M
                                          ,
                                          N
                                          ,
                                          j
                                          ,
                                          τ
                                          )
                                       
                                    :
                                       
                                          (19)
                                          
                                             
                                                
                                                   D
                                                
                                                
                                                   L
                                                
                                             
                                             =
                                             {
                                             I
                                             |
                                             
                                                
                                                   F
                                                
                                                
                                                   lsd
                                                   ,
                                                   lso
                                                
                                             
                                             
                                                
                                                   |
                                                
                                                
                                                   j
                                                
                                             
                                             <
                                             τ
                                             ,
                                             I
                                             ∈
                                             D
                                             }
                                          
                                       
                                    
                                    
                                       
                                          (20)
                                          
                                             
                                                
                                                   D
                                                
                                                
                                                   R
                                                
                                             
                                             =
                                             {
                                             I
                                             |
                                             
                                                
                                                   F
                                                
                                                
                                                   lsd
                                                   ,
                                                   lso
                                                
                                             
                                             
                                                
                                                   |
                                                
                                                
                                                   j
                                                
                                             
                                             ⩾
                                             τ
                                             ,
                                             I
                                             ∈
                                             D
                                             }
                                          
                                       
                                    The information gain 
                                       
                                          IG
                                          (
                                          φ
                                          )
                                       
                                     of each splitting is computed as:
                                       
                                          (21)
                                          
                                             IG
                                             (
                                             φ
                                             )
                                             =
                                             H
                                             (
                                             D
                                             )
                                             -
                                             (
                                             
                                                
                                                   w
                                                
                                                
                                                   L
                                                
                                             
                                             H
                                             (
                                             
                                                
                                                   D
                                                
                                                
                                                   L
                                                
                                             
                                             )
                                             +
                                             
                                                
                                                   w
                                                
                                                
                                                   R
                                                
                                             
                                             H
                                             (
                                             
                                                
                                                   D
                                                
                                                
                                                   R
                                                
                                             
                                             )
                                             )
                                          
                                       
                                    where H denotes differential entropy. 
                                       
                                          
                                             
                                                w
                                             
                                             
                                                L
                                             
                                          
                                       
                                     is the ratio between the number of samples in set 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                L
                                             
                                          
                                       
                                     and set D, and 
                                       
                                          
                                             
                                                w
                                             
                                             
                                                L
                                             
                                          
                                       
                                     is the ratio between the number of samples in set 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                R
                                             
                                          
                                       
                                     and set D. Here we model the head pose parameter vector 
                                       
                                          P
                                          =
                                          (
                                          α
                                          ,
                                          β
                                          ,
                                          γ
                                          )
                                       
                                     as a multivariate Gaussian distribution. Therefore Eq. (20) can be reformulated as:
                                       
                                          (22)
                                          
                                             IG
                                             (
                                             φ
                                             )
                                             =
                                             log
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      D
                                                   
                                                
                                             
                                             -
                                             
                                                
                                                   
                                                      
                                                         
                                                            w
                                                         
                                                         
                                                            L
                                                         
                                                      
                                                      log
                                                      
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  
                                                                     D
                                                                  
                                                                  
                                                                     L
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            w
                                                         
                                                         
                                                            R
                                                         
                                                      
                                                      log
                                                      
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  
                                                                     D
                                                                  
                                                                  
                                                                     R
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

Compute the largest information gain:

If 
                              
                                 IG
                                 (
                                 
                                    
                                       φ
                                    
                                    
                                       ∗
                                    
                                 
                                 )
                              
                            is larger than a fixed threshold, we label this node as a split node and assign the parameters of corresponding binary test 
                              
                                 φ
                                 (
                                 ω
                                 ,
                                 M
                                 ,
                                 N
                                 ,
                                 j
                                 ,
                                 τ
                                 )
                              
                            to the node. Or, we label it as a leaf node and store the mean and covariance of D in this node.

For an input test sample, it goes down from the root of each tree within the trained forests, and is recursively directed to left or right child according to the binary test stored in split nodes until a leaf node is reached. The distributions of all leaf nodes reached by this sample are averaged to generate the final result. The whole process of head pose estimation based on a decision tree is illustrated in Fig. 7.

@&#EXPERIMENTAL RESULTS@&#

Performance evaluation of head pose estimation is a challenging task. Firstly, it is difficult to precisely measure the head pose of subjects in practical applications. Even we can control the head pose of volunteers in database construction, it is still a nontrivial task to measure the ground truth of the three head pose parameters with a high precision. Secondly, it is difficult to capture head pose patterns with all possible variations. Ideally the head pose estimation methods should be tested for various subjects (male or female, age, race, body shape, etc.) under different imaging conditions (illumination, background, hair, clothes, etc.). Thirdly, how to evaluate the overall error of head pose estimation since it is constituted by three angles, i.e. yaw, pitch, and roll? And how to compare the performance of different head pose estimation methods based on their results on a database?

The publicly available head pose databases containing range data are limited. This paper uses Biwi head pose database [7] and ETH face pose range image dataset [12] for evaluating the performance of proposed method. The comparative evaluation of our method has been performed with respect to the methods reported in [11,5,7,12], as they are state-of-the-art range image based head pose estimation methods. In order to perform fair comparisons, we directly cite the experimental results of these methods from [11,5,7,12]. The method reported in [11] was tested on both Biwi and ETH databases, while [5,12] only provide experimental results on the ETH database, and [7] only shows the experimental results on the Biwi database. Thus, comparison of our method with [11,5,12] is performed on the ETH face pose range image dataset, and comparison of our method with [11,7] is performed on the Biwi Kinect head pose database.

Our method is mainly controlled by three types of parameters, which are slicing parameters 
                           
                              (
                              l
                              ,
                              d
                              )
                           
                        , pyramid parameters (M,
                        N), and random forests parameters including the threshold value of binary test τ, the maximum depth of decision tree λ, the sample count threshold for splitting a node η and the maximum number of trees T.

In our experiments, the random forests algorithm of OpenCV is employed to learn the mapping function from LSD or LSO features to head pose parameters. Thus, the threshold value of binary test τ is automatically decided by the algorithm. For other parameters of random forests algorithm, we set the maximum depth of decision tree λ as 10, the sample count threshold for splitting a node η as 20, and the maximum number of trees T as 20. The slicing parameters (l, d) and pyramid parameters (M,
                        N) are tunable variables in the following experiments.

According to Section 2.2, the depth values of a range image are normalized into the range of [0,255]. Thus, there are theoretically 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    255
                                 
                              
                              (
                              255
                              -
                              i
                              )
                              =
                              32
                              ,
                              640
                           
                         slices at most for a given range image. In practice, LSD or LSO features are generated from a subset of these slices. Each slice is uniquely decided by slicing parameters (l,
                        d). Therefore, there would be a large number of (l,
                        d) pairs for each set of LSD or LSO features. In our experiments, l is set as 0, and d is set as an increasing arithmetic sequence with a common difference Δd. The reasons for this setting are presented as follows.
                           
                              •
                              The feature dimensionality of both LSD and LSO can be dramatically reduced without significant degradation of head pose estimation accuracy. The resolution of range images in both Biwi Kinect head pose database and ETH face pose range image dataset is 640*480. Thus, the resolution of the head region would be about 150*150. This may cause that the local features of the slices with small d (e.g. d
                                 <5) are not distinctive to each other, and the information contained in the slices with l
                                 >0 is mostly included in the slices with l
                                 =0. A simple experiment has been performed to validate this analysis. When we set Δd
                                 >10 and l
                                 =0, the feature dimension of LSD and LSO is dramatically reduced, and the efficiency of this method is greatly increased, while the accuracy of this method is not decreased significantly.

It is more convenient to experimentally describe the relationship between slicing parameters (l,
                                 d) and system performance. For a given Δd, a sequence of d can be generated from 0 to 255. We can describe the relationship between slicing parameters (l,
                                 d) and system performance by analyzing the changes of Δd.

With these settings, the set of slices for generating LSD or LSO features are only decided by Δd. Each set of LSD or LSD features extracted from a head range image will contain 
                           
                              
                                 
                                    255
                                 
                                 
                                    Δ
                                    d
                                 
                              
                           
                         slices. The M and N parameters of LSD are limited in the set {3,4,5,6,7,8}, and the M and N parameters of LSO are limited in the set {1,2,3,4}. In this paper, all experiments were performed on a computer with an Intel Core2 CPU @2.83GHZ∗2 and 4GB RAM using C++.

Before showing experimental results, we introduce the metrics used for evaluating the performance of head pose estimation method. Generally, there are three metrics, which are mean absolute error (MAE), standard deviation (SD), and estimation accuracy. MAE and SD are common metrics for regression evaluation. The metrics of accuracy is usually used to indicate the comprehensive performance of a method in computer vision. Currently, the accuracy of head pose estimation method is not defined in the literature. In this section, we give the definition.

The accuracy of head pose estimation method refers how the predicted face orientation closes to groundtruth. Face orientation, which describes the direction a person looks to, has direct relationship with head pose and can provide a comprehensive description of head pose. In some applications (e.g. gaze estimation), the main purpose of head pose estimation is to predicate face orientation. And in some cases [12], face orientation is directly used to describe head pose. Thus, it is natural to evaluate the accuracy performance of head pose estimation method using face orientation of a head.

Euler rotation angle is the most widely used model for describing the pose of a head, shown as Fig. 8
                        (a). It regards head as a disembodied rigid object. Any pose of a head can be generated from the three Euler rotation angles (α,
                        β,
                        γ) by performing rotation operations to the head along x, y and z axis.

Thus, the face orientation Γ(x,
                        y,
                        z) can be calculated as follows:
                           
                              (24)
                              
                                 Γ
                                 (
                                 x
                                 ,
                                 y
                                 ,
                                 z
                                 )
                                 =
                                 R
                                 (
                                 α
                                 ,
                                 β
                                 ,
                                 γ
                                 )
                                 
                                    
                                       [
                                       1
                                       ,
                                       0
                                       ,
                                       0
                                       ]
                                    
                                    
                                       T
                                    
                                 
                              
                           
                        where R(α,
                        β,
                        γ) is the rotation matrix, [1,0,0]
                           T
                         is the orientation of the face with the rotations of (α,
                        β,
                        γ)=(0,0,0).

The estimation error of face orientation is defined as the angle θ between the predicted face orientation and the groundtruth. For a given threshold t and a testing sample, if its estimation error is less than t, then the testing sample is regarded as a positive sample. Or, it should be regarded as a negative sample. Then, the orientation estimation accuracy is defined as follows:
                           
                              (25)
                              
                                 acc
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       N
                                       (
                                       ξ
                                       )
                                    
                                    
                                       N
                                       (
                                       Ω
                                       )
                                    
                                 
                              
                           
                        where Ω is the test set, 
                           
                              ξ
                              =
                              {
                              i
                              |
                              
                                 
                                    θ
                                 
                                 
                                    i
                                 
                              
                              <
                              t
                              ,
                              i
                              ∈
                              Ω
                              }
                           
                         is the positive samples whose estimation error is less than t, t is the estimation error threshold, 
                           
                              N
                              (
                              ξ
                              )
                           
                         is the number of samples in ξ, and N(Ω) is the number of samples in Ω.

The Biwi head pose database is collected by a Kinect sensor, containing 24 image sequences captured from 20 subjects. There are roughly 15,000 frames annotated with head center locations and three rotation angles. Each frame of the video includes a pair of color image and range image. The background of these images are totally removed. The head pose parameters of most frames are within the range of [−45°, 45°] for yaw, [−45°, 45°] for pitch, [−25°, 25°] for roll, as shown in Fig. 9
                        . Moreover, during construction of this database, some variation factors (e.g., hairstyle, face expression, eye glasses and mustache changes) are introduced, which makes this database more challenging.

In this section, we evaluate the performance of the proposed slice representation of range data on the Biwi Kinect head pose database. In order to evaluate the person-independent performance of this method, the experiment conducted on this database follows the strategy of subject based leave-one-out cross validation. In each folder of validation, the samples from a subject are used as testing set, and the rest samples are used as training set. The complete process of our method can be automatically implemented on Kinect data.

The mean absolute error (MAE) of head pose estimation results for different rotation angles is presented in Fig. 10
                            when Δd is set as 15. We can see that accurate head pose estimation can be achieved when the head rotations are within [−40°, 40°] for pitch, [−40°, 40°] for yaw, and [−25°, 25°] for roll. But the accuracy of head pose estimation decreases dramatically for the extreme cases with large head rotation angles. The reasons are mainly twofold.
                              
                                 •
                                 Lack of enough training samples for these extreme cases with large rotation angles of head pose. As shown in Fig. 9, most samples in the Biwi Kinect head pose database are in the normal range 
                                       
                                          (
                                          yaw
                                          ∈
                                          [
                                          -
                                          45
                                          °
                                          ,
                                          45
                                          °
                                          ]
                                          ,
                                          pitch
                                          ∈
                                          [
                                          -
                                          45
                                          °
                                          ,
                                          45
                                          °
                                          ]
                                          
                                          and
                                          
                                          roll
                                          ∈
                                          [
                                          -
                                          20
                                          °
                                          ,
                                          20
                                          °
                                          ]
                                          )
                                       
                                    . Therefore the limited number of training samples with large pose angles determines that it is difficult to learn a stable estimator for these samples. This is a common problem of learning-based methods. A good solution to address this problem is to construct a more complete training database, including a large number of range images with large pose parameters. It is a good idea to generate an ideal synthetic training data set for head pose estimation (e.g., [14,5]).

Inaccurate segmentation of the neck region. Fig. 11
                                     shows the facial region segmentation results of our preprocessing method. We can see that the facial region can be accurately segmented for a frontal face image. However, a large portion of neck region is contained in the segmented results for a profile face image. This would decrease the accuracy of our head pose estimation method. If there is a more accurate facial region segmentation algorithm for profile face images, we believe that the accuracy of this head pose estimation method can be significantly improved. Unfortunately, it is currently a difficult problem to accurately segment facial regions from range images when the head has a large rotation angle.


                           Fig. 12
                            shows the accuracy of this method using local slice depth as features. In Fig. 12(a), the accuracy of this method as a function of Δd is demonstrated, when the estimation error threshold is set as 10°. And the plots in Fig. 12(b) indicate the relationship between the accuracy and the estimation error threshold. Generally, the accuracy of head pose estimation is improved with the increase of M and N. The reason is that larger M and N mean more details of LSD features. However, the dimensionality of LSD feature vector is also increased accordingly. In addition, the accuracy of head pose estimation can not be significantly improved when M and N are larger than a certain value. With the settings of M
                           =8 and N
                           =8, this method can achieve a 83.1% success rate within a tolerable error of 15°, and 87.8% for 20°. The results are good enough for coarse pose estimation. Moreover, LSD can achieve a high accuracy when the rotation angle of a head is controlled in normal range. The black solid plot in Fig. 12(b) presents the experimental results on the normal rotation subset of Biwi Kinect head pose database with yaw from −40° to 40°, pitch from −40° to 40° and roll from −25° to 25°. The high accuracy demonstrates that local slice depth is well suited for feature representation of range data in most cases.

The focus of this paper is on slice representation of range data, so we only use a simple nose-tip detection algorithm to obtain the reference point for local slice orientation. To evaluate the potential performance of LSO, two sets of experiments were conducted. One uses the manually labeled nose-tip as the reference point of LSO features, and its experimental results are shown as dotted plots. The other takes the automatically detected nose-tip and the results are shown as solid plots. The experimental results of the former can be regarded as the theoretical upper limit of the proposed LSO feature representation, while the latter is its practical results. With an accurate nose-tip detection method, the practical accuracy of head pose estimation is close to the theoretical accuracy of LSO.

The mean absolute error of fine pose estimation method is shown in Fig. 13
                            as a function of rotation angles when Δd is set as 15. We can see that the MAE of LSO is significantly smaller than LSD for yaw and pitch angle estimation and there is a slight improvement for roll angle estimation. This demonstrates that the distinctiveness of LSO features for roll angle is not good as yaw and pitch angles. Actually, the main information encoded in LSO features is the orientation and distance between slice centroid and the reference point. Both these two types of information is distinctive for describing the changes of yaw and pitch angles. Whereas, for the poses with different roll angles, the distance between slice centroid and reference point does not have a significant change. An example is graphically illustrated in Fig. 14
                           .

The head pose estimation accuracy of LSO as a function of Δd is shown in Fig. 15
                           (a). Generally, smaller Δd leads to higher accuracy of head pose estimation, but higher dimensionality of LSO feature vector as well. So there is a tradeoff between accuracy and efficiency in setting an appropriate value of Δd. In our method, it is a good choice to set Δd around 15. The estimation accuracy of LSO as a function of error threshold and the comparison with [7,11] are presented in Fig. 15(b). We can see that our method significantly outperforms Fanellil’s method [7] and is comparable with Padeleris’ method [11]. When the tolerable estimation error threshold is less than about 15°, Padeleris’ method [11] performs better than LSO. However, LSO is significantly better than Padeleris’ method [11] when the application can tolerate head pose error larger than 15°. It should be noted that Padeleris’ method [11] builds a user specific template for head pose estimation. And this method needs user cooperation to provide a frontal head pose as the reference at initial stage. As we know, there must exist individual difference between head geometric patterns of different subjects, therefore it is a much more difficult task for generic template based head pose estimation methods such as LSO and Fanellil’s method [7]. It is expected to achieve a much higher accuracy for our approach if we also train a specific pose model for each subject using the similar strategy of Padeleris’ method [11].

The detailed accuracy of our method compared with state-of-the-art head pose estimation methods is presented in Table 1
                           . Columns from 2 to 4 are the mean absolute error and standard deviation of estimation results for yaw, pitch and roll angles respectively. The last column is the estimation accuracy when the angle error threshold is set as 10°, 15° and 20° respectively. The second row presents Fanelli’s results cited from [7], and the third row shows Padeleris’ results cited from [11]. The fourth row describes our results using LSD features when M
                           =8, N
                           =8, and Δd
                           =15. And the fifth row shows the results of our automatic estimation method using LSO features when M
                           =3, N
                           =3 and Δd
                           =15. Generally, the accuracy of our fine pose estimation method is better than Fanelli’s method and is comparable with Padeleris’ method.

The ETH face pose range image dataset contains about 10,500 range images of 26 subjects including 20 males and 6 females. In this dataset, the range images are continuously captured by a depth camera of [13] at 28fps with a solution of 640*480. Since a professional depth sensor is used to collect the ETH database, the range data in the ETH database has higher quality than the data in the Biwi database. So higher accuracy of head pose estimation is expected in the ETH database. The ground truth of each range image includes the 3D coordinates of nose tip and face orientation. This dataset covers the rotation angles of a head from −90° to +90° for yaw and from −45° to +45° for pitch. Since the ETH database is captured by a depth camera rather than Kinect, there are only range images and without color images. So the preprocessing method in our previous work [6] is used to preprocess the range images in this database, and manually labeled nose-tip is used as the reference point of LSO features. We compare the MAE of yaw and pitch angles, and the head pose estimation accuracy of our method with Fanelli’s [5], Breitenstein’s [12] and Padeleris’ [11] methods on this database.

The mean absolute errors of head pose estimation using LSD and LSO features on the ETH database are shown in Fig. 16
                        , and the estimation accuracy is shown in Fig. 17
                        . We can see that both MAE and accuracy of LSO are obviously better than LSD. The mean absolute errors of LSO are well controlled in a small value even in the case of large head rotations, which proves the robustness and distinctiveness of LSO features. It is observed that the mean absolute errors of LSD are significantly degraded when the yaw rotation is larger than 50° or less than −50°, and pitch rotation is larger than 35° or less than −35°. The reason has been explained in the experiments on the Biwi Kinect head pose database. This demonstrates that LSD features are mainly suited for estimating head poses with normal rotation angles rather than extremely large angles.

The detailed comparison of our method with state-of-the-art head pose estimation methods is shown in Table 2
                        . We can see all methods can achieve a better result in this database because of high-quality range data. The local slice orientation (LSO) significantly outperform state-of-the-art head pose estimation methods based on generic pose templates [5,12] and is slightly worse than individually specific pose template based method [11]. The advantages of our method come from high-level and detailed representation of range data. LSD does not perform as well as state-of-the-art methods, but it is accurate enough for coarse head pose estimation.

Slice representation of range data is computationally efficient. The runtime of slice feature extraction is mainly determined by the parameter setting of LSD and LSO. Since we use the integral method to implement slice feature extraction, the number of patches in each slice determined by M and N has less influence on the computational cost than the number of slices determined by Δd. Fig. 18
                         shows the feature extraction runtime as a function of Δd. It takes about 8ms in average to preprocess a pair of range and color images captured by Kinect sensor. And it takes less than 1ms for random forest to obtain the pose estimation results. So currently our head pose estimation method using LSD features can operate in 20fps for Δd
                        =10 and 50fps for Δd
                        =30. With the nose tip provided by Kinect SDK, fine head pose estimation using LSO features can operate in 20fps for Δd
                        =20 and 35fps for Δd
                        =30. It should be noted that we have not optimized the program of our method. And it is expected to achieve real-time head pose estimation if we choose a computationally efficient method for feature extraction.

According to the experimental results described above, the proposed method achieves high estimation accuracy and real time performance. It can be used in the application of face recognition and human–computer interaction, which requires real time head pose estimation results. Generally, the advantages of our head pose estimation method are summarized as follows.
                           
                              •
                              Slice representation can characterize the distinctive and robust features for head pose estimation. A large number of slices can be obtained from a facial range image and each slice reflects the geometric shape information of head pose from a specific aspect. Therefore the slice representation has direct relationship to head pose parameters. And detailed features extracted from local slice patches such as local slice depth (LSD) and local slice orientation (LSO) provide abundant visual cues for accurate head pose estimation. Moreover, such a local feature representation not only improves the robustness of head pose estimation against noise but also provides a huge parameter space for selecting the most effective features for discriminating head poses.

Two slice feature descriptors namely Local Slice Depth (LSD) and Local Slice Orientation (LSO) are developed to achieve robust head pose estimation. LSD is suitable for coarse pose estimation, and LSO is used for fine pose estimation. These two feature sets can be adaptively used for various applications with different requirements of accuracy and efficiency.

A complete head pose estimation system is developed based on Kinect sensor. The visual cues of both color and range images are used to localize and segment the region of interest for head pose estimation. Therefore our head pose estimation system makes full use of the complementary information of Kinect sensor.

In addition to the above advantages, there are also some disadvantages lie in our head pose estimation method.
                           
                              •
                              The preprocessing algorithm used in this method is not ideal. Firstly, it is sensitive to illumination variation, due to skin tone detection algorithm is employed in the preprocessing method. Secondly, the accuracy of the face segmentation algorithm designed in this paper is not as good as expected, especially for profile view. The accuracy of this method can be significant improved if a more accurate face segmentation algorithm is designed.

The proposed method is not robust to occlusion. The main idea of this method is to utilize the range information of head pixels for head pose estimation. Occlusion would decrease the performance of this method. According to this method, if the surface of obstructions is with skin tone, it would be regarded as an area of head surface. The slices generated from these area would cause negative influence for head pose estimation. Otherwise, the occlusion area would not be regarded as an area of face and removed as noise.

@&#CONCLUSIONS AND FUTURE WORK@&#

This paper presents a promising method for accurate head pose estimation. The main novelty of this paper is design of a slicing model for range data representation. Based on this slicing model, two sets of features, namely local slice depth and local slice orientation, are proposed to estimate head pose from the image data captured by a Kinect sensor. In order to implement a head pose estimation system, a new preprocessing method is proposed to segment facial region from range images with the assistance of color images, and two novel integral images, which are slice depth integral image and slice coordinates integral image, are designed to achieve real-time feature extraction. Experiments on public databases have demonstrated the state-of-the-art performance of our method in terms of both accuracy and efficiency.

Although a promising feature representation method is proposed in this paper for head pose estimation, we believe our work will inspire more ideas on local feature description of range data. And more efforts are needed to improve the performance of head pose estimation in our future work.
                        
                           •
                           A more robust and accuracy face segmentation algorithm is needed to improve the illumination robustness and accuracy of this method.

A much larger database is needed to test the practical performance of head pose estimation under different conditions, including both internal (e.g. head shape, expression, aging) and external (e.g. occlusion, hair styles, makeup) variations.

In this paper the slices are obtained by two cutting planes perpendicular to the depth axis. It is expected to get more slice patterns using cutting planes with different orientations. These new slice patterns can reflect the head pose information from different aspects.

Extraction of novel local features from slice patterns is expected to improve the performance of head pose estimation.

Machine learning techniques such as Adaboost and Lasso algorithms can be used for optimal feature selection from high-dimensional slice features.

Other regression algorithms such as SVR (Support Vector Regression), PLS-regression (Partial Least Squares Regression), and deep learning can be used to learning the mapping function between local slice features and head poses.

This paper mainly investigates a common and generic head pose model for all subjects. It is expected to achieve a much higher accuracy using an individually specific head pose model which is trained for each subject.

Other landmark points in facial images such as eyes, lips can be combined with nose tip to achieve a robust representation of reference system for fine head pose estimation.

The slicing model provides a good feature representation for range data. It can not only be used for head pose estimation, but also be applicable for other applications of range data, such as generic object pose estimation and object detection.

@&#ACKNOWLEDGMENTS@&#

This work is supported by the National Basic Research Program of China (Grant No. 2012CB316300), the MOST International S&T Cooperation Program (Grant No. 2010DFB14110) and the National Key Technology R&D Program of China (Grant No. 2012BAK02B01).

@&#REFERENCES@&#

