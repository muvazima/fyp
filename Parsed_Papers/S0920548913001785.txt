@&#MAIN-TITLE@&#End-to-end policy based encryption techniques for multi-party data management

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We describe novel approaches for controlling data in distributed, multi-party contexts.


                        
                        
                           
                           Sticky policies cryptographically bind data to policies constraining how it may be used.


                        
                        
                           
                           Secret sharing techniques can be used to improve scalability.


                        
                        
                           
                           Such approaches are useful in a variety of business contexts, especially involving sensitive data.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cloud

Sticky policy

Policy enforcement

Privacy

Secret sharing

@&#ABSTRACT@&#


               
               
                  We describe a data management solution and associated key management approaches to provide accountability within service provision networks, in particular addressing privacy issues in cloud computing applications. Our solution involves machine readable policies that stick to data to define allowed usage and obligations as data travels across multiple parties. Service providers have fine-grained access to specific data based on agreed policies, enforced by interactions with independent third parties that check for policy compliance before releasing decryption keys required for data access. We describe alternative solutions based upon Public Key Infrastructure (PKI), Identity Based Encryption (IBE) and advanced secret sharing schemes.
               
            

@&#INTRODUCTION@&#

Lack of trust about privacy and security practice is at present a key inhibitor in moving to cloud models [1]. When sharing and storing information in the cloud, additional assurance is needed that appropriate security and privacy measures have been taken by Cloud Service Providers (CSPs). This problem is also present more generally as service provision chains become more global, complex and dynamic. Both business consumers and citizens are requiring more control over the usage and sharing of their personal and confidential information, as this is handled within potentially complex service provision chains.

Current commercial solutions primarily focus on traditional, back-end security controls (e.g. access control) on the data, once this data is stored on the service provider side. Privacy and data control aspects, such as fine-grained definition and enforcement of user's preferences and policies (on how to process data, to whom to disclose data, various obligations on data transformation, deletion, etc.), are rarely implemented unless in a coarse-grained way (e.g. via macro opt-in, opt-out options). These solutions usually do not scale across multiple control domains: users' preferences and policies on how to handle data are not necessarily propagated and enforced across a chain of data disclosures within multiple Cloud Service providers. This means that users have little end-to-end control about the destiny, usage and management of their data, once disclosed to a Cloud Service Provider.

To address this issue, we suggest a variety of solutions based on sticky policies, where policies and constraints are attached to data as it is transmitted and stored within the cloud. Sticky policies are strictly associated with users' data and drive access control decisions and enforcement of privacy and confidentiality.

Our solutions ensure that data disclosed within cloud services is used, accessed, processed, stored and shared, etc. based upon agreed (potentially fine-grained) policies and constraints and degrees of assurance are provided by independent (trusted) third parties about compliance to these policies. Mechanisms using data encryption, driven by policies, can be used to ensure degrees of (fine-grained) data protection; Trusted third parties (called Trust Authorities (TAs)) can be used to provide compliance checking, enforcement and audit capabilities. Our solutions provide a practical solution to enhancing user control and providing accountability within the cloud, removing business barriers in the sense that organizations might be willing to move more of their sensitive operations to the cloud model.

We believe that approaches based on cryptography are suitable to make significant progress towards providing the required level of control and accountability on personal and confidential data. This paper illustrates how this can be achieved by focusing on three solutions, one is general using ordinary Public Key Infrastructure (PKI), a second uses Identity Based Encryption (IBE) [2] and a third is based upon secret sharing [3]. In the PKI-based approach, it is assumed that all the stakeholders have certified public/private key pairs from trusted Certificate Authorities (CAs). In this context, these CAs can play the role of Trust Authorities. Policies are bound to data by encrypting the data under a symmetric key that a sender and receiver conditionally share based on fulfilment of policies, and sticking the data to the policing using public-key enveloping techniques. If IBE techniques are used instead for this binding then it means that a third party needs to check certain properties (as specified within the sticky policy associated with data) at the time of decryption, before an IBE decryption key for that data is released. These IBE techniques are conceptually equivalent to the PKI once, however they leverage a different cryptographic schema. An alternative approach consists in leveraging secret sharing techniques: in this case, the parties involved in the data management solution are enrolled in several, cascaded secret sharing schemes. By recreating the shared secrets, the parties can compute encryption keys required to access managed data. Instead of needing to a priori define all trusted authorities that will supervise access to the managed data and to manually enable each such Trusted Authority for each asset, the customer only has to provide a share of the secret sharing scheme. The resulting approach has more manageable computation, storage, and transmission bandwidth requirements as compared to prior solutions, and yet can still provide fine-grained control over access and usage of customer data. In general, the most appropriate solution will vary according to the context and trust models involved.

This paper focuses on a Cloud Scenario consisting of multiple Service Providers, end users and enterprises. In this scenario, both end-users and employees within enterprises make active use of services in the Cloud, as shown in Fig. 1
                     .

Cloud service providers can use services provided by other providers in the cloud, in order to supply the required capabilities. For example, a storage service provider might use third-party data back-up services and information lifecycle management capabilities and part of their offering.

In this context, personal information, confidential data, etc. can flow from one service provider to another one, due to a chain of service interactions and dependencies. For example, a user might disclose personal data to a CSP, during a business interaction and/or the provision of a service. The CSP might then need to interact with other service providers in the cloud, in order to provide the desired service. This might require sharing some of the personal data.

We consider situations, such as within health service provision, access to applications and services in the cloud (storage, computing, etc.), and so on, as shown in Fig. 1, where a customer (that might be a citizen, employee or an enterprise) indeed needs to reveal personal and even sensitive information in order to receive a service, but wishes to control the way in which that information is used.

In this paper we describe our approach to provide this control capability as well as degrees of assurance. We want to:
                        
                           •
                           enable users to express their (privacy and security) preferences and policies when disclosing their personal data;

provide mechanisms to protect data whilst it is shared across parties;

provide mechanisms to increase the level of accountability.

We define a system and mechanisms to enable the protection of data to be shared by a user (or service) with service providers, based on agreed policies and privacy preferences. The user can be actively involved in the selection of multiple, interchangeable services called Trust Authorities (TAs), that will track and audit for the fulfilment of these policies.

Our solutions use sticky policies associated with data to dictate how to handle data at the receiver side. Our schemas involve three types of parties: Cloud Service Providers (CSP), which store and process the user's data, Trusted Authorities (TA), which audit that the CSPs handle the user's data according to the sticky policies defined by the user, and the users themselves, who own the assets and define access restrictions in sticky policies.

We aim to enable the users to define policies which are preferences or conditions about how that information should be treated. The policy governs the use of associated data, and may specify for example the following:
                        
                           ---
                           The purposes of using data (e.g. for research, transaction processing, etc.).

That data may only be used within a given set of platforms (with certain security characteristics), a given network or a subset of the enterprise

Other obligations and prohibitions (allowed third parties, people or processes; blacklists; notification of disclosure; deletion of data after a certain time)

A list of trusted TAs (potentially the result of a negotiation process).

The policy may be represented in any convenient format.

The basic mechanisms of the proposed sticky policy solutions, also shown in Fig. 2
                     , are as follows:
                        
                           •
                           In order to be able to more easily interpret and enforce end user policies, instead of offering free expression of policies from end users, their preferences and policies are defined within a framework imposed by organizations. There are different ways of achieving this: one mechanism is that SPs offer a ‘smart notice’ containing the list of supported (macro) policies and TAs, where these policies relate to access control and obligation behaviours supported by the organization, and the end user can choose from these [4].

A user (customer) — interacting with a SP — can select the granularity of how policies apply to items or specific subsets of personal data to be disclosed (ranging from coarse grained to fine-grained) and customize related preferences (e.g. notification preferences, period of time after deletion, set of agreed purposes, list of parties not to interact with, etc.).

The user may have the option to select TAs that are to be trusted

Based on the above selections, a client-side component supports the creation of sticky policies and their association to data, i.e. the bundling of policies, preferences, data and TAs. In other words, the client-side component deals with the packaging of data along with selected parameterized policies and TAs.

The user can select the option to refer to secured data (e.g. personally identifiable information (PII)) by another third party (this is a storage provider that stores the encrypted data) rather than passing the encrypted data directly to the SP.

Encrypted data along with sticky policies is sent to the SP.

In order to gain access to the data in clear, the SP needs to interact with one of the selected TAs (based on availability). During this interaction the SP has to assert its willingness to fulfil the customized, sticky policies. This creates an audit trail that can be afterward used by the user and TA — in case of policy violations and misbehaviour.

The SP will allow a predefined period of time for connection with the TA. There may be swapping between TAs based on need.

Only after satisfying the requirements expected in that context from its role, can the TA decide to release the information that would enable the decryption of data.

The SP will then be able to decrypt and access the data — either in the case where the data was directly disclosed or in the case where just a reference to it was provided (in this latter case, the SP will need to fetch the data from a storage provider).

The various interactions and policy-related statements exchanged by a Service Provider with a TA are logged and audited by the TA. This provides forensic evidence in case of violations e.g. data misuses or policy violations. We believe that by introducing this additional step (to the process of releasing data, potentially in a complex chain of interactions) we increase the level of accountability of the various Service Providers and provide more assurance to the end-users that their data will be managed and processed according to their preferences and policies.

The next three sections describe in detail how the conceptual schema shown in Fig. 2 can be implemented by using PKI and IBE cryptographic techniques as well as extended by using a secret sharing approach. These approaches may be summarized as follows:
                        
                           •
                           In Section 5, the ‘sticky policy’ is mapped to an IBE encryption key, in order to encrypt the data (payload) and bind it to the desired usage policy.

For the mechanisms described in Section 4 and Section 6, the sticky policies are instead linked to the data (payload) by means of digital signatures: after the user defined the policy for a certain access, they calculate a hash value of both the payload and the sticky policy, and sign it with their private signature key. For this step, a Public Key Infrastructure (PKI) is required. The user then encrypts the payload with a randomly generated key 
                                 K
                              , using a symmetric encryption algorithm such as AES. The user then transmits the encrypted payload together with the cryptographically linked policies to the SP. If the SP needs access to the data, they need access to 
                                 K
                              .
                                 
                                    o
                                    The mechanism described in Section 4 solves this requirement by attaching a copy of 
                                          K
                                        to each artefact, where the copy was encrypted once with each public key of each TA, binding access to the artefact to a specific set of TAs being available, thus requiring an a priori definition of all TAs. This works well for a static TA set, but scales badly if the TA set changes. This is likely to be the case in dynamic, multi-party cloud and service provider contexts.

The mechanism described in Section 6 takes an alternative approach where the parties involved in the data management solution are enrolled in several, cascaded secret sharing schemes, implementing complex access structures based on combiner driven secret sharing schemes. This has advantages in terms of easier, more scalable security and key management.

In this approach the data is associated to the policy using public key enveloping techniques similar to Public Key Cryptography Standard 7 (PKCS 7). Fig. 2 shows the template interaction schema used in this solution. Three entities are involved: a user (U), a service provider (SP) and a trusted authority (TA). In the case of Fig. 2, the SP is a special type — a cloud service provider (CSP).

The actual implementation of this schema when using PKI-based solution is shown in Fig. 3
                     .

The user has a unique identity written as IdU which is indicated in the certificate of the user's public key, denoted by PubU. The corresponding private key is PrivU.

Similarly, the TA has a unique identity written as IdTA, which is indicated in the certificate of the TA's public key, denoted by PubTA. The corresponding private key is PrivTA.

Likewise, the SP has a unique identity written as IdSP, which is indicated in the certificate of the SP's public key, denoted by PubSP. The corresponding private key is PrivSP.

There are two options for the policyKeyMapping function that sticks the policy to the key that is used to encrypt the data, and thereby can be thought of as performing the sticky policy functionality. The first option is signcryption, and the second is encrypt-then-sign. These correspond to the following functions respectively:
                        
                           
                              
                                 policyKeyMapping
                                 
                                    
                                       PrivU
                                       ,
                                       PubTA
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                                 =
                                 Sigenc
                                 
                                    
                                       PrivU
                                       ,
                                       PubTA
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                              
                           
                        
                     or
                        
                           
                              
                                 policyKeyMapping
                                 
                                    
                                       PrivU
                                       ,
                                       PubTA
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                                 =
                                 
                                    U
                                    V
                                 
                              
                           
                        
                     where
                        
                           
                              
                                 U
                                 =
                                 A
                                 .
                                 Enc
                                 
                                    
                                       PubTA
                                       ,
                                       K
                                       
                                          
                                             policy
                                          
                                       
                                       IdU
                                    
                                 
                              
                           
                        
                     and
                        
                           
                              
                                 V
                                 =
                                 Sig
                                 
                                    
                                       PrivU
                                       ,
                                       U
                                       |
                                       |
                                       IdTA
                                    
                                 
                              
                           
                        
                     
                     
                        
                           •
                           “||” denotes concatenation


                              S.Enc() denotes a symmetric encryption algorithm, e.g. specified in ISO/IEC 18033-3


                              A.Enc() denotes an asymmetric encryption algorithm, e.g. specified in ISO/IEC 18033-2


                              Sig() denotes a signature algorithm, e.g., specified in ISO/IEC 14888 or ISO/IEC 9796


                              Sigenc() denotes a signcryption algorithm, e.g. specified in ISO/IEC 29150.

The protocol has the following stages, as shown in Fig. 3:
                        
                           (1)
                           Generation of the policy by the user, together with a symmetric key 
                                 K
                               used to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).

Generation of the message from the user to the SP. The message is arranged as
                                 
                                    
                                       
                                          policy
                                          ,
                                          policyKeyMapping
                                          
                                             
                                                PrivU
                                                ,
                                                PubTA
                                                ,
                                                K
                                                |
                                                |
                                                policy
                                             
                                          
                                          ,
                                          S
                                          .
                                          Enc
                                          
                                             K
                                             PII
                                          
                                       
                                    
                                 
                              where PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it. In that case, step (2) is replaced by two sub-steps:
                                 
                                    1.
                                    SP sends a nonce to U, say nSP,

U replaces 
                                          K
                                       ||policy with 
                                          K
                                       ||policy||nSP in the policyKeyMapping function.

The same change (from 
                                 K
                              ||policy to 
                                 K
                              ||policy||nSP) should be taken in steps (3) and (5) of Fig. 2.

Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender.

The TA carries out policy checking, potentially including challenges to the SP. The SP may have to provide signed statements about its policies.

If all checks are fulfilled, the TA will release the shared key: it generates a message from the TA to SP, which involves encrypting the symmetric key 
                                 K
                               with the SP's public key. By these means SP can get access to 
                                 K
                               and then decrypt the PII.

This approach works well with a single TA. However, once there is more than one TA involved, the policyKeyMapping() function must be computed and the result must be transmitted and stored for each TA and for each record stored in the SP as follows (with PubTAi
                      denoting the public key of Trust Authority TAi):
                        
                           
                              
                                 policyKeyMapping
                                 
                                    
                                       PrivU
                                       ,
                                       PubT
                                       
                                          A
                                          i
                                       
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                                 =
                                 Sigenc
                                 
                                    
                                       PrivU
                                       ,
                                       PubT
                                       
                                          A
                                          i
                                       
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                              
                           
                        
                     or
                        
                           
                              
                                 policyKeyMapping
                                 
                                    
                                       PrivU
                                       ,
                                       PubT
                                       
                                          A
                                          i
                                       
                                       ,
                                       K
                                       |
                                       |
                                       policy
                                    
                                 
                                 =
                                 
                                    U
                                    V
                                 
                                 .
                              
                           
                        
                     
                     Fig. 4
                      shows a variation of the above approach in which a cloud storage provider is used to store the encrypted PII. This entity stores encrypted data associated with a reference to that data. No PII is exposed to this SP as it will not know the encryption key. Instead of the obfuscated data being passed around the cloud, an encrypted reference to that data is used.


                     Fig. 5
                      illustrates a cryptographic mechanism by which this may be provided. We use two symmetric keys (although variations on this approach may be used): 
                        K2
                      is used to encrypt the PII and 
                        K1
                      is used to encrypt the reference to the PII (e.g. a URI). The client component sends S.Enc(K2
                     , PII), i.e .the PII encrypted with 
                        K2
                     , to one (or more) such cloud storage parties. The user sends S.Enc(K1
                     , refPII) to the CSP, i.e. the reference to the PII encrypted with 
                        K1
                     , together with a sticky policy binding 
                        K1
                      to the policy and A.Enc(PubTA, 
                        K2). The CSP then forwards on the sticky policy to the TA, together with the key 
                        K2
                      encrypted with the TA's public key. If the TA is satisfied that the SP meets the policy, it sends 
                        K1
                      and 
                        K2
                      encrypted with the SP's public key, by which means the SP can deduce 
                        K1
                      and 
                        K2
                      and hence is able to decrypt the reference to the PII and then the PII itself.

The PKI-based approach discussed in this section offers mechanisms to protect the data when in transit as well as degrees of accountability and assurance, thanks to the logging and auditing processes carried out by the involved Trusted Authorities.

Some complexity is introduced by having to manage the various PKI cryptographic material, certifications and the overall lifecycle. If multiple TAs are used, this approach requires both users and CSPs to manage multiple sets of keys, encryption processes and information.

In addition there is a clear separation between the “sticky policy” associated to the data — that is purely a textual description of constraints — and the cryptographic keys associated to protect the data. This requires additional effort to manage both keys and policies in a consistent way. The next section illustrates the Identifier-Based Encryption schema that is comparable to the PKI-based approach but addresses and simplifies this later point by using “sticky policies” directly as the “encryption key” for the associated data.

As an alternative approach, identity-based encryption (IBE) mechanisms can be used as the basis for provision of sticky policies. Identity-based encryption (IBE), e.g. [2], is a cryptographic schema where any kind of string (including a name, role, terms and conditions, etc.) can be used as a public encryption key. The generation of the corresponding IBE decryption key can be postponed until later than the encryption process. A trusted authority (TA) can generate this decryption key on the fly, under specific circumstances. Although this approach is conceptually similar to the PKI approach described above, the key difference is that we map a ‘sticky policy’ to an IBE encryption key. The role of the TA is expanded to perform a policy checking role (as it checks for the integrity and trustworthiness of the requestor's credentials and their IT environment before releasing the decryption key) and an auditing role (as it logs and audits disclosures of confidential data). The original idea of using IBE for sticky policies in key management was proposed in [5]. We now show an extended solution about how IBE-based sticky policies can be used to protect content in cloud computing environment.

A protocol of this approach involves three entities: a user (U), a service provider (SP) and a trusted authority (TA). As it is the same as the PKI solution in the previous section, the SP is a special type — a cloud service provider (CSP). These three entities have cryptographic keys as follows:
                        
                           1.
                           The TA has a unique identity written as IdTA, which is indicated in the certificate of the TA's public key, denoted by PubTA. The corresponding private key is PrivTA, which is a master key for an identity-based key generation service and allows the TA to generate identity-based private keys for the user and SP.

The user has a unique identity written as IdU, which is used to compute the user's public key denoted by PubU. The corresponding private key is PrivU, which is generated by the TA, i.e.:
                                 
                                    
                                       
                                          PubU
                                          =
                                          Id
                                          −
                                          pubkeyGeneration
                                          
                                             IdU
                                             PubTA
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          PrivU
                                          =
                                          Id
                                          −
                                          privkeyGeneration
                                          
                                             PrivTA
                                             PubU
                                          
                                          .
                                       
                                    
                                 
                              
                           

The SP has a unique identity written as IdSP, which, along with a policy, is used to compute the SP's public key, denoted by PubSP. The corresponding private key is PrivSP, which again is generated by the TA.

The policyKeyMapping function that sticks the policy to the SP's key that is used to encrypt the data and thereby can be thought of as performing the sticky policy functionality is achieved via generation of the SP's public key PubSP and private key PrivSP by:
                                 
                                    
                                       
                                          PubSP
                                          =
                                          Id
                                          −
                                          pubkeyGeneration
                                          
                                             IdSP
                                             PubTA
                                             policy
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          PrivSP
                                          =
                                          Id
                                          −
                                          privkeyGeneration
                                          
                                             PrivTA
                                             PubSP
                                          
                                          .
                                       
                                    
                                 
                              
                           

The protocol has the following stages:
                        
                           (1)
                           Generation of the policy by the user, together with a symmetric key 
                                 K
                               used to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).

Generation of the message from the user to the SP. The message is arranged as
                                 
                                    
                                       
                                          policy
                                          ,
                                          IdSP
                                          ,
                                          IdTA
                                          ,
                                          IdU
                                          ,
                                          IBE
                                          
                                             
                                                PubSP
                                                ,
                                                PubTA
                                                ,
                                                K
                                                |
                                                |
                                                policy
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          IBS
                                          
                                             
                                                PrivU
                                                ,
                                                IdU
                                                
                                                   
                                                      IdTA
                                                   
                                                
                                                IdSP
                                                |
                                                |
                                                policy
                                             
                                          
                                          ,
                                          S
                                          .
                                          Enc
                                          
                                             K
                                             PII
                                          
                                          ,
                                       
                                    
                                 
                              where PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it; similar to the PKI solution in the previous section.

Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender.

The TA carries out identity checking, policy checking and the user's signature verification, potentially including challenges to the SP.

If all checks are fulfilled, the TA will release the decryption capability to the SP: it generates a message from the TA to SP, which involves PrivSP. By this means SP can decrypt 
                                 K
                               and then decrypt the PII.

We recommend a standardized identity-based encryption scheme and symmetric encryption scheme specified by ISO/IEC. The references are as follows:
                        
                           •
                           
                              Id-pubkeyGeneration() and Id-privkeyGeneration() denotes identity-based key generation algorithms, e.g. specified in ISO/IEC 18033-5.


                              IBE() denotes an identity-based encryption algorithm, e.g. specified in ISO/IEC 18033-5.


                              S.Enc() denotes a symmetric encryption algorithm, e.g. specified in ISO/IEC 18033-3.

This approach works well with a single TA. However, depending on applications, more than one TA may be involved. For example, there may be two separated TAs: TAU and TASP, where the first creates the identity-based private key PrivU for the user and the second creates the identity-based private key PrivSP for the SP. Furthermore, the role of either TAU or TASP can be split into multiple TAs, in order to enhance trust and/or flexibility. An implementation example of multiple TAs for IBE can be found in [6]. The next sections discuss how we envisage addressing the issue of having to deal with multiple TAs.

Instead of encrypting the key material for each TA with the public key of the respective TA, as an alternative solution we suggest the definition of a set of secret sharing schemes to augment the usage of public key cryptography as the cryptographic backbone of the scheme. In contrast with public key cryptography, secret sharing schemes are a designated multi-party cryptographic tool, which addresses the original problem more efficiently and also with a potentially significantly higher level of security.

Secret-sharing schemes form a particular group of multi-party key establishment protocols [7] that enable distribution of control or trust in critical activities. The central idea of a secret sharing scheme is that a key (in our case, the key used to encrypt the data) would be divided into v pieces (the “shares”), such that any pre-defined combination of them can be used to reconstruct the whole original key but using any set of shares that is not on the pre-defined set of combinations will not help to reconstruct the key. In other words, secret sharing schemes are used to distribute a secret among a set of participants such that only authorized subsets of participants can recreate the shared secret 
                        K
                     , while unauthorized subset does not learn anything (in an information theoretic sense) about 
                        K
                     . The set of all authorized subsets is called the scheme's access structure. There are many different secret sharing schemes, implementing a variety of access structures. As an example, Shamir's Threshold Scheme [3] is a threshold-based secret sharing scheme, which allows any subset of at least r of the v participants in the scheme to recreate the secret.

In Shamir's (r, v) threshold scheme, a key (in our case, the encryption key 
                        K
                      used to encrypt the data) is divided into v pieces (the shares), such that any r of them can be used to reconstruct the original key 
                        K
                     , but using any number of shares less than r will reveal no additional information (in an information theoretic sense) useful to reconstruct 
                        K
                     .

When employing secret sharing schemes with threshold access structures, for the sticky policy scenario, the secret sharing scheme could be designed to require shares from the SP and at least one TA to recover 
                        K
                      and decrypt the PII, while at the same time providing some redundancy among TAs.

Secret sharing schemes are most suitable in situations where multiple TAs are employed and key management should be simplified, or where individual TAs might not be fully trusted and hence the other TAs should be used to audit and check what they are doing.

In this section, we will define a secret sharing scheme based approach that supports multiple verification and control instances and facilitates key management. Conventional secret sharing schemes have been developed for a number of years [3]. Our approach uses a combiner driven secret sharing scheme [8], where the combiner needs to contribute at least one share for each recreation operation. This behaviour significantly increases the security level, as it is sufficient to destroy the combiner to prevent any further access to the information. Further, as the combiner needs to be involved in any recreation operation, the combiner's audit log gives strong evidence at the point in time, including evidence on the participant set that has been used for each recreation of the key 
                        K
                     . This behaviour is enforced by making the combiner part of each (minimal) set of participants that is authorized to recreate the key 
                        K
                     . To achieve this, the combiner receives one or more sets of shares, which it needs to contribute during recreation. The shares that are assigned to the combiner are chosen such that the combiner's shares by themselves are not sufficient to recreate the secret. It is shown in [8] that, by altering the combiner's shares, it is possible to keep the key 
                        K
                      and existing participants' shares constant, even if the participant set changes, as well as to change the key 
                        K
                      without altering the participant's shares. These properties significantly distinguish combiner driven secret sharing schemes from conventional secret sharing schemes.

In the approach described in Section 4, service providers are not involved in decryption, whereas in this scheme both TAs and service providers are shareholders.

There can be benefits of having new roles for service providers, depending upon the model and context. In the cloud use case, the combiner can be (within) a tamper resistant device which can be physically located either on the TA side (this would conform to the use case described above), or on the service provider side. For multiple TAs, and to prevent the combiner becoming a bottleneck, the combiner can be cloned without lowering the scheme's security level. As indicated earlier, the combiner does not hold enough information to independently recreate the shared secret. It always requires the shares of an authorized subset of participants to perform the recreation. Nevertheless, protecting access to the cloned combiner instances prevent authorized set of participants to recreate the secret “in the wild”, without creating an audit trail.

With combiner driven secret sharing, the user's key can be changed in case it was compromised without the need of re-encrypting the entire cloud data store. Moreover, the scheme described in Section 4 binds access control to the public key of TAs. Hence, enrolling or disenrolling TAs in the original scheme would require extending each record in the cloud data store with a dataset, or finding and removing a dataset from all records respectively. In the secret sharing scheme based approach we describe in this paper, such global changes are not necessary: enrolment and disenrollment operations can be conducted by a simple combiner operation that does not affect the data store.

We consider a multi-party cloud interaction scenario as a significant example, as shown in Fig. 1 and as described in Section 4, with one trusted user, one or more service providers, and one fully trusted Trust Authority as participating entities.

For now, we assume that there is only one user, the user is fully trusted, and hence knows the key 
                           K
                         to encrypt and decrypt content. We will also discuss scenarios with multiple Trust Authorities or only partially trusted Trust Authorities in a later section.

Besides the simple threshold access structure described by Shamir, secret sharing schemes can be used to implement more complex access structures, allowing implementation variants with different security levels. We define an authorized subset in an access structure to be a set of participant that is allowed to recreate the secret. We call an access structure where each superset of an authorized subset is authorized to recreate the secret a monotone access structure.

We will use two types of monotone access structures and implementation thereof:
                           
                              –
                              The threshold access structure, implemented in a modified variant of Shamir's polynomial based (r, v) threshold secret sharing scheme driven by a combiner, as described in [8].

A simplified construction for (r, v) threshold schemes in the special case r
                                 =
                                 v. While originally described by Karnin et al. [9], we will use a slightly modified variant as described by Stinson [10].

The basic access structure is defined on the participant set T
                        =
                        T
                        
                           U
                        
                        ∪
                        T
                        
                           TA
                        
                        ∪
                        T
                        
                           CSP
                         with:
                           
                              –
                              The user, defined as t
                                 
                                    u
                                  in the set T
                                 
                                    U
                                 
                                 ={t
                                 
                                    u
                                 }

The TA, defined as t
                                 
                                    TA
                                  in the set T
                                 
                                    TA
                                 
                                 ={t
                                 
                                    TA
                                 }

The CSPs, defined in T
                                 
                                    CSP
                                 
                                 ={t
                                 
                                    CSP,1,…,t
                                 
                                    CSP,c
                                 } where c is the number of participating CPSs.

The basic access structure Z
                        1, shown in Fig. 6
                        , is defined such that either the user alone, or both the TA and at least one CSP must participate during the recreation. We define the access structure Z
                        1 through a combined set of sub-access structures Z
                        1,1, Z
                        1,2, and Z
                        1,3. Each sub-access structure represents a secret sharing scheme, which protects an intermediate secret. The intermediate secrets are eventually used to compute the shared secret 
                           K
                        . For the sub-access structures Z
                        1,1, Z
                        1,2, and Z
                        1,3, the functions representing a secret sharing scheme that implements these access structures would be f
                        1, f
                        2, and f
                        3 respectively. The elements of the resulting secret sharing scheme can be represented by a graph. Fig. 5 shows a representation of the access structure using the graph based access structure definition schema introduced in [11]. The function f
                        3 represents a secret sharing scheme where one or more of the participants t
                        
                           CSP,c
                         can recreate the secret. The resulting intermediate secret is used as a share in f
                        2, where it can be used in combination with a share t
                        
                           TA
                         to recreate another intermediate secret. Function f
                        2 requires that both the intermediate secret computed by f
                        3 and the share t
                        
                           TA
                         are present. To recreate 
                           K
                        , the share is used as an input parameter in f
                        1. The function f
                        1 is designed so that the secret 
                           K
                         can be computed if either the intermediate secret resulting from f
                        2, or the share t
                        
                           u
                         are present. We refer to [11] for a detailed discussion of graph-based access structure definitions and an overview of common functions.

Note that this schema also works for non-monotone access structures, if, for instance, the user and one CSP alone cannot recreate the secret key.

The secret sharing scheme functions are defined on the set of possible shares S as the functions' input, and the set of possible secret keys G as the functions' output. For simplicity, we assume S
                        =
                        G.

The participants' shares are defined as:
                           
                              –
                              
                                 s
                                 
                                    u
                                  as the share of the user t
                                 
                                    u
                                 
                                 ∈
                                 T
                                 
                                    U
                                 
                              


                                 s
                                 
                                    TA
                                  as the share of the TA t
                                 
                                    TA
                                 
                                 ∈
                                 T
                                 
                                    TA
                                 
                              

{s
                                 
                                    CSP,1,…,s
                                 
                                    CSP,c
                                 } as the share of the CSPs in T
                                 
                                    CSP
                                 , where s
                                 
                                    CSP,i
                                  denotes the share of CSP t
                                 
                                    CSP,i
                                  for 1≤
                                 i
                                 ≤
                                 c.

Function f
                        1 is trivially defined as:
                           
                              
                                 
                                    
                                       f
                                       1
                                    
                                    
                                       s
                                    
                                    =
                                    s
                                    ∀
                                    s
                                    ∈
                                    S
                                    .
                                 
                              
                           
                        
                     

As we do not employ a combiner with f
                        1, the user's share is equal to the key 
                           K
                        .

Function f
                        2 is an implementation of Stinson's (v, v) scheme [10]. We convert the input share t
                        
                           TA
                         and the result of f
                        3 computed on a CSP share t
                        
                           CSP,i
                         into a binary representation of equal length, and define ⊕ as the binary XOR operation. The function f
                        2 is then defined as:
                           
                              
                                 
                                    
                                       f
                                       2
                                    
                                    
                                       
                                          s
                                          1
                                       
                                       
                                          s
                                          2
                                       
                                    
                                    =
                                    
                                       s
                                       1
                                    
                                    ⊕
                                    
                                       s
                                       2
                                    
                                    ∀
                                    
                                       s
                                       1
                                    
                                    ,
                                    
                                       s
                                       2
                                    
                                    ∈
                                    S
                                    .
                                 
                              
                           
                        
                     

Function f
                        3 is a combiner driven threshold secret sharing scheme as described in [8]. The combiner is collocated with the TA, which implies that a CSP is not able to recreate the shared secret of f
                        3. Instead, the CSP i sends the share t
                        
                           CSP,i
                         to the TA for the recreation operation. The CSP can take advantage of the existing public key infrastructure, and encrypt the share t
                        
                           CSP,i
                         with the TA's public key PubTA.

The combiner allows the disenrollment of CPSs from the access structure Z
                        1,3 as well as the enrolment of new CPPs to Z
                        1,3 without changing the result of the recreation operation computed on f
                        3. To achieve this, the combiner holds a set of shares which enables it to control the recreation process. Depending on the shares the combiner contributes, it can even influence the recreation result, that is, the combiner can be designed such that with different participant sets, different keys K
                        
                           j
                         are recreated.

After the TA received the key 
                           K
                         from the user, it creates shares sCSP,j for each CSP, 1≤
                        j
                        ≤
                        c. A share is a pair s
                        
                           CSP,j
                        
                        =(x
                        
                           j
                        ,y
                        
                           j
                        )∈
                        F
                        
                           p
                        
                        ×
                        F
                        
                           p
                        ,1≤
                        j
                        ≤
                        c, where F
                        
                           p
                         is a finite field of prime order p, with |b(p)|=|b(
                           K
                        )|, and b(p) and b(
                           K
                        ) denoting the binary representation of p and 
                           K
                         respectively.

The TA chooses the y
                        
                           j
                         for the participant shares randomly and the x
                        
                           j
                        
                        ≠0 pairwise distinct. Then, the TA interpolates a polynomial g
                        3 through the points described by the CSPs' shares (x
                        
                           j
                        ,y
                        
                           j
                        ), and the random intermediate secret key 
                           K
                        
                        3
                        =(0,y
                        0). This is similar to Shamir's threshold scheme [3], with the difference of the desired degree of g
                        3 being deg(g
                        3)=
                        c, where c is the number of CSPs. To create a (1,c) threshold scheme, the TA computes a set of c combiner shares s
                        
                           c,3,i
                        
                        =(x
                        
                           i
                        ,g
                        3(x
                        
                           i
                        )),1≤
                        i
                        ≤
                        c and stores these combiner shares in the combiner. Afterwards, for all t
                        
                           CSP,j
                        
                        ∈
                        T
                        
                           CSP
                        , the TA encrypts the share s
                        
                           CSP,j
                         of CSP
                        
                           j
                         with the CSP's public key PubCSP
                        
                           j
                        , and distributes the result to CSP
                        
                           j
                        .

As all shares and (recreated) secrets are in S, the TA can transform the function to:
                           
                              
                                 
                                    
                                       s
                                       2
                                    
                                    =
                                    
                                       s
                                       1
                                    
                                    ⊕
                                    
                                       f
                                       2
                                    
                                    
                                       
                                          s
                                          1
                                       
                                       
                                          s
                                          2
                                       
                                    
                                    .
                                 
                              
                           
                        The TA then computes the TA share s
                        
                           TA
                         as:
                           
                              
                                 
                                    
                                       s
                                       TA
                                    
                                    =
                                    
                                       
                                          0
                                          ,
                                          
                                             g
                                             3
                                          
                                          
                                             0
                                          
                                       
                                    
                                    ⊕
                                    K
                                    .
                                 
                              
                           
                        
                     

Finally, the TA destroys its copy of 
                           K
                        .

Note that, although random shares provide the highest level of security, all shares that have been chosen randomly can also be set to a non-random value in case the CSP wants to use a custom, pre-defined share. Shares can also be changed during runtime by re-computing the combiner shares
                           
                              
                                 
                                    
                                       s
                                       
                                          c
                                          ,
                                          3
                                          ,
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          
                                             x
                                             i
                                          
                                          ,
                                          
                                             g
                                             3
                                          
                                          
                                             
                                                x
                                                i
                                             
                                          
                                       
                                    
                                    ,
                                    1
                                    ≤
                                    i
                                    ≤
                                    c
                                 
                              
                           
                        accordingly.

The function f
                        3(s),s
                        ∈
                        S is defined as the interpolation function for g
                        3, recreating the polynomial g
                        3 from the provided share s and the combiner shares s
                        
                           c,3,i
                        ,1≤
                        i
                        ≤
                        c.

Updates of a CSP's share require the TA to have either access to 
                           K
                        , or to recreate 
                           K
                        
                        =
                        t
                        
                           TA
                        
                        ⊕
                        f
                        3(s
                        
                           CSP,i
                        ) with the help of the CSP t
                        
                           CSP,i
                         that requested the share update. In other words, CPSs can request a share update from TA without the user's interaction, and the TA can enforce a share update on the user's request.

If the user requests a share update for a CSP, and the new share is not communicated to the CSP, the CSP has effectively been disenrolled and can no longer participate in key recreation operations.

Adding new CSPs requires the user to provide the key 
                           K
                        , which allows the TA to interpolate the polynomial using the combiner shares. With knowledge of the polynomial, the TA can compute a new share for the newly enrolled CSP, and distribute it as indicated above.

After the TA destroyed the local copy of 
                           K
                        , there are not enough shares available in the TA or the combiner to recreate the polynomial f
                        3, and so the key 
                           K
                        . A CSP t
                        
                           CSP,i
                         cannot recreate f
                        3(s
                        
                           CSP,i
                        ), because the CSP does not have access to the combiner shares, which are crucial to do the required polynomial interpolation.

See [8] for a detailed discussion on the scheme's security, as well as enrolment, disenrollment, and update operations.

The possible storage protocol for one TA has the following stages, as shown in Fig. 7
                        . Note that the protocol can vary, for instance, if the shares are computed by the user instead of the TA:
                           
                              (1)
                              Generation of the policy by the user, together with a symmetric key 
                                    K
                                  used to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).

Generation of the message from the user to the SP. The message is arranged as
                                    
                                       
                                          
                                             policy
                                             ,
                                             Sig
                                             
                                                
                                                   PrivU
                                                   ,
                                                   K
                                                   |
                                                   |
                                                   policy
                                                
                                             
                                             ,
                                             S
                                             .
                                             Enc
                                             
                                                K
                                                PII
                                             
                                          
                                       
                                    
                                 where PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it. In that case, step (2) is replaced by two sub-steps:
                                    
                                       3.
                                       SP sends a nonce to U, say nSP,

U replaces 
                                             K
                                          ||policy with 
                                             K
                                          ||policy||nSP.

Sending the Key 
                                    K
                                  to the Trust Authority

Generation of the combiner share(s) SC
                                  and the share STA
                                  through the TA, transferring the combiner share(s) SC
                                  to the combiner, and retaining the TA share STA
                                  in the TA's secure data store

Generation of the share SCSP
                                  and transferring it to the CSP

Destruction of the original and intermediate key material 
                                    K
                                 , SC
                                 , STA
                                  and SCSP
                                  used during computation in the TA's volatile memory, but retaining the TA share STA
                                  in the TA's secure data store.

The basic retrieval protocol for one TA has the following stages, as shown in Fig. 8
                        :
                           
                              (1)
                              Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender, and the CSP's share SCSP
                                 .

The TA carries out policy checking, potentially including challenges to the SP. The SP may have to provide signed statements about its policies.

If all checks are fulfilled, the TA will release the key 
                                    K
                                 : the TA sends the shares STA
                                  and SCSP
                                  to the combiner

The combiner recreates 
                                    K
                                 .

The TA generates a message from the TA to SP, which involves encrypting the symmetric key K with the SP's public key. By these means SP can get access to K and then decrypt the PII.

Unacceptable business disruptions and delays may be caused if some of these entities (specifically the TAs) might not be available online all the time or have limited connectivity. The solution described in Section 4 can be extended to support degrees of resilience to failure due to communications issues (e.g. delays) between CSPs and TAs. Again, the “client component” at the user side generates a session key K and encrypts the user's PII with it. When the user wants to authorize a CSP to access their PII, they send to the CSP:
                           
                              •
                              
                                 policy: the selected policies and ordered list of authorized TAs

the encrypted PII (using the symmetric key 
                                    K
                                 )

for each of the authorized TAs, a sticky policy that includes a digital signature generated by the user on the policies and TAs with his/her private key PrivU
                                  and the symmetric key 
                                    K
                                  encrypted with the TA's public key.

As shown in Fig. 9
                        , when the CSP needs to access the user's PII, it sends the relevant sticky policy to one of the authorized TAs listed in policy — received from the user.

The TA then checks the signature on the policy to verify that policy is authentic: if it is authentic, the TA further verifies that the CSP fulfils the conditions specified in the policy. If they are verified, the TA provides the CSP with the symmetric key 
                           K
                        . The CSP can then use its public key to decrypt the symmetric key and decrypt the PII.

In the above case, the user needs to select: (1) the policies specifying the conditions under which his PII can be accessed and (2) the Trusted Authorities (TAs) authorized to verify whether an entity fulfils the policies. Next in this section we describe an alternative model where the user implicitly specifies the authorized TAs by including them in a secret sharing scheme access structure.


                        Fig. 10
                         illustrates a possible protocol where the user computes the shares. The “client component” at the user side generates a session key 
                           K
                         and encrypts the user's PII with it. When the user wants to authorize a CSP to access their PII, they send to the CSP:
                           
                              •
                              
                                 policy: the selected policies and ordered list of authorized TAs

the encrypted PII (using the symmetric key K).

Compared with the mechanism described above based on the PKI case, it is no longer necessary for the user to also send a sticky policy that includes a digital signature generated by the user on the policies and TAs with his/her private key PrivU
                         and the symmetric key 
                           K
                         encrypted with the TA's public key PubTAi for each of the authorized TAs. Instead, the user sends a signed copy of the sticky policy, and shares the key 
                           K
                         using a secret sharing scheme where the authorized TAs are members of authorized subsets.

When the CSP needs to access the user's PII, it sends the relevant sticky policy to one of the authorized TAs listed in policy — received from the user, and includes the CSP's share.

The TA (e.g. t
                        
                           TA,1) then checks the signature on the policy to verify that Policy is authentic: if it is authentic, t
                        
                           TA,1 further verifies that the CSP fulfils the conditions specified in the Policy. If they are verified, t
                        
                           TA,1 recreates the symmetric key 
                           K
                         and provides the CSP with 
                           K
                        , encrypted with the CSP's public key 
                           PubCSP
                        . The CSP can then use its private key to decrypt the symmetric key 
                           K
                         and decrypt the PII.

With multiple Trust Authorities being present, and either the user alone, or both at least one TA and at least one CSP must participate during the recreation, the access structure changes as illustrated in Fig. 11
                         for Z
                        2. The access structure Z
                        2 defines sub-access structures Z
                        2,1, Z
                        2,2, Z
                        2,3 and Z
                        2,4 as the access structures of f
                        1, f
                        2, f
                        3, and f
                        4 respectively.

We redefine T
                        
                           TA
                         as:
                           
                              
                                 
                                    
                                       T
                                       TA
                                    
                                    =
                                    
                                       
                                          t
                                          
                                             TA
                                             ,
                                             1
                                          
                                       
                                       …
                                       
                                          t
                                          
                                             TA
                                             ,
                                             d
                                          
                                       
                                    
                                 
                              
                           
                        where d is the number of Trust Authorities.

Implementing Z
                        2 requires a secret sharing scheme function that allows recreation of the shared secret if any of the TAs participates in the reconstruction. Implementation of such a scheme is possible with a combiner driven secret sharing scheme, using the function f
                        4 on the binary representation of a TA share (s
                        
                           TA,i
                        , 1≤i≤d) and a combiner share of the TA (
                           
                              s
                              
                                 C
                                 ,
                                 T
                                 
                                    A
                                    i
                                 
                              
                           
                        , 1≤i≤d) as:
                           
                              
                                 
                                    
                                       f
                                       4
                                    
                                    
                                       
                                          s
                                          1
                                       
                                       
                                          s
                                          2
                                       
                                    
                                    =
                                    
                                       s
                                       1
                                    
                                    ⊕
                                    
                                       s
                                       2
                                    
                                    ∀
                                    
                                       s
                                       1
                                    
                                    ,
                                    
                                       s
                                       2
                                    
                                    ∈
                                    S
                                    .
                                 
                              
                           
                        
                     

The function f
                        4 requires a TA's share and a matching combiner share:
                           
                              
                                 
                                    
                                       f
                                       4
                                    
                                    
                                       
                                          s
                                          
                                             TA
                                             ,
                                             i
                                          
                                       
                                       
                                          s
                                          
                                             c
                                             ,
                                             4
                                             ,
                                             T
                                             
                                                A
                                                i
                                             
                                          
                                       
                                    
                                    =
                                    
                                       s
                                       
                                          TA
                                          ,
                                          i
                                       
                                    
                                    ⊕
                                    
                                       s
                                       
                                          c
                                          ,
                                          4
                                          ,
                                          T
                                          
                                             A
                                             i
                                          
                                       
                                    
                                    ∀
                                    1
                                    ≤
                                    i
                                    ≤
                                    d
                                 
                              
                           
                        
                     

The combiner share 
                           
                              s
                              
                                 C
                                 ,
                                 T
                                 
                                    A
                                    i
                                 
                              
                           
                         of a TA t
                        
                           TA,i
                         is computed such that
                           
                              
                                 
                                    
                                       f
                                       2
                                    
                                    
                                       
                                          
                                             f
                                             4
                                          
                                          
                                             
                                                s
                                                
                                                   TA
                                                   ,
                                                   i
                                                
                                             
                                             
                                                s
                                                
                                                   c
                                                   ,
                                                   4
                                                   ,
                                                   T
                                                   
                                                      A
                                                      i
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             f
                                             3
                                          
                                          
                                             
                                                s
                                                
                                                   CSP
                                                   ,
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    =
                                    
                                       f
                                       4
                                    
                                    
                                       
                                          s
                                          
                                             TA
                                             ,
                                             i
                                          
                                       
                                       
                                          s
                                          
                                             c
                                             ,
                                             4
                                             ,
                                             T
                                             
                                                A
                                                i
                                             
                                          
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       
                                          s
                                          
                                             CSP
                                             ,
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    =
                                    
                                       s
                                       
                                          TA
                                          ,
                                          i
                                       
                                    
                                    ⊕
                                    
                                       s
                                       
                                          c
                                          ,
                                          4
                                          ,
                                          T
                                          
                                             A
                                             i
                                          
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       
                                          s
                                          
                                             CSP
                                             ,
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    =
                                    K
                                    .
                                 
                              
                           
                        
                     

With randomly chosen s
                        
                           TA,i
                        , the 
                           
                              s
                              
                                 c
                                 ,
                                 4
                                 ,
                                 T
                                 
                                    A
                                    i
                                 
                              
                           
                         can hence be computed as:
                           
                              
                                 
                                    
                                       s
                                       
                                          c
                                          ,
                                          4
                                          ,
                                          T
                                          
                                             A
                                             i
                                          
                                       
                                    
                                    =
                                    K
                                    ⊕
                                    
                                       s
                                       
                                          TA
                                          ,
                                          i
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       
                                          s
                                          
                                             CSP
                                             ,
                                             i
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

As f
                        3(s
                        
                           CSP,i
                        )=
                        f
                        3(
                           K
                        ) holds, the 
                           
                              s
                              
                                 c
                                 ,
                                 4
                                 ,
                                 T
                                 
                                    A
                                    i
                                 
                              
                           
                         can also be computed as:
                           
                              
                                 
                                    
                                       s
                                       
                                          c
                                          ,
                                          4
                                          ,
                                          T
                                          
                                             A
                                             i
                                          
                                       
                                    
                                    =
                                    K
                                    ⊕
                                    
                                       s
                                       
                                          TA
                                          ,
                                          i
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       K
                                    
                                    .
                                 
                              
                           
                        
                     

Hence, there are two options to enrol a new TA or update the share of an existing TA:
                           
                              1.
                              The user actively contributes 
                                    K
                                 .

As 
                                    K
                                  can also be computed by a CSP and an already enrolled TA, a CSP and a TA can collaborate to enrol additional TAs. Depending on the business case, this can be an advantage, but it also imposes a security risk. In any case, such an action leaves an audit trail with the combiner of the TA.

Note that the TA holds two sets of combiner shares: one for the function f
                        3, which is accessible to the TA for modification, and one for the function f
                        4, which is not accessible to the TA (as an example, the combiner can be designed as a tamper resistant device). However, while each TA must hold the complete set of combiner shares for f
                        3, the TAs should be restricted such that a TA t
                        
                           TA,i
                         only holds the combiner share 
                           
                              s
                              
                                 c
                                 ,
                                 4
                                 ,
                                 T
                                 
                                    A
                                    i
                                 
                              
                           
                         for the function f
                        4. While additional shares are not required for the operation of the TA, they could be used by a TA to impersonate other TAs in case the attacking TA ever got access to the share set stored in the f
                        4 combiner.

To recreate 
                           K
                        , a CSP t
                        
                           CSP,i
                         contacts any TA t
                        
                           TA,j
                         and provides the share CSP s
                        
                           CSP,i
                        , encrypted with 
                           PubTA
                        
                        
                           
                              j
                           
                        . The TA then uses the c combiner shares s
                        
                           c,3,k
                        ,1≤
                        k
                        ≤
                        c for the computation of f
                        3(s
                        
                           CSP,i
                        ) as discussed above, and computes 
                           K
                         as
                           
                              
                                 
                                    K
                                    =
                                    
                                       s
                                       
                                          TA
                                          ,
                                          j
                                       
                                    
                                    ⊕
                                    
                                       s
                                       
                                          c
                                          ,
                                          4
                                          ,
                                          T
                                          
                                             A
                                             j
                                          
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       
                                          s
                                          
                                             CSP
                                             ,
                                             i
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Enrolment and disenrollment of CSPs, and updates of CSP shares requires access to 
                           K
                        , which implies that those operations are only possible with the consent of the user, or of a CSP.

The approaches described in Sections 4 and 5, where policies and constraints are attached to data as it is transmitted and stored within the cloud, can suffer from key management issues. Specifically, the approach suggested in Section 4 relies on a PKI infrastructure, delegating a significant amount of trust to trusted third parties (called Trust Authorities (TAs)) that need to provide compliance checking capabilities. Temporarily unavailability of such a TA might create unacceptable business disruptions and delays. The PKI-based scheme solves this problem by adding redundancy through several TAs. With redundant TAs, the PKI becomes hard to manage in practice, as the number of asymmetric PKI operations required in their process scales with the number of involved TAs. In the use case of a detached Cloud Storage Provider (CSP), the schema becomes even more complex. While that approach theoretically addresses the needs of user control and accountability of data access in the cloud, there is still no practical solution for this problem available. The secret sharing scheme based solution addresses this problem by considering an alternative approach using shares, as described in this section. Compared with the PKI-based scheme, storage and key management is easier, for example providing the following gains:
                           
                              –
                              Auditing can be enhanced as neither a TA alone, nor a CSP, can recreate the secret without the TA combiner, leaving an audit log trace — as long as the key K is destroyed properly after usage.

The number of policyKeyMapping for each artefact is much lower as it is not necessary to store that for each TA, and so the effort is constant, as compared with the alternative scheme of scaling with the number of TAs.

There is still the possibility to only enable a subset of all TAs, because there can be different access structures for each artefact if necessary.

The approach of supporting multiple TAs can be adapted to support multiple verification and control: instead of any TA authorizing access (i.e. the OR condition described in the previous section), it could be multiple TAs (i.e. an AND condition). Modifying the access structures so that at least 2 TAs have to participate in the recreation process allows for the CSP to recover K and decrypt the PII, while still providing for some redundancy among TAs and at the same time allow the TAs to audit each other's recreation attempts.

Such a setup is most suitable in situations where individual TAs might not be fully trusted and hence the other TAs can audit and check what they are doing. However, we note that the TAs are still trusted to destroy shares (such as, shares from the CSP) as well as the key 
                           K
                         after a successful recreation. Hence, the TAs are still in a strong trust position, which might require in-depth auditing in case the trust level should be lowered.

We suggest using an access structure that either allows the user to access the secret key 
                           K
                        , or requires 2 or more TA shares, and one or more CSP shares to recreate the secret. This access structure is illustrated in Fig. 12
                         for Z
                        3. The access structure Z
                        3 defines sub-access structures Z
                        3,1, Z
                        3,2, Z
                        3,3 and Z
                        3,4 as the access structures of f
                        1, f
                        3, f
                        5, and f
                        6 respectively.

The secret sharing scheme used to implement Z
                        3,2 for the CSPs is identical to the function f
                        3 discussed earlier: the CSP sends its share to TA t
                        
                           TA,i
                        ,1≤
                        i
                        ≤
                        d, and t
                        
                           TA,i
                        , recreates an intermediate result using the combiner driven threshold scheme f
                        3 discussed above.

At the same time, the CSP also indicates to TA t
                        
                           TA,j
                        ,1≤
                        i
                        ≤
                        d and i
                        ≠
                        j that a recreation operation is pending with t
                        
                           TA,i
                        . The TA t
                        
                           TA,j
                         will then send a share of a combiner driven (2, d) threshold scheme to t
                        
                           TA,i
                        , which allows t
                        
                           TA,i
                         to recreate another intermediate result using the secret sharing scheme implemented by the function f
                        5, and then combine the two intermediate results to the key 
                           K
                         using the function f
                        6.

The function f
                        6 is an XOR function that recreates the secret key 
                           K
                         from the binary representation of the result of f
                        3 and f
                        5 for any two TAs t
                        
                           TA,i
                        ,t
                        
                           TA,j
                         and any CSP t
                        
                           CSP,j
                        :
                           
                              
                                 
                                    K
                                    =
                                    
                                       f
                                       5
                                    
                                    
                                       
                                          s
                                          
                                             TA
                                             ,
                                             i
                                          
                                       
                                       
                                          s
                                          
                                             TA
                                             ,
                                             j
                                          
                                       
                                    
                                    ⊕
                                    
                                       f
                                       3
                                    
                                    
                                       
                                          s
                                          
                                             CSP
                                             ,
                                             k
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

This implies that the result of the functions f
                        3 and f
                        5 must be constant for all input shares, which is guaranteed by employing a combiner in both schemes.

The function f
                        5 is a combiner driven threshold scheme similar to f
                        3 discussed earlier: the user creates shares s
                        
                           TA,j
                         for each TA, 1≤
                        j
                        ≤
                        d. Again, the shares are created as pairs s
                        
                           TA,j
                        
                        =(x
                        
                           j
                        ,y
                        
                           j
                        )∈
                        F
                        
                           p
                        
                        ×
                        F
                        
                           p
                        ,1≤
                        j
                        ≤
                        d, where Fp is a finite field of prime order p, with |b(p)|=|b(K)|, and b(p) and b(
                           K
                        ) denoting the binary representation of p and 
                           K
                         respectively.

The user chooses the y
                        
                           j
                         for the TA shares randomly and the x
                        
                           j
                        
                        ≠0 pairwise distinct. Then, the user interpolates a polynomial g
                        5 through the points described by the TAs' shares (x
                        
                           j
                        ,y
                        
                           j
                        ), and the intermediate secret key K
                        5
                        =(0,
                           K
                        
                        ⊕
                        f
                        3(s
                        
                           CSP,k
                        )). The degree of g
                        5 is deg(g
                        5)=
                        d, where d is the number of TAs.

To create a (2,d) threshold scheme, the user computes a set of d
                        −1 combiner shares s
                        
                           c,5,i
                        
                        =(x
                        
                           i
                        ,g
                        5(x
                        
                           i
                        )),1≤
                        i
                        ≤
                        d
                        −1 and stores these combiner shares in the combiner. Afterwards, for all t
                        
                           TA,j
                        
                        ∈
                        T
                        
                           TA
                        , the user encrypts the share s
                        
                           TA,j
                         of TA
                        
                           j
                         with the TA's public key 
                           PubTA
                        
                        
                           
                              j
                           
                        , and distributes the result to TA
                        
                           j
                        .

The function f
                        3 is created as described in the previous section. We mention that the enrolment, disenrollment and update operations are carried out in the same way as discussed for f
                        3 earlier.

The protocol described above generates a second audit trail with the second TA. By increasing the threshold of f5
                        , this security level can be increased further.

As with the scheme described in Section 4, the TA is trusted to reliably destroy the key 
                           K
                         every time after using it.

In the schemes supporting multiple TAs based upon the approach described in Section 4, the core innovation comes from the fact that no TA is irreplaceable, e.g. the customer can select one or more of them (from a trusted list, agreed with the service provider): the service provider will automatically interact with one or more of them based on their online availability, response time, trust relationship and whether multiple verification is required. The principle underpinning the encryption of data with fine-grained policies can be used both to transfer data between parties and for the storage of the data themselves.

Our solution is potentially very flexible as it enables a great variety of ways in which interactions could happen. This is very important as we target a cloud environment where multiple interaction models might happen. These include:
                           
                              1.
                              the user disclosing data directly to the CSP (in encrypted form) or the data being accessed via a cloud storage provider

the user deciding which TAs to use, and backup options being in place

a potential configuration on the operational mode of the TA, in case encrypted PII data is sent to a cloud storage provider as discussed above. In this case the TA could fetch the encrypted data and send it (encrypted) to the CSP along with the symmetric key, or else just send the encrypted key to the CSP and let the CSP fetch the data from the cloud storage provider.

Choosing between these options might be part of an early negotiation phase with the user, or else some or all might be decided in advance by the infrastructure provider.

The protocols described above can be combined, for example to allow transmission of data governed by sticky policies along chains of CSPs, and to allow usage of cloud storage providers in combination with allowing choice between multiple CSPs providing a Trust Authority role.

The interactions described should not be interpreted as applying only to users representing people, as many interactions occur from machine to machine or from service to “service provider” and the protocols we describe can also apply more broadly to these cases.

This solution allows tracing and auditing within the cloud via TAs and enforcement of user preferences by cloud service providers. It is flexible in that different approaches can be used by which the TAs control decryption of the data; this suits a cloud model in that alternative options are allowed in case of unavailability of the TAs, backup TAs, specialized cloud services for storage and avoiding forcing any specific interaction pattern. In addition, the TAs can audit each other.

The key 
                           K
                         can only be recreated with the cooperation of the combiner, that is, the combiner needs to contribute at least one share. For this reason, it is sufficient to destroy the combiner to prevent any further access to the information, which significantly increases the security level. With the combiner involved in any recreation operation, the combiner's audit log gives strong evidence on time and participant set for each recreation of the key 
                           K
                        . This allows keeping the key 
                           K
                         and existing participants' shares constant, even if the participant set changes, and distinguishes combiner driven secret sharing schemes from conventional approaches. Using a combiner driven scheme allows creation of a perfectly secure implementation (see [8] for proof), where none of the participants by themselves has a better chance of finding the secret key than guessing it.

In the approaches described in Sections 4 and 5, service providers are not involved in decryption, whereas in the approach described in Section 6 both TAs and service providers are share holders. There can be benefits of having new roles for service providers, depending upon the model and context. In the cloud use case, the combiner can be (within) a tamper resistant device which can be physically located either on the TA side (this would conform to the use case described in Section 4 above), or on the CSP side. For multiple TAs, and to prevent the combiner becoming a bottleneck, the combiner can be cloned without lowering the scheme's security level. With certain extensions to our model, the user's key can be changed in case it was compromised without the need of re-encrypting the entire cloud data store. Moreover, the scheme described in Section 4 binds access control to the public key of TAs. Hence, enrolling or disenrolling TAs would require extending each record in the cloud data store with a Enc(PubTA
                        
                           new
                        ,K) dataset, or finding and removing a Enc(PubTA
                        
                           toDelete
                        ,K) dataset from all records respectively. In our secret sharing scheme based approach, such global changes would not be necessary. Enrollment and disenrollment operations can be conducted by a simple combiner operation that does not affect the cloud data store.

The PKI approach described in Section 4 above can suffer from key management issues, which in particular manifest themselves when adding new participants such as trusted authorities, and might unnecessarily disclose and leak keys: Enrolling of new TAs with the original scheme requires a significant amount of computation effort to recompute a key component for each asset that is already stored in the storage provider. Computing this key component requires access to the private, symmetric master encryption key, which makes it necessary to transfer the master encryption key over the network, and give another party access to the symmetric key. Enrolling new TAs within the approach described in Section 4 requires a significant amount of computation effort specifically because each additional TA requires computation of the policyKeyMapping() function for each asset that is already stored in the SP. Computing the policyKeyMapping() function requires access to the private, symmetric key 
                           K
                        , the policy and the PII. Hence, creating this information requires transferring the already protected information from SP to a trusted entity such as the TA, original user, or another trusted third party, and giving that party access to the required confidential key material. Transferring this data can be a security issue, as a single entity will have access to the entire data during the decryption and re-encryption process, as well as all required key material. This operation is highly vulnerable against leaks of data or key material, both during transport, but also during the actual crypto operation which (depending on the amount of data) can take weeks. The required data transfer and re-encryption is also a significant performance and cost factor when enrolling new TAs, making enrollment or disenrollment of TAs de facto economically impossible. The set of cascaded secret sharing schemes described in Section 6 takes advantage of combiner driven secret sharing as described in [8], and so prevents the performance and key management issues of the scheme proposed in Section 4.

@&#RELATED WORK@&#

To provide mechanisms for online privacy management, there has already been substantial research carried out related to anonymization technologies, enforcement of privacy policies (for example, enforcement of privacy-enhanced access control policies, as considered for example in the Prime and PrimeLife EU projects; policy lifecycle management, etc.), and on compliance with global regulations relating to data protection. However, major outstanding issues remain to be adequately addressed, including how to move control to end users, how to gather and manage end users' consent and how to make privacy management effective when information is transmitted across parties.

An alternative approach to transmitting data that is obfuscated via sticky policies, and protecting the de-obfuscation process, is to place more emphasis upon trust management before transmission of the data. If such techniques are available then it may only be necessary to employ encryption of the data in transit, although the receiving entity would still have to be trusted with respect to onward transfer of the data and therefore the control mechanisms related to this approach used alone are relatively weak. These techniques maybe used in combination with the approach suggested in this paper in order to achieve a strengthened approach: in particular, the degree of obfuscation of the data might depend upon the level of trust achieved in advance before data transmission.

Our approach can have a B2C focus, and thus complement other user-centric approaches to information management, but also has B2B applicability, and hence can help organizations transmit and enforce obligations along the service provision chain.

There are several variations on the approaches described in this paper, especially in terms of policy definition, the degrees of stickiness, the fine-grained nature of the encryption that occurs and the protocols themselves (for example, in the PKI approach, the user can bind the policy to the data within a signing operation rather than within the encryption). An alternative is to encrypt attributes with different keys, enveloping the sensitive data and passing it on, revealing different attributes to different entities in the chain. Furthermore, the mechanisms are independent of the particular policy representation used. Existing policy specification, modelling and verification tools that can be used as a basis for privacy policy representation include EPAL [12], OASIS XACML [13] (extended to handle privacy [14–16]), PRIME [17], W3C P3P [18], SecPAL4P [19] and Ponder [20]. A common understanding for the semantics used within the policies can be achieved by use of ontologies or alternatively pre-agreement for the meaning of clauses and terms.

There are a number of ways in which policies can be associated with data, ranging from weak to strong bindings. Weak binding of policies with data are often used within systems and frameworks, but there has also been some prior research related to stronger mechanisms including cryptographic techniques [21]. In the PRIME project, and subsequently in the PrimeLife project, policy-based frameworks were developed to express data handling conditions and enforce restrictions and obligations related to the data usage [17,22,23], but there was no strong binding of policies to data. The closest previous work in relation to this paper was the authors' previous papers [24,25], which considered only the PKI-based case. We can potentially use any encryption mechanism in order to associate policies with data. For example, Voltage [26] and Navajos [27] provide format-preserving encryption [28] and search-enabled encryption respectively; if the operation involves indexing, this could be used when encrypting the different attributes and thereby it would still be possible to do searching and indexing on the encrypted attributes.

There are limitations to all these approaches. A logical binding can be easily unbound, but even with a cryptographic binding, after the personal data have been decrypted, the binding is broken, in the sense that the users' data is then fully available to the authorized party and subsequently actions may be taken that contravene the policy. Furthermore, different keys may be used to encrypt different attributes, so that not all of the information need be revealed to a SP; by these means, much of the material could be enveloped up and passed along the chain of service provision without being accessible to the CSPs in between. Nevertheless, ideally policy enforcement techniques and/or detective controls such as the one proposed by Zuo et al. [29] or data taint tracking techniques would be used in combination with this approach, to protect data after it has been decrypted. However, current options for those result in stronger protection at the cost of poor scalability, high overhead, or unrealistic expectations as to the hardware or operating system environment used by service providers. Trusted computing might also be used to try to ensure that receivers act according to associated policies and constraints [30,31]: for example, trusted computing group integrity-checking mechanisms can verify that the receiver's platform is trusted, its software state is conformant with the disclosure policies, and it correctly implements defined privacy-management mechanisms. Watermarking schemes [32], obfuscation techniques [33] and other novel cryptographic schemes [34,35] can also be used for content protection, but again in general do not provide support for protecting the data after access. Other potential limitations are that the digital signature only proves the authenticity of a binding established in the past by the data subject, and that if encryption is applied only to text files that adhere to a predefined structure, policies can be relatively easy to corrupt and a skilled hacker can tamper with the file and make the policy illegible.

One drawback of this approach described in Section 5 is that data is bonded with the policy itself, which makes data heavy-weighted and potentially not compatible to the current information systems. However, traceability is provided. An alternative solution, that permits binding of privacy preferences to data and conveying the consent of the individual as well, has been proposed by Pöhls [36]. However, the solution does not avoid the non-consented (unauthorized) use of data. Furthermore, IBM [37] has introduced a unified policy model, to provide improved control over suspension and resumption of individuals' personal data, although limited enterprise scenarios were discussed.

We have worked out the details of how this approach would work and have implemented the basic mechanisms for sticky policy management within the EnCoRe project [38,39]. One example of this is that the data can be stored at rest in an encrypted form, and references to it can be bound to policies rather than the data itself. We have also considered how our solution can be adapted to different trust scenarios — for example, in the case of multiple or partially trusted users. For a single, a partially trusted user a SSS could be used on the user side with a combiner, creating a (1+1, 1+1) scheme. Multiple users are always only partially trusted, because there must be an audit trail: an SSS can be used on the user side with a combiner, creating a (1+1, n
                     +1) scheme.

Currently we have implementations of most of the required solution components within HP Labs (including for IBE), as well as a working prototype of sticky policies [40] that provides a proof-of-concept of the proposed schema, and we are intending to extend this work within the context of the EU A4Cloud project [41], with an emphasis on policy refinement and enforcement of the policies using trusted infrastructure.

Our current research focus is on extending this approach to enhance the type of checking carried out by the TAs and on combining these techniques with policy enforcement mechanisms once the data has been released at the cloud service provider side, especially with trusted computing technologies.

@&#CONCLUSIONS@&#

In this paper a novel user-centric data control mechanism has been proposed and explained. This method involves machine-readable policies (defining allowed usage and associated obligations) that are attached to data (or references to data) and travel with it as it passes among multiple parties. We have described various different approaches that can support multiple verification and control. We have also considered how key management can be simplified by means of using secret sharing instead of a public key infrastructure as the cryptographic backbone of the scheme. In contrast to PKIs, secret sharing schemes are a designated multi-party cryptographic tool which addresses the original problem more efficiently and also with a potentially significantly higher level of security.

These ‘sticky policy’ techniques are likely to be most suitable in environments where increased trust and protection justify the additional expense, or alternatively to business partners of ‘good willing’ enterprises who might encourage its use. The solutions could be used in a number of business areas but are particularly suitable to enhance privacy protection in sectors like healthcare, where sensitive information is involved, and in the cloud. The mechanisms that are most suitable for a given context will depend upon the trust model involved; in particular, the PKI mechanism is suitable where individual audit authorities are trusted by consumers and service providers to play a key role, whereas the secret sharing mechanism described in this paper is especially suitable for trust models where the parties involved in provision of decryption keys cannot be wholly trusted individually, and so the trust is spread across multiple entities.

@&#ACKNOWLEDGEMENTS@&#

We would like to acknowledge previous input to our sticky policy research from Gina Kounga and Archie Reed.

@&#REFERENCES@&#

