@&#MAIN-TITLE@&#A new local search for continuous location problems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New local search is proposed.


                        
                        
                           
                           Shifting systematically between two formulation spaces (continuous and discrete) is novel.


                        
                        
                           
                           Incorporation of the new local search within VNS.


                        
                        
                           
                           Very competitive results when tested on the continuous p-median problem.


                        
                        
                           
                           This is a general optimization type approach that can have a massive research impact in the future.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Continuous location

Weber problem

Space search formulation

Variable neighbourhood

@&#ABSTRACT@&#


               
               
                  This paper presents a new local search approach for solving continuous location problems. The main idea is to exploit the relation between the continuous model and its discrete counterpart. A local search is first conducted in the continuous space until a local optimum is reached. It then switches to a discrete space that represents a discretisation of the continuous model to find an improved solution from there. The process continues switching between the two problem formulations until no further improvement can be found in either. Thus, we may view the procedure as a new adaption of formulation space search. The local search is applied to the multi-source Weber problem where encouraging results are obtained. This local search is also embedded within Variable Neighbourhood Search producing excellent results.
               
            

@&#INTRODUCTION@&#

Location models generally require finding the location of a given number, say p, of new facility sites in order to serve in some optimal way (e.g., minimum cost) a given set of existing facilities, also known as customers or demand (or fixed) points. If the model is formulated in continuous space, a distance function is required to calculate the distance between pairs of points. Since the new facilities may be located anywhere in the continuous space or regions thereof, these models are referred to as site generating models (e.g., see Love, Morris, & Wesolowsky, 1988). The distance functions most commonly used are the Euclidean norm and the rectangular (or Manhattan) norm; however, more sophisticated models of distance are available when more accurate estimates of actual travel distances are desired (e.g., Brimberg & Walker, 2010).

The same location problem may be formulated in discrete space by restricting the potential new facility sites to a specified finite set of points in the continuous space. If these sites are chosen well, and a good algorithm or heuristic is available to solve the discrete formulation, we may anticipate a “good” solution to the original problem. For example, if we restrict the candidate facility sites to the given set of fixed points, the classical multi-source Weber problem, also known as the continuous location-allocation problem, converts to the classical (discrete) p-median problem. We may then try to obtain a good solution to the discrete model, and use it as a starting point for the continuous model.

Exploiting the relation between the p-median model and the continuous location-allocation model has been suggested as early as in the original work of Cooper (1963, 1964). Hansen, Mladenović, and Taillard (1998) tested a heuristic that first solves the p-median problem exactly using a primal–dual algorithm by Erlenkotter (1978), and then completes one iteration of “continuous-space adjustment” by solving the p continuous single facility problems identified in the first phase. Brimberg, Hansen, Mladenović, and Taillard (2000) examined this heuristic among others, and concluded that computation time became a limiting factor on larger problem instances. Gamal and Salhi (2003) used a similar approach where in the first phase, an effective heuristic is applied instead of an exact solution approach to solve the p-median problem.

In certain cases it may be shown that the continuous problem has a finite dominating set. For example, if the rectangular norm (l
                     1-norm) is used as the distance function, it is well known that an optimal solution of the continuous location-allocation problem exists where each of the facilities is located at a vertex of a grid formed by drawing horizontal and vertical lines (the fundamental directions of the l
                     1-norm) through each of the demand points. Since an optimal solution in the plane must also exist with all facilities inside the convex hull of the demand points (e.g., see Hansen, Perreur, & Thisse, 1980), or the smaller rectangular hull for the l
                     1-norm (Love et al., 1988), a discrete formulation of the continuous location-allocation problem with a fewer number of nodes is also possible that guarantees an optimal solution of the original problem. This idea can be extended to the class of polyhedral (or block) norms (e.g., Ward & Wendell, 1980,Ward, Wendell, & Richard (1985)), although the grid will be more complicated in general due to a higher number of fundamental directions attributed to the norm. This discretisation of the continuous space does not extend to round metrics such as the Euclidean norm.

In practice the discrete formulation, whether or not it contains an optimal solution of the original continuous location problem, may become rather large to be tackled optimally. Aras, Altinel, and Orbay (2007) propose a discrete approximation to solve the capacitated multi-source Weber problem (CMSWP) with Euclidean, squared Euclidean and l
                     
                        p
                      distances with 1<
                     p
                     <2. The authors discretise the solution space while increasing the number of potential sites by using the rectangular grid points that are within the convex hull of the customers. Two MILP formulations are proposed using this new set of potential sites, including some attempts in choosing a subset. Heuristic approaches such as a Lagrangean relaxation-based method, the p
                     −median heuristic of Hansen et al. (1998) and the cellular Heuristic of Gamal and Salhi (2001) are also investigated. Aras, Orbay, and Altinel (2008) adapt the previous approaches to the case of rectilinear distances whereas Durmaz, Aras, and Altinel (2009) extend this discretisation approach to cater for uncertainty due to changes in the customer set. Very recently, Akyüz, Altinel, and Öncan (2013) studied the CMSWP using two branch-and-bound techniques where one is related to the discretisation of the location space. Heuristics based on solving the discrete approximation of the CMSWP by Lagrangean Relaxation are proposed by Boyaci, Altinel, and Aras (2013).

For an overview of the continuous location-allocation problem, the interested reader is referred to the survey paper by Brimberg, Hansen, Mladenovic, and Salhi (2008) and the references therein, while for the discrete p-median model and solution approaches the review by Mladenović, Brimberg, Hansen, and Moreno-Perez (2007) can be useful.

The relation between discrete and continuous formulations may be extended to many other location models. For example, the less-studied continuous p-centre problem becomes the better-known discrete p-centre problem when candidate facility sites are once again restricted to the set of fixed points. The classical (discrete) simple plant location problem has more recently been modelled in continuous space by Brimberg and Salhi (2005), and in a related paper by Brimberg, Mladenovic, and Salhi (2004). Indeed, the idea of exploring the relation between discrete and continuous location problems presents in our view a rich new area of research.

In this paper we present a new local search for solving continuous location problems that is based on reformulations of the problem in continuous and discrete space. The basic idea is to find a local optimum in continuous space using any convenient local search algorithm. The search space is then modified by reformulating the problem in discrete space. Here we introduce the idea of augmenting a specified set of fixed points (the current set) with the local optima obtained in the continuous phase. Thus, we solve exactly or heuristically a discrete problem where the nodes of the network now include the new facility sites obtained in the previous step. We switch back to continuous space using the discrete solution as the starting point. The procedure alternates between continuous and discrete spaces, always adding newly acquired facility sites to the current set in the discrete formulation, until no further improvement is found.

The local search outlined above incorporates elements of a metaheuristic known as formulation space search (FSS). The basic idea here as presented in Mladenović, Plastria, and Urosevic (2005) is to use different formulations of a combinatorial or global optimization problem in an iterative fashion, where in each formulation suitable local searches are used. For example, the authors applied two formulations in different coordinate systems of the circle packing problem with excellent results.

In formulation space search, the different formulations are all equivalent to each other. However, in our case, the discrete model is an approximation of the continuous model, thus presenting a fundamental departure from FSS. We may also argue, meanwhile, that the discrete formulation is equivalent to the continuous formulation in an asymptotic sense, as more facility sites generated in the continuous phase are added to the network.

The paper is organized as follows. In the next section we provide a basic framework for the proposed local search. Section 3 illustrates the local search on the multi-source Weber problem (MWP) using a well-known 50-customer problem from the literature. Larger problem instances of MWP are examined later in this section. Section 4 develops a variable neighbourhood search (VNS) heuristic for solving MWP that employs the proposed local search in its local search step. The same data sets are also tested here and superior computational results are obtained. The last section summarizes our conclusions and highlights some suggestions for further research.

We consider an unconstrained location problem of the general form
                        
                           (GLP)
                           
                              min
                              
                              f
                              (
                              
                                 
                                    X
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    X
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                              
                              )
                              .
                           
                        
                     where 
                        
                           
                              
                                 X
                              
                              
                                 i
                              
                           
                           ∈
                           
                              
                                 R
                              
                              
                                 N
                              
                           
                        
                      gives the unknown location of new facility i, i
                     =1,…,
                     p, and the objective function f(.) represents some performance measure, such as total cost. Typically the location problem occurs in the plane, so that N
                     =2, and X
                     
                        i
                      is given by the Cartesian coordinates (x
                     
                        i
                     ,
                     y
                     
                        i
                     ).

Consider as an illustration the classical multi-source Weber problem, which may be formulated as follows:
                        
                           (MWP1)
                           
                              min
                              
                              f
                              (
                              
                                 
                                    X
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    X
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              
                                 
                                    w
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    min
                                 
                                 
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    p
                                 
                              
                              {
                              ‖
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    A
                                 
                                 
                                    j
                                 
                              
                              ‖
                              }
                              .
                           
                        
                     Here A
                     
                        j
                      denotes the known coordinates of customer j, w
                     
                        j
                     
                     >0, the known demand at A
                     
                        j
                     , and ∥X
                     
                        i
                     
                     −
                     A
                     
                        j
                     ∥ the Euclidean distance between the pair of points X
                     
                        i
                      and A
                     
                        j
                     , i
                     =1,…,
                     p, j
                     =1,…,
                     n. The objective function gives a sum of weighted distances from the demand points to their nearest facilities, and thus, represents a measure of the total cost of the current solution.

As a second illustration, consider the continuous weighted p-centre problem, which may be formulated as follows:
                        
                           (MCP)
                           
                              min
                              
                              g
                              (
                              
                                 
                                    X
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    X
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       max
                                    
                                    
                                       j
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       n
                                    
                                 
                              
                              {
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    min
                                 
                                 
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    p
                                 
                              
                              {
                              ‖
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    A
                                 
                                 
                                    j
                                 
                              
                              ‖
                              }
                              }
                              ,
                           
                        
                     where weight v
                     
                        j
                     
                     >0 reflects the “importance” of demand point A
                     
                        j
                     , and the remaining notation is the same as for (MWP1). The objective function gives the maximum (weighted) distance between the demand points and their nearest facilities, and thus, represents a measure of the quality of service of the current solution.

Other examples include the use of ordered medians (e.g., Nickel & Puerto, 2005), or the use of negative-valued weights in (MWP1) or (MCP) to model obnoxious facilities (e.g., Erkut & Newman, 1989). In the latter case, restrictions on the location of the facilities may be required in order to guarantee that an optimal solution exists. Capacity constraints and flow variables may also be included in the model.

We now describe the basic steps of the proposed local search for problems of type (GLP). To differentiate between the continuous and discrete formulations of the problem, we let (GLP) denote the original continuous formulation and (GLP)′ the discrete approximation. Let S denote a finite set of identified potential sites for the new facilities, and X a subset of p of these sites. For example, S
                     ={A
                     1,…,
                     A
                     
                        n
                     }, where typically n
                     ≫
                     p, has been recommended in earlier works as noted above. The discrete formulation of the problem is then given by:
                        
                           (GLP′)
                           
                              
                                 
                                    min
                                 
                                 
                                    X
                                    ⊂
                                    S
                                 
                              
                              f
                              (
                              X
                              )
                              .
                           
                        
                     Assuming w.l.o.g. that the new facilities are identical, there are 
                        
                           
                              
                                 
                                    
                                       
                                          
                                             M
                                          
                                       
                                       
                                          
                                             p
                                          
                                       
                                    
                                 
                              
                           
                        
                      combinations of candidate solutions of (GLP)′, where M is the cardinality of the set S. (The case of non-homogeneous new facilities is readily handled using a solution space that contains up to a factor of p! more points.) Finally, we let L
                     
                        C
                      and L
                     
                        D
                      denote the selected local search operators for (GLP) and (GLP)′, respectively. These search engines stop at a current solution if, and only if, a better solution cannot be found in the specified neighbourhood of this point.

A simple approach combining the discrete and continuous formulations of the problem is given next. (The main heuristic will be given afterwards.) The general idea is to solve (GLP)′ first either heuristically or exactly, and use the obtained solution as the starting point for the local search in (GLP). Although the idea of solving (GLP)′ first has been suggested before (e.g., Hansen et al., 1998), the inclusion of a second phase of local search in the continuous space is, to the best of our knowledge, a general approach yet to be formalized.
                        Algorithm 1
                        Basic local search (BLS).
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      Step 1:
                                                   Select an initial set S for (GLP)′.
                                                
                                                
                                                   
                                                      Step 2:
                                                   Solve (GLP)′ heuristically or exactly to obtain an initial solution 
                                                         
                                                            
                                                               
                                                                  X
                                                               
                                                               
                                                                  0
                                                               
                                                            
                                                            =
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           X
                                                                        
                                                                        
                                                                           1
                                                                        
                                                                        
                                                                           0
                                                                        
                                                                     
                                                                     ,
                                                                     …
                                                                     ,
                                                                     
                                                                        
                                                                           X
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                        
                                                                           0
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      .
                                                
                                                
                                                   
                                                      Step 3:
                                                   
                                                      L
                                                      
                                                         C
                                                      (X
                                                      0)→
                                                      X
                                                      
                                                         C
                                                      , and stop (final solution =
                                                      X
                                                      
                                                         C
                                                      ).
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In effect, Algorithm 1 is a 2-phase approach that may be viewed as a hybrid heuristic. The solution of the discrete problem (GLP)′ is used as a good starting solution for the local search in continuous space (step 3 above) in much the same way that a constructive heuristic could be used.

We also emphasize that BLS is distinctly different from the p-median heuristic used in Brimberg et al. (2000) in the following ways: (i) In the latter method the discrete p-median problem is solved exactly, followed by one step of continuous adjustment only (i.e., it solves p independent single facility problems using the customer partition found in the discrete solution). Thus the p-median heuristic does not guarantee to reach a local minimum in continuous space as our heuristic does. (ii) The exact solution of the discrete problem limits the p-median heuristic to smaller problem instances. (iii) The discrete formulation in the p-median heuristic defines the set of candidate sites as given by the set of customer locations. In our heuristic the set of candidate sites is defined in a general way. (It can be the customer set, part of the customer set or can have other “attractive” points added to it.)

The next algorithm provides a new way of combining the discrete and continuous phases of the search, which we term “Reformulation local search”.
                        Algorithm 2
                        Reformulation local search (RLS).
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      Step 1:
                                                   Select an initial set S for (GLP)′ and an initial solution 
                                                         
                                                            
                                                               
                                                                  X
                                                               
                                                               
                                                                  0
                                                               
                                                            
                                                            =
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           X
                                                                        
                                                                        
                                                                           1
                                                                        
                                                                        
                                                                           0
                                                                        
                                                                     
                                                                     ,
                                                                     …
                                                                     ,
                                                                     
                                                                        
                                                                           X
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                        
                                                                           0
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      .
                                                
                                                
                                                   
                                                      Step 2
                                                   
                                                   (solving the continuous problem): L
                                                      
                                                         C
                                                      (X
                                                      0)→
                                                      X
                                                      
                                                         C
                                                       (where X
                                                      
                                                         C
                                                      
                                                      ≠
                                                      X
                                                      0, only if f(X
                                                      
                                                         C
                                                      )<
                                                      f(X
                                                      0)).
                                                
                                                
                                                   
                                                      Step 3
                                                   
                                                   (augmenting S): S
                                                      ←
                                                      S
                                                      ∪
                                                      X
                                                      
                                                         C
                                                      .
                                                
                                                
                                                   
                                                      Step 4
                                                   
                                                   (solving the discrete problem): L
                                                      
                                                         D
                                                      (X
                                                      
                                                         C
                                                      )→
                                                      X
                                                      
                                                         D
                                                       (where X
                                                      
                                                         D
                                                      
                                                      ≠
                                                      X
                                                      
                                                         C
                                                      , only if f(X
                                                      
                                                         D
                                                      )<
                                                      f(X
                                                      
                                                         C
                                                      )).
                                                
                                                
                                                   
                                                      Step 5:
                                                   If X
                                                      
                                                         D
                                                      
                                                      =
                                                      X
                                                      
                                                         C
                                                      , stop (final solution=
                                                      X
                                                      
                                                         D
                                                      ); else X
                                                      0
                                                      ←
                                                      X
                                                      
                                                         D
                                                       and return to step 2.
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Note that we could use the solution found in step 2 of BLS as the starting solution within the general framework of RLS. This would consequently guarantee that RLS is never worse than BLS. However, the aim of our study is to present an adaptive approach that augments the set of potential sites in discrete space by adding newly found points in continuous space in a systematic and simple way and not to promote efficient implementations which could without any doubt be useful at producing better solutions. This latter objective could be achieved by the combined BLS/RLS approach noted above, or by using powerful global optimization techniques such as metaheuristics to produce such initial discrete high quality solutions (see Mladenović et al., 2007).

The multi-source Weber problem, also referred to as the continuous location-allocation problem, is a well-studied model in location theory. As observed above in (MWP1), the objective is to generate optimal sites in continuous space, notably 
                        
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        
                     , for a given number of new facilities in order to minimize a sum of transportation (or service) costs to a given set of customers at known point locations and with known demands.

Thus, we wish to locate p new facility sites in the plane in order to service a set of n customers at known locations A
                     
                        j
                     
                     =(a
                     
                        j
                     ,
                     b
                     
                        j
                     ) and with given demands (weights) w
                     
                        j
                     
                     >0, j
                     =1,…,
                     n. The basic version of the (uncapacitated) multi-source Weber problem given in (MWP1) may be rewritten in the following equivalent form (e.g., Love et al., 1988), which is more suitable for gradient-based search methods:
                        
                           (MWP2)
                           
                              
                                 
                                    
                                       min
                                    
                                    
                                       w
                                       ,
                                       X
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       p
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              
                                 
                                    w
                                 
                                 
                                    ij
                                 
                              
                              ‖
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    A
                                 
                                 
                                    j
                                 
                              
                              ‖
                           
                        
                     subject to
                        
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   p
                                                
                                             
                                          
                                          
                                             
                                                w
                                             
                                             
                                                ij
                                             
                                          
                                          =
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                          
                                          ∀
                                          j
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                w
                                             
                                             
                                                ij
                                             
                                          
                                          ⩾
                                          0
                                          
                                          ∀
                                          i
                                          ,
                                          j
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     where X
                     =(X
                     1,…,
                     X
                     
                        p
                     ) designates the set of location decision variables, with X
                     
                        i
                     
                     =(x
                     
                        i
                     ,
                     y
                     
                        i
                     ) being the unknown location of facility i, i
                     =1,…,
                     p; w
                     =(w
                     
                        ij
                     ) designates the set of allocation decision variables, where w
                     
                        ij
                      gives the flow to customer j from facility i, i
                     =1,…,
                     p, j
                     =1,…,
                     n; and 
                        
                           ‖
                           
                              
                                 X
                              
                              
                                 i
                              
                           
                           -
                           
                              
                                 A
                              
                              
                                 j
                              
                           
                           ‖
                           =
                           
                              
                                 
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       -
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       -
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                      is the Euclidean distance between facility i and customer j. Note that the objective function measures the total service cost while the constraints ensure that all the customer demands are satisfied. The model above uses the Euclidean norm to estimate travel distances or times, but other distance functions, such as the Manhattan norm or, more generally, the l
                     
                        p
                      norm, have also been employed (e.g., see Love et al., 1988 or Francis, McGinnis, & White, 1992 for a review).

Finding an optimal solution to (MWP2) is a difficult proposition due to the non-convexity of the objective function and the existence of multiple local minima. This fact was known to the originator of the model; see Cooper (1963, 1964). It was shown later that the problem is NP-hard (Megiddo & Supowit, 1984). Brimberg, Hansen, and Mladenović (2010) demonstrate the difficult nature of (MWP2) on a 50-customer problem taken from the classical textbook by Eilon, Watson-Gandy, and Christofides (1971) by using 10,000 random restarts of Cooper’s well-known alternating heuristic for p
                     =5, 10, 15, to generate 272, 3008 and 3363 different local minima, respectively. Furthermore, the worst deviation from the optimal solution was respectively, 47%, 66% and 70%, while the optimal solution was obtained 690 times for p
                     =5, 34 times for p
                     =10 and only once for p
                     =15. Such relatively small instances are useful in demonstrating the tendency for the number of local minima to increase exponentially with problem size as defined by n and p.

Early attempts to solve the problem exactly are given in Kuenne and Soland (1972) and Ostresh (1973); however the branch-and-bound algorithms were capable of solving at the time only very small instances, of the order of n
                     =15, p
                     =4 and n
                     =50, p
                     =3. Rosing (1992) was able to incorporate improvements in the methodology that solved problems with n
                     =30, p
                     =5 and n
                     =25, p
                     =6. It was not until quite recently that the original 50-customer problem in Eilon et al. (1971) was solved exactly using a novel column generation approach combined with global optimization and branch-and-bound (Krau, 1997). This author was also able to obtain exact solutions for instances with up to n
                     =287 customers (ambulance problem from Bongartz, Calamai, & Conn (1994)) and up to p
                     =100 facilities by utilizing a dual formulation of the problem. A bundle method in the l
                     1 norm (du Merle, Villeneuve, Desrosiers, & Hansen, 1997) is added to stabilize the solution of the dual, leading to an algorithm in Hansen, Krau, and du Merle (2000) that successfully solves problems up to n
                     =1000 and p
                     =100.

Despite these advances, large scale problems found in the literature remain unsolvable by exact methods. Furthermore, the newer algorithms tend to be highly sensitive to the starting solution, and so, require state-of-the-art heuristics to obtain the best initial solution possible. Thus, advances in heuristic approaches are continually sought. For instance, Taillard (2003) solves very large centroid problems by using efficient clustering techniques.


                     Brimberg and Drezner (2013) suggest an improved alternate algorithm which is a modified version of the well known locate-allocate of Cooper (1963, 1964) enhanced by a transfer follow-up. In brief, instead of finding the optimal location within each cluster using the Weiszfeld recursive equation (Weiszfeld, 1937) and then re-allocating customers based on the new facility locations, the authors randomly choose one facility at a time to re-locate and re-assign customers to their nearest facilities after each re-location. A flag stating whether or not a facility has been affected is activated and the process is repeated until all flags remain unchanged. This scheme has the advantage of being less rigid and hence avoids entrapment in the same local optimum obtained by the systematic approach of Cooper’s locate-allocate. An exchange of customers based only on those that lie on the boundary of two nearest facilities is then examined for possible reallocation (allocate a customer to its second nearest facility) and the saving due to these two affected facilities is evaluated to see whether or not the swap is worthwhile. The examination of boundary customers is a powerful and efficient allocation scheme as also shown in Salhi and Sari (1997) when studying a class of multi-depot vehicle routing problems.

Very recently, Drezner, Brimberg, Mladenović, and Salhi (submitted for publication) propose an effective constructive heuristic that finds a good initial solution by combining the drop method and the gravity concept (see Brimberg, Drezner, Mladenović, & Salhi, 2013 for its details), a decomposition method that relies upon those triangles that constitute the nodes of the Delaunay triangulation of the set of facilities, and a concentric tabu search whose set of neighbourhoods is defined by different radii around the current set of facility locations. Sophisticated methods such as these and others may be used as local search operators (L
                     
                        C
                      or L
                     
                        D
                     ) in algorithm RLS, resulting in a rich variety of heuristics embedded in the RLS framework.

Consider a simple problem comprising 8 customers with coordinates and weights tabulated below (also see Fig. 1
                        ):
                           
                              
                                 
                                 
                                 
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          x
                                          
                                             i
                                          
                                       
                                       
                                          y
                                          
                                             i
                                          
                                       
                                       
                                          w
                                          
                                             i
                                          
                                       
                                    
                                    
                                       1
                                       1
                                       0
                                       1
                                    
                                    
                                       2
                                       0
                                       1
                                       1
                                    
                                    
                                       3
                                       −1
                                       0
                                       1
                                    
                                    
                                       4
                                       0
                                       −1
                                       1
                                    
                                    
                                       5
                                       2.41
                                       0
                                       10
                                    
                                    
                                       6
                                       0
                                       2.41
                                       10
                                    
                                    
                                       7
                                       −2.41
                                       0
                                       10
                                    
                                    
                                       8
                                       0
                                       −2.41
                                       10
                                    
                                 
                              
                           
                        
                     

Note that the external demand points are each given a weight of 10 while the internal ones have unit weights. The objective is to find optimal locations for p
                        =5 facilities.

Let the BLS algorithm begin by randomly selecting five demand points from the set S
                        ={A
                        
                           j
                        ,
                        j
                        =1,…,8}. Thus, there must be at least one external point and one internal point in this initial solution. A simple vertex exchange heuristic as the local search in discrete space will then move facilities from internal points to the heavier external points until the four external points are covered and a single facility (of the five) remains at an internal point (see the configuration in Fig. 1). This yields a local minimum which is also a global solution of the given discrete problem. A subsequent Cooper-style heuristic will fail to move the facilities from their current positions since the current solution is also a local minimum in continuous space. Thus the BLS terminates with an objective value of 3×1.41=4.23. Meanwhile if we let RLS start from five random points in continuous space, it is possible to capture the Weber point (0,0) and subsequently the optimal solution denoted by small squares in Fig. 1 with objective value of 4.0.

This simple example illustrates the advantage of adding Weber points (i.e., solutions from a continuous phase) in the discrete approximation of the original continuous problem. This example also shows that BLS is not globally convergent, whereas RLS has the inherent flexibility to be so.

We now test the basic local search (Algorithm BLS) and the reformulation local search (Algorithm RLS) on a relatively small instance, the well-known 50-customer problem from Eilon et al. (1971). The benchmark used for comparison is the classical multi-start Cooper method (MALT).

In brief, MALT consists of (a) randomly generating the locations of p facilities, either from the rectangle that encloses all customers, or from potential sites such as the demand points, (b) allocating each customer, to its nearest facility to determine p clusters, (c) applying the Weiszfeld procedure to obtain an optimal location within each cluster, and (d) repeating the allocation and the location steps (b) and (c) until there is no change in the total weighted distance or in the facility configuration. The entire process is repeated several times from random starting points, and the best solution is selected.

All methods were programmed in Fortran 95 compiler release 5.50e and run on a PC with 1.8gigahertz processor. Cooper’s alternating algorithm is chosen as the local search operator in continuous space (L
                        
                           C
                        ). The discrete search operator (L
                        
                           D
                        ) is a simple vertex swap originally proposed by Teitz and Bart (1968). This local search is based on the exchange of one facility from its current location on a vertex to an unoccupied vertex on the network, with customers re-allocated to their closest facilities in each configuration. All such vertex exchanges are examined and the one giving the best improvement is taken. The process is repeated until there is no further improvement with respect to this facility exchange neighbourhood. In our implementation of this local search, the change in the objective function resulting from a vertex exchange (or ‘swap’) is calculated using an efficient procedure by Whitaker (1983), that requires the retention of second nearest facility distances. The Whitaker improvement avoids unnecessary repetition of calculations on parts of the objective function that are unchanged.

In summary, we note that the most basic local searches are employed in the two phases of RLS. We repeat the experiment 100 times for each value of p and for each heuristic to gather basic statistics such as the number of different local minima found, the number of times the best, second best and third best solutions of each respective method are obtained, as well as the number of times a local minimum is obtained whose deviation from the optimum is within three thresholds which are set to 0.0005, 0.005 and 0.05. Table 1
                         summarises these statistics. Note that the first best solution is also globally optimal in all instances for BLS and RLS but not for MALT.

It can be observed that the idea of augmenting the set of potential sites with Weber locations in RLS increases the power of the method at obtaining a larger number of occurrences of the best solution as well as guaranteeing a larger number of occurrences of local minima whose fractional deviation is less than 0.0005. Note that this does not guarantee that there will always be many successes at reaching a global minimum even if the method is robust at generating excellent solutions around the global minimum. This observation can be seen in Table 1 for RLS and p
                        =20 where there are only 2 occurrences of ‘first-best’ but 71 of second-best that happens to lie within a tiny deviation of 0.0005 from the global minimum. With regard to MALT, we see that it obtained many more distinct local minima, and as a result, very few occurrences of its first, second and third-best solutions. BLS seems to perform for this small example nearly as well as RLS. This shows the improvements over MALT are quite substantial when the search is extended to discrete space. It is also worth noting that RLS produces a larger number of solutions within 0.0005 in all cases except for p
                        =25. For instance, when p
                        =20, the number of very good solutions (within 0.0005) is extremely high at 73 compared with 3 only for BLS. The exceptional case at p
                        =25 may have a simple explanation. As the number of facilities increases, more and more of them will be located at fixed points in an optimal solution. Thus the relative performance of BLS improves for these very large values of p. Though the aim is not to compare these two approaches, the above result demonstrates the robustness of the innovative and simple approach used in RLS.

In our implementation, MALT and RLS both begin with uniformly random continuous facility locations within the rectangle that encloses all the fixed points (e.g., Scott, 1971). BLS on the other hand starts with a random selection of p nodes from S in its first phase when solving the discrete p-median problem. RLS and BLS both use the set of fixed points as the initial set S; but BLS stops after finding the continuous location (or Weber) points in phase 2, whereas RLS continues augmenting the set of potential sites which then allows the new Weber points to be used in the next local search on the larger network. According to these encouraging empirical results, further experiments are conducted next to test our proposed BLS and RLS approaches on larger data sets and with varying values of p.

We conducted an extensive empirical experiment on four data sets commonly used for the multi-source Weber problem (see Brimberg et al., 2000) as a platform to test our methodology. These include the 50-customer problem in Eilon et al. (1971), the 287-customer ambulance problem from Bongartz et al. (1994), and the 654- and the 1060-customer problems listed in the TSP library (see Reinelt, 1991). Note that the summary results of the first data set are provided in the previous subsection in Table 1.

We run each instance for the same amount of CPU time for each method described in the previous section. For each instance, the time allowed for n
                        =287, 654 and 1060 is 20, 120 and 300 s respectively. The results are given in Tables 2–4
                        
                        
                         where the first two columns list the value of p and the best known solution as reported in Table 1 of Brimberg et al. (2000); this is followed by 3 columns giving the deviation of the best solution from the best known and then 3 columns providing the times (in secounts) when the best solution was found. A bold format in Table 3 is used to denote instances where an improvement over the best known solution was obtained. For n
                        =287, ‘Best’ represents the optimal solution as shown by Krau (1997).

We observe again a substantial improvement in solution quality of BLS and RLS over the conventional MALT. Meanwhile BLS and RLS yield comparable results. Furthermore, the quality of the solutions obtained by both local searches is very good. For the 287-customer problem (Table 2), MALT fails miserably while BLS and RLS both are on average 0.04% above the optimal solution. For the larger data sets (Tables 3 and 4), the average deviations of BLS and RLS from the best-known solutions obtained by the relatively sophisticated metaheuristic methods in Brimberg et al. (2000) are only of the order of 1/5%. Also, it is observed that RLS, on the larger instances, produces its best solution slightly earlier than the other two approaches.

The computational results above support the notion that a combined local search in discrete and continuous spaces can be a powerful heuristic approach. The combined local search may be as simple as the BLS algorithm presented here, or as flexible as the proposed RLS algorithm. In spite of the comparable results of BLS and RLS on the limited data sets examined here, we recommend RLS over BLS for the following reasons:
                           
                              (i)
                              RLS provides a general framework for building local searches, and hence, is a more adaptable methodology. In fact, BLS may be viewed as a stripped-down implementation of RLS.

RLS has a stronger theoretical basis than BLS, as the simple example in Section 3.1 amply demonstrates.

In this section, we incorporate our new local search within a powerful metaheuristic known as variable neighbourhood search (VNS). VNS is a metaheuristic for solving combinatorial and global optimization problems. Its basic idea is to systematically change neighbourhoods in the search for a better solution (see Mladenović & Hansen, 1997). The main loop consists of three steps: Shaking or perturbation of the incumbent solution X to a random solution in some neighbourhood of X, a local search from the perturbed solution, and a neighbourhood change. For various VNS variants and their successful applications, see Hansen, Mladenović, and Moreno Perez, 2010; Mladenović, Todosijevic, and Urosevic, 2013. For a number of different variants of VNS applied to the multi-source Weber problem, see Brimberg et al., 2000.

The Basic VNS (BVNS) method we employ is outlined in Algorithm 3, where two parameters are needed: t
                     
                        max
                      relating to the limit on execution time and k
                     
                        max
                      to the number of neighbourhoods used in the shaking operation.
                        Algorithm 3
                        Steps of the Basic VNS (BVNS).
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      Step 1:
                                                   Specify k
                                                      
                                                         max
                                                      , t
                                                      
                                                         max
                                                       and define the neighbourhood structures 
                                                         
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  k
                                                               
                                                            
                                                            ;
                                                            k
                                                            =
                                                            1
                                                            ,
                                                            …
                                                            ,
                                                            
                                                               
                                                                  k
                                                               
                                                               
                                                                  max
                                                               
                                                            
                                                         
                                                      ; set t
                                                      =0, and obtain an initial solution X.
                                                
                                                
                                                   
                                                      Step 2:
                                                   While t
                                                      <
                                                      t
                                                      
                                                         max
                                                       do
                                                         
                                                            
                                                               Step 2a:
                                                            Set k
                                                               =1
                                                         
                                                         
                                                            
                                                               Step 2b:
                                                            Repeat until k
                                                               =
                                                               k
                                                               
                                                                  max
                                                               
                                                               
                                                                  
                                                                     (i)
                                                                     Generate a random 
                                                                           
                                                                              
                                                                                 
                                                                                    X
                                                                                 
                                                                                 
                                                                                    ′
                                                                                 
                                                                              
                                                                              ∈
                                                                              
                                                                                 
                                                                                    N
                                                                                 
                                                                                 
                                                                                    k
                                                                                 
                                                                              
                                                                              (
                                                                              X
                                                                              )
                                                                           
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        (Shaking)
                                                                     
                                                                  
                                                                  
                                                                     (ii)
                                                                     Apply a local search from X′ to determine X
                                                                        ″
                                                                        
                                                                        
                                                                        
                                                                        (Local search)
                                                                     
                                                                  
                                                                  
                                                                     (iii)
                                                                     If the solution is improved, move there (X
                                                                        ←
                                                                        X
                                                                        ″) and go to Step 2a, else set k
                                                                        =
                                                                        k
                                                                        +1.
                                                                        
                                                                        
                                                                        
                                                                        (Change neighbourhood)
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               Step 2c:
                                                            Set t
                                                               =
                                                               CpuTime ()
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The distance function we use to define the different neighbourhood structures counts the number of facilities that are not in the same locations as in the incumbent X (e.g., Brimberg et al., 2000). Thus, a shake to neighbourhood 
                        
                           
                              
                                 N
                              
                              
                                 k
                              
                           
                        
                      involves randomly re-locating k facilities to unoccupied fixed points.

In the reformulation local search (RLS), we simply add new Weber points to the set of potential sites for the discrete problem each time the continuous phase reaches a local minimum. Also, after 10 unsuccessful big iterations (full cycles of the VNS), we start again from the incumbent solution while deleting all added Weber points; that is, we return to the original set S
                        ={A
                        
                           j
                        , j
                        =1,…,
                        n}. In this way the discrete problem is kept at a manageable size.

Two algorithms are compared. In the first, termed VNS1, we implement the successful variant of VNS given in Brimberg et al. (2000) which relocates facilities to unoccupied fixed points in the shaking operation as discussed above (this refers to VNS3 in that paper). The second method, VNS2, uses our new RLS as the local search. Note that the discrete phase of RLS uses a Teitz and Bart vertex swap (Teitz & Bart, 1968) with Whitaker’s accelerated implementation (Whitaker, 1983) starting from the solution just obtained in the continuous phase.

Both versions of VNS are tested on the same 4 data sets described in the previous section. For both implementations of VNS, the following parameter values are used: t
                        
                           max
                        
                        =300s, k
                        
                           max
                        
                        =
                        p, and as noted above, we set the maximum number of unsuccessful full cycles to 10 for re-initializing S.

As the best-known results for the small data set (n
                        =50) are all optimal and our RLS based approach found all those solutions, we do not reproduce them here. The results for the other data sets (n
                        =287, 654 and 1060) are summarized in Tables 5–7
                        
                        
                        . We also highlight the best percentage deviation in bold when it shows an improvement on the best known solution from Brimberg et al. (2000). On average VNS2 outperforms VNS1 slightly. For the case of n
                        =287, VNS2 proved to be slightly better than VNS1 when compared against the optimal solutions. Average deviations of 0.025% and 0.011% with the worst deviations of 0.24% and 0.05% are recorded for VNS1 and VNS2, respectively. For the 654-customer instances, 22 and 21 best solutions are found including 4 new best solutions for VNS1 and VNS2 respectively. Their respective average deviations are 0.024% and 0.028% above the best known, while the largest improvements are −0.27% and −0.22%, and worst deviations are 0.38% and 0.35% respectively. For the largest instances (n
                        =1060) 28 and 29 best solutions are identified including 20 and 24 new ones for VNS1 and VNS2 respectively. Besides this, their average deviation shows improvement of −0.093% and −0.107% and the worst deviation is found to be negligible at 0.04% and 0.02% respectively. Again we see that VNS2 performs slightly better than VNS1. The average computing times when the best solution is found are similar for n
                        =287 for both approaches but VNS2 is faster as n increases requiring an approximate CPU time of 2/3 of that of VNS1 in the largest data set (n
                        =1060).

@&#DISCUSSION AND CONCLUSION@&#

A new local search for continuous location problems that systematically oscillates between the continuous space and a discretised space is proposed. In each iteration new potential sites obtained in the continuous phase are added to the discrete space in order to improve the quality of the discrete approximation. We implemented this idea on the well known multi-source Weber problem with encouraging results. In brief, once the new Weber locations are found at a local minimum in the continuous space, these are added to the set of potential sites in the discrete space. If an improved solution is found in the discrete space, it then serves as an initial solution in the continuous space and a new iteration begins. This process is repeated until there is no change in the solution in either space. We also incorporated this local search within VNS and this proved to be very competitive when tested on the classical data sets from the literature.

The proposed methodology can be adapted and applied to many other location models. For example, consider the continuous p-centre problem and the relation to its well-known discrete vertex p-centre problem, or the simple plant location problem on the plane and its relation to its discrete counterpart. Another variant related to discrete location problems includes the capacitated case on the plane. Indeed, the idea of exploring the relation between discrete and continuous location problems presents in our view a rich new area of research.

@&#ACKNOWLEDGEMENT@&#

The authors thank two anonymous referees for their interesting suggestions that improved the content as well as the presentation of the paper.

@&#REFERENCES@&#

