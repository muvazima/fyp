@&#MAIN-TITLE@&#A metamodel and taxonomy to facilitate context-aware service adaptation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A context metamodel to classify different types of contexts has been provided.


                        
                        
                           
                           MoDAS was improved through an XML document that facilitates context code-generation.


                        
                        
                           
                           MoDAS provides model-driven trustworthy and well-structured code.


                        
                        
                           
                           The aspect-oriented implementation facilitates system evolution and maintenance.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Metamodel

Context-awareness

Web services

Model-driven development

@&#ABSTRACT@&#


               
               
                  Increasingly, companies are adopting service-oriented architectures to respond to rapid changes in the market. Even though there are excellent tools and frameworks for service-oriented architecture adoption and service development, the latest adaptation to context has not been properly dealt with yet. Current approaches are mostly focused on solving context-aware issues for web applications only, focusing mainly on client-side adaptation, and there is a clear lack of context taxonomies which facilitate context-aware applications. In our previous work we proposed Model-Driven Adaptable Services (MoDAS): a methodology and tool for the development of context-aware services. In this paper, we propose two key improvements on MoDAS: firstly, leveraging the proposal’s abstraction level, facilitating the use of a larger collection of contexts through the definition of an extensible context taxonomy by means of a metamodel; secondly, providing additional opportunities for code generation.
               
            

@&#INTRODUCTION@&#

Web services provide us with loosely coupled, platform-independent communication among distributed systems. This is thanks to their use of standard protocols for interface description (Web Service Description Language, WSDL) and message exchange (Simple Object Access Protocol, SOAP), among others. In this regard, web services have succeeded in the software community, providing software units that are reusable in heterogeneous software systems, and therefore easier maintenance and evolution of the above mentioned systems. In this scope, modern enterprises are increasingly adopting Service-Oriented Architecture (SOA) to respond to rapid changes in the market. Even though there are excellent tools and frameworks for SOA adoption and service development, the latest adaptation to context has not been properly dealt with so far, as explained in the following paragraphs. In this field, context can be defined as any information that can be used to characterize the situation of an entity [1,2]. According to Dey’s definition “A system is context-aware if it uses context to provide relevant information and/or services to the user, where relevancy depends on the user’s task” [1,2], where they also explain that many researchers define context-aware applications as “applications that dynamically change or adapt their behaviour based on the context of the application and the user”. To simplify, we define context-awareness in one sentence: the ability of a system to dynamically adapt its response depending on the context. In this regard, context-aware computing has hugely increased in popularity and is in great demand, especially by mobile users. The large number of devices and their continuous use clearly illustrate the importance of access, not only to desktop services but also to mobile ones. It is important to mention that, even though context-awareness seems to be strongly associated with mobile applications, many users are starting to demand desktop context-aware applications. In addition, some users have the same applications installed on their mobile phone and on their computer (linked through their private account), and they may use the application on their desktop computer more comfortably, when they have the chance. Thus, both markets—desktop and mobile applications—are relevant when talking about context-awareness.

In any case, for mobile and desktop users, this is an emerging field for software development in which many members of the industry and scientific community are starting to provide software pieces and proposals. However, we are going to highlight three relevant issues with the existing proposals in SOA; first and second were already dealt with in our previous proposals, as will be later explained; in this paper, we will particularly focus on the third one. Firstly, these approaches focus mostly on solving context-aware issues for rich-client web applications only, such as [3], leaving a gap, as previously mentioned, for web service adaptation to context. Secondly, most solutions focus on adaptation on the client-side [4]. This means further computation and resources are used, and larger bandwidths are required, which could be a hindrance for some mobile users. It might be the case that the mobile device does not have enough resources for context-adaptation or that we are simply slowing down the process by doing it on the client, rather than the server side, where resources are expected to be much higher in any case. Thirdly, there is a clear lack of context taxonomies or classifications which might help to deal with context definition in order to facilitate their subsequent system adaptation [5]. Regarding the first issue, web services can be invoked from any type of application, not only web-based ones, and are popular for their use rom both desktop and mobile applications. This is why we have provided a solution centred not only around web applications but also on web service-based applications in general. Concerning the second issue, in our previous work we focused on making the adaptation on the service side, freeing the client from this computation load, sometimes significantly reducing the bandwidth consumed and, last but not least, improving user experience and satisfaction with the services used. Finally, with regards to the third issue, the main aim of this paper will be to solve the third mentioned issue: facilitating context classification for subsequent adaptation and including it in MoDAS methodology.

Ntanos et al. highlight the still pending challenge of developing a taxonomy for the representation of context types in the scope of context-aware computing [6]. As previously mentioned, in this paper we focus on providing this taxonomy through metamodelling techniques and integrating their definition and implementation into our already developed methodology and tool for model-driven development of context-aware web services. In the past, we used model-driven development and aspect-oriented techniques in order to adapt web service response to mobile devices [7], and for additional context types [8]. Not only did we provide a methodology for developing context-aware services, but also a tool which facilitates the methodology application in conjunction with other widely used existing tools for UML (Unified Modelling Language)-based software modelling and Java-based web service development.
                        i
                        The plugin and help documents are available for public download at https://neptuno.uca.es/redmine/attachments/download/318/MoDAS.zip and https://neptuno.uca.es/redmine/attachments/download/323/MoDAS_guides.zip, respectively.
                     
                     
                        i
                      Currently, MoDAS (Model-Driven Adaptable Services) methodology [8] has been extended in this paper with two main purposes; the first purpose is to provide a taxonomy for contexts and define a metamodel in order to facilitate context-modelling, according to this taxonomy; secondly, to leverage the proposal abstraction level, enabling the user to utilize a larger collection of contexts in their applications. As a result, we have also improved code generation for context adaptation, providing different opportunities for code generation.

In order to assess the proposal, two different methods have been used, namely observational and descriptive evaluation, according to Hevner’s seminal work on information systems research [9]. The observational evaluation has been developed through the implementation and observation of the case study; the descriptive evaluation through the scenario implemented in the case study, and the comparison of the proposal with related work. In our previous evaluation of MoDAS we followed an analytical evaluation of the generated code, the code-generation process and performance of the aspect-oriented implementation. The results can be found at [8] and it would be redundant to repeat the experiments in this paper.

The remainder of the paper is organized as follows: Section 2 gives background information on the technologies approached in this paper, as well as on MoDAS first version; Section 3 provides related work and state-of-the-art research on the scope of the presented approach; Section 4 explains how MoDAS methodology has been improved; Section 5 explains the proposed context metamodel; Section 6 explains further details regarding the metamodel adoption in the methodology; Section 7 illustrates the proposal with a case study; discussion is included in Section 8, and conclusions are presented in Section 9.

@&#BACKGROUND@&#

In this section, we introduce the main technologies used throughout the paper, such as web services, model-driven development and aspect-oriented programming, as well as a basic introduction to MoDAS first version.

Web services bring us one step further on the long way that object-oriented technologies and distributed platforms have developed, having become an effective way to integrate third-party approaches on the Web, and collaborating in the client–server architecture replacement by peer-to-peer distributed architectures. They are often seen as applications accessible to other applications over the Web [10]. Such applications will be accessible via HTTP or SMTP, which facilitate message exchange. In addition, services mainly use SOAP as the message format for communication. This message is composed of a mandatory body, where invocation parameters are included, and one or more optional headers.

Model-Driven Development (MDD) aims to promote the role of models, allowing us to focus on the system’s conceptual design, delaying the decision of which implementation technology to use for a later step. Models may be used at multiple phases of development, from the initial system specification to testing. Each model will address one concern, regardless of the remaining issues involved in the system’s development, thus allowing the separation of the final implementation technology from the business logic adopted by the system. Model-to-code transformations permit the system’s automated development from models.

Following OMG Model-Driven Architecture (MDA) proposal, we might consider three main model categories: Platform-Independent Models (PIM) representing the system without coupling it to any specific platform or language, Platform-Specific Models (PSM) which express the system based on a specific platform, technology and programming languages, and finally, Code Layer provides the final application as code. Transformation rules may also be created in order to transform the system PIM into PSMs and PSMs into code automatically [11].

Aspect-Oriented Programming (AOP) arises to solve problems detected in Object-Oriented Programming (OOP). OOP is supposed to permit the encapsulation and modularity of related data and methods which address a common goal. However, we may find it impossible to model several concerns into a unique and structured decomposition of units [12]. As a result of these cross-cutting concerns, code is scattered and tangled all over our application. AOP allows us to modularize crosscutting concerns by encapsulating them into meaningful independent units called Aspects. Aspects are units of encapsulation which incorporate pointcuts and advices. Pointcuts are the specific points in the program’s execution where we want to inject new code, that is, where we want to alter the application’s behaviour. The advice identifies the new code to be injected into the named pointcuts, thus reflecting the new desired behaviour in the application. Afterwards, a method to weave the aspect code with the original one is applied [12].

MoDAS [8] is a development methodology and a tool which provides a model-driven process that can be used in conjunction with other tools in order to implement context-aware adaptable services. A model-driven approach was selected due to the facilities given to the developer: MDD generally provides us with faster and error-free development by generating code rather than handwriting each file, and having the system well structured and modelled since early stages of development. In this section, we will briefly explain the fundamentals.

Our proposed methodology is a model-driven approach, following MDA model categories explained in Section 2.2, for context-aware web services which starts at the services’ design phase and consists of three main steps:
                           
                              •
                              Firstly, we will design an initial model (a UML class diagram) for the system.

Secondly, several transformations will follow, in order to refine the initial model. MoDAS is built so that no refinement is needed to generate a deployable skeleton version of the services in the class diagram and their adaptation. However, we allow the developer to refine them as much as he wants.

Finally, when no more refinement is required, code for context-aware web services will be generated. The generated code will be aspect-oriented, allowing us to intercept the invocation to services and adapt their answers based on current context in a non-intrusive way.

MoDAS is able to automatically adapt the web services designed by developers to the following types of contexts, which require different procedures to be followed in the model-driven process: reduction contexts (contexts in which the information to be sent has to be reduced; for instance, device adaptation), transformation contexts (contexts in which the information has to be transformed; for instance, currency adaptation), filter contexts (contexts in which the information has to be filtered depending on several factors; for instance, location adaptation). The adaptation to each context implies transformations in the initial UML class diagram, as well as generation of context-aware code. Stereotypes are used in the diagram in order to show the adaptations to be performed.

The tool has been developed for Eclipse IDE and it allows us to automate the adaptation to context for those web services which are represented in a UML class diagram. The tool’s functions are:
                           
                              •
                              
                                 Stereotyping the platform-independent model. The developers have to design a UML class diagram, with web services and complex types represented in it. In order to indicate the adaptations to be performed, they have to stereotype the UML diagram. In this regard, MoDAS provides the profiles needed for the supplied adaptations.


                                 Generating the platform-specific model. It is possible to automatically obtain the PSM from the initial PIM. The advantage of generating this diagram is that the developer may make changes to it before code generation. Another benefit is that the developer has a graphical view of the code to be generated.


                                 Generating context-aware code. The main aim of MoDAS is the automatic generation of context-aware code from a stereotyped UML class diagram.


                                 Generating a UML class diagram from a WSDL. If a developer already has a WSDL file with the description of the web services to be adapted, this file can be transformed automatically into a UML class diagram using MoDAS or any other available tool.

Let us clarify that MoDAS generates Java and AspectJ code. Since it is a model-driven approach, it could be extended for further programming languages, but the current version has only be built for Java (and AspectJ).

@&#RELATED WORK@&#

In computing, there are many definitions of context given by authors. Dey [1] defines context as “any information that can be used to characterize the situation of an entity. An entity is a person, place, or object that is considered relevant to the interaction between a user and an application, including the user and applications themselves”. Depending on the context of an entity, a system can adapt its response dynamically. This is the basis of context-aware web services, using context to provide relevant information and/or services to the user, where relevance depends on the user’s task [2].

In this respect, there are multiple approaches for context adaptation in different computer science domains. Among the existing techniques, we can mention the following ones [13]:
                        
                           •
                           
                              Middleware and platform solutions: this perspective provides a layer-based architecture for context adaptation systems so that low level details are completely transparent for the developer.


                              Ontology-based solutions: these use semantic web principles in order to produce ontologies in order to describe contextual information and their associations, as well as providing the means for context reasoning and inference.


                              Rule-based reasoning: a system based on rules, which is a combination of rules and activation conditions for them. A knowledge base is provided in order to drive a behaviour activation based on rules and activation patterns.


                              Code level approaches: these normally extend programming languages’ syntax, or provide external additional mechanisms.


                              Model-driven approaches: transformations between models are done, as well as code generation. We could also include research related to product line engineering and feature models in this category; the boundaries between them and model-driven development is quite unclear; however the most relevant works related to context-awareness we found were closer to model-driven approaches, rather than to product line engineering.


                              Message interception: service input and output messages are intercepted and modified without disturbing service behaviour and functionality. It is also possible to use this technique by intercepting and modifying the application objects rather than the messages.

These techniques are not exclusive and a developer could opt for combining several of them in order to deal with the context. In the following paragraphs some outstanding approaches related to the most relevant techniques are presented.

Some prominent frameworks and middlewares can be mentioned: the ESCAPE framework and the inContext project deserve a special mention. Both are proposed by Truong et al., in [14,15], respectively, and deal with a service-based context-management system for team collaboration. Even though the concepts provided for exchanging and using context information in a service-based scope are of high quality, the narrow scope of their main focus (collaboration teams) weaken the value of this proposal in the scope of this paper. Secondly, two approaches closely related to mobile services are highlighted. On the one hand, Anyserver platform, proposed by Han et al. [16], gives support to context in mobile services. It uses several types of information, related mainly to net status and device capabilities. On the other hand, De Almeida et al. propose Omnipresent [17], a system where several services are supplied to provide information based on localization, such as maps or routes. The paper from Fuentes et al. [18] depict a middleware for building and testing executable aspect-oriented models, with contexts modelled as aspects. This proposal does not take into account how the context is obtained or how context-awareness is implemented, it merely deals with context modelling, and only a specific implementation is proposed for a particular example Some of these works are specific for a type of context; others are not adaptable to web services; therefore it is difficult to apply these approaches in a wider range of applications.

Controlled vocabularies, shared ontologies and other metadata formalisms, designed initially with the aim of improving information systems’ interoperability, have been used to support context modelling and reasoning. Early ontology-based context modelling approaches only considered a limited set of properties. An example is the SOCAM RMI-based middleware [19] which uses Web Ontology Language (OWL) to model persons, locations, activities and computational devices. Shared vocabularies and application-specific schema extensions are used in webinos [6] to distribute contextual information. The shared context model in webinos covers a broad range of properties (e.g. device capabilities, user properties and environmental conditions) that are predetermined, in contrast to the improved MoDAS solution. We can also find some works for context taxonomy, the one from Kühn et al. is of special interest, where they propose a context taxonomy for supporting public system design [20]. The taxonomy is quite thorough and under our point of view also applicable to other domains; the main problem is that it is only contemplated for design purposes and no automatic implementation can be derived from it; solving this issue is why MoDAS proposes a taxonomy which bears in mind development methodology.

Some code level approaches can also be mentioned. For instance, context-oriented programming (COP) is the method proposed by Keays and Rakotonirainy [21] which incorporates context as a first-class construct of a programming language. The main execution skeleton code is completed by dynamically selecting portions of context-aware code. In general, the main drawbacks of all code-related approaches are their lack of abstraction and the developer’s difficulty to acquire and integrate them into the system’s modelling phase.

Finally, we highlight some model-driven and message interception techniques. First of all, Sheng and Benatallah [22] propose ContextUML: a UML-based modelling language for the model-driven development of context-aware web services. ContextUML is later modified, as presented in Prezerakos and Tselikas [23], where context model and service model design are decoupled, but still with some dependences between them. The main drawback of this proposal is that they make the adaptation on the client side. Kapitsaki et al.’s approach [24] also deserves a special mention. They have developed an Axis2 handler whose purpose is to intercept SOAP messages, retrieve the context information and return the message adapted to context. The message modification is carried out through a number of plugins. The main handicap here is that they assume that the service client will be a web application. Besides, they provide three types of adaptation: parameter injection, operation selection and response manipulation for sorting, converting, etc. Since we are providing six types of adaptation (plus the custom one), more code can be automatically generated for adaptation to context in our approach compared to Kapitsaki’s. The work from Hoyos et al. presents a domain-specific language (DSL) for context modelling [25]; with their DSL they can provide two separate models: the application model and the context one. The main advantage is that they propose the use of generic context models that therefore can be reused for different applications; the main drawback compared to our proposal is that they do not generate the adaptation-to-context code.

The methodology proposed in this paper is based on our previous work (described in the paper referenced in footnote i) MoDAS: a methodology and tool for Model-Driven Adaptable Services, which was introduced in Section 2.4. The new methodology aims to solve some problems which are described later in this section.

As stated in Section 2.4, the previously defined methodology provides the developers with a variety of contexts to which a web service can be adapted, specifically: reduction contexts, transformation contexts and filter contexts. We encountered two problems in this approach:
                        
                           •
                           
                              The number of contexts to which a developer is able to adapt web services is limited. If they want to adapt web services to other contexts not included in MoDAS, they have to create new transformations to generate extra code.


                              The adaptation type for each context is predefined. For example, in location context the information is filtered by region, but the customer may require all the information to be returned, starting with information relevant to his particular region. In this case, the developer also has to create new transformations to generate extra code.

The origin of these problems is that both context and adaptation types are statically defined inside MoDAS, as well as the current lack of taxonomies for context. Considering these issues, we propose abstracting the definition of context types and adaptation types to a configuration file in XML (Extensible Markup Language) format, through the use of a proposed context taxonomy which has been defined by means of a metamodel. The metamodel behind this XML document will be explained in Section 5.

Using the new approach, a developer will be able to define the main details of their own contexts and adaptations in a XML document, and MoDAS will take this information in order to generate context-aware code. Actually, in the developer’s eyes, this will be the only change between the previous version and the new one, since the stereotypes in the model will still be necessary, and what we are doing is providing extra information through the XML file. Please bear in mind that that the developer will not have to write the xml, but fill in the required fields in a xml editor form, in which links to the stereotypes are automatically included in advance.

The contexts defined in the previous methodology can be classified as follows:
                        
                           •
                           Contexts in which the information to be sent has to be reduced (i.e., device context).

Contexts in which the information has to be filtered depending on several factors (i.e., location context).

Contexts in which the information has to be converted (i.e., currency and language contexts).

With the new methodology, the developer will define the contexts in the XML configuration file, thus a classification is not necessary. Adaptation types become more relevant, in addition to the contexts themselves; since they allow developers to indicate which adaptations should be applied for each web service. Based on relevant differences we found in the way they have to be dealt with, we defined the following adaptation types in the context taxonomy:
                        
                           •
                           
                              Reduce. The information to be returned has to be reduced.


                              Filter. The information to be returned has to be filtered based on a condition.


                              Convert. The information to be returned has to be converted.


                              Sort. The information to be returned has to be sorted based on a sort order.


                              Enrich. Some input parameter is completed thanks to contextual information.


                              Select. A different action will be performed instead of the service invocation, depending on contextual information and conditions referred to in this information. If there is no condition evaluated as true, the initial invocation will be performed.


                              Custom. If no other adaptation type is suitable for the developer’s purpose, they can choose this one and implement their own adaptation in the generated code.

Context-aware code is encapsulated in separate aspect-oriented modules. This separation will allow us to maintain the main service code completely decoupled from context-related code, therefore facilitating context maintenance and evolution according to web services philosophy. The code below shows the skeleton of the aspect code generated by MoDAS. This skeleton is common to all contexts; specific context-aware code will be inserted in lines (4) and/or (6), replacing current comments. This code will depend on the stereotypes applied to the operation in the UML class.
                        
                           
                              
                              
                                 
                                    
                                       (1) public aspect Adapting_Operation1 {
                                    
                                 
                                 
                                    
                                       (2)pointcut PC_Operation1 (String parameter):
                                    
                                 
                                 
                                    
                                       execution (∗ Class1.Operation1(String)) && args (parameter);
                                    
                                 
                                 
                                    
                                       (3)Info around (Sting parameter): PC_Operation1 (parameter) {
                                    
                                 
                                 
                                    
                                       (4) // context-aware code before invocation
                                    
                                 
                                 
                                    
                                       (5) Info tmp = proceed(parameter);
                                    
                                 
                                 
                                    
                                       (6) // context-aware code after invocation
                                    
                                 
                                 
                                    
                                       (7)return tmp;}}
                                    
                                 
                              
                           
                        
                     
                  

Adaptation code follows a pattern; firstly, the necessary contextual information is requested and stored in variables; and secondly, the particular adaptation code is executed, using the previous variables. Sometimes a variable named tmp will be used in the code; this is the return variable defined in line (5) in the aspect skeleton.

We will explain more about adaptation types in the following sections: the context metamodel proposed will be described in Section 5, the corresponding XML configuration file in Section 6 and a case study with the transformations and code generation in Section 7.

With the proposed improvement, the number of adaptations that may be performed for web services, represented in a UML class diagram, has been considerably increased. Moreover, generated code will be richer and more abundant thanks to the information provided by the developer through the XML document. Finally, the proposal increases its flexibility for context and adaptation definition, by improving [the] system evolution.

In this section, we will describe the metamodel defined for the inclusion of information in the XML configuration file, according to the taxonomy context types proposed; this metamodel is one of the main contributions of this paper.

As shown in Fig. 1
                     , the root class is named ContextAwareness and it will be composed of a set of context types and adaptation type definitions. In order to make the explanation easier, we will talk about the information that characterizes context types and adaptation types separately in Sections 5.1 and 5.2, respectively.


                        Context is the class that represents context types in the metamodel. A context type has an identifier (id attribute) and optionally a name (name attribute). The contextual information that may be obtained from a certain context is represented by class ContextualInfo. Contextual information also has an identifier and an optional name. Moreover, a type can be indicated, which is the primitive data type used for representing this information. There is additional information, such as Parameter and ObtainingMethod classes, that the developer may provide so as to generate code, although these are optional.

When we need external data to obtain contextual information, the class Parameter is used. A parameter has a name and a type. Also, if more than one parameter is needed, it is important to sort them using the position attribute.

The developer can describe the methods that should be used to obtain the contextual information. The base class ObtainingMethod represents this information. If more than one method is needed, the developer has to sort them using the position attribute. By default, there are two methods in the methodology by which code will be generated:
                           
                              •
                              
                                 SOAP header. Sometimes there is some information that cannot be deduced from context and the client must send it to the service. An alternative way to do it is by using an optional tag in the invocation SOAP message header, where required information can be pointed out by the client. The developer has to indicate the tag name.


                                 Web service. An external web service provides the contextual information required. The developer has to indicate the URL of the external web service and the operation to be invoked.

The class that represents adaptation types in the metamodel is Adaptation. An adaptation type has an identifier (id attribute) and, optionally, a name (name attribute). We have defined different adaptation types. There is a class that represents each one, and these classes are subclasses of the Adaptation one. The Info class supplies required information to an adaptation related to contextual information; the contextualInfoId attribute must match an id attribute of some defined contextual information, and a position attribute is used to sort all the contextual information in the adaptation. This order is needed because some contextual information might be a parameter for another. In addition, this position number will be used in some special tokens that will be explained in Section 6.2.

In the following lines, we will explain the information that should be provided by the developer to generate code for the adaptation types proposed in Section 4. We must bear in mind that by code, we are referring to Java code which may contain some special tokens that will be explained in Section 6.2.
                           
                              •
                              Convert adaptation. The code to be executed in the conversion has to be provided.

Filter adaptation. The condition to be used when filtering should be provided.

Sort adaptation. A developer can express the order to be applied in the adaptation explicitly or implicitly. Doing so in an explicit way, they have to give the code for equal-to, greater-than and less-than cases so as to define the order in which two objects should be compared. Alternatively, we have implemented two predefined comparators, that we have named implicit comparators: one of them, preferencesFirstComparator, arranges the elements according to a specified preference (it is possible to specify a list of preferences); the other, inOrderComparator, arranges the elements, which ought to be primitive data types, in the order expected according to their type, e.g. numerical order for numbers or alphabetical order for strings.

Reduce adaptation. A condition should be supplied to decide whether or not reduction has to be performed.

Enrich adaptation. The developer has to indicate which input parameter will be enriched. The position number in the list of input parameters is needed.

Select adaptation. Condition-action pairs should be provided. The action whose condition is verified first will be the one to be performed instead of the web service invocation. If no condition is verified, the web service is invoked normally.

Custom adaptation. An adaptation can be performed before, after or instead of the web service invocation. This is a custom adaptation, thus, the developer has to indicate when it should be performed.

In this section, we will explain the XML code the developer has to use to configure the context and adaptation types’ definitions. Let it be noted that the named XML code was not used in the previous MoDAS version, and its definition is another contribution of this paper. The XML file is only used in the development process; from it all necessary code at running stage is generated and compiled with the service code.

The developer will be able to define their own context types. An example of the XML code to be specified ifor the definition of a new context is shown below:
                           
                              
                                 
                                 
                                    
                                       
                                          (1) <context id=“contextId” name=“contextName”>
                                       
                                    
                                    
                                       
                                          (2)<contextualInfo id=“infoId” name=“infoName” type=“String”>
                                       
                                    
                                    
                                       
                                          (3) <parameter name=“paramName” type=“String”/>
                                       
                                    
                                    
                                       
                                          (4) <SOAPHeader tagName=“TAGNAME”/>
                                       
                                    
                                    
                                       
                                          (5)</contextualInfo>
                                       
                                    
                                    
                                       
                                          (6) </context>
                                       
                                    
                                 
                              
                           
                        
                     

In line (1) an identifier and name are given to the new context. This context provides the contextual information defined in lines (2–5). An identifier, name and type are given to describe the contextual information. Some extra information might be necessary to obtain the contextual information; in this case, a line such as (3) is used to specify the name and type of parameter. The fact that there are several ways to obtain contextual information must be taken into account. In this example the selected method is the SOAP header. In line (4), this obtaining method is indicated and a tag name is given.

No specifications are needed in the PIM, rather than the ones explained in the previous work [8], to generate the Java classes related to contexts defined in the XML configuration file. Thanks to the XML code, a transformation will generate the class that represents the new context, its name being contextName. It has a method named infoName that will provide the contextual information given an input parameter. Its return type is String type, and the name and type of the input parameter are paramName and String, respectively. The method code will depend on the specified obtaining method, and in this case, the code to obtain contextual information from the SOAP header will be generated, as well as the extra classes and methods needed for this purpose.

The developer has to define which adaptations will be applied in the PIM to generate context-aware code. The adaptation types XML definitions have an attribute named id, which is the identifier of the adaptation. This identifier must match the name of the stereotype used in the PIM to mark the method for which this context adaptation is required.

In the XML configuration file, there are some nodes for the adaptation type definition where Java code is expected. Some attributes are defined in the PIM or at the code-generation phase. For this purpose we have created certain tokens to refer to those attributes from Java code nodes in the XML configuration file. The tokens will be translated to their correct variable name at the code-generation phase. There are three token types, explained below; some examples are given in Table 1
                        :
                           
                              •
                              
                                 Tokens that refer to some contextual information. These tokens are represented by a dollar sign followed by a number. The contextual information needed in an adaptation type definition is specified by info nodes; the number indicated in the position attribute declared in those nodes is the one which should be used after the dollar sign.


                                 Tokens that refer to a UML attribute. These tokens are represented by a name surrounded by two dollar signs. This name must match a stereotype name applied to an attribute from a class that represents a complex type in the PIM.


                                 Tokens that refer to the input parameters of the web service. These tokens are represented by a double dollar sign. These tokens match all input parameters of the web service.

The PIM has to be stereotyped in order to indicate the adaptations to be performed for each web service. The method that represents a web service has to be stereotyped. The stereotype name must be the same as the name attribute defined in the XML file for the adaptation or id attribute if no name has been defined. Also, the attributes in the complex types that are referenced from the XML code have to be stereotyped. The stereotype name must be the same as the name used in the token; for instance, if the token in the code is $varname$, the stereotype must be «varname». Some complex types involved in the adaptations may have to be stereotyped. This will be explained in Section 7.2, when each adaptation is described.

As we explained in Section 5.2, we have designed several adaptation type examples that developers may use to define their own adaptations, depending on their application necessities. A description of those adaptation types and examples of the XML code needed for their usage is as follows:
                           
                              •
                              
                                 Convert adaptation. This is the adaptation to be used when the information returned from the web service has to be transformed into another one. The code to perform the transformation has to be provided. An example can be seen below in lines (4–9).


                                 Filter adaptation. If we want to filter the information retrieved from a web service, we must define a filter adaptation in the XML file; an example is shown in the XML code below. A condition must be supplied as shown in line (3). This condition is our filter, so those objects that do not verify the condition will be removed.


                                 Sort adaptation. If we want to sort the response provided by a web service, the sort adaptation is used. As we explained in Section 5.2, there are three types of sort; in the example below an implicit comparator is used: preferencesFirstComparator. This comparator sorts the elements, giving the first position to a specific preference. It is also necessary to indicate which value we want to compare, in order to sort the elements. This is done in the toCompare node (line 4). In the example the value to be compared with user preference is the attribute genre, and the elements whose genre is equal to the user’s preference will be positioned first.


                                 Reduce adaptation. Reduce adaptation is used when we want to return a variable amount of data in the web service response, depending on the context. In the XML code example below, the reduction depends on the invocation device. A condition is provided, which will be the one that decides if the reduction has to be performed.


                                 Enrich adaptation. The purpose of the enrich adaptation is to provide contextual information to a web service’s optional input parameters since such information could improve the response. In the XML example below, line (3) shows that the first parameter of a web service will be enriched with the region where the invocation user is; the latest information is indicated in line (2).


                                 Select adaptation. Select adaptation is used when we want to choose one out of several actions rather than the web service invocation. The action performed will be the one for which its condition is verified first (conditions are checked in a particular order). When no condition is verified, the web service is invoked normally. An example of XML code of this type of adaptation is shown below. Each case node has a position attribute that specifies the order to be used for checking conditions, and also has a condition and the action to be performed if this condition is verified.


                                 Custom adaptation. If none of the adaptations provided in the methodology suits the developer’s needs, they can use a custom adaptation. The when node allows the developer to specify in the XML configuration file when the custom adaptation will be performed (line 3): before, after or instead of the web service invocation. Please bear in mind that to keep it simple for developers we have only allowed the custom adaptation to: (1) retrieve information following any of the methods previously mentioned (such as SOAP header or external web service); (2) indicate when the adaptation is going to be performed (before, after or instead of the web service invocation). Then, the developer can include the particular code for his own adaptation in the aspect generated code.

A case study has been developed to illustrate and evaluate the presented methodology improvements, and the usefulness of the proposed context types in the metamodel. The greatest part of the XML file for the case study has been explained in the examples of each adaptation in Section 6, thus we only discuss the most relevant items here. Please note that the code and explanations in Section 6 can be used for any case study which requires this type of adaptation; we give concrete examples in this section for illustration purposes.

The case study PIM is shown in Fig. 2
                        , where we can see the web services to be adapted, and the complex types needed for their usage. There are two web services represented by classes stereotyped with «WebService». The explanation of the operations provided by them is as follows:
                           
                              •
                              
                                 Greeting. This web service has one operation:
                                    
                                       o
                                       
                                          Greet. This operation returns a string with a greeting. It has two adaptations:
                                             
                                                ▪
                                                Select adaptation: it will adapt the greeting to a language given.

Custom adaptation: it will include the name of the user in the greeting.


                                 Bookstore. The operations of this web service are:
                                    
                                       o
                                       
                                          getBookInfo. This operation has an input parameter of type String; an ISBN must be supplied. It returns information about the book with the provided ISBN (if it exists). It has two adaptations:
                                             
                                                ▪
                                                Convert adaptation: book pricing information will be context-aware.

Reduce adaptation: the amount of information about the book returned will depend on the type of invoking device.


                                          searchBook. This operation will search the books in which some of their information (title, author, publisher,…) corresponds with the keywords in the string input parameter.
                                             
                                                ▪
                                                Convert adaptation: book pricing information will be context-aware.

Filter adaptation: returned books will be filtered by user’s age; only books with an age rating less or equal to user age will be returned.

Sort adaptation: returned books will be ordered by user preferences; in particular, according to their preferred book genre.

Reduce adaptation: the amount of information about the books returned will depend on the type of invoking device.


                                          getStoresInfo. This operation returns information about existing bookshops. It has an optional input parameter with the region from where the books will be provided.
                                             
                                                ▪
                                                Enrich adaptation: if an input parameter is not provided (it has a null value), the user’s region will be obtained, and will be used to replace the null value. In this case the user’s location is obtained by localization of the IP address from which the invocation has been done and its inclusion in the SOAP header.

Once the context and adaptations types are defined in the XML configuration file, the PIM has to be stereotyped for the adaptations to be performed. In this section, we will explain how to stereotype the PIM for each adaptation type, as well as the transformations performed from PIM to PSM, and the generated code. Fig. 2 already includes the stereotypes in the PIM and Fig. 3
                         shows the automatically obtained PSM according to the adaptation explained in Section 6.2. The context-aware code is the one included in the aspect generated for each method’s adaptation. All the information for the PIM-to-PSM transformation is obtained from the elements stereotyped in the PIM and the information included in the XML file, as explained in the following paragraphs for each adaptation type. Please bear in mind that, as previously mentioned, MoDAS is built so that no refinement is needed to generate a deployable skeleton version of the services in the class diagram and their adaptation from the PIM; however, we give developers the possibility of refining them as much as they want in the generated PSM.

In convert adaptation, the operation to be adapted and the complex type related to the conversion have to be stereotyped, with the name given to the adaptation in the XML; «currencyConvert» in this case. A new method will be included during the PIM to PSM process in the complex type stereotyped. This method will contain the conversion code and will be called in the generated code, as shown below in line (5). The name of this method will be the same as the adaptation name.

In the converted adaptation code, which will be performed after the invocation of the web service, contextual information is stored firstly in variables (one of them has a parameter, baseCurrency), and the conversion method is called afterwards.
                           
                              
                                 
                                 
                                    
                                       
                                          (1) String currency=CurrencyContext.getCurrency();
                                       
                                    
                                    
                                       
                                          (2) // TODO: obtain baseCurrency
                                       
                                    
                                    
                                       
                                          (3) String baseCurrency=null;
                                       
                                    
                                    
                                       
                                          (4) double exchangeRate=CurrencyContext.getExchangeRate(baseCurrency);
                                       
                                    
                                    
                                       
                                          (5) tmp.currencyConvert(currency, exchangeRate);
                                       
                                    
                                 
                              
                           
                        
                     

In filter adaptation, the operation that represents the web service to be adapted and the complex type related to the filter have to be stereotyped with the adaptation name; «ageFilter» in this case. A new method will be included during the PIM to PSM process in the complex type stereotyped. This method will contain the condition code and will be invoked in the generated code, as shown below in line (4). The name of this method will be the same as the adaptation name.

In the filter adaptation code, performed after the invocation to the web service, the contextual information is stored in line (1), then a loop iterates over a collection. If an element does not verify the filter (line 4), it will be removed (line 5).
                           
                              
                                 
                                 
                                    
                                       
                                          (1) int age=ProfileContext.getAge();
                                       
                                    
                                    
                                       
                                          (2) for (Iterator<BookInfo_Base> iter=tmp.iterator(); iter.hasNext();) {
                                       
                                    
                                    
                                       
                                          (3)BookInfo_Base var=iter.next();
                                       
                                    
                                    
                                       
                                          (4)
                                             if(!var.ageFilter(age)) {
                                       
                                    
                                    
                                       
                                          (5)
                                             
                                             iter.remove();} }
                                       
                                    
                                 
                              
                           
                        
                     

In sort adaptation, the operation that represents the web service to be adapted and the complex type related to the comparison have to be stereotyped with the adaptation name, «genrePreferenceSort» in this case. A new method will be included during the PIM to PSM process in the complex type stereotyped. This method will contain the comparator code and will be invoked in the generated code, as you can see in line (5) below. The name of this method will be the same as the adaptation name.

The sort adaptation code is performed after the web service call. In this adaptation, contextual information is retrieved first (line 1). Afterwards a Java comparator is defined (lines 2–7). This comparator has to implement the compare method, and it returns a negative integer, zero, or a positive integer if the first argument is less than, equal to, or greater than the second. The Java programming language provides a method to sort a list using a comparator. This method is used in line (8) to sort the collection returned by the web service response, using the defined comparator.
                           
                              
                                 
                                 
                                    
                                       
                                          (1) final String genrePreference=ProfileContext.getGenrePreference();
                                       
                                    
                                    
                                       
                                          (2) Comparator<BookInfo_Base> genrePrefefenceSortComparator=new Comparator<BookInfo_Base>() {
                                       
                                    
                                    
                                       
                                          (3)@Override
                                       
                                    
                                    
                                       
                                          (4)
                                             public int compare(BookInfo_Base o1, BookInfo_Base o2) {
                                       
                                    
                                    
                                       
                                          (5)
                                             return o1.genrePreferenceSort(o2, genrePreference); } };
                                       
                                    
                                    
                                       
                                          (8) Collections.sort(tmp, genrePreferenceSortComparator);
                                       
                                    
                                 
                              
                           
                        
                     

In reduce adaptation, the method that represents the web service to be adapted has to be stereotyped with the adaptation name; «deviceTypeReduce» in this case. The complex type to be reduced depending on the context has to be stereotyped with that name too. Its attributes—whose value will be returned when the invocation device is a mobile one—are stereotyped with «cldc». Otherwise, all attributes will be returned. In the PIM to PSM process, the complex type to be reduced will be transformed into two classes: a base class containing the attributes returned to mobile invokers («cldc» stereotyped attributes); and another class that will extend it with the remaining attributes. In addition, the class that extends the base class will include a new method; convertToBase. This method will be used to transform an object of the extended class into one of the base class.

The generated code is shown below, and it will be performed after the invocation to the web service. In line (1), contextual information is retrieved; in this case it is the device type. If the condition from the XML code is verified (line 2), and if the information returned by the web service is an extended class object (line 3), the reduction will be performed using the convertToBase method (line 4), obtaining a base class object.
                           
                              
                                 
                                 
                                    
                                       
                                          (1) String deviceType=DeviceContext.getDeviceType();
                                       
                                    
                                    
                                       
                                          (2) if(deviceType.equals(“CLDC”)){
                                       
                                    
                                    
                                       
                                          (3)if(tmp instanceof BookInfo_Extended) {
                                       
                                    
                                    
                                       
                                          (4)
                                             tmp=((BookInfo_Extended)tmp).convertToBase(); } }
                                       
                                    
                                 
                              
                           
                        
                     

In the next adaptations the method that represents the web service to be adapted has to be stereotyped with the adaptation name. There are no changes in the PIM to PSM transformation of these adaptation types.

The code that will be generated for enrich adaptation in the aspect is shown below, and it will be performed before the web service invocation. The input parameter of the web service to be adapted is named location in this example. If the input parameter that is indicated in the parameter node in the XML file is equal to null (line 1), the contextual information sent in the web service invocation will be retrieved (line 2) and it will replace the null value of the parameter (line 3).
                           
                              
                                 
                                 
                                    
                                       
                                          (1) if(location==null) {
                                       
                                    
                                    
                                       
                                          (2)String region=LocationContext.getRegion();
                                       
                                    
                                    
                                       
                                          (3)location=region; }
                                       
                                    
                                 
                              
                           
                        
                     

The code generated for select adaptation is shown below. The contextual information is stored in a variable and later a concatenation of if-else sentences is performed with the conditions and actions from the XML file in the specified order. The last else is reserved to the invocation to the web service when previous conditions are not verified.
                           
                              
                                 
                                 
                                    
                                       
                                          (1) String language=ProfileContext.getLanguage();
                                       
                                    
                                    
                                       
                                          (2) if(language.equals(“en”)) {
                                       
                                    
                                    
                                       
                                          (3)tmp=“Hello”;
                                       
                                    
                                    
                                       
                                          (4) }else if(language.equals(“es”)) {
                                       
                                    
                                    
                                       
                                          (5)tmp=“Hola”;
                                       
                                    
                                    
                                       
                                          (6) } else if(language.equals(“fr”)) {
                                       
                                    
                                    
                                       
                                          (7) tmp=“Salut”;
                                       
                                    
                                    
                                       
                                          (8) }else if(language.equals(“de”)) {
                                       
                                    
                                    
                                       
                                          (9)tmp=“Hallo”;
                                       
                                    
                                    
                                       
                                          (10) }else if(language.equals(“it”)) {
                                       
                                    
                                    
                                       
                                          (11)tmp=“Ciao”;
                                       
                                    
                                    
                                       
                                          (12)}else {
                                       
                                    
                                    
                                       
                                          (13)tmp=proceed(); }
                                       
                                    
                                 
                              
                           
                        
                     

The code generated in the aspect for custom adaptation is shown below. Since it is a custom adaptation, the developer has to provide context-aware code. In the code generated for the example, the web service is invoked (line 1), after which the contextual information is stored in a variable (line 2), and finally, the code provided by the developer will be executed.
                           
                              
                                 
                                 
                                    
                                       
                                          (1) tmp=proceed();
                                       
                                    
                                    
                                       
                                          (2) String name=ProfileContext.getName();
                                       
                                    
                                    
                                       
                                          (3) // Custom context-aware code
                                       
                                    
                                 
                              
                           
                        
                     

@&#DISCUSSION@&#

MoDAS is a methodology which allows us to easily create Model-Driven Adaptable Services, where context plays a key role for adaptation. It uses model-driven development techniques to facilitate the system’s development from the initial modelling stages, as well as a final aspect-oriented implementation of context-related code, in order to maintain the main system implementation, completely decoupled from the context-adaptation code, and also to facilitate system evolution easily, by adding or removing contexts when necessary. The main drawback we detected in the first version of MoDAS was the limited set of contexts provided, and the low flexibility it provided with regards to the specific code generated for a particular context, mainly due to the lack of context taxonomies in the scope of context-aware applications.

This is why we considered it to be of extreme relevance to increase the level of abstraction for context definition, as well as making it more flexible concerning the generated code. In order to increase the level of abstraction, we reckoned it was key to provide a general context taxonomy, with different relevant context type definitions. Since we did not find any standard definition for this purpose in the scientific literature, we described our own one through the definition of a metamodel. This metamodel facilitates a further description of a larger number of contexts. It is important to mention that the taxonomy does not intend to include all context types, but it has been defined to be easily extendable and adaptable to system requirements. In this regard, the developer can include new contexts through the XML definition, and the MoDAs tool will generate the corresponding code for it, therefore facilitating the developer’s tasks and saving code-writing time.

To benefit from context classification and description, MoDAS methodology has been modified, including an XML document description during the definition of the initial system models, where we can include key aspects of the specific contexts, which will clarify the particular needs of a specific customer concerning every particular context. Besides, MoDAS has been improved with a better code generation mechanism: the code generated for each context is not so rigid now, but is more flexible according to specifications given in the XML document. In addition, improved MoDAS makes the definition of new contexts by the developer much easier, and also allows the generation of a larger variety of code, so the number of adaptations that may be performed to web services represented in a UML class diagram has been increased considerably. Moreover, the generated code will be richer thanks to the information provided by the developer through the XML document. These improvements can be observed in the scenario represented through the case study described in depth in Section 7.

In Table 2
                     , we have included a set of relevant features for context-awareness, and cross-referenced those which are accomplished by the most relevant related work mentioned in Section 3, so that we can fulfil a descriptive evaluation [9], by comparing MoDAS features with other mentioned as related work. References with ‘∼’ in one of the feature means that they provide such a feature in some cases or with some limitations. The evaluation features are based on Boehm’s seminal characterization of software quality [26]. In particular, we focus on understandability, portability and modifiability. Furthermore, Guttag [27] stated that in order to reduce the amount of complexity or detail that must be considered at any time, two common and effective approaches are abstraction and classification or decomposition. Consequently, the understandability feature is divided into abstraction and classification issues. Concerning the modifiability feature, it has been also decomposed further, since the advantages of enabling software programme modification and extension are not as convenient at compile time or at runtime. To sum up, according to the aims and scope of this paper, a more detailed specification of such features is provided in line with other fundamental works on software development [27].
                        
                           •
                           
                              Abstraction: the approach permits the definition of context properties with a certain degree of abstraction, ranging from model specification to abstract data types.


                              Classification: the approach includes a specific decomposition or classification scheme for the concept of context (ranging from concrete data types to taxonomies), which facilitates the software system’s definition and specification requirements.


                              Portability: the approach is portable in the sense that it is not specific to a particular domain of application, or limited to browser clients.


                              Compile-time modifiability: the proposal to model or define context properties is extensible to additional types of context at compile time.


                              Run-time modifiability: the proposal allows the inclusion of new context elements and their adaptation code at run-time.

In this comparison we have discarded those approaches in Related Work that do not actually enable the performance of context adaptations, but only deal with detecting or defining context situations.

Regarding abstraction, in contrast with MoDAS, we can see that there are several approaches in which context adaptation has to be somehow handwritten, and there are no models or other high-level artefacts which let us describe context in an abstract way. Concerning classification or taxonomy availability, we can see that there are approaches which provide a general mechanism to define context, and therefore, are fully extensible for their description, but then they do not provide a context classification or taxonomy which facilitates code generation or context-adaptation in general. On the other hand, as to portability, some of the examined approaches are limited to a specific domain or to web-rich client applications only. In this sense we can see that not all the approaches can be extended with further contexts at compile time. This is the main contribution we have included in MoDAS in this paper, where a portable taxonomy has been provided, as well as complemented by a compile time extension mechanism. The taxonomy has been thoroughly evaluated by a case study that considered common types of context adaptation and future user-defined adaptations.

Finally, there is an issue in which MoDAS requires improvement. We can see that there are some approaches which provide some mechanism to add, or are able to adapt to new contexts at runtime, even though those might only be domain-specific contexts. Up until now, MoDAS has only been able to adapt to context elements existing at design/compile time; that is, we cannot add new types of context to services already deployed. However, it is part of our future lines of work to include dynamic aspects which allow the inclusion of new context adaptations at runtime. Do bear in mind that even though the types of context for adaptation are done at compile time, the adaptation is carried out dynamically by the aspects. There is dynamic adaptation to context, done by the aspects. For instance we say we are going to adapt to the system language at compile time (we obtain the system language and adapt the service at runtime); but we cannot expect, for instance, to adapt the system to the user’s location if we did not say it before at compile time.

Therefore, we can conclude that new MoDAS features—context taxonomy and its inclusion in the modelling and code generation stage and extensibility—provide a clear advantage to related work in this field.

@&#CONCLUSIONS@&#

In this paper, we have presented a key improvement for MoDAS methodology for Model-Driven Adaptable Services. MoDAS allows us to define our context-aware services from initial system models and, through a set of automated transformations, easily obtain skeleton code for services and most code for their context-adaptation.

We have defined and provided a context metamodel, which allows us to classify different types of context, according to their requirements for code implementation. Based on the metamodel, we have improved our methodology to allow the developer to configure additional information about context definition at a higher level of abstraction. Such improvements facilitate context code generation, so that a larger number of context definitions can be used in the target systems. The mechanism to customize context definitions has also been improved, facilitating further opportunities for code generation and flexibility.

The model-driven approach largely facilitates software development tasks, as well as enabling the generation of trustworthy and well-structured code. In addition, the aspect-oriented implementation of context-aware source code decouples the main system implementation from context-related issues, thus simplifying system evolution and maintenance by easily plugging in new contexts as required by the system.

Future works include to improve MoDAS by adding dynamic aspects at runtime. We also plan to extend MoDAS with services that can be dynamically invoked depending on context events.

@&#ACKNOWLEDGEMENT@&#

G. Ortiz thanks the support for this research by Ministerio de Ciencia e Innovación, under Contract TIN2011-27242.

@&#REFERENCES@&#

