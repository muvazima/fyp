@&#MAIN-TITLE@&#Implementing design patterns as parametric aspects using ParaAJ: The case of the singleton, observer, and decorator design patterns

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Implementation of design patterns depends on the language being used.


                        
                        
                           
                           ParaAJ helps in creating reusable aspects.


                        
                        
                           
                           Some design patterns can be implemented as reusable aspects in ParaAJ.


                        
                        
                           
                           ParaAJ simplifies the reuse of design patterns to a single line of code.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Design patterns

Reusability

Parametric aspects

ParaAJ

@&#ABSTRACT@&#


               
               
                  Implementation of a design pattern can take many forms according to the programming language being used. Most of the literature presents design patterns in their conventional object-oriented implementations. Several other studies show the implementation in aspect-oriented languages such as AspectJ, EOS, and Caesar. In this work, we compare the implementation of three design patterns: singleton, observer, and decorator design patterns in these languages and also discuss the possibility of implementing them in ParaAJ: an extension to the AspectJ language that implements the idea of parametric aspects. We found that ParaAJ helps in making the implementation of the singleton and observer patterns reusable but it fails to help in the decorator case. The problem with the decorator pattern exists because of the current translation mechanism of ParaAJ׳s aspects to normal AspectJ׳s aspects. This opens the door for further work in ParaAJ to better support the idea of parametric aspects.
               
            

@&#INTRODUCTION@&#

Design patterns represent proven solutions to commonly recurring problems [1]. Most of the literature presents design patterns implementations in object oriented (OO) languages. Although OO languages are sufficient to implement most patterns, they lack proper constructs to make the implementation of design patterns maintainable, local, and reusable. Design patterns differ in their complexity and structure. In some cases, the pattern code gets scattered in many modules making it difficult to implement and even more difficult to maintain. As Denier and Cointe [2] state, a major problem when implementing design patterns is that they tend to disappear in the code.

Aspect oriented programming (AOP) [3] provides extra constructs to deal with crosscutting concerns. Those constructs can also be used to enhance design patterns implementation. The first study in this area is the one conducted by Hannemann and Kiczales [4] who implemented the design pattern catalog [1] in AspectJ – an aspect oriented version of the Java programming language. The implementation showed an improvement in 17 out of 23 design patterns in the original catalog [1].

Many design patterns have similar structures (and implementation) across different applications. Examples of these patterns include the observer, singleton, and decorator patterns. Other patterns depend heavily on their structure and implementation on the application they are applied in (e.g., facade and adapter). For those patterns which have similar structure and implementation, it would be advantageous to implement them as reusable modules instead of having to go through the tedious task of creating their template code every time they are required in a new application.

For example, in the observer design pattern, there is nothing special about the addObserver() and removeObserver() methods and they will probably be the same in all applications. Yet, we have to write them every time we use the observer pattern (considering Java as the implementation language). The AspectJ implementation of the observer pattern (as implemented in [4]) provides a better solution but it also suffers from some problems that will be discussed in Section 4.2. Other AOP languages such as EOS and Caesar have different mechanism and construct to deal with crosscutting concerns and thus can be used differently to implement the various design patterns. We will highlight the advantages and disadvantages of each approach during our discussion in the following sections. We focus mainly in this paper on aspect-oriented languages since they represent the proper tool to deal with crosscutting concerns – a problem that appears clearly in most design patterns.


                     ParaAJ 
                     [5] is a language extension built on top of AspectJ to facilitate the idea of parametric aspects. With parametric aspects, aspects can be parameterized so that they can be reused easily in different contexts. This is different from the reuse opportunities currently available in AOP languages such as AspectJ.

As we mentioned before, not every pattern can be made reusable because the idea of that pattern can be implemented differently according to the context in which it is applied. Hence, we are focusing on this paper on three design patterns: singleton, observer, and decorator. The reason of choosing these three patterns is the high frequency of usage among developers and therefore the need for these patterns to be made reusable.

The main contribution of this work is the implementation of some design patterns as reusable components (parametric aspects) using the ParaAJ language. Parametric aspects can be used generally but in this paper we showed how they can be effectively used to implement design patterns. The approach we are presenting is unique in the sense that the effort required to apply a design pattern in a new context is only one line of code.

The rest of this paper is outlined as follows. Section 2 provides some background about the idea of parametric aspects and ParaAJ. Sections 3, 4 and 5 show the various ways of implementing the singleton, observer, and decorator patterns respectively in traditional object-oriented and also aspect-oriented languages. Section 6 briefly discusses why this paper focuses on these three patterns and not on other patterns. Section 7 presents some related work and finally Section 8 includes some concluding remarks.

In this section, we will discuss the main constructs of the ParaAJ language and its approach toward the idea of parametric aspects [5]. This is needed for our discussion in the next few sections. A parametric aspect (para-aspect for short) is an abstract aspect that defines a self-contained piece of reusable functionality. It provides an explicit interface between itself and its clients and is considered abstract because it cannot be used as is; it has to be applied to a target component and each application specifies a separate concrete aspect.

Kersten and Murply [6] distinguish four types of class-aspect association: closed, open, class-directional, and aspect-directional associations. A closed association means that both the aspect and its target (usually a class) do not know about each other. In an open association, on the other hand, both know about the other by means of references in the aspect or in the class itself. Most AspectJ׳s aspects rely on class-directional association where aspects include information about affected class but the class is oblivious to this relation.

Parametric aspects in ParaAJ use the aspect-directional relation where the aspect is generic and oblivious to the relation and the class has all the information about the connection between the two. Thus, ParaAJ shifts the control point from the aspect to the class side. With this kind of association, the developer can see the various aspects affecting the class by looking at its source code (hence, improving visibility) and still have the crosscutting concern code encapsulated in the aspect (avoiding the tangling and scattering problems associated with most crosscutting concerns).

Another advantage in the parametric aspect approach is aspect reusability as they can be implemented without explicitly referring to their targets (i.e., base code). Unlike normal aspects, a parametric aspect uses parameters as an interface between itself and its clients. This avoids any coupling resulting from hard-coding the target class in the pointcut. Mainly, parameters are used to pass target class information but they can also be used to pass any other parameters as we do in constructor and method parameters. Target class information might include pointcuts, types, field names, method names and signatures. We believe that this would be more convenient than using aspect inheritance to create a separate specialized aspect for each use of a reusable aspect.


                     ParaAJ 
                     [5] is an extension to the AspectJ language that allows the creation of component aspects, i.e., modular aspects that can be applied and used in different contexts according to the supplied parameters. One of the main goals of ParaAJ is to overcome the limited reuse opportunities in AspectJ (abstract pointcuts). This can have many applications beyond implementation of design patterns but we focus in this paper in this particular topic.


                     ParaAJ allows either aspect-directional or closed associations. Its main distinguishing features are that aspects must be explicitly applied to the classes they affect, and that aspect applications may specify parameters that indicate how the aspect is to be applied. These features enhance maintainability, as the aspect parameters create a formal interface between aspects and classes, allowing each to be developed and maintained separately, and encouraging reuse of both aspects and classes.

It is worth noting that ParaAJ׳s parameters are different from the currently available parameters in AspectJ׳s constructs such as pointcut and advice. The parameters in AspectJ are translated simply to method parameters during the weaving process. Then, they get evaluated at run-time. In ParaAJ, on the other hand, parameters can be used to represent programming constructs (e.g., fields and methods).

The parameters in parametric aspects are similar to the constructor and method parameters in normal classes except for the fact that they are evaluated at compile-time. ParaAJ׳s parameters come right after the aspect name in the declaration following the syntax: 
                        
                           
                              
                              
                                 
                                    
                                       
                                          〈
                                          visibility
                                          〉
                                        
                                       aspect 
                                       
                                          〈
                                          name
                                          〉
                                        
                                       
                                          
                                             
                                                (
                                                〈
                                                formals
                                                〉
                                                )
                                             
                                             
                                                ̲
                                             
                                          
                                        
                                       
                                          {
                                       
                                    
                                 
                                 
                                    
                                       
                                       
                                          〈
                                          aspect
                                          
                                          body
                                          
                                          declarations
                                          〉
                                       
                                    
                                 
                                 
                                    
                                       
                                          }
                                       
                                    
                                 
                              
                           
                        
                     where 
                        〈
                        visibility
                        〉
                      is a visibility modifier as can be applied to a normal aspect; 
                        〈
                        name
                        〉
                      is an aspect name; 
                        〈
                        formals
                        〉
                      specifies the formal parameters of the aspect; and 
                        〈
                        aspect
                        
                        body
                        
                        declarations
                        〉
                      are any declarations that can appear in a normal AspectJ aspect.

Similar to normal parameters in constructors and methods, each formal parameter declaration consists of a type and a name. The name can be any normal Java identifier. The type can be any primitive Java type such as int, double, char, boolean, etc. or a meta-type that could be one of the following: type, field, fields, method, methods, pointcut, and ident.


                     type is a meta-type to pass primitive or reference type names. We would be able to achieve the same thing using an identifier (ident) but using type instead helps the compiler to detect errors early if a wrong type is passed to the aspect (for example, if we pass string instead of String). The type ‘field’ and ‘fields’ are used to pass field names to the aspect. Such parameters can be used to construct pointcuts inside the aspect. Also, ‘method’ and ‘methods’ are used in the same way.

The ident type is a new type that we introduced to the language to allow developers to pass arbitrary identifiers to the aspects. This would be particularly useful for aspects that introduces new members to targets and we would like to parameterize the name of these members.

Usually in methods and constructors, when a parameter is declared in the module definition, it is used inside the module as it is. For example, in the following listing, the parameters a and b appear inside the method in the same format as the method definition. 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        However, inside the body of parametric aspects, parameter names should appear between ‘
                           
                              
                                 $[
                              
                           
                        ’ and ‘
                           
                              
                                 ]
                              
                           
                        ’ symbols. The reason in using this notation is that parametric aspect parameters are evaluated during compile-time and thus we need a way to differentiate them from other symbols in the aspect body. In programming languages compiler terms, if the compiler encounters the following statement: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        it would declare a variable of class or interface Foo. However, if the compiler encounters the following statement: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        it would declare variable of type specified by aspect parameter foo. These nodes (i.e., meta-nodes) are replaced during compilation with the actual values passed by the apply declaration (shown next).

As mentioned before, ParaAJ allows parameters to appear only inside the body of the aspect. However, it restricts the places where the parameter can be used according to the type of the parameter itself. For example, in Java grammar, Type is a Java rule to represent primitive types (such as int, char, etc.) or reference types (for example, String, java.util.List, user created types, etc.). This rule is used in many rules in Java and AspectJ. For example, in Java it is used in field declarations, method headers (return types), and formal parameters. Also, in AspectJ, it is used in inter-type member declarations and type patterns. ParaAJ adds a rule to the grammar to allow meta-types to appear anywhere where a type can be applied. 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The advantage of this restriction is to ensure that ParaAJ can produce semantically correct programs. In a similar way, ParaAJ allows several other grammar rules such as meta-field declaration and meta-inter-type declaration. At this stage, ParaAJ does not support passing complete statements or a group of statements to the parametric aspect. We believe that this would add more power to the language but it is not supported yet.

Parametric aspects can be applied to a target class internally resulting in an aspect-directional relationship, or externally (from another class) resulting in a closed association between the aspect and the class. Both cases leave the parametric aspect reusable and the second case allows the target class to be reused with or without the application of that aspect. Deciding on whether we should apply an aspect internally or externally depends mainly on the aspect and on the concern it is implementing.


                        Internal application: In an internal application, the apply declaration resides inside the target class and only affects that particular class. It can be placed anywhere where class members can be declared and has the following syntax: 
                           
                              
                                 
                                 
                                    
                                       
                                          apply 
                                          
                                             〈
                                             name
                                             〉
                                           (
                                             〈
                                             actuals
                                             〉
                                          );
                                    
                                 
                              
                           
                        where 
                           〈
                           name
                           〉
                         is a parametric aspect name; 
                           〈
                           actuals
                           〉
                         specifies the actual parameters that will be passed to the aspect.


                        External application: In an external application, the apply declaration resides inside one class (the host) but specifies that it applies to another class (the target). The overall effect of this kind of application is a crosscutting concern that connects the functionality of two separate classes. The syntax of the apply declaration in this case is: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             〈
                                             target
                                             〉
                                           . apply 
                                          
                                             〈
                                             name
                                             〉
                                          (
                                             〈
                                             actuals
                                             〉
                                          );
                                    
                                 
                              
                           
                        
                     

Consider a logging requirement that logs any updates that are performed on a certain field. To implement this requirement, we create a parametric aspect that takes the field name as its interface as shown in Listing 1. This field should belong to the target that is using the aspect and can be used (i.e., the field) inside the aspect to build other constructs such as pointcuts.
                           Listing 1
                           A simple parametric aspect and applying it to a class. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

In AspectJ, the pointcut set(field_pattern) is used to capture any statement modifying the field matched by field_pattern. A field_pattern consists of modifier (optional), field type, host, and field name. For example, we could write: 
                           
                              
                                 set
                                 (
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               int
                                                            
                                                            
                                                               ︸
                                                            
                                                         
                                                      
                                                      
                                                         type
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               Foo
                                                            
                                                            
                                                               ︸
                                                            
                                                         
                                                      
                                                      
                                                         host
                                                      
                                                   
                                                
                                                ·
                                                
                                                   
                                                      
                                                         
                                                            
                                                               bar
                                                            
                                                            
                                                               ︸
                                                            
                                                         
                                                      
                                                      
                                                         name
                                                      
                                                   
                                                
                                             
                                             
                                                ︸
                                             
                                          
                                       
                                       
                                          field
                                          
                                          pattern
                                       
                                    
                                 
                                 )
                              
                           
                        In ParaAJ, we need not, and must not, specify the host class, as that is determined by the class to which our aspect is applied. In this example, $[f] specifies the field whose changes should be announced. The actual name of the field will be passed in the apply statement. After defining the aspect, it can be applied to any class using the apply declaration shown in Line 9 in Listing 1.

Based on the capabilities of ParaAJ, we believe that it would be advantageous to use them in implementing design patterns. As we mentioned before, the current problem when it comes to implementing design patterns is that the implementation tends to disappear in the core logic [2]. In the aspect-oriented based implementation [4], the case is better but we still have the problem of implementation overhead i.e., number of lines required to achieve a certain design pattern. Because of these reasons, we thought of using parametric aspects to implement some design patterns to achieve better maintainability, reusability, and expressiveness. In the following sections, we will discuss various implementations of three design patterns (singleton, observer, and decorator) in different object-oriented and aspect-oriented languages.

The singleton design pattern is a very well known pattern that is used to “ensure that a class has only one instance, and provides a global point of access to it” [1].

In object-oriented languages such as Java, this pattern can be implemented as shown in Listing 2. The implementation is divided into three parts: (1) an instance variable holding a reference to the created object, (2) a private constructor, and (3) a public method to get the instance. When an object of type MyClass gets created for the first time, theInstance field would be created. Later requests to create new objects would not create another theInstance field, but rather, would return the object that has already been created. 
                           Listing 2
                           Implementing the singleton pattern in Java. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Although the implementation does not appear to be crosscutting, it actually mixes the singleton logic with the actual functionality of the class (not shown in the listing). The singleton pattern is widely used and the same procedure has to be followed whenever the singleton is needed.

Hannemann and Kiczales [4] reimplemented the singleton design pattern using AspectJ (see Listing 3). The main component in their implementation is an abstract aspect (SingletonProtocol). In this abstract aspect, they provide an empty interface (usually called marker interface 
                        [7,8]) that is used as a parent interface (i.e., the class to be made singleton should implement it). They use a pointcut that captures calls to the class constructor “call((Singleton+).new(..))” and uses an around advice to create a new instance or returns the existing one. 
                           Listing 3
                           Implementing the singleton pattern in AspectJ. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

This implementation separates the singleton logic from the core logic of the class. The SingletonProtocol represents the reusable building block for the singleton pattern. However, creating the actual singleton instance (Lines 19–26 and 27–34) is not as easy as we think it should be. There is a lot of code that will be the same in each singleton instance; yet, it has to be repeated every time. The gray-shaded areas in Listing 3 represent the parts that will vary in each application of the SingletonProtocol. Other un-shaded parts will remain the same and have to be duplicated in all aspects.


                        AspectJhas many powerful constructs and supports aspect reuse through abstract aspects. However, as we can see in Listing 3 (Lines 21 and 29), one of the main limitations of AspectJ is the inability to make inter-type declarations reusable i.e., they have to be declared completely in each new concrete aspect. In other words, inter-type declarations cannot be parameterized in the current implementation of AspectJ.

Furthermore, the identifiers PrinterSubclass and ScreenSubclass that appear in the pointcuts (Lines 25 and 33) cannot be passed easily to the aspect. In other words, the protectionExclusions pointcuts have to be repeated just to include these small parts (i.e., the identifiers).

An interesting approach is the one followed in Sally 
                        [9]. Sally is a general-purpose aspect-oriented language that has many similarities to AspectJ. However, unlike AspectJ, Sally uses normal classes to encapsulate crosscutting code (instead of creating new constructs such as aspects). Also, it adds more power to the language by allowing variability in its static crosscutting constructs. In other words, while AspectJ pointcut language expresses only the dynamic parts of the language (for example, methods call and field access), Sally allows introductions to be expressed in a parametric way. This is useful to create generic aspects; many AspectJ aspects cannot be expressed easily in a generic way because of the inability to write reusable introductions. Using parametric introductions, developers can declare what to be introduced to the target class without explicitly specifying the actual target. Listing 4 shows an implementation of a generic singleton aspect in Sally. 
                           Listing 4
                           Parametric singleton implementation pattern Sally. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           


                        ParaAJis similar to Sally 
                        [9] in that it supports parameterization in modules. In ParaAJ, this is applied to aspects. The implementation of the singleton pattern as a parametric aspect has many similarities to the original object-oriented implementation. The only difference is the parts that refer to the actual class that need to be made as singleton. The implementation is shown in Listing 5. 
                           Listing 5
                           Implementing parametric singleton aspect in ParaAJ. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

The code includes some new constructs that we did not cover in Section 2: the inject and thisTarget keywords. The inject statement is similar to inter-type declaration in AspectJ except that it does not need to specify the target class where the member is to be introduced (i.e., that contains the apply declaration). The effect of this injection is creating a member that is visible to the target class (i.e., as if it was hard coded in that class). The thisTarget is a kind of reflection mechanism that specifies the class or component which is applying the aspect. To make a class singleton, we just need to apply the MakeSingleton aspect as shown in Line 11.

The advantage of this approach is that the aspect clearly reflects the conventional object-oriented approach of implementing the singleton pattern. Any developer who is familiar with the object oriented implementation of the singleton can understand and modify the aspect (e.g., to apply the double-checking mechanism required in multi-threaded applications).

The implementation in ParaAJ is different from the one in AspectJ in the sense that AspectJ׳s aspect is used for all classes that need to be implemented as singleton. In ParaAJ, the aspect serves as a template, whenever a class applies it, a new aspect specific to that class will be created.

@&#DISCUSSION@&#

As shown in this section, the object-oriented based implementation is straightforward and simple. However, it mixes the logic of the singleton pattern with the main logic of the class. Thus, ignoring the separation-of-concerns principle [10]. The SingletonProtocol aspect shown in the AspectJ solution separates completely the singleton logic from main classes. However, as shown in Listing 3, the effort required to use the SingletonProtocol is considerable. Every time we need to make a class singleton, we have to repeat these 4 lines in the SingletonInstance aspect (Lines 19–26). In other words, it is true that the SingletonProtocol is reusable but it is not easily reusable. Another minor issue is the central management of all singleton classes. The SingletonProtocol keeps record (Line 2) of all classes that are set to use this protocol. Thus, all calls to instantiate object of any type is supposed to go through Line 12 to check the existence of older objects in the hashtable.

It is worth noting that some languages such as Scala 
                        [11,12] has built-in features implementing the singleton concept. Scala has a special keyword ‘object’ which creates a class and also makes it singleton in the same time without any additional coding (see the code below). 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The singleton implementation in ParaAJ takes a different direction from the ones in AspectJ and Sally. The implementation is much closer to the object-oriented implementation. When we compare it with the AspectJsolution, we can see the minimal effort required to convert a class to become singleton.

The observer design pattern is probably the most well known design pattern among the 23 patterns in the catalog of Gamma et al. [1]. It is used to allow cooperation between various classes without making a tight coupling between them. It is also known as “publish-subscriber” pattern [13]. Actually, the observer pattern has been used extensively in the aspect-oriented software development (AOSD) literature as an exemplar of crosscutting concerns [4,14–16].

As described by Gamma et al. [1], the intent of the observer pattern is to: “Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically”. It works by specifying two types of entities: subjects and observers. A subject might change in its state and registered observers should be notified upon these changes. In the following sections, we will compare the implementation of this pattern in different programming languages.

In an object-oriented language such as Java, this pattern can be implemented as shown in Listing 6. The Point class is the actual subject to be observed and Screen is the class representing the observer. To decrease the coupling between the actual subject and the observers, the observation logic is abstracted in two interfaces: Subject and Observer. To make the connection, the Point class has to implement the Subject interface (line 1). Similarly, the Screen class has to implement Observer interface (line 26). 
                           Listing 6
                           Implementing the observer pattern in Java. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

This implementation suffers from a crosscutting presence especially in the subject part. In the Point class, whenever the x or y coordinates change, observers have to be notified by calling the notifyObservers() method. Although it is not that much (i.e., only a single line in both methods), it mixes the original logic (that is, changing coordinate values) with the observation logic. Also, the Point class has to implement three methods: addObserver, removeObserver, and notifyObservers – all of which are not part of the logic of the Point class. Finally, it has to keep a record of the observers by maintaining a list as shown in line 2. The gray-shaded areas in the code represent the observation logic that crosscuts the point main-logic.

m:1 
                           m
                           :
                           1
                         Another problem with the object-oriented implementation is that the observation logic cannot be used in different contexts; i.e., the same code (in the gray-shaded areas) has to be repeated in all classes that need the observation logic.

Hannemann and Kiczales [4] reimplemented the observer pattern using AspectJ. As shown in Listing 7, the AspectJ-based implementation relies on defining an ObserverProtocol aspect that reflects the subject and observer roles as inner interfaces. 
                           Listing 7
                           Implementing subject–observer pattern in AspectJ – ObserverProtocol. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

This ObserverProtocol represents the building block for the pattern. Users can then extend this aspect to specify the actual subject–observer behavior. The ColorObserver aspect (Lines 31–45) extends the ObserverProtocol to specify the actual observation logic. Reusing this protocol requires the following steps: (1) create a new aspect that extends ObserverProtocol, (2) assign the roles of participating classes using the ‘declare parents’ statement (Lines 33–35), (3) define the observation points by using the pointcut construct, and (4) define the logic that should be executed when the event happens (Line 43).

The solution in AspectJ is a generic solution for the observer pattern. It captures the relation between subjects and observer in a central ObserverProtocol. However, despite this improvement, the pattern code cannot be reused easily in other contexts. There is a lot of code duplication needed for each new observer required even if we are encapsulating most of the logic in the ObserverProtocol. The duplicated code is highlighted in gray in Listing 7 (Lines 31–45).

Another interesting AOP language is EOS 
                        [17] – a language model designed by Rajan and Sullivan to unify classes and aspects as one modular unit called classpect [18]. The idea of classpects is to “extend classes with capabilities of aspects, and aspects with the compositionality of objects” [18].

In a study similar to the one conducted by Hannemann and Kiczales [4], Rajan [19] considered implementing some of Gamma et al.׳s design patterns in the EOS language. As indicated in [19], the implementation of the observer pattern is similar to AspectJ in the sense that both depend on abstract ObserverProtocol component (aspect in AspectJ and class in EOS). The ObserverProtocol in EOS is, however, 78% smaller in size (lines of code) than its AspectJ׳s counterpart [19] (see Listing 8). 
                           Listing 8
                           Observer pattern in EOS. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

A clear advantage of this approach, unlike the AspectJ implementation, is that it clearly reflects the intent of the observer pattern. One can clearly read it as: when a subject changes, update the observer (Line 6). The change to the subject is captured in Line 2 and updating the observer is defined in Line 4.

The ColorObserver can be implemented as shown in Lines 8–20. It is similar to its AspectJ counterpart. However, we find the EOS code to be more elegant and compact especially when assigning roles to the participating components. In AspectJ, we have to use the declare parents statement to achieve that. Also, initialization (or binding) of subjects and observers is slightly different in AspectJ and EOS. EOS makes it easier to refer to the observer unlike AspectJ which has to use the aspectOf() method.
                           Listing 9
                           Binding subjects to observers in AspectJ and EOS. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           


                        Caesar
                        [20] aims to build aspects as reusable components. It separates the actual definition of the aspect from its binding to the targets. Binding of aspects to their targets is done in the aspect collaboration interface (ACI). This separation of aspect implementation from aspect binding greatly improves reusability of aspects. Another feature of Caesar is that aspects can also be composed using their collaboration interfaces.


                        Caesarprovides a new kind of classes called cclass supporting family polymorphism – ability to treat inner classes the same way as methods [21]. It also has an interesting feature: aspectual polymorphism, which allows choosing which aspect or advice to run according to the type of the target [22].

Sousa and Monteiro [21] followed the same approach of Hannemann and Kiczales [4] and Rajan [19] in implementing some design patterns in Caesar. They chose a subset of 7 patterns (out of the 23 patterns in [1]). The ObserverProtocol in Caesar is represented as shown in Listing 10. 
                           Listing 10
                           ColorProtocol in Caesar. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

@&#DISCUSSION@&#

As described in Section 4.1, the pattern works by identifying one class as a subject and another class (or classes) as observers. In the subject class, the developer should add the required data structure to hold a list of observers and also add three methods namely: addObserver, removeObserver, and notifyObservers. The observer class simply implements the Observer interface and implements one method: refresh which specifies the observation logic in that specific observer.

By studying the resulting code, we can clearly observe the pollution that the observer code had on the original code. When we try to implement the observer pattern in a different context, we can also see that the amount of boiler-plate code in this pattern is high. The only part that need to be changed is what goes inside the refresh method in each observer.

A quick look at the solutions offered by AOP languages would show the advantage of using AOP constructs. First, the original code (e.g., Point class) is not concerned or affected with the observer logic. Second, most of the observer logic is localized in one module (e.g., the ObserverProtocol aspect in AspectJ). Third, the effort required to implement a new observer is minimized (see Listing 7). Finally, the ability to observe multiple subjects rather than one at a time is something unique to AOP languages. In other words, instead of creating an observer for the Line class and then creating another observer for the Point class, we can combine both in one aspect (in short: no scattering).

However, we tackle this issue from an expressiveness point of view. Why do we need to write this amount of code every time I need to observe a certain class? If one applies or uses the observer protocol in a different context, he would easily observe the amount of code to be repeated in each case (see gray-shaded areas in Listing 7). This is why we thought of achieving this using the parametric aspects idea in ParaAJ (next section).

For the observation logic, we use a different type of aspect application. As shown in [5], parametric aspects can be applied either internally or externally. In the case of internal application, the apply declaration resides inside the target class and only affects that particular class. It can be placed directly in the class code anywhere where class members can be declared. The internal application approach is the one we used to implement the singleton pattern (Section 3).

In an external application, the apply declaration resides inside one class (the host) but specifies that it applies to another class (the target). The overall effect of this kind of application is a crosscutting concern that connects the functionality of two separate classes.

For example, if we would like to apply observer to the Point class, it is most appropriate that the code that displays the Point information should apply the observer aspect (in this case, the Screen class). This maintains a single point of control over the observation logic in the class that is responsible for that functionality. The main thing here is to determine what is required to be observed? For example, one might be interested in observing the behavior of some methods, so we can use a mechanism similar to the one used in the synchronization aspect (i.e., using the ‘execution’ pointcut). Another one might be interested in observing some fields, so, in this case we would use a ‘set’ pointcut instead. Answering the previous question would determine the appropriate interface of the observer aspect.

Ignoring implementation details in Java and AspectJ, we can describe the situation as follows:
                           
                              1.
                              A subject to be observed by another component. This subject has to be oblivious to the whole monitoring requirement. It should not contain any code that belongs to the observation logic.

An observer that knows about the subject. It has a method that can process updates.

We can simply implement this as shown below (Listing 11). This is slightly a modified version of the original observer pattern. 
                           Listing 11
                           Implementing observation logic in ParaAJ. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Beside specifying what is to be monitored, the aspect should also specify the actual monitoring logic. Hard-coding the monitoring logic inside the aspect limits its reusability, so, it is better to parameterize this by passing a method name to the aspect. To apply this aspect, we have to specify the field to be monitored and also pass the method that encapsulates the observation logic as shown in Line 31 in Listing 11.

One clear advantage of this approach with parametric aspects is the simplicity of the aspect itself (in terms of development effort). Also, applying the FieldObserver aspect can be done in one line. Surely, this implementation is not equivalent to the original GoF implementation but it would serve well for many observation cases.

One would suggest using the same approach of Hannemann and Kiczales [4] in their ObserverProtocol. To link subject and observers together, we should write statements of the form: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In ParaAJ, each apply declaration results in a new aspect whose name is similar to the original parametric aspect but mangled to avoid name conflict. Thus, we will not be able to use the aspectOf() statement (as shown in the code above).

The decorator is another interesting design pattern presented by Gamma et al. [1]. Its intent is to “attach additional responsibilities to an object dynamically” [1]. The basic implementation of the decorator design pattern in Java depends on creating a basic OutputDecorator that can include the actual concrete object implementing the type Output (Line 10 in Listing 12). When creating a concrete decorator (e.g., StarDecorator or BracketDecorator), the developer has to pass the actual concrete object to the constructor (Lines 25 and 35).

The implementation is simple and straightforward. It allows the user to wrap any object with as many decorators required. For example, one can say: 
                        
                           
                              
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

However, the implementation does not help in making the various decorators reusable in other contexts. As shown in Listing 12, the two decorators are subclasses of the OutputDecorator which specifies that they can only wrap objects of type Output. 
                        Listing 12
                        Implementing decorators in Java. 
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Hannemann and Kiczales [4] reimplemented the decorator pattern using AspectJ (see Listing 13). The implementation uses a pointcut to capture any call to the print method (Lines 7 and 16). After that, it uses an around advice to wrap this method with a new behavior (brackets and stars) as shown in Lines 10–11. Although the implementation looks straightforward and easy to follow, it neglects a core feature of the decorator pattern: decorating individual objects rather than all objects of the decorated class. In other words, this implementation leaves us with a class-decorator not an object-decorator. Another problem with this implementation is that it does not allow flexible composition of different decorators [19] as it is the case in the original object-oriented implementation. 
                           Listing 13
                           Implementing decorators in AspectJ. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

A major feature in EOS 
                        [19] is its ability to achieve instance-level advising which means that it can affect selected instances of a certain class rather than all of them (as it is the case in AspectJ). The decorator can be implemented in EOS as shown in Listing 14 (Source: [19]-Figure 17).

The decorator in EOS fulfills the instance-level decoration as it is the case by the original Gang-of-Four definition of the decorator pattern. Unlike the original object-oriented implementation, the decorator should be first created as an object (Line 11) then objects can be decorated by adding them to this object (Line 12). 
                           Listing 14
                           Implementing decorators pattern in EOS. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

An interesting approach is the one presented by Caesar 
                        [23]. The basic idea of the decorator pattern is to wrap an object with an extra behavior. As shown in [21,24], Caesar has two ways of achieving this effect: (1) using normal pointcut and advice (as in AspectJ) and (2) using its special language construct: the ‘wrap’ keyword.

Unlike AspectJ, Caesar allows instantiating its aspects using a normal new keyword. With its dynamic deployment feature, it is easy in Caesar to add or remove decorators at runtime. However, one problem with this approach is controlling the order of different decorators. For this particular issue, AspectJ would be more flexible. The other way by which decoration can be achieved in Caesar is by using its language construct: the wrap keyword. The wrapping mechanism works by allowing a certain object to wrap another object (or objects) so that it can extend its behavior. The wrap keyword (Lines 11 and 18 in Listing 15) reflects the decorator intent. 
                           Listing 15
                           Implementing decorator pattern in Caesar. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

@&#DISCUSSION@&#

When considering the decorator pattern, the AspectJ solution provides class-level advising and thus all objects of the affected class will be decorated rather than selected objects. Also, as shown in Listing 13, there is a great deal of code duplication required to create new decorators. EOS, on the other hand, provides instance-level advising by providing a special method: addObject. This has a special advantage in terms of understandability of the code. In other words, we can easily associate this line of code with the idea of the decorator (since the decorator needs an object to decorate!). It is unclear to us whether EOS allows the object to be wrapped with more than one decorator or not. Caesar provides a new syntax like the keyword ‘wrap’ to allow a new type of composition of objects. However, the ‘wrap’ keyword does exactly what one wants in this case.

A modified version of the AspectJ implementation is presented by Monteiro and Fernandes [25] who achieved the effect of object-decorator by implementing a mechanism to register specific objects that need to be decorated. Thus, although the aspect is actually affecting all instances of the required class, the extra behavior will only be executed for the registered objects. It works as shown in the following code: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In ParaAJ, the original parametric aspect serves as a template for concrete aspects. The apply declarations are responsible for specifying the actual values of the parameters to be filled inside the aspect. During compilation, the compiler converts each apply declaration to a new parametric aspect. The newly created aspects are exactly the same as the original parametric aspect except that their names get mangled to avoid name conflicts with the original aspect. This mechanism works fine for most cases where we want to create-and-forget about the aspects. In other words, in cases where we do not need to refer to the aspect at runtime. The decorator pattern is indeed different in the sense that we need to frequently refer to the decorators (aspects in this case) so that we can attach them or detach them while the program is running. For this reason, ParaAJ (at this stage) is not suitable to implement the decorator design pattern.

Not every pattern has a crosscutting nature to it and thus it is not needed to apply aspect-oriented techniques to all of them. Hannemann and Kiczales [4] clearly mentioned that not all patterns would benefit from the new constructs and facilities in AspectJ. Only those patterns with crosscutting presence in their implementation might improve in terms of locality and reusability. Patterns such as Factory, Abstract Factory, Template Method, Builder, and Bridge cannot be made more reusable (compared to the Java implementation) and thus do not benefit from the AspectJ׳s construct. However, one feature that might be utilized is the fact that in AspectJ one would replace abstract classes with interfaces with default implementation. This feature frees the concrete class from the forced inheritance relationship that is required in most object-oriented languages with single inheritance.

Also, not all patterns are applied in a similar way and hence they cannot be made reusable. In other words, many design patterns in the GoF [1] catalog represent best practices rather than reusable solutions (i.e., components). The idea of the pattern is recurring and the design of the solution is reusable but the code is not. For example, the factory and abstract factory patterns are common in software development. However, the way they are applied differs greatly from one application to the other. In other words, we cannot design them as aspects (AspectJ, EOS, Caesar) or as parametric aspects (ParaAJ).

To summarize, if the pattern (GoF or any other pattern) has a crosscutting presence in its code, then it might benefit from the AOP constructs. If the application of the pattern is similar in different contexts, then it might benefit from the ParaAJ׳s constructs.

@&#RELATED WORK@&#

The work done by Hannemann and Kiczales [4] represents the most comprehensive study in implementing and comparing design patterns implementation in two languages: Java and AspectJ. Rajan [19] showed the need of instance-level aspects in EOS to implement patterns such as the observer and decorator. Caesar 
                     [21] is similar to EOS in the sense that both support instance-level advising. Actually, Caesar provides some language constructs that help in achieving reusable designs like the use of the wrap construct to implement the decorator design pattern.

In our work, we focus on aspect reusability. Hanenberg and Unland [7] noticed the insufficiency of AspectJ-like languages to provide proper reuse and proposed new idioms to overcome this issue. For example, the container-introduction idiom [7] is used to make AspectJ introductions reusable. Many other idioms such as template advice, pointcut method, and chained advice are used in other cases where other parts of the aspect need to be reused [7,8]. Despite their usefulness, these idioms provide an indirect way to achieve aspect reusability.

Meta-programming is the act of writing programs that generate other programs [26]. It is a powerful technique for developers to simplify the development process and can be used effectively to implement domain specific languages [26,27]. Huang and Smaragdakis [27] express the power of generating program code (meta-programming) using their language: MAJ. MAJ combines the abilities of code generation with the power of AspectJ 
                     [26]. As indicated by Shonle et al. [28], this could be utilized to simplify complex implementations of some patterns that are difficult to implement in AspectJ. For example, the declare-parents statements shown earlier can be easily generated with MAJ׳s ‘quote’ (‘[...]) and ‘unquote’ (#[...]) operators. We share the same idea of Zook et al. [26] in the sense that there is a need for program-generating to reduce the development effort. However, their approach is general and can be applied to a range of situations. In our case, we focus on the need to generate code for some recurring patterns.

Huang and Smaragdakis [27] argue that “changing the syntax and semantics of a programming language is confusing and can lead to incomprehensible code.” However, we believe that it would be useful to enrich current programming languages with constructs that can simplify development of recurring solutions such as various design patterns.

@&#CONCLUSION@&#

The implementation of design patterns takes many forms depending on the language being used. In this paper, we presented and evaluated implementations of three design patterns in several aspect-oriented languages including AspectJ, EOS, and Caesar. We also explored the possibility of using ParaAJ to implement these patterns. Our results show that ParaAJ can be used to provide a reusable implementation of the singleton and observer patterns (with some differences in the observer pattern). However, because of the current translation mechanism in ParaAJ, the new constructs cannot be used to successfully implement the decorator pattern as a parametric aspect. We plan to investigate the possibility of changing the translation mechanisms in ParaAJ to facilitate the support of more design patterns. By showing the different approaches to implement design patterns, this paper emphasizes the power of program generation and its advantages in reducing the development effort and also in facilitating program maintainability.

@&#ACKNOWLEDGMENTS@&#

The author acknowledges the support of King Fahd University of Petroleum and Minerals. This work was carried out under Grant no JF111004. The author also acknowledges the valuable comments on earlier versions of this article made by the anonymous reviewers.

@&#REFERENCES@&#

