@&#MAIN-TITLE@&#An analysis of metamodeling practices for MOF and OCL

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           An empirical study of metamodeling practices.


                        
                        
                           
                           A set of metrics formally defined on MOF and OCL.


                        
                        
                           
                           An openly available benchmark of metamodels.


                        
                        
                           
                           OCLMetrics: an Eclipse-based environment to compute metrics.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Metamodeling

MOF

OCL

@&#ABSTRACT@&#


               
               
                  The definition of a metamodel that precisely captures domain knowledge for effective know-how capitalization is a challenging task. A major obstacle for domain experts who want to build a metamodel is that they must master two radically different languages: an object-oriented, MOF-compliant, modeling language to capture the domain structure and first order logic (the Object Constraint Language) for the definition of well-formedness rules. However, there are no guidelines to assist the conjunct usage of both paradigms, and few tools support it. Consequently, we observe that most metamodels have only an object-oriented domain structure, leading to inaccurate metamodels. In this paper, we perform the first empirical study, which analyzes the current state of practice in metamodels that actually use logical expressions to constrain the structure. We analyze 33 metamodels including 995 rules coming from industry, academia and the Object Management Group, to understand how metamodelers articulate both languages. We implement a set of metrics in the OCLMetrics tool to evaluate the complexity of both parts, as well as the coupling between both. We observe that all metamodels tend to have a small, core subset of concepts, which are constrained by most of the rules, in general the rules are loosely coupled to the structure and we identify the set of OCL constructs actually used in rules.
               
            

@&#INTRODUCTION@&#

Metamodeling is a key activity for capitalizing domain knowledge. A metamodel captures the essential concepts of an engineering domain, providing the basis for the definition of a modeling language. A precise metamodel is essential to drive all the development steps of the modeling language (definition of semantics, construction of editors, etc.) [1]. Yet, the activity of capturing a specific domain expertise in the form of a generic metamodel, is still a craft, where domain experts are the craftsmen. They look at existing practices, interact with stakeholders who build models in that domain and identify the essential concepts to describe abstractions in that domain, providing an initial metamodel. Metamodeling, is thus a labor intensive task, which is not well supported with established best practices and methodologies [2,3]. Our work aims at observing previous metamodeling experiences, through rigorous empirical inquiry, in order to provide a quantified state of the practice.

Fifteen years ago, the Object Management Group (OMG) [4] introduced the first version of the Meta-Object Facility (MOF) as an attempt to provide a standard metamodeling language, in conjunction with the Object Constraint Language (OCL) [5] to define additional properties through well-formedness rules. Today, in practice MOF is not clearly established as a standard, but a large number of metamodels are defined with two parts: an object-oriented definition of concepts and relationships, and a set of logic-based well-formedness rules. This work׳s intuition is that the conjunct usage of two languages is cumbersome and thus a major concern for the metamodeling craftsmen (domain experts). Actually, when looking at the most popular metamodel repositories, we find hundreds of metamodels which include only the object-oriented structure, with no well-formedness rules. The consequence is an increased risk of errors in the metamodel [6] and thus errors in all assets that rely on the metamodel. This intuition is thus the hypothesis that guides our scientific method, and the basis for our research questions.

This paper proposes the first extensive empirical analysis of metamodeling practices. The authors published a preliminary proposal at Experiences and Empirical Studies in Software Modeling (EESSMod 2011) held in conjunction with MODELS 2011 [7]. This earlier publication proposed the idea and sketched the workflow to perform the analysis; we present the full survey in this paper. The study focuses on the articulation of an object-oriented MOF-compliant language with a logic-based language (OCL) for the definition of metamodels. We have gathered a collection of 33 metamodels, which combine both paradigms. These metamodels come from diverse backgrounds, in order to effectively cover the state of practice: the OMG (a standardization organism), industry and academia. The object-oriented structures are modeled either with MOF or UML, and all well-formedness rules are modeled with OCL. We analyze the complexity of both parts, as well as different aspects of the coupling relationship. This analysis, based on a set of metamodeling metrics, aims at understanding possible trends in the way metamodeling craftsmen articulate both languages. We observe four phenomena that occur, independent from the metamodel origin:
                        
                           •
                           Well-formedness rules written in OCL are generally loosely coupled to the underlying object-oriented structure, with a high tendency (87.62% of studied expressions) to define rules referring to 4 or less elements of the domain structure.

The definition of these rules are not scattered throughout the metamodel, but actually centered in a small subset of classes. In our study, 25 metamodels have a concentration of 80% of their invariants in only one quarter of the metamodel concepts.

Less than half of the OCL language is used to define invariants. Almost 97% of the studied invariants use a subset of OCL consisting only of 10 concrete expression types out of the 22 specified by the complete language.

Only 84% of the studied set of invariants (840 out of 995) were written in accordance to the correct syntax of OCL and conforming to the underlying object-oriented structure.

The main contributions of this paper are:
                        
                           •
                           An empirical inquiry of metamodeling practices, focusing on the combined usage of OCL-based logic formulas and MOF-based object-oriented structures.

A set of metrics formally defined on MOF and OCL, to quantify the relationship between two paradigms used for metamodeling.

An openly available set of metamodels using both standards, with a benchmark measuring the aforementioned metrics.

An Eclipse-based environment to automatically import metamodels and compute metrics on the MOF and OCL parts. OCLMetrics is the core tool in this environment, which implements our set of metrics for metamodeling.


                     Target audience: This paper is intended for software engineers who use model-driven techniques and wish to get acquainted with current practices in building metamodels with MOF and OCL, tool vendors interested in providing support for the metamodeling activity with these standards.


                     Article structure: In Section 2 we illustrate some design issues that arise when metamodeling with MOF and OCL. Then, we give an overview of the two languages. Section 3 formulates our research questions and defines the set of metrics, while Section 4 introduces our set of data. Section 5 presents the implementation in the OCLMetrics tool. Section 6 answers our research questions and provides empirical answers. Section 7 presents related work. Finally, Section 8 concludes and proposes future directions for this work.

@&#BACKGROUND@&#

This section illustrates the issues that arise from the conjunct usage of two languages for metamodeling, taking Petri nets as an illustrative example. Then, we define the most important notions of MOF and OCL, which will support our analysis. It is important to notice that MOF is presented in its specification in two versions, namely Essential MOF (EMOF), which is the core of concepts necessary for the construction of metamodels, and Complete MOF (CMOF), which does not add new concepts but merges EMOF with the core definitions of UML. As all the metamodels have been defined with only the essential core of concepts of MOF, in the rest of the paper, mentions to MOF refer actually to Essential MOF.

The model in Fig. 1
                         specifies the concepts and relationships of the Petri net domain structure, expressed in MOF. A PetriNet is composed of several Arcs and several Nodes. Arcs have a source and a target Node, while Nodes can have several incoming and outgoing Arcs. The model distinguishes between two different types of Nodes: Places or Transitions.

The domain structure in Fig. 1 accurately captures all the concepts that are necessary to build Petri nets, as well as all the valid relationships that can exist between these concepts in a net. However, there can also exist valid instances of this structure that are not valid Petri nets. For example, the model does not prevent the construction of a Petri net in which an arc׳s source and target are only places (instead of linking a place and a transition). Thus, the sole domain structure of Fig. 1 is not sufficient to precisely model the specific domain of Petri nets, since it still allows the construction of conforming models that are not valid in this domain.

The domain structure needs to be enhanced with additional properties to capture the domain more precisely. The following well-formedness rules, expressed in OCL, show some mandatory properties of Petri nets.
                           
                              1.
                              
                                 i1: Two nodes cannot have the same name. 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 i2: No arc may connect two places or two transitions. 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 i3: A place׳s marking must be positive. 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 i4: An arc׳s weight must be strictly positive. 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              

One can notice that i2 could have been modeled with MOF by choosing another structure for concepts and relationships. However, the number of concepts and relationships would have increased, hampering the understandability of the metamodel and increasing the distance between the metamodel and a straightforward representation of domain concepts (see Figs. 2 and 3
                        
                        ).

In our study we consider that the metamodel for Petri nets is the composition of the model domain structure and the associated well-formedness rules. We learn from this example that the construction of a precise metamodel, that accurately captures a domain, requires (i) mastering two formalisms: MOF for concepts and relationships; OCL for additional properties; (ii) building two complimentary views on the domain model; (iii) finding a balance between what is expressed in one or the other formalism, (iv) keeping the views in synchronization, which are expressed in different formalisms. This last point is particularly challenging in case of evolution of one view or the other. One notable case from the OMG and the evolution of the UML standard is that the AssociationEnd class disappeared after version 1.4 in 2003, but as late as in version 2.2, released in 2009, there were still OCL expressions referring to this metaclass [8]. In the same manner, the OCL 2.2 specification depends on MOF 2.0, however we have observed that a particular section of the specification defining the binding between MOF and OCL [5, p. 169] makes use of the class ModelElement which only existed until MOF 1.4.

This section defines the terms we use to designate the focus of our analysis of modeling languages based in MOF and OCL. A modeling language captures all the elements that are necessary to build abstract models in a specific business or technical domain. These elements include a metamodel that specifies the concepts and properties that define the structure of models, a concrete graphical or textual representation of these concepts, the semantics associated to the concepts and properties, and a set of generators for code, documentation, verification, etc.

This paper focuses on the metamodel part of modeling languages. The relationship between a model and a metamodel can be described as shown in Fig. 4
                         
                        [9]. Here the conformsTo relation is a predicate function that returns true if all objects in the model are instances of the concepts defined in the metamodel, all relations between objects are valid with respect to relationships defined in the metamodel and if all properties are satisfied.
                           Definition 1
                           
                              Metamodel: A metamodel is defined as the composition of
                                 
                                    •
                                    
                                       Concepts: The core concepts and attributes that define the domain.


                                       Relationships: Relationships that specify how the concepts can be bound together in a model.


                                       Well-formedness rules: Additional properties that restrict the way concepts can be assembled to form a valid model.

In this study, we consider metamodels defined with techniques aligned to the OMG standards, MOF and OCL. We distinguish two parts as defined below.
                           Definition 2
                           
                              Metamodel under study: For this work, a metamodel is defined as the composition of
                                 
                                    •
                                    
                                       Domain structure: A MOF-compliant model portraying the domain concepts as metaclasses and relationships between them.


                                       Invariants: Well-formedness rules that impose invariants over the domain structure and that are expressed in OCL.

MOF and OCL are modeling formalisms standardized by the OMG. Ever since its introduction in 1997, MOF has been the metamodeling formalism used by all OMG specifications and it is historically linked to the UML specification, since both standards share a common Core package of constructs. OCL emerged as a component of the UML 1.4 specification and later became an independent standard with application domains outside UML. Today it is the formalism employed for diverse activities such as model transformations, automatic generation of instances and others within the Model-Driven Engineering realm [10–12]. In this section, we discuss the main MOF and OCL concepts that are necessary to perform our analysis, as well as the connection between the two formalisms.


                        Fig. 5
                         displays a subset of (or an abstraction of) the structure of MOF version 2.0 [4]. MOF allows us to specify the concepts of a metamodel in a Package. This Package contains Classes and Properties to model the concepts and relationships. The Properties of a Class are typed by a Classifier, which can be either a DataType Boolean, String or Natural; or another Class.


                        Fig. 6
                         displays a subset of the structure of OCL expressions [5] that can be used to constrain the structure defined with MOF. The most noticeable constructs for OCL expressions are: the ability to declare Variables, whose type is a concept modeled with MOF; the ability to use control structures such as IfExp and LoopExp; the ability to have composite OCL expressions, through CallExps.


                        Fig. 7
                         illustrates how OCL and MOF formalisms are bound to each other [5, p. 169]. This figure specifies that it is possible to define Constraints on MOF Elements (everything in MOF is an Element, cf. Fig. 5). One particular subtype of Element is important for metamodeling: Classifier, as it appears previously in Fig. 5. Constraints can be defined as Expressions, and one particular type of expression is ExpressionInOCL, an expression whose the body is defined with OCL. The existence of this binding between formalisms is essential for metamodeling: this is how two different formalisms can be smoothly integrated in the construction of a metamodel. This binding is also what allows us to automatically analyze metamodels built with MOF and OCL. Notice that ModelElement class in Fig. 7 refers to the Element metaclass in Fig. 5.

In this section we introduce the research questions that we address to understand the usage of MOF and OCL for metamodeling. We also discuss the measurable attributes we compute defining reusable metrics and providing answers to the research questions. All metrics are defined on the basis of data sets that we gather from the MOF domain structure and the associated OCL invariants. We use OCL itself as the formalism to define data sets and metrics, as it provides an interesting trade-off between understandability and formality, and it has been successfully used before in metrics both at code and model levels [13].

As explained in Section 2, the domain structure part, concretely the modeling of concepts and relationships, takes high priority in the development of modeling languages, resulting in a high use of MOF compared to the use of OCL. This initial question aims at providing an overview of the validity of invariants defined over MOF structures and a global comparison of OCL usage among all metamodels. We check to what extent expressions in OCL defined in the sample metamodels are syntactically correct with respect to the MOF concepts and relations definitions. For all cases of invalid expressions, we classify and list the causes of errors, providing an initial qualitative assessment of the collect metamodels.

As shown in the MOF-OCL binding of Fig. 7, every invariant is defined over a concept class in the metamodel, which forms the context of the rule. Since the domain structure of a metamodel defines the set of classes in the metamodel, we wonder whether all concept classes in the domain structure equally serve as context, i.e. if well-formedness rules are equally scattered in the metamodel or if they tend to concentrate on a subset of the structure. To answer this question, we will develop a metric to measure the proportion of the number of invariants defined for every context of the total set of invariants of the metamodel.

OCL invariants express relationships between concepts and properties that are captured in the domain structure. This question aims at understanding the level of coupling between invariants and structure, and how this coupling varies among the different structures. Some metamodels contain lengthy and complex invariants, while others seem to define them using simple expressions. We will compute the expansion in the domain structure of each invariant, i.e. the classes and attributes that the invariant captures. We define a metric to measure the size of this expansion, thus quantifying the complexity of OCL invariants.

As shown in Section 2.3, OCL is a rich language providing several types of expressions, albeit the critique raised by its usability and ambiguity shortcomings [14,15]. Consequently, many OCL engines implement the standard with a certain degree of inaccuracy, as demonstrated by Gogolla et al. [11]. Our intuition is that OCL contains some essential concepts for metamodeling, while some other concepts are rarely used. This question aims at identifying whether there is such a core subset of OCL. We will compute the expansion in the OCL language for each invariant, i.e. identify the constructs of the language used in every expression. We will quantify the usage for every invariant by looking at the number of employed constructs.

This subsection defines formally the data sets for MOF models, OCL invariants and the binding produced when both are used together. This will allow us to measure the attributes discussed in the research questions.


                        MOF data sets: All data for a metamodel are gathered in the context of a package (Fig. 5). Our metrics manipulate the set of properties in a class (classContent()), the set of classes in one package (packageContent()), the set of all classes in the metamodel (packageAllContent() recursively collects all the classes from contained subpackages). All these MOF data sets are formally defined as follows:
                           Listing 1
                           Definition of the packageContent dataset. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

Definition of the packageAllContent dataset. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

Definition of the classContent dataset. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           


                        OCL data sets: Metrics about OCL expressions are defined using two data sets gathered from instances of the OCL expression metamodel (Fig. 6):
                           
                              •
                              
                                 computeOCLE(): the set of all OclExpression instances that are manipulated in an ExpressionInOCL.


                                 expansionInDS(): the set of different properties of the referenced domain structure that are used in an OCL expression. Note that the context for computing this set is ExpressionInOCL, and we assume that this expression is an invariant, since OCL expressions considered in this study are only invariants (not pre- or post-conditions).


                                 expansionInOCL(): the set of the OCL constructs used by the OclExpressions returned by computeOCLE().

Definition of the computeOCLE data set. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

Definition of the expansionInDS data set. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

Definition of the expansionInOCL data set. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           


                        MOF-OCL binding data sets: Metrics about the binding between the MOF structure and the OCL expressions:
                           
                              •
                              
                                 classInvariants(): Retrieves the invariants of a specific class of the metamodel.

Definition of the classInvariants data set. 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

Based on the defined data sets, we can compute the following metrics to answer our research questions.
                           Definition 3
                           Size of domain structure (SDS)


                           The size of a domain structure is the sum of the number of classes and the number of properties (i.e. attributes and association ends) in the metamodel. This is formally defined as follows:

Definition of the size of a domain structure (SDS). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

The number of invariants defined in OCL defined over the classes and its properties (i.e. attributes and association ends) of the metamodel. This is formally defined as follows:

Size of specified invariant set (SSIS). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

We count the number of elements in the subset of the specified invariants set that can be successfully parsed according to our reference OCL parser embedded in our metrics computation tool. This will be further detailed in Section 5.

Size of parsed invariant set (SPIS). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

This is the equivalent of the precedent metric at the class level. It is simply the count of invariants defined with a class as context.

Number of invariants defined by context (NIC). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

The complexity of an invariant i with respect to a domain structure IC_DS is the number of different roles defined in the domain structure that are used in i. IC is thus computed as the size of expansionInDS().

Definition of the invariant complexity w.r.t. a domain structure (IC_DS). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

This metric computes the number of different elements from the domain structure that are used in all the invariants of one class.

Definition of the class complexity w.r.t. a domain structure (CC_DS). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

The complexity of an invariant i with respect to the OCL language is the number of unique OCL constructs used in the invariant.

Definition of the invariant complexity w.r.t. OCL (IC_OCL). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

This is the number of unique OCL constructs that are used by all invariants of a class.

Definition of the class complexity w.r.t. OCL (CC_OCL). 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           

This section illustrates the computation of some of the metrics with the Petri nets example.
                           Example 1
                           Let ds be the Petri nets domain structure presented in Section 2. The value of SDS is calculated as follows:
                                 
                                    
                                       SDS
                                       (
                                       ds
                                       )
                                       =
                                       Set
                                       {
                                       
                                          PetriNet
                                       
                                       ,
                                       
                                          Node
                                       
                                       ,
                                       
                                          Arc
                                       
                                       ,
                                       
                                          Transition
                                       
                                       ,
                                       
                                          Place
                                       
                                       }
                                       −
                                       >
                                       size
                                       (
                                       )
                                       +
                                       Set
                                       {
                                       
                                          name
                                       
                                       ,
                                       
                                          name
                                       
                                       ,
                                       
                                          weight
                                       
                                       ,
                                       
                                          marking
                                       
                                       ,
                                       
                                          source
                                       
                                       ,
                                       
                                          target
                                       
                                       ,
                                       
                                          ingoings
                                       
                                       ,
                                       
                                          outgoings
                                       
                                       }
                                       −
                                       >
                                       size
                                       (
                                       )
                                       =
                                       13
                                    
                                 
                              
                           

Consider the invariants of Petri nets i1, i2, i3, i4. The value of IC_DS is calculated as follows:
                                 
                                    
                                       IC
                                       _
                                       DS
                                       (
                                       i
                                       1
                                       )
                                       =
                                       IC
                                       _
                                       DS
                                       (
                                       i
                                       2
                                       )
                                       =
                                       2
                                       IC
                                       _
                                       DS
                                       (
                                       i
                                       3
                                       )
                                       =
                                       IC
                                       _
                                       DS
                                       (
                                       i
                                       4
                                       )
                                       =
                                       1
                                    
                                 
                              
                           

Invariants i1 and i2 deal each one with two MOF properties, whereas i3 and i4 deal with one, therefore its complexity with respect to the domain structure is two and one respectively.

Consider the invariants of Petri nets i1, i2, i3, i4. The value of IC_OCL is calculated as follows:
                                 
                                    
                                       IC
                                       _
                                       OCL
                                       (
                                       i
                                       1
                                       )
                                       =
                                       |
                                       {
                                       
                                          OperationCallExpr
                                       
                                       ,
                                       
                                          PropertyCallExpr
                                       
                                       ,
                                       
                                          VariableExp
                                       
                                       }
                                       |
                                       =
                                       3
                                       IC
                                       _
                                       OCL
                                       (
                                       i
                                       2
                                       )
                                       =
                                       |
                                       {
                                       
                                          OperationCallExpr
                                       
                                       ,
                                       
                                          PropertyCallExpr
                                       
                                       }
                                       |
                                       =
                                       2
                                       IC
                                       _
                                       OCL
                                       (
                                       i
                                       3
                                       )
                                       =
                                       |
                                       {
                                       
                                          OperationCallExpr
                                       
                                       ,
                                       
                                          IntegerLiteralExpr
                                       
                                       ,
                                       
                                          PropertyCallExpr
                                       
                                       }
                                       |
                                       =
                                       3
                                       IC
                                       _
                                       OCL
                                       (
                                       i
                                       4
                                       )
                                       =
                                       |
                                       {
                                       
                                          OperationCallExpr
                                       
                                       ,
                                       
                                          IntegerLiteralExpr
                                       
                                       ,
                                       
                                          PropertyCallExpr
                                       
                                       }
                                       |
                                       =
                                       3
                                    
                                 
                              
                           

Answering our research questions requires a sample of metamodels from repositories in diverse backgrounds. Accessing such a sample proved from the start to be a challenge. There exist multiple open repositories,
                        1
                     
                     
                        1
                        The most extensive repository known to us is the AtlanMod Metamodel Repository, containing 305 metamodels.
                      but these contain exclusively metamodels without any well-formedness rules. There are very few metamodels making use of MOF and OCL for metamodeling. Data collection was thus an important step for our analysis.

Our sample data comes from standard bodies, academia and industry altogether. We collected standard metamodels from the OMG.
                        2
                     
                     
                        2
                        
                           http://www.omg.org
                        
                      For academic and industry metamodels, we asked the model-driven engineering community if it could provide data. We made a call for participation on the PlanetMDE mailing list dedicated to the dissemination of news and information about model-driven engineering, counting over 700 subscribers in July 2012. We received replies from Europe and North America, on the basis of which we constituted our academic and industry data sets.

We filtered our initial set of metamodels in order to keep the ones that could be automatically processed for analysis. As a first criterion for selection, we only considered metamodels that make use of OCL to define invariants. Additionally, we considered only modeling language specifications containing metamodels defined with formalisms aligned with the MOF standard. In some cases, we have got metamodels expressed in UML, which in turn conform themselves to MOF. Metamodels created with more complex mechanisms, such as UML Profiles, were not taken into account. Table 1
                      shows the studied specifications, each one containing one or more metamodels. We have divided our data samples in three groups according to their origin.


                     Standards community: The first group comes from the OMG. The OMG defines standards across several domains, such as object-oriented development, real-time systems and embedded systems, extending the boundaries of modeling to specific domains such as finance and healthcare. An OMG specification is a public, textual document proposed by the OMG to define one or more metamodels. The analyzed specifications are the following:
                        
                           •
                           
                              UML (Unified Modeling Language) version 2.2 [16]: It uses a structure of 13 packages to define different types of diagrams to represent the different views of a system, as well as the extension mechanism through profiles. Each one of these packages is regarded in this study as an independent metamodel. We consider the Ecore
                                 3
                              
                              
                                 3
                                 Ecore is an implementation of MOF provided by the Eclipse Modeling Framework 
                                    [17].
                               metamodels provided by the Eclipse UML2 project, version 3.0.1 [18]. To our knowledge, this project constitutes the best analyzable form of the UML specification openly available; it has been constructed according to the UML 2.2 specification.


                              MOF (Meta-Object Facility) version 2.0 [4]: The specification that created the standard for the exchange of metadata, therefore creating the language for metamodels themselves. It was created from the modeling foundations of UML and comprises two metamodels, Essential MOF (EMOF) and Complete MOF (CMOF).


                              OCL version 2.2 [5]: We analyze the specification of the OCL language itself, which contains four metamodels. An Ecore implementation of the four metamodels is available from the Eclipse OCL project [19]. We consider only the two metamodels that contain OCL invariants, namely OCL types and OCL expressions.


                              CORBA Component Model version 1.0 [20]: An Ecore implementation of the four metamodels in this specification is provided by the SourceForge CORBA project [21]. We introduced few minor modifications to align this metamodel with the one defined in the standard specification. OCL invariants are defined only for three metamodels, in which we focus for our analysis.


                              Diagram Definition (DD) version 1.1 [22]: Standard providing a basis for creating and interchanging graphical notations. It contains two metamodels: diagram common elements and diagram graphics.


                              Common Warehouse Metamodel (CWM) version 1.1 [23]: Specification to enable interchange of warehouse and business intelligence metadata between warehouse tools. It contains one metamodel, structured in 19 packages.


                     Academic research community: The following group presents metamodels taken from research in academic groups and projects.
                        
                           •
                           
                              B language metamodel created at IMAG.


                              SAD3 is a software architecture component model created at ENSTA Bretagne.


                              CPFSTool is a metamodel and tool developed for the specification of patterns for security requirements engineering at the University Duisburg-Essen.


                              Declarative Workflow is a metamodel describing an approach to define workflows in a declarative way. It has been developed with USE at University of Rostock and University of Bremen.


                              ER 2 RE is a metamodel describing a model transformation from an entity-relationship scheme to a relational model. It has been developed with USE at University of Bremen.


                              RBAC is a metamodel describing the Role-Based Access Control security standard. It has been developed with USE at University of Bremen.


                              HRC (Heterogeneous Rich Components) is a metamodel created within the European research project SPEEDS with the Kermeta metamodeling environment [24].


                     Industrial community: This group contains metamodels developed in enterprises using model-driven techniques for their software projects.
                        
                           •
                           
                              MTEP and XMS are metamodels created by Thomson Video Networks for encoding standards for video hardware.


                              SAM is a metamodel from the Topcased open source software project.


                     Table 1 details a list of standard specifications of modeling languages coming from different sources. Each specification contains one or more metamodels. The first two columns contain the name and group; the third column counts the number of metamodels. In the OMG group, specifications define large modeling languages, normally structured in packages, therefore we treat each one of these as a separate metamodel. In the remaining cases, each specification contains only one metamodel. The fourth column mentions the formalism used to express invariants. As expected, we chose specifications using OCL. The fifth column shows the different standards that exist to specify the domain structure. The sixth column presents the format for expressing invariants in OCL. These are found either as separate .ocl text files or embedded in .ecore as annotations. We present in Table 2
                      each one of the metamodels analyzed, assigning an ID that will be later used in the layout of our results.

We make available this set of metamodels based on MOF and OCL, as one of the contributions of our work, should the community wish to carry further studies involving metamodels expressed in both standards. They are available for download in the web page created for our study.
                        4
                     
                     
                        4
                        
                           http://diverse.irisa.fr/source-metamodels/
                        
                     
                  

We have developed a tool to automatically compute metrics on both parts of a metamodel and provide data for our empirical enquiry. All the metamodels we gathered had different formats. Thus, our measurement environment has a preprocessing step that transforms all these formats into a common one over which we compute metrics. The architecture of the tool is extensible through the definition of plug-ins to allow future experiments with metamodel formats that are not currently supported. This section presents the data flow for analysis as well as the global architecture of the tool.


                        Fig. 8
                         shows the overall process to analyze a metamodel. The process is composed of three activities with their own tools:
                           
                              1.
                              If the OCL invariants are not defined as a model conforming to the OCL metamodel (extension .oclxmi in Fig. 8), the first activity consists of parsing the invariants to build a model (activity OCL Parsing in Fig. 8) linked to the domain structure of the metamodel, which is given in the Ecore format, which is a lightweight implementation of MOF [17], providing equally an XMI-based persistence mechanism. Parsing must be defined depending on the input format of the OCL invariants (sixth column of Table 1).

The next step consists of using OCLMetrics, the tool we have developed to automatically compute the metrics over the metamodel (activity Metrics Computation in Fig. 8). OCLMetrics takes as an input the metamodel composed of the domain structure expressed in Ecore, and the invariants expressed in OCL. Then, OCLMetrics produces a CSV file containing all the metric values for the input metamodel.

The metric values are finally analyzed with R
                                 
                                    5
                                 
                                 
                                    5
                                    
                                       R, cf. http://www.r-project.org/
                                    
                                  (activity Statistical Analysis in Fig. 8). R is an open-source language for statistical applications, which provides several functionalities to run analysis and create plots, both one-variable and multi-variable. For metamodel analysis, we provide a set of generic scripts that could be used for any CSV file produced with OCLMetrics. These scripts automate the production of graphics (statistical charts in Fig. 8 in terms of bar plots, boxplots and treemaps) to help the metrics analysis over the metamodel.

Our metamodeling analysis environment has been designed with an extensible architecture. It has been developed as a set of plug-ins for Eclipse. Fig. 9
                         shows an extract of the architecture. The components of this architecture are the following.

This component realizes the preprocessing step specified in the previous subsection. It provides utilities for preprocessing the different possible formats:
                              
                                 •
                                 An extractor of OCL constraints from Ecore metamodels, using Xpath.

An extractor of OCL constraints from XMI files based on the UML schema, using Xpath.

An extractor of OCL constraints from XMI files based on the CMOF schema, using Xpath.

A transformer from MOF 1.1 to Ecore.

A transformer from CMOF (Complete MOF) 2.0 to Ecore.

A wrapper for the Eclipse OCL parser of individual constraints.

A wrapper for the Eclipse OCL parser of documents of constraints (.ocl files).

A wrapper of the Eclipse OCL persisting mechanism in order to save a parsed version of an OCL expression as an instance of the OCL abstract syntax metamodel (.oclxmi files).

A wrapper to the Kermeta Metamodel Pruner. This is an utility that allows the preprocessor to prune a metamodel to include only a set of required classes and properties given as an input. [25].

For our study, we have created loaders for each one of the specifications in our experimental setup; for example, the UML Metamodels Loader uses the preprocessing core׳s utilities to load the 13 UML metamodels. Each loader is an Eclipse plug-in that makes use of the extension point provided by the preprocessing core component. Every metamodel can define its MOF and OCL artifacts in a single file, a file for each, or multiple files for both. Each metamodel loader takes care of loading this set of files, and then it invokes the utilities in order to extract constraints, validate them and parse them, and then persist them in order to have them in the .oclxmi format, which is suitable to perform the metrics analysis.

In the case of specifications DWF, CSPF, ERRE, HRC, RBAC, MTEP, XMS, SAM, which provide the domain structure in a single .ecore file and define the integral set of invariants a single .ocl file, a single loader was built (called “OCL Document Loader”). Loaders for additional metamodels can be built to include them in the sample and run OCLMetrics on them. It only takes declaring the extension to the preprocessor core׳s extension point in the plug-in׳s configuration file.

In the figure, as an example the Corba Component Metamodel uses the service to extract the OCL invariants embedded in an Ecore file, as well as the parsing of each individual invariant and persistence. The RBAC Metamodel, as there was an available source file of OCL invariants as an .ocl file, uses the service of parsing such file type and secondly to persist them. Table 3
                            shows the used components by each one of the metamodel loaders.

At the root of the architecture, the OCLMetrics component makes use of the Preprocessing Core, because it depends on the output format of the metamodels (.ecore for the MOF part and .oclxmi for the OCL part) to perform the measurement of metrics. The data sets and metrics specified in the previous section were implemented in the OCLMetrics tool. OCLMetrics considers a domain structure defined in Ecore and the associated OCL. The tool can then analyze both parts of a metamodel, to automatically extract the data sets and compute the metrics.


                           Fig. 10
                            shows the class diagram of the OCLMetrics tool. For every analyzed metamodel, the main class MetricsAnalysis loads the domain structure (method loadEcoreMetamodel()) and the associated OCL invariants (method loadOCLInvariants()). MetricsAnalysis relies on the binding between MOF/Ecore and OCL as shown in Fig. 7 to load and manipulate the corresponding models. The tool uses the Ecore and OCL metamodels defined in the packages Ecore and OCL. The class MetricsAnalysis mainly defines data sets (reference datasets) and metrics (reference metrics) specified in the previous section. Each data set (class DatasetDefinition) is implemented in the method query() that computes the resulting collection for a given metamodel. A data set is used by a metric (class MetricDefinition) whose definition is implemented in the method compute().

This component also creates the following .csv files of data:
                              
                                 •
                                 
                                    TabAllInvariants: Table measuring the metrics at the invariant level; each record corresponds to an invariant, described by an identifier given by the metamodel where it is defined, followed by the context class and then an unique ID number. This is followed by all the metrics at the invariant level.


                                    TabAllClasses: Table measuring the metrics at the class level; each record corresponds to a class in a metamodel, described by an identifier given by the metamodel where it is defined and then an unique ID number. This is followed by all the metrics at the class level, which summarize all the invariants that have been defined with this class as context.


                                    TabAllMetamodels: Table measuring the metrics at the metamodel level; each record corresponds to a metamodel, describing all the metrics at the metamodel level, which summarize all the invariants that have been defined within this metamodel.

In this section we compute the metrics defined in Section 3 in order to answer our research questions, and discuss potential threats to validity.

@&#RESULTS@&#

For each question, we display some metrics relevant to the answer and comment the results.

To answer this question we run a preprocessing step of our analysis process on each metamodel. We learn that OCL invariants are not always syntactically correct, as a number of invariants do not pass the syntactic or semantic validation of the parser. Fig. 11
                            shows this phenomenon, comparing the size of the specified invariants set (SSIS metric) versus the size of the parsed invariants set (SPIS) that could not be parsed, for each metamodel.

When analyzing the 995 invariants of 33 metamodels, 567 were successfully parsed. Regarding the 428 invariants that could not be successfully parsed at first, in the case of 273 invariants we have been able to identify the source of the problem and we have fixed these invariants. This leaves us with a total of 840 parsed invariants. Throughout this process we have observed the following issues.


                           Different storage formats: Our data setup includes metamodels in different storage formats. Although they are all aligned with MOF, as seen in Table 2, different formats exist to express the domain structure, and we also realize there is no single standard format to store OCL expressions for a metamodel. Besides OCL text files, invariants are also added as annotations; however these only consist of maps of string-to-string entries, which can themselves present different schemas. Our preprocessing program automatically detects the format and proceeds to parse and produce the previously mentioned output.


                           Different OCL syntaxes: Different parsers allow or reject certain OCL constructs [11]. To enable automation analysis of the OCL expressions, such variations must be streamlined to satisfy the precise syntax required for Eclipse OCL; this was performed by replacing the unrecognized constructs by its accepted equivalents; for example, the use of the minus “−” operator to exclude elements from a collection, instead of the exclude operation.


                           Errors in invariants: In many cases, OCL invariants are added to a metamodel with the sole purpose of documentation and might not be checked syntactic validity. The studied sets of invariants from the selected specifications contained incorrect OCL expressions, containing errors from syntax (invalid use of OCL constructs) or semantics (references to non-existent model elements from the domain structure). Table 4
                            presents simple errors, which we could fix, as well as those that could not be fixed, since it would require knowledge from the domain expert.

Most of the 155 invariants that we could not fix do not parse because of pointers to properties or operations that do not exist in the domain structure. In some cases these properties were defined in previous versions of the domain structure and we do not know how or if they have been replaced in the version under study. One notable example can be found in the OCL Expressions modeling language (o2): it defines 14 invariants invoking the conformsTo operation, which does not exist in the OCL Expressions domain structure, but rather in a foreign imported package which is not available for the OCL parser to validate. Table 5
                            summarizes these uncorrected errors.

This determines our study with 840 invariants which were successfully parsed and analyzed. The rest of the research questions deal exclusively with this set of parsed invariants. It is also worth noting that the metamodels UML Composite Structures (uml6) and UML Components (uml10) do not contain any parsed invariant after the preprocessing phase, so the final number of analyzed metamodels is 31 instead of 33.

In order to answer this question, we look at the proportion of classes in the domain structure that serve as the context for the invariants. Each line in Table 6
                            displays the cumulated proportion of invariants defined on each percentile of domain structure classes. Every proportion is rounded to two decimal points. For example, for the OCL Types metamodel (“ocl1”), 17% of the invariants were defined on 10% of the classes; 30% of invariants are defined on 20% of its classes, and so on. In metamodels where the domain structure is not big enough to calculate a subset of metaclasses with a given percentile, a dash (‘–’) is given. The table is sorted from the most balanced metamodel (top line) to the most unbalanced. We observe that 23 out of 31 metamodels define their complete sets of invariants taking as context only 40% of classes from the domain structure. An interesting observation is found in column of percentile 25%; here we see that 25 metamodels define 80% or more of their invariants in a subset of only one quarter of classes of the domain structure.

Nevertheless, the table makes it clear that our sample of metamodels comprises both balanced and unbalanced metamodels. In the first case, we can see for the RBAC metamodel how its integral set of invariants is spread across 75% of classes of its domain structure. In the case of this domain, a dynamic security approach, a large majority of concepts need to be specified with invariants. In this version of this metamodel, three quarters of its concepts have associated invariants expressing rules for correct models of RBAC. On the other end, the SAD3 metamodel defines its whole set of invariants on only 10% of classes on its domain structure. However, when looking back at Fig. 11, we realize that the specified set of invariants is very small, forcing its invariants to be defined on a small subset of classes. In the case of another unbalanced metamodel, UML State Machines (uml9) show a case where invariants are spread across the domain structure but there is a concentration in a small subset of classes. This is because there are clearly concepts in the domain structure that carry a higher significance in the metamodel. In this case, the classes State, Transition, FinalState and Pseudostate are used as context of 26 invariants out of 42 defined in this metamodel. It is also noted, however, that the domain structure of this metamodel imports a large number of concepts of the UML infrastructure, which are not directly related to the State Machines domain but enlarge however the domain structure.


                           Fig. 12
                            displays the distribution of invariant complexities to the domain structure for each metamodel. For example, among the 42 invariants of UML State Machines (uml9) the least complex invariants use only one element (complexity 1) from the domain structure and the most complex ones use seven (complexity 7).

We observe that among 25 metamodels out of 31, their complexity varies between 1 and 8. Twelve metamodels define invariants with a complexity in the range of 1–4. Of all metamodels, the ER to RE transformation metamodel shows a special case of very complex invariants, the highest measure being of 38; this is due to the special purpose of the OCL expressions in this metamodel, which were constructed to specify the outcome of a model transformation. Also we can notice the specific case of UML State machines which defines two invariants of complexity 7 (0.84% of the analyzed invariants). Among all invariants, 87.62% have a complexity of 4 or below. This means that this percentage of the studied OCL expressions contain references to 4 or less model elements of the domain structure.


                           Fig. 13
                            provides another perspective on the complexity of invariants with respect to the UML State Machines metamodel. In this treemap, each class c of the metamodel is represented as rectangle, the area of the rectangle is proportional to the size of c.classContent() and the gray level corresponds to the 
                              c
                              .
                              CC
                              _
                              DS
                            (lighter for invariants of the class that use few elements of the domain structure, darker for invariants defined over many elements). Following the discussion from the preceding question regarding the fact of a few classes concentrating a big number of invariants, here we observe that few classes define invariants that strongly couple them to the rest of the domain structure. For example, Pseudostate and State define invariants which use 11 and 9 properties, respectively. These invariants belong also to the subset we identified in preceding question to carry a big part of the set of invariants. On the other hand, ProtocolConformance, Port, TimeEvent and Vertex present a class complexity of 0, either because their invariants do not invoke properties directly or because they do not define invariants. Invariants may also present a complexity of 0 when their body consists of the invocation on an operation on the same context (there is no direct invocation of properties).

We can emphasize two general observations about question 3: (i) there are strong variations in invariants complexities from one metamodel to the other, even if most of them (25/31) define simple invariants (complexity with respect to the domain structure (IC_DS) is lower than 8); (ii) when analyzing metamodels with complex invariants, it appears that there is also a strong variation in invariant complexities among classes and that few metaclasses concentrate the most complex invariants.


                           Fig. 14
                            shows the occurrence frequency of the different OCL expression types in the analyzable invariants defined within the metamodels under study. For example, in 840 invariants under study, we find 3423 occurrences of the OperationCallExp expression from OCL.

The navigation expressions OperationCallExp, VariableExp, PropertyCallExp are the most present expressions in the invariants we analyze. When adding the types TypeExp, IteratorExp, CollectionLiteralExp, EnumLiteralExp, BooleanLiteralExp, IfExp and IntegerLiteralExp we capture 98.60% of the OCL constructs present in the 840 invariants. Furthermore, 96.90% of these invariants rely only on these constructs, whereas only 3.1% make some use of the remaining expression types. This means that 96.90% of valid invariants in OMG specifications are expressed with 45.45% of the OCL (10 constructs out of 22 concrete expression types).

This unbalanced use of the OCL language might indicate several things. The low number of occurrences of string literals (StringLiteralExp), 22, might suggest a guideline to not use strings in invariant definitions. The low usage of ‘if’ expressions (IfExp) seems consistent with the previous observations of low IC_DS values for most invariants. Since ‘if’ expressions require at least three subexpressions (condition, ‘then’ and ‘else’), it is very unlikely to find an invariant using ‘if’ with a complexity lower than 2. One particular type of expression, OperationCallExp, deserves special attention since due to its nature of an expression used to invoke an operation, and different operations are called among the matched occurrences. Fig. 15
                            shows the frequency of the called operations. The most important observation comes from the fact that the most invoked operation, eContainer(), does not belong to the official OCL specification. It is a helper operation defined by some OCL interpreters, among which Topcased, which allows us to navigate the composition relationships, by being called on the composed object. This is perhaps an indication that more versatile operations to navigate through the different types of relationships between object are needed in the OCL specification. The figure also shows some frequent operations such as getInputFlow() or getOutputFlow() are ad hoc operations added to certain metamodels, in this case UML, by the domain expert to ease the expression of well-formedness rules.

From another perspective, Fig. 16
                            shows a treemap for the CC_OCL metric on the UML State Machines classes. We observe that the usage of the OCL is different from one class to the other. For instance, the invariants in Region use the largest number of OCL expression types, which correspond to the eight types mentioned above.

Our study was conducted as accurately as possible, given the inputs specified in Section 4, with the aforementioned assumptions. Nevertheless, we identify here possible construction, internal and external threats to validity.


                        Internal threats lie on the source of the empirical data. For the industrial and academic groups, the main source of data was a call for participation in the PlanetMDE mailing list. As the premier mailing list of practitioners from industry and academia in the Model-Driven Engineering world, we can assert the representativeness of this population. Furthermore, in these groups the developers constructing the metamodel can present levels of expertise ranging from beginner to expert, and thus this might influence greatly on the quality of the metamodels. This is less threatening in the case of the standards group, as all standards come from the OMG, the organization that created the MOF and OCL themselves, and furthermore accounts for great experience in the creation of domain models [26]. For the standards group, we have examined three OMG specifications based on the availability of machine-readable files. In some cases we manually edited these files to be able to process them by our tools; this manual step is prone to errors. Likewise, the process of fixing constraints was performed respecting the intentions of the specification writers, albeit it remains a human process subject to errors. Since we seized metamodels available from the web, we have no pointer about the skills of the developers who have written the invariants. It is possible that well-trained modelers could write more complex invariants, or use a larger portion of the OCL.


                        Construction threats lie in the way we define our metrics and their measurement. The way we have defined metrics to answer our research questions responds to our own judgement on how to measure this phenomena. However, another choice of metrics and statistical descriptive analysis may yield different results and consequently produce different conclusions. Validity of our results could also be affected by analysis and calculations performed by our program OCL Metrics. Although the algorithms were designed to follow precisely the metric definitions presented in Section 3, and integrally analyzed the abstract syntax tree of each invariant, subtleties and assumptions made by the underlying tools (particularly Eclipse OCL) are the subject of possible bias. Our metrics result might be too coarse grained to draw pertinent conclusions, and other metrics might be better fitted for this purpose.


                        External threats lie on the statistical significance of our study. In industry group, we only have 3 metamodels; however they contribute a total of 172 invariants to our base. We acknowledge that we have only observed 840 syntactically valid invariants. We do not know to what extent this can be generalized to invariants that define languages from other domains.

@&#RELATED WORK@&#

To our knowledge, there has not been another study on the articulated usage of MOF and OCL for metamodeling. On the OCL side, a very important effort has been made by Gogolla et al. [11] when analyzing different OCL environments (both parsing and checking), to find the different implementations that have been made of the standard. Although an important contribution that motivated our research question about the usage of OCL constructs, the study does not go into surveying practices in modeling or metamodeling.

Our work emerges from a need to better understand metamodeling practices. We focus on the conjunct usage of OCL and MOF, but there are many other activities for metamodeling. For example, some works explain processes to build a metamodel that generalizes a set of existing metamodels in a given domain. Beydoun et al. [27] discuss the mix of top-down and bottom-up process they have followed to build a generic metamodel for multi-agent systems, starting from a set of existing metamodels in this domain. Monperrus et al. [28] define a systematic process to build a requirements metamodel with an explicit measurement purpose.

In this study we have considered metamodels defined with implementation of OMG standards, such as Ecore for Essential MOF and USE for UML. However, it should be noted that other implementations of these standards also exist, such as the Generic Metamodeling Environment (GME) [29] which is also based on MOF. Another popular metamodeling environment is MetaEdit+, a commercial tool that provides an integrated tool suite to define metamodels and automatically generate end-user model editors [30].

Regarding the definition, formalization and implementation of metrics on models, extensive work exists in the field of metrics for UML modeling as an activity in object-oriented analysis and design. The goal is to assess model quality, either at the model level or the metamodel level.

At the model level, Gronback provides a list of metrics and recommended value ranges to ensure model quality, called “audits” [31]. In future work, we plan to establish a set of guidelines based on the metrics presented in our study, that assist the application of the best practices for metamodeling. Lange et al. [32] focus on the quality of software development processes relying on UML models, and as such they propose a set of metrics on modeling artifacts. It is interesting how some of these metrics, such as the count of model elements and class complexity have a relationship to metrics in our study, namely SDS and IC_DS respectively. In earlier work of the same authors, they perform empirical analysis on a sample UML models, and propose a quantitative measuring of the completeness of a software design with UML models. They assess diagram well-formedness and completeness, and inter-diagram consistency [33].

At the metamodel level, the OMG has proposed the structured metrics metamodel [34], and Monperrus et al. [35] propose an approach for the definition of metrics at the meta level, associated to a generative approach, which provides a measurement tool on models. It is completely model-driven, so the definition of metrics is a model itself that is coupled to the user׳s metamodel, and allows the automatic generation of a measurement tool to be executed in the user׳s models.

Another work at the metamodel level, Hein et al. [36] propose a set of generic metrics written in OCL which are evaluated on the user׳s metamodel.

It should be noted though that the motivation of all these works is model quality, and as such the metrics suggested by these works are mostly an adaptation of the metrics of the Object-Oriented Programming world adapted to models. However, there exists no metrics approaches with the goal of measuring and understanding the usage of languages such as MOF and OCL forming complex structures. Furthermore, there exists no approach regarding the usage of two articulated formalisms. Nevertheless, McQuillan et al. [37] discuss the challenges in definition and implementation of metrics across different viewpoints throughout different abstraction levels of a software system. This was our case when creating metrics for the different views of a metamodel, namely the object-oriented structure and the logic-based well-formedness rules.

Metrics about usage of language constructs have also been developed for empirical studies in software engineering, albeit not in the model-driven engineering world. For instance in [38] the authors focus on language grammars, and explore different proposals of metrics to measure the quality and complexity of these grammars. It is also worth noting Muñoz et al. [39], where the authors measure the usage of features offered by aspect-oriented programming languages in open source projects.

@&#CONCLUSION@&#

Model-driven engineering encourages domain experts to embody their knowledge in the form of a metamodel. This metamodel can serve to define the valid structure of all models in the domain. However, experts who wish to precisely specify the scope of their domain have to master two different formalisms for metamodeling: an object-oriented, MOF-compliant, language to model the domain structure and a logic-based language to add rules that further specify the structure of models. The conjunct usage of two languages for metamodeling represents a major challenge, which is not currently supported by methodologies or best practices.

The intuition of this work is that a systematic observation of practices in different areas can provide hints on how these two languages are used together. We have performed an empirical enquiry of the conjunct usage of OCL and MOF in 995 invariants over 33 metamodels. We have made available this collection of data to provide the community with an openly available benchmark to carry further experiments on MOF and OCL. Our analysis was based on a new set of metrics, which reveal various aspects of the coupling and scattering of OCL rules in the metamodels. We formally defined these metrics and embedded them in an extensible tool that automates the analysis over metamodels stored with different formats.

We observed that domain experts tend to identify a small set of essential concepts in their domain structure in the context of which they express most well-formedness rules. We also observed that well-formedness rules are loosely coupled to the metamodel, i.e. most of the rules are defined over less than five concepts of the domain structure. Despite this low coupling, we also observed that the usage of two languages hinders maintenance tasks in metamodeling: 155 OCL invariants out of 995 could not be analyzed because they did not match with the MOF structure anymore. Although OCL became the de facto formalism to express well-formedness rules over MOF-compliant structures, this is not the initial intent of the language. Consequently, we observe that a significant portion of the language is never used in well-formedness rules: 10 out of 22 constructs of the concrete syntax were never used to define our observed set of invariants.

This survey indicates that the conjunct use of OCL and MOF is a difficult task and that experts are more or less likely to master OCL׳s logic for precise metamodeling. Based on our findings, we propose the following actionable outputs for practitioners:
                        
                           •
                           Our main advice we propose for metamodeling stakeholders is the throughout checking of metamodel specifications, containing both metamodel and well-formedness rules, with the help of a syntax checking tool, validating both the correct usage of the OCL language syntax and the syntactically correct usage of the modeling elements found in the underlying domain structure.

Our set of MOF-OCL metrics can be used for comparative analysis for the expert׳s well-formedness rules. One could be interested, for instance, in comparing two sets of metrics where one contains a majority of expressions defined for a specific metaclass as their context, and the other where their contexts are scattered throughout the metamodel, and evaluate how choosing one of these two approaches affects the complexity with respect to the domain structure, making them more or less understandable for users of the metamodel, and so on.

We realize that OCL is a very rich language, oftentimes exceeding the needs of writing well-formedness rules. We have identified the effective subset of the language that new practitioners unfamiliar with OCL are required to learn in order to express these rules. Likewise, a supporting tool focused only on this subset would greatly simplify work for these practitioners.


                     Future work: As a next step for this analysis we plan to look for patterns in the usage of OCL for metamodel invariants. Recurring patterns could be used to assist the development of new metamodels and provide concrete guidelines for precise metamodeling. Such guidelines could help mature the capitalization of knowledge in a metamodel similarly to the work of Mernik et al. for domain-specific programming languages [40]. It is equally important to explore the topic of metamodel reusability. Since reuse is a main concern in model-driven engineering, we need to assess the question whether well-formedness rules improve or hinder the reusability of a model, what issues could arise and how to tackle them by means of our tooling solution proposed in this work.

@&#ACKNOWLEDGMENTS@&#

The authors wish to thank Jens Brüning, Bastien Coatanéa-Gouachet, Pierre Gaufillet, Prof. Martin Gogolla, Akram Idani, Mirco Kuhlmann, Holger Schmidt, for their valuable contribution to our study with data subjects. We also thank James Hill, Bran Selic, Juha-Pekka Tolvanen and Fabian Buttner for their support about this study. Special thanks to Véronique Thelen, associate professor in the Economy Department of University of Lille 1, for her helpful advice on our quantitative analysis.

@&#REFERENCES@&#

