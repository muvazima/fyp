@&#MAIN-TITLE@&#Morphology-preserving smoothing on polygonized isosurfaces of inhomogeneous binary volumes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We design an effective mesh smoothing framework that focuses on medical data.


                        
                        
                           
                           The LSQ gives an isosurface mesh a compact approximation to the underlying surface.


                        
                        
                           
                           We improve the staircase detection strategy by a novel cascaded operation.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mesh smoothing

Morphology preservation

Local spatial quadrics

Polygonized isosurface

Binary volume

@&#ABSTRACT@&#


               
               
                  Polygonized isosurfaces of anatomical structures commonly suffer from severe artifacts (e.g., noise and staircases), due to inhomogeneous binary volumes. Most state-of-the-art techniques can reduce these artifacts but inevitably ruining anatomical structures’ morphology. Given an initial polygonization of an isosurface, we first eliminate these apparent staircases based on a context-aware Laplace filter, and then solve the morphology-preserving problem of anatomical structures as an optimization of the local spatial quadrics (LSQ) of fitted Bézier surfaces during mesh evolution. This results in a conceptually simple approach that provides a unified framework for not only handling artifacts, but also for enabling the morphology preservation of anatomical structures.
               
            

@&#INTRODUCTION@&#

Constructing morphologically accurate surface models for human organs is essential for medical applications. However, the process of generating isosurface polygonizations (usually represented by triangular meshes) of those anatomical structures of organs undergoes a series of sophisticated steps. For example, the physical object is first non-uniformly sampled into volume data by CT or MRI scans for less radiation exposure to patients. The volume data is commonly with resolutions varying from 128×128×64 to 512×512×400, whereas the resolution is much finer in the imaging plane than in the orthogonal direction. Second, the region of interest (ROI) is acquired by segmenting the raw volume to the binary volume based on their values (e.g., parenchyma with 
                        20
                        ≤
                        H
                        U
                        ≤
                        70
                     , and bones with 
                        H
                        U
                        ≥
                        1000
                      in CT). However, the ROI often possesses complex heterogeneous tissues at various scales, and the boundaries between neighboring tissues are sometimes indistinguishable because of similar intensity values. Thus, the polygonization extracted by isocontouring the inhomogeneous binary volume possibly contains severe noise and staircases.

A straightforward way to remove staircases is to first interpolate enough intermediate slices in the scanning direction (also called image slices direction) of CT or MRI scans to generate a volume with higher resolution. Using these interpolated volumes in the current clinical routine requires large storage and computational resources. Reducing staircases and noise during the image processing stage (e.g., image smoothing) or the isosurface extraction stage (e.g., improved Marching Cubes (MC)) is also possible, but it is likely to introduce significant loss of morphological features in the created 3D model of anatomical structures.

Mesh smoothing is a common strategy to remove noise and other related artifacts for surface models. The most obvious problem of existing mesh smoothing techniques is the inability to deal with staircases. For example, classical isotropic filters remove staircases at the expense of introducing additional artifacts, such as shape distortion and volume shrinkage, while feature-preserving approaches do avoid these side effects, they will easily perceive staircases as features and incorrectly maintain them. This becomes a critical issue when we are designing our approach to eliminate these feature-like artifacts. Fig. 1
                      shows these drawbacks of two existing filters: Laplace filter may lead to volume shrinkage and shape distortion, while the bilateral normal filter cannot eliminate staircases effectively. Recently, researchers attempted to solve these artifacts by carefully selecting existing filters [1] or by adapting some of them [2]. In general, these efforts were still based on the traditional smoothing framework, which cannot completely avoid the aforementioned disadvantages.

We present a novel mesh smoothing approach for preparing morphology-preserving isosurfaces from inhomogeneous binary volume data. The effectiveness of our approach stems mainly from a new formulation local spatial quadrics (LSQ), which encodes the deviation of the mesh normals from the locally fitted surface normals. Thus, minimizing LSQ can yield a compact mesh where each triangle is tangent to the fitted underlying surface of the anatomical structure. That is why we can restore a defective isosurface mesh to its original appearance.

Generally, we need to know the underlying surface before formulating LSQ. The isosurface mesh of the anatomical structure often possesses sophisticated geometry and topology, and suffers from noise and staircases. Fortunately, it can be approximated patchwisely. Here the biquadratic Bézier surface fitting [5] is exploited to approximate the surface patch around each mesh vertex. Whereas, because of the superiority on morphology preservation of the fitting technique used, the staircases would be maintained as well. Thus, it is necessary to detect and eliminate the staircases before fitting the surface. If we know the image slices direction in advance from the volume data (this is not recommended because the isosurface mesh may be re-aligned with another coordinate system) or can at least estimate the direction from the isosurface mesh, the staircases as pseudo-features can be detected. The main contributions of this paper are two-fold.


                     
                        
                           -
                           We design an effective mesh smoothing framework that focuses on polygonized isosurfaces of inhomogeneous binary volumes.

We formulate the 
                                 L
                                 S
                                 Q
                              , which gives the polygonized isosurface a compact approximation to the underlying surface of the anatomical structure.

Our algorithm consists of two steps: (1) staircase identification and elimination, and (2) morphology-preserving smoothing. Fig. 2
                      provides a schematic illustration of the pipeline in 2D. Fig. 2(a) shows an isosurface mesh by employing conventional approaches, which has a poor approximation quality (see the polygonization) of the underlying surface. Fig. 2(b) shows the result after performing our improved staircase-sensitive Laplace filter, most staircases are removed, but the morphology of the underlying surface is still not well-recovered. After fitting local surfaces with a biquadratic Bézier surface (Fig. 2(c)), projecting facet centroids onto the fitted Bézier surfaces (Fig. 2(d)) and constructing tangent planes at the new positions of these facet centroids (Fig. 2(e)), we determine the optimized vertex positions by formulating LSQ, which encodes the sum of squared distances from a vertex to the tangent planes at its neighboring facet’s new centroids. Thus, our approach can produce a compact approximation to the underlying surface with its morphology well preserved (Fig. 2(f)).

Staircase is a special artifact that commonly appears in a medical mesh extracted from binary volumes due to resolution inhomogeneity. It ordinarily presents as sharp edges and corners, which are, unfortunately, also the important characteristics of morphology and anatomy of the organ. To solve this problem, we first distinguish staircases from morphological features and eliminate them using a staircase-sensitive Laplace filter.


                        Staircase identification. Möench et al. proposed to identify and remove staircases based on an estimation of the image slices direction  [2]. The limitations are two-fold. First, the image slices direction is difficult to be estimated in the presence of noise. Second, it may obtain a wrong direction when the number of staircases is relatively small on the mesh, since it heuristically selects the vector with maximum facets being almost perpendicular to it as the direction.

In our method, we first employ a fast and effective feature-preserving normal filter  [3] to denoise the facet normal field on the mesh so that the negative effects on feature detection from noise can be avoided. (Note that we just perform the normal filtering to denoise the facet normal field while not actually updating vertex positions.) Then, we apply the normal tensor voting technique  [6] to classify the vertices into three types: face, sharp edge and corner. The vertices associated with sharp edges and corners are temporarily considered as features. Then, the associated facets of these detected feature vertices are used to determine the image slices direction according to  [2]. In detail, we 
                           
                              (i)
                              project all facet normals associated with feature vertices into a unit sphere;

calculate the density of each normal by counting the number of normals within a given radius 
                                    r
                                  (with default value 0.1);

cluster the normals with the region-growing algorithm;

consider the centroids of clusters as candidate image slices directions;

select the centroid which maximizes the total sum of all relative facet direction 
                                    
                                       
                                          θ
                                       
                                       
                                          
                                             
                                                f
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                  as the image slices direction.

Compared with  [2], as we just exploit the facets associated with features rather than all facets of the mesh, the calculation of the image slices direction becomes robust. Finally, we perform an automatic identification on vertices to determine if they are real staircase vertices. Our identification method is based on the fact that morphological feature vertices are often sparse and the facet normals associated with these vertices are randomly distributed  [7]. In contrast, a staircase vertex commonly has at least one of its associated facets perpendicular to the image slices direction. In this regard, we can assume that if a feature vertex has more than one associated facet perpendicular to the image slice direction, it is a staircase vertex.

In case that a feature vertex has only one perpendicular facet, we will double check with the direction change of the vertex. It is about the difference between the maximal and the minimal direction of the associated facets. For a typical staircase vertex, the biggest dihedral angle of all associated facets would be equal to 90°, and the direction change is 1. In practice, we allow imperfect staircase vertices, so that the direction change can tolerate a prescribed error. In our experiments, the empirical value 0.7 works well for all tested models. As a result, staircase vertices can be decoupled from real morphological features (see Fig. 3
                        ).


                        Staircase-sensitive Laplace filter. We adopt a non-uniform staircase-sensitive Laplace filter to eliminate the detected staircases. In the filter, we assign an adaptive factor for each mesh vertex according to the distance between the considered vertex and the closest staircase vertex to it. It is formulated as: 
                           
                              (2)
                              
                                 ∀
                                 v
                                 ∈
                                 V
                                 :
                                 
                                    
                                       v
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 v
                                 +
                                 
                                    
                                       
                                          
                                             λ
                                          
                                          
                                             v
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             u
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         v
                                                      
                                                   
                                                
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                       
                                       
                                          
                                             ω
                                          
                                          
                                             u
                                             v
                                          
                                       
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       u
                                       ∈
                                       
                                          
                                             N
                                          
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   v
                                                
                                             
                                          
                                       
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       u
                                       v
                                    
                                 
                                 
                                    (
                                    u
                                    −
                                    v
                                    )
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 v
                              
                              
                                 ′
                              
                           
                         is the new position of 
                           v
                        ; 
                           
                              
                                 ω
                              
                              
                                 u
                                 v
                              
                           
                         is the Laplace weight; 
                           
                              
                                 λ
                              
                              
                                 v
                              
                           
                         is the adaptive factor and the 
                           
                              
                                 N
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       v
                                    
                                 
                              
                           
                           
                              (
                              1
                              )
                           
                         is the 1-ring neighborhood of vertex 
                           v
                        . We applied the cotangent Laplace weights 
                           
                              
                                 ω
                              
                              
                                 u
                                 v
                              
                           
                         in our filter, as the commonly used uniform weights 
                           
                              
                                 ω
                              
                              
                                 u
                                 v
                              
                           
                           =
                           1
                         may yield strong tangential shifts when a lot of staircases exist.

The adaptive factor is defined as 
                           
                              (3)
                              
                                 ∀
                                 v
                                 ∈
                                 V
                                 :
                                 
                                    
                                       λ
                                    
                                    
                                       v
                                    
                                 
                                 =
                                 1
                                 −
                                 
                                    
                                       
                                          
                                             d
                                          
                                          
                                             v
                                          
                                       
                                    
                                    
                                       
                                          
                                             d
                                          
                                          
                                             
                                                max
                                             
                                          
                                       
                                    
                                 
                              
                           
                         where 
                           
                              
                                 d
                              
                              
                                 v
                              
                           
                         is the Euclidean distance from 
                           v
                         to the nearest staircase vertex, and 
                           
                              
                                 d
                              
                              
                                 
                                    max
                                 
                              
                           
                         is the largest one of all these 
                           
                              
                                 d
                              
                              
                                 v
                              
                           
                        . According to the definition, 
                           
                              
                                 λ
                              
                              
                                 v
                              
                           
                           =
                           1
                         when 
                           v
                         is a staircase vertex, and the filter becomes original Laplace filtering, so that those staircases will be removed after a few iterations. The value of adaptive factor 
                           
                              
                                 λ
                              
                              
                                 v
                              
                           
                         is gradually decreasing when the vertex is farther away from staircase areas. Once 
                           
                              
                                 λ
                              
                              
                                 v
                              
                           
                         reduces to 0, the vertex will not be updated.

To further enhance the smoothness of the isosurface mesh while preserving its local morphology, we first use biquadratic Bézier fitting to estimate its local underlying surfaces and then update mesh vertices based on these surfaces. Biquadratic Bézier surface fitting is an efficient technique for accurate surface estimation, and is resilient to irregularity in triangulation  [5]. Thus, it is suitable for medical meshes with important features and many irregular triangles caused by the inhomogeneity of binary volumes. Moreover, biquadratic Bézier fitting is flexible because of more degrees of freedom (
                           9
                           ×
                           3
                           =
                           27
                         coefficients), and it is easy to add smoothing constraints.

The biquadratic Bézier surface is described as 
                           
                              (4)
                              
                                 f
                                 
                                    (
                                    u
                                    ,
                                    v
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       0
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       0
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 
                                    
                                       B
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    u
                                    )
                                 
                                 
                                    
                                       B
                                    
                                    
                                       j
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    v
                                    )
                                 
                                 ;
                                 
                                 u
                                 ,
                                 v
                                 ∈
                                 
                                    [
                                    0
                                    ,
                                    1
                                    ]
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 B
                              
                              
                                 i
                              
                              
                                 2
                              
                           
                           
                              (
                              u
                              )
                           
                           ,
                           
                              
                                 B
                              
                              
                                 j
                              
                              
                                 2
                              
                           
                           
                              (
                              v
                              )
                           
                         are Bernstein basis functions, and 
                           
                              
                                 b
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                         are the Bézier control points which form the Bézier control net. To guarantee the fitted surface to be as well-behaved as possible in the vicinity of the central vertex, we use its 2-ring vertex neighbors as the local surface patch for the least squares system. As noise will affect robustness of the fitting, a constraint  [5] is considered during the fitting.

Ideally, each mesh facet should be approximately tangent to local Bézier surfaces and each mesh vertex should be as close as possible to local Bézier surfaces, making the optimized mesh better approximate the underlying surface. Thus, we formulate vertex position update as an optimization of the LSQ. The optimization procedure is detailed as follows.

The unit normal and the tangent plane at a point 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                         on the fitted biquadratic Bézier surface are given by 
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           =
                           
                              
                                 ∇
                                 f
                                 
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                              
                                 
                                    ‖
                                    ∇
                                    f
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    ‖
                                 
                              
                           
                         and 
                           m
                           
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           ⋅
                           
                              (
                              p
                              −
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           =
                           0
                        , where 
                           ∇
                         is the symbol of gradient, 
                           f
                         is the biquadratic Bézier function, and 
                           p
                         is an arbitrary point in the tangent plane. To define the quadrics, we first project centroids 
                           
                              
                                 c
                              
                              
                                 i
                              
                           
                         of the central vertex’s 1-ring neighboring facets onto the fitted biquadratic Bézier surface. We attempt to find a sample point 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                         on the surface which minimizes the distance 
                           
                              ‖
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              −
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              ‖
                           
                        . This optimization problem can be solved by various numerical methods (e.g., the gradient descent method).

After obtaining all projection points 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                         of centroids of 1-ring neighboring facets, the quadrics of the central vertex 
                           v
                         can be formulated as: 
                           
                              (5)
                              
                                 ∀
                                 v
                                 ∈
                                 V
                                 :
                                 L
                                 S
                                 Q
                                 
                                    (
                                    v
                                    )
                                 
                                 =
                                 ∑
                                 
                                    
                                       
                                          (
                                          m
                                          
                                             (
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          ⋅
                                          
                                             (
                                             v
                                             −
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          )
                                       
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                         where 
                           V
                         is the set of mesh vertices. Note that the 
                           L
                           S
                           Q
                         encodes the sum of squared distances from a vertex to its neighboring tangent planes at the projection points on the surface. Finally, the optimal position for each vertex is obtained by solving 
                           d
                           L
                           S
                           Q
                           
                              (
                              v
                              )
                           
                           /
                           d
                           v
                           =
                           0
                        , which is a simple linear system. The optimal position is finally transformed to global coordinate system according to the inverse matrices obtained when fitting the biquadratic Bézier surface.

In total, a new vertex position is produced by 
                           
                              
                                 
                                    [
                                    
                                       
                                          
                                             (
                                             s
                                             t
                                             e
                                             p
                                             
                                             1
                                             )
                                          
                                       
                                       
                                          
                                             
                                                n
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    +
                                    s
                                    t
                                    e
                                    p
                                    
                                    2
                                    ]
                                 
                              
                              
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        , where 
                           s
                           t
                           e
                           p
                           
                           1
                         is the staircase-sensitive Laplace filter, and 
                           s
                           t
                           e
                           p
                           
                           2
                         is the vertex optimization, and 
                           
                              
                                 n
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                         are the iteration numbers. By iterating this process for all vertices, we gradually obtain quality smoothing results. To demonstrate the effectiveness of our two-step approach, we compare it with one that only uses the first step. Fig. 4
                         gives an example of the right kidney model to demonstrate the effectiveness of the collaboration of the two steps. We notice that, if only performing the first step, annoying staircases and noise remain even with the iteration number 
                           n
                           =
                           16
                        . However, the two-step approach can produce more desirable results, compared to the reference surface.

@&#RESULTS AND DISCUSSION@&#

We have tested our algorithm on a variety of human structures, and illustrated several typical examples here, namely, pathological pancreas (Fig. 5
                     ), liver (Fig. 6
                      top), bone (Fig. 6 middle), and portal vein (Fig. 6 bottom). Isosurface meshes extracted from those medical imaging data follow close to the current clinical routine. That is, the volumes are segmented semi-automatically and the resulting binary masks are dilated. Thereafter the contour information is used to mask the intensity data and the traditional MC algorithm is used to extract the isosurface mesh from the masked data. From Figs. 5–6 we can see, both the pathological pancreas and bone models possess geometry details (smoothing features), the liver model is nearly smoothing everywhere, and the portal vein model has complicated and thin structures. In order to more objectively evaluate the smoothing results, the masked intensity data is resampled to isotropic voxel dimensions using cubic B-spline interpolation, and then used to generate a high resolution MC model which serves as a reference surface.

Three outstanding mesh smoothing techniques are implemented for comparisons, namely Taubin’s 
                        λ
                        |
                        μ
                      filter  [8], Vollmer et al.’s HC+Laplacian filter  [9], and Wang et al.’s surface fitting technique  [1]. To allow for a fair comparison, we have improved 
                        λ
                        |
                        μ
                      filter and HC+Laplace filter as suggested in  [2], so that they can somehow eliminate staircases while avoiding leading to a large shape distortion.


                     Parameters setting. We carefully tune parameters for each approach to produce the best results. Taubin’s 
                        λ
                        |
                        μ
                      filter represents a combination of two Laplace-like filters, one with a positive weighting factor 
                        λ
                      and one with a negative factor 
                        μ
                      that are executed alternatingly. The 
                        μ
                      is set to 
                        μ
                        =
                        −
                        1.02
                        λ
                      as suggested by Taubin. Thus, there are three parameters 
                        
                           (
                           λ
                           ,
                           μ
                           ,
                           n
                           )
                        
                      in the 
                        λ
                        |
                        μ
                      filter (
                        n
                      denotes the iteration number). Similar to 
                        λ
                        |
                        μ
                      filter, Vollmer et al.’s HC+Laplace filter also has a smoothing step 
                        α
                      and a backward moving step 
                        β
                      that are alternately executed for better preserving the volume. As inspired by Vollmer, 
                        α
                      is set to 
                        α
                        =
                        0
                     , so that mesh vertices can be only moved back to their previous positions, and 
                        β
                      is set to 
                        β
                        =
                        0.2
                     , so that the own displacement vector contributes with a factor of 0.2 and the mean displacement vector of the neighboring vertices with a factor of 0.8 to the backward movement. Thus, it has three parameters 
                        
                           (
                           α
                           ,
                           β
                           ,
                           n
                           )
                        
                     . Wang et al.’s surface fitting generally only has one parameter 
                        n
                      which needs to be adjusted. In our approach, we mainly have 2 parameters (
                        
                           
                              n
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              n
                           
                           
                              2
                           
                        
                     ) which need to be adjusted. Since input isosurface meshes often have different levels of noise and staircases, and automatically estimating the level is an ill-posed problem, like other smoothing approaches, we let the user control the number of iterations to reduce the artifacts to a desired level. The assigned values for different data set and different methods are listed in Table 1
                     . Particularly, we find that 
                        
                           
                              n
                           
                           
                              1
                           
                        
                        ∈
                        
                           [
                           2
                           ,
                           5
                           ]
                        
                      and 
                        
                           
                              n
                           
                           
                              2
                           
                        
                        ∈
                        
                           [
                           4
                           ,
                           20
                           ]
                        
                      are good choices for most cases of our approach.

Our experiments are preformed with the criteria that only a small volume shrinkage is allowed. It is particularly important for preserving morphological features, as inaccurate volume of human organs would cause significant errors in medical simulations and operations. With this consideration, we restrict the volume change ratio to a pre-specified range, which is bounded in [99%–101%]. Here the volume change ratio is measured by computing the change of volume in the smoothed result to that of the reference surface.


                     Visual comparison. The improvement in visual quality of our results shown in all mesh models is obvious. As illustrated in the MC results of Figs. 5–6, the isosurface meshes extracted from binary volume data contain a great variety of artifacts and the curvature distribution (see the mean curvature visualization of portal vein model) is highly inhomogeneous due to the artifacts. The smoothed meshes with our method clearly show that the staircases are eliminated. All previous methods either are not able to produce desirable results that fully remove staircase patterns or even introduce new artifacts such as shape distortion.


                     Quantitative comparison. To provide a quantitative comparison of the results, we measure the Hausdorff distance between the smoothed surface and the reference surface. Fig. 7
                      shows the results, where the horizontal axis is the absolute distance value between the smoothed surface and the reference surface, and the vertical axis is the corresponding histogram (in percentage) with respect to each distance. From the figure, we notice that our approach consistently leads to smaller Hausdorff distances than all previous approaches. This indicates that our approach yields a closer surface in terms of the reference surface.


                     Time performance. Our method is implemented using C++ and the experiments are performed on a PC with a 2.90 GHz Intel core i5 and 8.0 GB of RAM. The method is relatively time-consuming, especially when the model contains a large number of vertices. For example, it takes around 7.2, 0.28, 6.66, and 1.87 min on Liver 
                        
                           (
                           
                              |
                              V
                              |
                           
                           :
                           330364
                           ,
                           
                              |
                              F
                              |
                           
                           :
                           660724
                           )
                        
                     , Pathological pancreas 
                        
                           (
                           
                              |
                              V
                              |
                           
                           :
                           7030
                           ,
                           
                              |
                              F
                              |
                           
                           :
                           14056
                           )
                        
                     , Bone 
                        
                           (
                           
                              |
                              V
                              |
                           
                           :
                           310006
                           ,
                           
                              |
                              F
                              |
                           
                           :
                           619260
                           )
                        
                     , and Portal vein 
                        
                           (
                           
                              |
                              V
                              |
                           
                           :
                           86752
                           ,
                           
                              |
                              F
                              |
                           
                           :
                           173515
                           )
                        
                      respectively. In future, we will attempt to implement some computations on GPUs for performance improvement.


                     Application in surgical simulation. Interventional radiology (IR) is widely used in the treatment of cardiovascular disease. Computer-based training simulators of IR provide solutions to overcome many drawbacks of the traditional apprenticeship training. To vividly simulate the vascular IR, accurate vascular models with morphological and anatomical details at various scales are required. In this regard, raw models that are reconstructed from patients’ imaging data need further processing for quality improvements. A quality vascular mesh with morphology preserved is essential for the effectiveness of the simulator. First, the mesh facets smoothed by our method are approximately tangent to its underlying surface. Therefore, the curved guide-wire could press the vessel wall more tightly, as shown in Fig. 8
                     , which corresponds to the real interventional situation. Second, in the interventional simulation, the guide-wire bends as a result of colliding with the vascular mesh. The orientation of elastic forces induced by the collision is closely related to the colliding mesh normals. In our method, the deviation of the mesh normals from the underlying surface normals has been minimized. Therefore, the orientation of elastic force generated by the vascular mesh surface varies more gradually rather than abruptly, as shown in Fig. 8. To the end, more steady and accurate forces are provided to support the guide-wire to maintain its shape in the vasculature. Third, in the region of vascular bifurcation and tunnels with high curvatures, the mesh smoothed by our method uses more facets to represent the sharp turning part. Accordingly, there are more possible supporting spots for the guide-wire to perform a sharp turn at a bifurcation, as shown in Fig. 9
                     .

@&#CONCLUSION@&#

We propose an effective mesh smoothing algorithm according to the characteristics of medical data. Benefiting from the two steps, we can remove staircases and noise while keeping a compact mesh that approximates the underlying surface, which is validated by both visual comparison and quantitative evaluation. In future, we will improve the algorithm’s efficiency and find clinical applications.

@&#ACKNOWLEDGMENTS@&#

We thank the anonymous reviewers for their valuable comments. We thank Haoyu Wang for helping to implement the application. This work was supported by grants from the Research Grants Council of Hong Kong (Project Nos. 412412 and 412513), a grant from NSFC (Project No. 61272328), a grant from Natural Science Foundation of Guangdong (Project No. S2013010014973) and a grant from Shenzhen Basic Research Project (Project No: JCYJ20120619152326448).

@&#REFERENCES@&#

