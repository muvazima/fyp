@&#MAIN-TITLE@&#Minimising total tardiness for a single machine scheduling problem with family setups and resource constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a new single-machine scheduling problem with family setups and resource constraints.


                        
                        
                           
                           The problem is motivated from a real-life problem in the steel industry.


                        
                        
                           
                           We present mathematical formulations and heuristic approaches for two variants of the problem.


                        
                        
                           
                           The heuristics can be used for a variety of multi-stage production processes with arbitrary supply and demand rates.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Single-machine scheduling

Family scheduling

Tardiness minimisation

Resource constraints

@&#ABSTRACT@&#


               
               
                  This paper considers a single machine scheduling problem in which each job to be scheduled belongs to a family and setups are required between jobs belonging to different families. Each job requires a certain amount of resource that is supplied through upstream processes. Therefore, schedules must be generated in such a way that the total resource demand does not exceed the resource supply up to any point in time. The goal is to find a schedule minimising total tardiness with respect to the given due dates of the jobs. A mathematical formulation and a heuristic solution approach for two variants of the problem are presented. Computational experiments show that the proposed heuristic outperforms a state-of-the-art commercial mixed integer programming solver both in terms of solution quality and computation time.
               
            

@&#INTRODUCTION@&#

In this paper we study the problem of scheduling jobs on a single machine with the goal of minimising total tardiness. Each job has a given processing time, a due date, and belongs to a given family. The machine can only process one job at a time and each job must be processed without preemption. A setup task has to be conducted between jobs belonging to different families and during this setup the machine cannot process any job.

The problem studied in this paper, each job requires a certain amount of a common resource that is supplied through upstream processes. At any time, the cumulative consumption must not exceed the cumulative supply. Therefore, jobs may have to wait due to an insufficient availability of the resource.


                     Fig. 1 illustrates the implication of the resource constraints. The figure shows the cumulative amount of resource supplied and the cumulative amount of resource required over time. The cumulative amount of resource supplied is shown as a linear curve with a constant supply rate. The cumulative resource demand over time is shown as a piece-wise linear curve that increases whenever a job is processed. The dotted vertical lines illustrate completion times of individual jobs. Horizontal segments of the demand curve illustrate times during which the machine has not yet started processing the next job, e.g. because a setup is conducted. As the cumulative amount of resource required must not exceed the cumulative amount of resource supplied at any time and because each job must be processed without preemption, the machine may also have to be idle before starting to process a job due to limited resource availability.

Our work is motivated by a practical problem arising in the continuous casting stage of steel production. A continuous caster is fed with ladles of liquid steel. Each ladle contains a certain steel grade and has orders allocated to it that determine a due date. Whenever two ladles of similar steel grade (within one setup family) are processed consecutively, no setup process is necessary. However, a setup is required whenever changing to a steel grade from another setup family. The liquid steel is produced from hot iron supplied by the blast furnace with a constant rate. The sequence of ladles, including setups between ladles of different setup families, is not allowed to consume more hot metal then supplied by the blast furnace (see e.g. Box & Herbe, 1988).

Similar situations occur in multi-stage production processes, where upstream work systems supply the common resource that is consumed by the jobs produced on the machine. Examples can be found in assembly processes where parts and components provided by an upstream stage are used to assemble different products (e.g. Drótos & Kis, 2013, cutting pieces from a steel slab).

The remainder of this paper is organised as follows. Section 2 gives an overview of related work. Section 3 contains a detailed description of the problem and presents MIP formulations for two variants of the problem. In Section 4 we present an iterated local search approach for solving the problem. Section 5 presents computational experiments before final remarks are given in Section 6.

@&#RELATED WORK@&#

There are three main streams of literature that are of interest for the problem studied in this paper. First, scheduling with the target of minimising total tardiness. Second, single machine scheduling with setup considerations. Third, scheduling with resource constraints.

Comprehensive surveys for the minimum tardiness scheduling problem are presented by Koulamas (2010) and Sen, Sulek, and Dileepan (2003). Even without setup considerations, the single machine total tardiness problem is proven to be NP-hard (Du & Leung, 1990). Most methods developed for single machine problems that minimise total tardiness use properties developed by Emmons (1969) and Lawler (1977). Emmons (1969) describes conditions that need to be fulfilled in an optimal schedule, and Lawler (1977) introduced a decomposition approach that separates a problem into two mutually exclusive sub problems using the longest job to separate. For the problem of scheduling independent jobs on identical parallel machines, Shim and Kim (2007) present a branch and bound algorithm to minimise total tardiness. Schaller (2009) presents improved lower bounds that can be used in this branch-and-bound algorithm to reduce the computational effort required. Recently, Lee and Kim (2015) present a branch-and-bound algorithm for the problem of minimising the total tardiness of jobs in which for both of the two identical machines periodic maintenance activities are required during which the machine cannot process any job. Furthermore, Mensendiek, Gupta, and Herrmann (2015) developed properties for optimal sequences with the total tardiness objective on parallel machines with fixed delivery dates and present heuristics for solving the problem.

The literature on scheduling with setup considerations is summarised e.g. in surveys of Allahverdi, Ng, Cheng, and Kovalyov (2008) and Potts and Kovalyov (2000). For the problem of minimising total tardiness on a single machine with sequence-dependent setup times, Gupta and Smith (2006) presented a GRASP multi-start heuristic as well as a space-based local search procedure, Liao and Juan (2007) developed a method based on ant colony optimization, Lin and Ying (2008) a hybrid of simulated annealing and tabu search, Ying, Lin, and Huang (2009) an iterated greedy heuristic based on local search, and Sioud, Gravel, and Gagné (2012) a hybrid genetic algorithm. An exact branch-and-bound algorithm for this problem class is presented by Bigras, Gamache, and Savard (2008). For the variant of the problem where the goal is to minimise the weighted tardiness of all jobs, Tanaka and Araki (2013) recently developed an exact procedure based successive sublimation dynamic programming and Subramanian, Battarra, and Potts (2014) recently presented an iterated local search heuristic.

In family scheduling problems, all jobs are assigned to a certain family and a set of jobs of the same family that is produced consecutively without a setup is called a batch. While the allocation of jobs to families is given as a parameter, the allocation of jobs to batches for a certain setup family is part of the decision process. Under the group technology assumption (GTA) (see e.g. Potts & Van Wassenhove, 1992) all jobs of the same setup family must be produced within exactly one batch, while several batches of the same family can be scheduled in the general case that is considered in this paper.


                     Gupta and Chantaravarapan (2008) and Schaller (2007) study a family scheduling problem in which the goal is to minimise total tardiness. Gupta and Chantaravarapan (2008) studied the problem under consideration of the GTA. They present a MIP formulation to solve small problem instances as well as a heuristic algorithm for larger instances. In their heuristic the authors separate the sequencing of jobs within a batch and the sequence of batches. Inside each batch they used a combination of neighbourhood operators previously developed by Holsenback and Russell (1992) and Panwalkar, Smith, and Koulamas (1993).


                     Schaller (2007) studied the family scheduling problem with and without the GTA. Based on the properties described by Emmons (1969), two optimal branch and bound procedures for both cases are developed. Furthermore, a heuristic based on five local search moves is proposed. These moves include the combining of two batches of the same setup family, moving jobs between batches of the same setup family, breaking a batch into two parts, and interchanging pairs of jobs. Furthermore, Schaller and Gupta (2008) study the minimisation of both earliness and tardiness for a single machine scheduling problem with family setups and propose exact and heuristic methods with and without the GTA. More recently, Schaller (2014) presents several heuristic approaches for scheduling identical parallel machines with family setups for the problem of minimising total tardiness.


                     Grigoriev, Holthuijsen, and Van De Klundert (2005) provide a survey on scheduling problems with raw material constraints. They distinguish between three types of raw material usages: (a) each job has its own raw material, (b) a common resource is required by all jobs, and (c) multiple common raw materials are required for each job. For all three cases they considered the objective of minimising maximum lateness and minimising makespan. Briskorn, Choi, Lee, Leung, and Pinedo (2010) study a single machine scheduling problem where jobs cannot be processed if the required resource is not available. Among the objectives considered are the objectives of minimising maximum lateness and minimising the number of tardy jobs. Györgyi and Kis (2014) study variations of the problem of minimising makespan with resource constraints using propositions from the knapsack and vertex cover problems to develop a polynomial-time approximation scheme. Briskorn, Jaehn, and Pesch (2013) study the single machine problem with inventory constraints to minimise the weighted sum of completion times. The authors derived properties for an optimal solution and developed a branch and bound as well as a dynamic programming approach to solve the problem. They conclude that even for small problem instances with 20 jobs, exact approaches are not efficient enough and heuristic approaches are required. None of these works considers the objective of minimising total tardiness.

While previous work on family scheduling problems does not include resource constraints, papers published on scheduling problems with resource constraints do not consider family setups. To the best of our knowledge, the single machine scheduling problem with family setups and resource constraints has not been studied.

The machine scheduling problem studied in this paper can be described as follows. Let J denote a set of jobs to be processed by a single machine. Each job is characterised by a due date dj
                     , a processing time pj
                     , and the quantity qj
                      of a resource required by the machine to process the job. It is assumed that the resource is consumed at a constant rate qj
                     /pj
                     . Furthermore, each job belongs to a given setup family fj
                     . For any pair of jobs i, j ∈ J with fi
                      ≠ fj
                     , a setup of duration sij
                      is required between processing jobs i and j. A single machine is available that can process one job at a time. The resource required is supplied with a constant rate of r per unit of time, and initially an amount of r
                     * of the resource is available. The goal is to find a production schedule that minimises total tardiness.

The fundamental difference of this problem to the case without resource constraints is, that it may be necessary that the machine is idle because the required resource for the next job is net yet available, whereas in the case without resource constraints the machine is only idle for the time of the setups that may be required. In the case without resource constraints the optimal duration of any subsequence of jobs is always the sum of all processing times and the required setups. Fig. 2
                      shows an example where the minimum duration of a sequence is larger than the sum of processing and setup times because the machine has to wait for the resource required. In the example shown in the figure, it is not possible to schedule job j immediately after job i and the completion of the setup, because the cumulative resource requirements exceeds the cumulative resource supply if no additional waiting time is scheduled.

Without resource constraints, any sequence of jobs of the same family can be reordered without impacting the completion time of this sequence and the tardiness of subsequent jobs. Therefore, it is possible to locally optimise the order in which jobs of the same family are scheduled. In the presence of resource constraints, however, any permutation of jobs may lead to an increase or decrease of the cumulative duration due to necessary waiting times. Fig. 3
                      illustrates an example in which the sequence of jobs within a batch can impact cumulative duration due to necessary waiting times. In the sequence illustrated by the dashed line, job j
                     2 has to wait after completion of job j
                     3 due to insufficient resource availability, whereas no waiting time is required in the sequence illustrated by the solid line. Thus, the tardiness of subsequent jobs may change if the order of jobs within a subsequence is modified.

For the first problem variant studied in this paper let us assume that the machine can be idle for any period of time after completion of one job and before starting to process the next job. For the ease of notation we assume that 
                        
                           
                              s
                              
                                 i
                                 j
                              
                           
                           =
                           0
                        
                      for any pair of jobs i, j ∈ J with 
                        
                           
                              f
                              i
                           
                           =
                           
                              f
                              j
                           
                        
                     . Furthermore, we assume that each schedule begins with a dummy job j
                     * that is included in J. This job has a due date large enough so that it will never be tardy, has zero precessing time and resource demand, and no setup time is required before processing any other job. Let xij
                      denote a binary variable indicating whether job j ∈ J is scheduled immediately after job i (
                        
                           
                              x
                              
                                 i
                                 j
                              
                           
                           =
                           1
                        
                     ) or not (
                        
                           
                              x
                              
                                 i
                                 j
                              
                           
                           =
                           0
                        
                     ).

For each job j ∈ J let Cj, Tj
                      and Qj
                      be variables indicating the completion time, the tardiness, and the accumulated amount of the resource requirements. Furthermore, let xij
                      denote a binary variable indicating whether job i is processed immediately before job j or not.

The problem is

                        
                           (1)
                           
                              
                                 minimise
                                 
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       J
                                    
                                 
                                 
                                    T
                                    j
                                 
                              
                           
                        
                     subject to

                        
                           (2a)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       J
                                       ∖
                                       {
                                       j
                                       }
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 all
                                 
                                 j
                                 ∈
                                 J
                              
                           
                        
                     
                     
                        
                           (2b)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       J
                                       ∖
                                       {
                                       i
                                       }
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ∈
                                 J
                              
                           
                        
                     
                     
                        
                           (3a)
                           
                              
                                 
                                    C
                                    
                                       j
                                       *
                                    
                                 
                                 =
                                 0
                              
                           
                        
                     
                     
                        
                           (3b)
                           
                              
                                 
                                    C
                                    j
                                 
                                 ≥
                                 
                                    C
                                    i
                                 
                                 +
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 +
                                 
                                    p
                                    j
                                 
                                 −
                                 
                                    (
                                    1
                                    −
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                                 M
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ∈
                                 J
                                 ,
                                 j
                                 ∈
                                 J
                                 ∖
                                 
                                    {
                                    
                                       j
                                       *
                                    
                                    }
                                 
                              
                           
                        
                     
                     
                        
                           (4a)
                           
                              
                                 
                                    T
                                    j
                                 
                                 ≥
                                 0
                              
                           
                        
                     
                     
                        
                           (4b)
                           
                              
                                 
                                    T
                                    j
                                 
                                 ≥
                                 
                                    C
                                    j
                                 
                                 −
                                 
                                    d
                                    j
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 j
                                 ∈
                                 J
                              
                           
                        
                     
                     
                        
                           (5a)
                           
                              
                                 
                                    Q
                                    
                                       j
                                       *
                                    
                                 
                                 =
                                 0
                              
                           
                        
                     
                     
                        
                           (5b)
                           
                              
                                 
                                    Q
                                    j
                                 
                                 ≥
                                 
                                    Q
                                    i
                                 
                                 +
                                 
                                    q
                                    j
                                 
                                 −
                                 
                                    (
                                    1
                                    −
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                                 M
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ∈
                                 J
                                 ,
                                 j
                                 ∈
                                 J
                                 ∖
                                 
                                    {
                                    
                                       j
                                       *
                                    
                                    }
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    Q
                                    j
                                 
                                 ≤
                                 
                                    r
                                    *
                                 
                                 +
                                 r
                                 
                                    C
                                    j
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 j
                                 ∈
                                 J
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ,
                                 j
                                 ∈
                                 J
                              
                           
                        
                     
                  

The objective (1) is to minimise the sum of tardiness of all jobs in the production schedule. Constraints (2a) and (2b) require that each job is fulfilled exactly once. Constraints (3a) and (3b) require that the completion time of a job must be at least as large as the the completion time of the preceding job plus the required setup time (which may be zero), and the processing time. Constraints (4a) and (4b) restrict the tardiness of each job so that in the optimal solution we have 
                        
                           
                              T
                              j
                           
                           =
                           max
                           
                              {
                              0
                              ,
                              
                                 C
                                 j
                              
                              −
                              
                                 d
                                 j
                              
                              }
                           
                        
                     . Constraints (5a) and (5b) ensure that Qj
                      is at least as large as the cumulative resource requirements until job j ∈ J. The cumulative resource requirements must not exceed the amount available until completion of the job as required by Constraint (6). Finally, Constraint (7) restricts the domain of the binary decision variables.

Because of operational requirements it is not always possible that a machine can be idle between completion of one job and start of the next job. This is the case, if a machine must be brought to a state in which it can remain idle, e.g. if cleaning is required. For such cases, we assume that the duration of a setup that may be required between jobs of different families can be increased by an arbitrary amount, however, an additional setup between jobs of the same family is required if the job does not start immediately after completion of the preceding job. For this second problem variant we thus have sij
                      > 0 for jobs i, j ∈ J with 
                        
                           
                              f
                              i
                           
                           =
                           
                              f
                              j
                           
                        
                     . As this setup between jobs of the same family is not always necessary we have to add a binary variable yij
                      indicating whether a setup is conducted between jobs i and j to our model. The following constraints are added to the problem

                        
                           (8a)
                           
                              
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ,
                                 j
                                 ∈
                                 J
                                 :
                                 
                                    f
                                    i
                                 
                                 ≠
                                 
                                    f
                                    j
                                 
                              
                           
                        
                     
                     
                        
                           (8b)
                           
                              
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 ≤
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ,
                                 j
                                 ∈
                                 J
                                 :
                                 
                                    f
                                    i
                                 
                                 =
                                 
                                    f
                                    j
                                 
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ,
                                 j
                                 ∈
                                 J
                              
                           
                        
                     
                  

and Constraints (3a) and (3b) are replaced by constraints

                        
                           (10a)
                           
                              
                                 
                                    C
                                    
                                       j
                                       *
                                    
                                 
                                 =
                                 0
                              
                           
                        
                     
                     
                        
                           (10b)
                           
                              
                                 
                                    C
                                    j
                                 
                                 ≥
                                 
                                    C
                                    i
                                 
                                 +
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    s
                                    
                                       i
                                       j
                                    
                                 
                                 +
                                 
                                    p
                                    j
                                 
                                 −
                                 
                                    (
                                    1
                                    −
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                                 M
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ∈
                                 J
                                 ,
                                 j
                                 ∈
                                 J
                                 ∖
                                 
                                    {
                                    
                                       j
                                       *
                                    
                                    }
                                 
                              
                           
                        
                     
                     
                        
                           (10c)
                           
                              
                                 
                                    C
                                    j
                                 
                                 ≤
                                 
                                    C
                                    i
                                 
                                 +
                                 
                                    p
                                    j
                                 
                                 +
                                 
                                    (
                                    1
                                    −
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    
                                       y
                                       
                                          i
                                          j
                                       
                                    
                                    )
                                 
                                 M
                                 
                                 for
                                 
                                 all
                                 
                                 i
                                 ∈
                                 J
                                 ,
                                 j
                                 ∈
                                 J
                                 ∖
                                 
                                    {
                                    
                                       j
                                       *
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     
                  

Constraint (8a) ensures that a setup is conducted if jobs of different families are processed after another, whereas Constraint (8b) allows a setup to be conducted if jobs of the same family are processed after another. Constraint (9) gives the domain of the additional binary decision variables. Like Constraint (3a) and (3b), Constraints (10a) and (10b) require that the completion time of a job must be at least as large as the the completion time of the preceding job plus the setup time, if a setup is conducted, and the processing time. Furthermore, Constraint (10c) ensures that job j is processed immediately after completion of a preceding job i if no setup is conducted.

Obviously, any feasible solution for this problem variant is also a feasible solution to the first problem variant described by (1) - (7). However, the sequences of jobs that are optimal for the two problem variants may differ. Let us consider the example with two jobs belonging to the same setup family with parameters 
                        
                           
                              d
                              1
                           
                           =
                           0
                           ,
                        
                     
                     
                        
                           
                              p
                              1
                           
                           =
                           14
                        
                      and 
                        
                           
                              d
                              2
                           
                           =
                           15
                           ,
                        
                     
                     
                        
                           
                              p
                              2
                           
                           =
                           12
                        
                     . Furthermore, assume that at the beginning of the planning horizon there is an initial inventory that is sufficient to process either of the jobs without delay, but not both, and that after 30 units of time the resource supply reaches a level that is sufficient to process both jobs. Furthermore, let us assume that for the second problem variant, the duration of a setup between the two jobs is sufficiently large, so that an optimal solution will not have a setup between the two jobs. Fig. 4 illustrates the optimal sequences for both problem variants. The optimal sequence is illustrated by a solid line, whereas the inferior sequence by a dashed line. For the first problem variant, where the machine may be idle for any period of time after completion of one job and before starting to process the next job, the optimal sequence is to process job 1 before job 2 with 
                        
                           
                              C
                              1
                           
                           =
                           14
                           ,
                        
                     
                     
                        
                           
                              T
                              1
                           
                           =
                           14
                           ,
                        
                     
                     
                        
                           
                              C
                              2
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              T
                              2
                           
                           =
                           15
                        
                      and a total tardiness of 29. If job 2 is processed before job 1, we have 
                        
                           
                              C
                              1
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              T
                              1
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              C
                              2
                           
                           =
                           12
                           ,
                        
                     
                     
                        
                           
                              T
                              2
                           
                           =
                           0
                        
                      and a total tardiness of 30. For the second problem variant, where an additional setup between jobs of the same family is required if the job does not start immediately after completion of the preceding job, it is better to delay the start of the first job in the optimal sequence instead of adding an additional setup. The optimal sequence is to process job 2 before job 1 with 
                        
                           
                              C
                              1
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              T
                              1
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              C
                              2
                           
                           =
                           16
                           ,
                        
                     
                     
                        
                           
                              T
                              2
                           
                           =
                           1
                        
                      and a total tardiness of 31. If job 1 is processed before job 2, we have 
                        
                           
                              C
                              1
                           
                           =
                           18
                           ,
                        
                     
                     
                        
                           
                              T
                              1
                           
                           =
                           18
                           ,
                        
                     
                     
                        
                           
                              C
                              2
                           
                           =
                           30
                           ,
                        
                     
                     
                        
                           
                              T
                              2
                           
                           =
                           15
                        
                      and a total tardiness of 33.

As the above example and the example of Fig. 3 illustrate, the optimal sequence depends on both the resource availability as well as the operational details determining when necessary waiting times can be scheduled. Thus, the previously developed optimality conditions for minimising total tardiness, e.g. those presented by Schaller (2007), are not valid for scheduling with resource constraints. As a result, a solution approach cannot exploit these properties.

Solving the problem described above using a MIP-solver is in general too time consuming for problem instances with larger numbers of jobs. In fact, if all jobs belong to the same family and r
                     * is sufficiently large, the problem reduces to the single machine total tardiness problem studied by Du and Leung (1990) which is proven to be NP-hard. It follows that the problem studied in this paper is also NP-hard. Therefore, we present a heuristic approach based on simple operators for modifying the sequence of jobs. With this approach we are able to generate schedules with low total tardiness quickly.

The pseudocode of our heuristic is shown in Fig. 5
                     . The approach begins by generating an initial solution which can be any sequence of jobs. It then initialises an iteration counter and repeats the same steps until the iteration counter has reached a given limit. In each iteration, the approach selects the next neighbourhood operator from a randomly generated sequence of the operators. For each operator, all possible moves are examined. If an improving solution is found, this solution is accepted as the new incumbent solution. If no improvement can be obtained by any of the operators a locally optimal solution is found. Following the iterated local search framework of Lourenço, Martin, and Stützle (2003), the search process is repeated in order to be able to escape from local optima of poor quality. Before continuing with the next iteration, the incumbent solution is perturbed in order to obtain a new solution that potentially can be improved using the operators.

The solution approach comprises three main components: the evaluation of tardiness of a given sequence of jobs, different neighbourhood operators to modify sequences, and a method to perturb a solution.

To evaluate the tardiness of a particular sequence the approach has to compute completion times and tardiness values for each job in the sequence. For the first problem variant, in which the machine may be idle for any period of time after completion of one job and before starting to process the next job, optimal completion times for a given sequence of jobs can be computed very easily. For a job j in a given sequence, let Qj
                         denote the cumulative amount of resource required by all jobs in the sequence up to job j. The completion times of the jobs in the sequence can be computed as follows. The first job j in the sequence has completion time

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        For all other jobs j the completion time is

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          C
                                          i
                                       
                                       +
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    ,
                                 
                              
                           
                        where job i is the predecessor of j. The tardiness of any job j is

                           
                              
                                 
                                    
                                       T
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       0
                                       ,
                                       
                                          C
                                          j
                                       
                                       −
                                       
                                          d
                                          j
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

Now, let us consider the second problem variant, where an additional setup between jobs of the same family is required if the job does not start immediately after completion of the preceding job. If the values yij
                         indicating whether there is a setup between i and j are known, completion times and tardiness can be scheduled analogously to the method described above. The solution approach presented in this paper, however, is based on operators changing the sequence of jobs and the decision whether a setup is taken or not is not explicitly taken by the operators. Instead, this decision is taken when calculating the completion times of the jobs in the sequence. The first job j in the sequence is tentatively given the completion time

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        This value may have to be increased if a subsequent job without intermediate setup cannot be processed due to the resource constraint.

For any other job j, we have to distinguish between several cases. If fi
                         ≠ fj
                        , where job i is the predecessor of j, then a setup is required and the completion time job j is tentatively set to

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          C
                                          i
                                       
                                       +
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

If 
                           
                              
                                 f
                                 i
                              
                              =
                              
                                 f
                                 j
                              
                           
                         then two alternatives must be considered. In the first alternative, an additional setup is included and the completion time of job j is tentatively set to

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          C
                                          i
                                       
                                       +
                                       
                                          s
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        In the second alternative, no setup is made between i and j and the completion time of job j is tentatively set to

                           
                              
                                 
                                    
                                       C
                                       j
                                    
                                    =
                                    max
                                    
                                       {
                                       
                                          C
                                          i
                                       
                                       +
                                       
                                          p
                                          j
                                       
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        To eliminate possible idle time between jobs, the completion time of all jobs prior to j which are not separated by a setup is increased by

                           
                              
                                 
                                    Δ
                                    =
                                    max
                                    
                                       {
                                       0
                                       ,
                                       
                                          
                                             
                                                Q
                                                j
                                             
                                             −
                                             
                                                r
                                                *
                                             
                                          
                                          r
                                       
                                       −
                                       
                                          (
                                          
                                             C
                                             i
                                          
                                          +
                                          
                                             p
                                             j
                                          
                                          )
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        As above, the tardiness of any job j is

                           
                              
                                 
                                    
                                       T
                                       j
                                    
                                    =
                                    min
                                    
                                       {
                                       0
                                       ,
                                       
                                          C
                                          j
                                       
                                       −
                                       
                                          d
                                          j
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

The approach can efficiently be implemented as follows. For any job in a given sequence of jobs let 
                           
                              l
                              =
                              (
                              
                                 l
                                 time
                              
                              ,
                              
                                 l
                                 tardiness
                              
                              )
                           
                         be a label where l
                        time denotes the completion time of the job and l
                        tardiness denotes the cumulative tardiness until completion of the job. The approach begins with a label 
                           
                              l
                              =
                              (
                              0
                              ,
                              0
                              )
                           
                        . Then it iterates through the given sequence of jobs and calculates completion times and tardiness values as described above. For each different alternative a new label is generated. By extending each alternative label, a tree of alternatives is generated. To reduce the number of alternative labels to be considered the following dominance criteria are used to reduce the number of labels.

                           Proposition 1
                           
                              Let l
                              1 
                              and l
                              2 
                              denote labels associated to schedules up to the same job i in a sequence of jobs and let j denote the next job in the sequence. Label l
                              1 
                              dominates label l
                              2 
                              if 
                              
                                 
                                    
                                       
                                          
                                             l
                                             1
                                             time
                                          
                                          +
                                          
                                             s
                                             
                                                i
                                                j
                                             
                                          
                                          ≤
                                          
                                             l
                                             2
                                             time
                                          
                                       
                                    
                                 
                              
                              and 
                              
                                 
                                    
                                       
                                          
                                             l
                                             1
                                             tardiness
                                          
                                          ≤
                                          
                                             l
                                             2
                                             tardiness
                                          
                                          .
                                       
                                    
                                 
                              
                           

Let 
                                 
                                    
                                       l
                                       ^
                                    
                                    1
                                 
                               denote the label associated to the schedule obtained by adding a setup of duration sij
                               and job j to the schedule associated to l
                              1 and let 
                                 
                                    
                                       l
                                       ^
                                    
                                    2
                                 
                               denote the label associated to a schedule obtained by extending the schedule associated to l
                              2 by job j. We have 
                                 
                                    
                                       
                                          l
                                          ^
                                       
                                       1
                                       time
                                    
                                    ≤
                                    
                                       
                                          l
                                          ^
                                       
                                       2
                                       time
                                    
                                 
                               and 
                                 
                                    
                                       
                                          l
                                          ^
                                       
                                       1
                                       tardiness
                                    
                                    ≤
                                    
                                       
                                          l
                                          ^
                                       
                                       2
                                       tardiness
                                    
                                 
                              . Furthermore, for any extension of 
                                 
                                    
                                       l
                                       ^
                                    
                                    1
                                 
                               and 
                                 
                                    
                                       l
                                       ^
                                    
                                    2
                                 
                               adding setups at the same positions, every job in the schedule associated to the former will be completed earlier or at the same time compared to the same job in the schedule associated to the latter. Thus, the total tardiness of the former will be smaller or equal to the latter and l
                              1 dominates l
                              2.□

By eliminating all dominated labels, the size of the search tree built to evaluate total tardiness is reduced effectively.

It must be noted that total tardiness can similarly be evaluated for non-constant supply and demand rates. By replacing all occurrences of the term 
                           
                              
                                 
                                    Q
                                    j
                                 
                                 −
                                 
                                    r
                                    *
                                 
                              
                              r
                           
                         with a function that calculates the earliest point in time when the job j can be completed subject to a sufficient resource availability, arbitrary supply and demand patterns can be considered.

The solution approach uses six different operators. The first two operators are directly based on the sequence of jobs, whereas the other operators are based on batches, i.e. subsequences without a setup. The advantage of such batch-based operators is that some structural properties of the current solution are maintained and unnecessary setups can be avoided.

The Job Move operator selects a job and inserts it at another position in the sequence. Fig. 6
                           
                           
                           
                           
                           
                            illustrates all possible operator moves for a given job. After selecting a job, the operator iterates through the sequence of jobs and evaluates the insertion of the job at all possible positions. If total tardiness can be reduced, the job is moved to the position leading to the lowest total tardiness. This operator is a generalisation of the Move procedure of Schaller (2007), which only moves jobs within batches of the same family. Our operator also allows to remove a job from a batch and generate a new batch containing only the removed job. This may be particularly beneficial if the due date of the job does not fit well to the due dates of other jobs of the same family.

The Job Exchange operator selects a job and and exchanges its position with another job in the sequence. Fig. 7 illustrates a single operator move. After selecting a job, the operator iterates through the sequence of jobs and evaluates the exchange of the job with any other job in the sequence. If total tardiness can be reduced, the positions of the two jobs leading to the lowest total tardiness reduction are exchanged. This operator is equivalent to the JI procedure proposed by Schaller (2007).

The Batch Move operator selects a batch and inserts it at another position in the sequence. Fig. 8 illustrates the operator move. After selecting a batch, the operator iterates through the sequence of batches and evaluates the insertion of the complete batch at any sequence position. If a reduction of the total tardiness can be achieved, the batch is moved to the position leading to the lowest total tardiness.

The “Batch Exchange” operator selects a batch and and exchanges its position with another batch in the sequence of batches. Fig. 9 illustrates a single operator move. After selecting a batch, the operator iterates through the sequence of batches and evaluates the exchange of the positions of the complete batches. If total tardiness can be reduced, the positions of the two batches leading to the lowest total tardiness reduction are exchanged. This operator is equivalent to the BI procedure proposed by Schaller (2007).

The Batch Combine operator selects a batch and combines the batch with the next batch of the same family. Fig. 10 illustrates a single operator move. It removes the jobs of both batches and iterates through the sequence to evaluate whether reinsertion of the combination of both batches can reduce total tardiness. If total tardiness can be reduced, the combined batch is inserted at the position leading to the lowest total tardiness. This operator is equivalent to the CONSOL procedure proposed by Schaller (2007).

The Batch Break operator selects a batch, breaks the batch into two parts and inserts both parts at a new position in the sequence. Fig. 11 illustrates a single operator move. After selecting a batch, the operator sorts all the jobs within the batch according to their due date and divides the batch at the position of the largest due date difference. The operator then iterates over all possible sequence positions for both parts and evaluates the total tardiness. If total tardiness can be reduced, the parts are inserted at the positions leading to the lowest total tardiness.

Although the Break procedure proposed by Schaller (2007) can also be used to break a batch into two parts, both operators have conceptual differences. While the Break procedure moves one job at a time into a new batch as long as total tardiness is reduced, our operator breaks a batch at the position of the largest due date difference and inserts both parts at the best positions in the sequence. Especially, if jobs with inhomogeneous due dates are grouped together, our Batch Break operator can increase the likelihood that a new sequence with lower tardiness is found.

Our approach for perturbation is motivated by Lü and Hao (2009). Their critical element-guided perturbation strategy (CEGP) investigates a current best solution and calculates a scoring variable for each job. Based on the scores, which are derived from problem characteristics, a new initial sequence is derived.

The idea of our perturbation approach is to evaluate for each job the most promising sequence position in terms of tardiness minimisation. Based on the current solution we calculate the lateness of each job by

                           
                              
                                 
                                    
                                       L
                                       j
                                    
                                    =
                                    
                                       C
                                       j
                                    
                                    −
                                    
                                       d
                                       j
                                    
                                    .
                                 
                              
                           
                        A positive lateness value indicates that tardiness may be reduced by shifting this job towards the beginning of the sequence, whereas a negative lateness value indicates that the job can be shifted to a later position without increasing tardiness. In order to estimate a promising shift in sequence positions, we divide each lateness value by the average processing time and calculate a new position index 
                           
                              k
                              j
                              ☆
                           
                         by subtracting the calculated shift from the original position index kj
                         by

                           
                              
                                 
                                    
                                       k
                                       j
                                       ☆
                                    
                                    =
                                    
                                       k
                                       j
                                    
                                    −
                                    
                                       
                                          
                                             |
                                             J
                                             |
                                          
                                          
                                             L
                                             j
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                p
                                                i
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        A new initial solution is obtained by ordering the jobs according to their values 
                           
                              k
                              j
                              *
                           
                         and using the original position index kj
                         as a tie breaker.

This section presents test instances and computational experiments conducted to evaluate the proposed approach for both variants of the problem.

Artificially instances are generated motivated from a real-world scheduling problem in the steel industry. The generated instances share common characteristics of the real-life problem, however, for confidentiality reasons, these characteristics cannot be described in detail.

For each instance, a set of jobs J and a set of families F are generated. Each family is randomly assigned one job and the remaining jobs are distributed across the families according to a random distribution derived from the real-world problem that motivated this work. Fig. 12
                         gives an illustration of this distribution.

In the real-world problem, processing times of a job depend on the setup family and the production width. Therefore, for each setup family f ∈ F processing times pf
                         are randomly generated in the range between 2400 and 3000. Then, for each job j in family f, the processing time pj
                         is randomly generated in the range between max (0.9pf
                        , 2400) and min (1.1pf
                        , 3000). Thus, processing times are similar for jobs of equal setup family, but still vary as a result of the production width.

For each pair of families, setup times between any pair of jobs of these families are randomly selected to be either 900 or 2700. This is also motivated from real world instances, where a reduced setup time is possible in case certain characteristics are given.

Motivated from the real problem instances, the resource demand qj
                         of job j is set to a random number in the range between 250 and 270.

The due date of jobs are set as follows. First, a sequence of jobs is generated by grouping all jobs belonging to one family together, and ordering the groups in descending number of jobs. This approach is similar to scheduling with the group technology assumption (GTA). The resulting sequence minimises the number of setups required. For this sequence we calculate the minimum total time t
                        1 required without resource constraints. Then, for each job j, the due date dj
                         is randomly set to a value between 
                           
                              −
                              0.25
                              
                                 t
                                 1
                              
                           
                         and 1.25t
                        1. This random selection of due dates resembles the real-world situation, where some jobs are already delayed at the beginning of the planning horizon. As a negative due date will contribute equally to the total tardiness of any schedule, we replace negative due date values by zero.

In order to generate instances in which the resource constraint is not trivially satisfied and does not always require waiting times, the supply rate r and the initial inventory r
                        * are determined as follows. Another sequence is generated in which jobs are ordered according to their due dates, with the earliest due date first. For this sequence we calculate the minimum total time t
                        2 required without resource constraints. For all instances we have t
                        1 < t
                        2 because more setups are required. The supply rate r is chosen as 
                           
                              r
                              =
                              
                                 2
                                 
                                    
                                       t
                                       1
                                    
                                    +
                                    
                                       t
                                       2
                                    
                                 
                              
                              
                                 ∑
                                 
                                    j
                                    ∈
                                    J
                                 
                              
                              
                                 q
                                 j
                              
                           
                        . As shown in Fig. 13
                        , the resource supply (without initial inventory) grows at a rate that is between the average demand rates of the two sequences generated. The initial inventory is now set to 75percent of the largest difference between the cumulative demand of the first sequence and the supply curve without initial inventory. As a result, the first sequence, which minimises the total number of setups, would be infeasible without additional waiting times. When searching for a solution with low total tardiness, a good tradeoff between minimising the number of setups and minimising waiting times thus has to be found.

@&#EXPERIMENTS@&#

The solution approach presented in this paper is evaluated using the test instances described above which are available at http://www.telematique.eu/research/download. The experiments are conducted on an Intel Xeon(R) CPU W3530 @ 2.80 gigahertz X 4 with UBUNTU 14.04 64-bit operating system. To obtain optimal solutions or lower bounds on the total tardiness the MIP formulated in Section 3 was solved using the commercial solver CPLEX with version 12.6, one thread, 2 gigabyte RAM, and a 10 gigabyte tree limit. Furthermore, a run time limit of 3600 seconds was used.

An initial sequence of jobs is obtained by ordering the jobs according to their due dates. This sequence is given to both the MIP solver and the heuristic solution approach as the initial solution. In the heuristic, the neighbourhood operators are selected in a random order and whenever no further improvement is possible with the chosen operator the next neighbourhood operator is selected. Based on preliminary experiments we limited the iterated local search to three runs.


                        Tables 1
                         and 2
                         show average results for both variants of the problem and detailed results for the individual instances are provided in the appendix. In Tables 1 and 2, each line shows average values of all instances with the same number of jobs. The first column indicates the number of jobs. The second column gives the average computation time (in seconds) required by the MIP solver. The third column indicates the solution quality by providing the average percentage by which the gap between the initial solution to the best lower bound is closed (GAP). This value is computed as 
                           
                              100
                              
                                 (
                                 
                                    T
                                    Start
                                 
                                 −
                                 
                                    T
                                    UB
                                 
                                 )
                              
                              /
                              
                                 (
                                 
                                    T
                                    Start
                                 
                                 −
                                 
                                    T
                                    LB
                                 
                                 )
                              
                              ,
                           
                         where T
                        Start denotes the total tardiness of the initial solution, T
                        UB denotes the total tardiness of the best found solution, and T
                        LB denotes the lower bound obtained by the MIP solver. A value of 100 indicates that the gap is closed completely, i.e. that the solution is optimal. The next two columns give the same information for the heuristic. The last column indicates the ratio between the GAP value for the heuristic divided by the GAP value for the MIP. A ratio larger than 1 indicates that the heuristic outperforms the MIP.

The MIP manages to find optimal solutions for the smaller instances with 8 or 10 jobs in 20 out of 20 cases for the first problem variant and 19 out of 20 cases for the second problem variant. For all of these small-sized instances, the heuristic finds equally good solutions, however, the time required by the heuristic to find these solutions is magnitudes lower. For instances with more than 10 jobs, the MIP struggles closing the gap between the lower and upper bound and only finds the optimal solution for one of the instances with 12 jobs and 3 families and the first problem variant. This optimal solution is also found by the heuristic approach.

In total, the heuristic is able to find equally good or better solutions for 77 of 80 instances for the first problem variant and for 79 of 80 instances for the second problem variant. As the computational effort required by the heuristic is much smaller than for the MIP solver, and typically takes only a few minutes or less, the heuristic is well suited for application scenarios where human decision makers want to obtain good schedules quickly.

This paper studies a
                     
                      single-machine family scheduling problem with sequence dependent setup times and resource constraints. This problem differs from similar problems without resource constraints because both the optimal sequence and the timing of jobs can be influenced by the resource constraint. We present a mathematical formulation for two variants of the problem that differ in the way necessary waiting times due to limited resource availability can be scheduled. We present a heuristic approach for both problem variants and show how tardiness can be evaluated. While tardiness evaluation is trivial if waiting times can be scheduled between any pair of jobs, the evaluation is non-trivial if waiting times can only be scheduled when a setup is performed. We present a labelling approach to determine the optimal scheduling of additional setups and waiting times. Computational experiments are conducted on instances derived from instances of a practical problem in steel production that motivated the research. Our experiments show that the proposed solution approach outperforms a state-of-the-art mixed integer programming solver both in terms of solution quality and computation time. Furthermore, the solution approach is fast enough to be used in practical scenarios where larger instances must be solved within a few minutes.

Throughout this paper we assumed that the resource is supplied and consumed at a constant rate. While these assumptions are essential for the mathematical formulation presented in this paper, the heuristic approach can easily be adapted to be used for different application scenarios with arbitrary supply and demand. Thus, the proposed solution approach can be used for a variety of multi-stage production processes in which schedulers must take into account that a sufficient amount of a required resource
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                      is supplied by upstream processes.

In this appendix detailed results for all instances are reported. Tables 3–10 give the results for the first problem variant and Tables 11–18 give the results for the second problem variant. In the tables the first column provides the name of the instance. The names of the instances are formatted as |F|X|J|_k where k ∈ {1, 2, 3, 4, 5} is a counter to distinguish different instances with the same number of jobs |J| and families |F|. The second column in the tables give the total tardiness of the initial solution. The next columns present the results for the MIP and the heuristic. The tables shows the calculation time (CPU), lower bound obtained by CPLEX (LB), the upper bound (UP), and the degree to which the gap between initial solution and lower bound is closed (GAP). The last column indicates the ratio between the GAP value for the heuristic divided by the GAP value for the MIP.

@&#REFERENCES@&#

