@&#MAIN-TITLE@&#Social role-based secure large data objects dissemination in mobile sensing environment

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Social role based distributed Large Data Object dissemination framework is proposed.


                        
                        
                           
                           XOR network coding method is introduced in the proposed algorithm.


                        
                        
                           
                           XOR network coding and security framework are seamlessly integrated into PRXeluge.


                        
                        
                           
                           PRXeluge does not bring any additional load to the subscriber nodes.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Network coding

Authentication

Hash function

Proxy re-signature

@&#ABSTRACT@&#


               
               
                  At present, in mobile sensing environment, almost all the existing secure large data objects dissemination algorithms are centralized. The centralized servers publicize the sensing tasks and are also the authorized parties to initiate sensed data dissemination. This paper proposes a novel social role and network coding based security distributed data dissemination algorithm referred as PRXeluge to overcome the shortcomings of existing centralized data dissemination algorithms. Unlike the existing participatory sensing applications, in PRXeluge, service provider just publicizes the sensing tasks and utilizes a conditional proxy re-signature technique to authorize different social roles such as authorized smartphone users to be utilized as a contracted picture reporters, which sense the data and directly disseminate the sensed large data. Furthermore, PRXeluge proposes the XOR (Exclusive-OR) network coding scheme on the basis of Seluge security framework. To maximize the number of successfully decoded packets, PRXeluge introduces a neighbor node table to determine the optimal coding scheme. Experimental results reveal that the proposed PRXeluge shows better performance in terms of lower data packet transmission and dissemination delay compared to that of Seluge. Furthermore, it is observed from the experiment that the proposed algorithm is stronger as compared to that of centralized scheme and performs the fine grain access control without giving any additional load to subscriber nodes.
               
            

@&#INTRODUCTION@&#

With growing popularity of smartphones, according to statistics till date, the current global smartphone ownership has exceeded 1.9billion and mobile data traffic is predicted to grow further by over 100 times in the next ten years. Various sensors embedded in smartphones such as photosensitive sensors, Global Position System (GPS), accelerometer, bidirectional microphone and high-resolution cameras, provide smartphone users very convenient and powerful data-aware capabilities. Mostly participants in social networking applications share real-time perceived multimedia data or participate in a variety of hot events multimedia data-aware services through smartphones or other mobile sensing devices [1]. The great potential of the mobile phone sensors led the researchers to develop various related applications and systems. Fig. 1
                     (a) shows a traditional framework of these applications. These systems generally consist of a service provider, which consists of multiple sensing servers, many smartphone users, and the subscriber group of mobile social networks. First, the service provider discloses the sensing tasks and then the registered or authorized smartphone users such as the contracted picture reporters send the sensed data to the corresponding service provider. Finally, the service provider disseminates the sensed data such as the pictures of hot event to the subscribers. In the centralizing framework, the centralized servers are highly susceptible to attack targets and it is easy to produce a single point failure (such as Deny of Service (DoS) attack).

In this paper, as shown in Fig. 1(b), the framework of the distributed data dissemination is employed. In the distributed framework, the service provider only publicizes the sensing tasks and the registered or authorized smartphone users sense the data and disseminate directly the sensed data to the subscribers. In the distributed framework, the secure transmission or dissemination of large data objects is very significant and hot topic these days. This paper mainly discusses the following four significant points.
                        
                           (1)
                           The authentication of the smartphone users.

To withdraw the malicious authorized users.

To verify the authentication of the received sensed data immediately after reception.

To perform the fine grain access control. For example, the authorized smartphone users just are permitted to disseminate the sensed data to the special subscriber group.

This paper proposes a social role-based secure distributed large data dissemination algorithm in mobile sensing environment to address the above mentioned four issues. The main contributions of the proposed algorithm are as follows.
                        
                           •
                           A social role based distributed Large Data Object (LDO) dissemination framework, named PRXeluge, is proposed involving the service provider or network owner, authorized smartphone users, and the subscriber groups of mobile social networks. In the new framework, the service provider is not directly involved in the sensed data dissemination and a conditional proxy re-signature technique is utilized to authorize different smartphone users. By the conditional proxy re-signature technique, the fine-grain access control is performed. For example, the authorized smartphone users just are permitted to disseminate the sensed data to the special subscriber group.

A XOR network coding method is introduced in the proposed algorithm. The neighbor node table is proposed to find the optimal coding scheme. With just one data packet transmission, each node can obtain required packet through the optimal coding scheme. Hence, there is a reduction in the number of transmitted packets. Furthermore, the neighbor node table is extended where, two additional fields SC (Sending Counter) and RC (Receiving Counter) are introduced. Based on the extended neighbor table, a counter method for Anti-DOS attacks is proposed.

The security framework of Seluge [2] and XOR network coding method are seamlessly integrated into PRXeluge. PRXeluge shows similar security performance as that of Seluge and exhibits better performance than Seluge in terms of reduction in the transmitted data packets and dissemination delay. Furthermore, compared to the centralized scheme, PRXeluge does not bring any additional load to the subscriber nodes, and exhibits stronger performance in terms of fine grain access control.

The rest of this paper is organized as follows: Section 2 introduces the related work. Section 3 gives out the framework of the PRXeluge protocol. In Section 4, the preprocessing of sensed LDO is described. Section 5 describes networking coding and transmission of packets. The security analysis is given in Sections 6 and 7 explains the experimental results. At last, a brief summary is drawn in Section 8.

@&#RELATED WORK@&#

In mobile sensing environment, participatory sensing applications in the social networks have attracted great attention from researchers. In [3–5], some incentive mechanisms for participatory sensing are proposed. For example, Wang et al. propose a mechanism based on anonymous reputation and trust to solve the problem of “trust without identity” in participatory sensing networks [3]. Yang et al. propose an auction-based incentive mechanism and an incentive mechanism using a Stackelberg game for the mobile phone sensing [4]. Koutsopoulos et al. focus on the optimal incentive-driven design of participatory sensing systems [5]. In [6], fair energy-efficient sensing task allocation in participatory sensing with smartphones are proposed. However, all the above algorithms mainly focus on the design of participatory sensing system and data disseminations in these systems are yet to be explored. Recently, Sahoo et al. propose a strategy to determine the optimal location of aggregation that minimizes the delay of dissemination of sensed data in mobile cyber-physical systems [7]. To improve the packet delivery performance in wireless sensor networks, an algorithms based on publish/subscribe mode is proposed [8] and a publish-subscribe smartphone sensing platform is also proposed in [9].

The closely related work with our work is the code dissemination in Wireless Sensor Networks (WSNs). In this situation, the LDO is the PI (Program Image) to be updated. Most of the algorithms on the code dissemination in WSNs have been proposed in the literature. The incremental multi-hop online code dissemination algorithm Deluge, proposed by Culler et al. recently represents one of the online code dissemination algorithms [10]. However, Deluge does not consider any security issues. Hence, most of the secure code dissemination algorithms based on Deluge framework are proposed. Lanigan et al. first propose a security certification algorithm for code dissemination in WSNs, named Sluice [11]. Sluice utilizes a one-way hash function to ensure the integrality and correctness of updated PI. However, due to use of coarse-grained page-level hash value by the Sluice, all the packets in the page are forced to be retransmitted after authentication failure of a page. Dutta et al. propose a similar security authentication scheme for online code dissemination [12]. Unlike Sluice, Dutta et al. use a fine-grained packet-level hash value. However, in the method proposed by Dutta et al., the requested packets must arrive in order. In addition, He et al. propose a message dissemination algorithm for delay tolerant wireless sensor networks [13].

In the literature, it is found that a variety of methods are proposed to mitigate DoS attacks against online code dissemination. Shaheen et al. propose a code dissemination protocol, which utilizes one-way key chain to protect the integration of updated PI [14]. However, the algorithm proposed by Shaheen et al. is used in a single-hop WSNs and is vulnerable to multiple DoS attacks. For DoS attacks against digital signature packet, Dong et al. present two filtering methods based on group and key chain, but these two filtering methods are heavily dependent on key pair establishment between a sender and a receiver, which involves new security risks [15]. Tan et al. propose confidentiality-considered and Anti-DOS attacks multi-hop code dissemination protocol where, the content of the updated PI is self sensitive [16]. For the delay based DoS attacks, Hyun et al. propose a secure online code dissemination algorithm [2]. The algorithm proposed by Hyun et al. introduces Merkle Hash Tree (MHT) for real-time packet authentication, and introduces a weak authentication mechanism called Message Special Puzzle (MSP) to mitigate DoS attacks against digital signature packet.

Recently, online code dissemination algorithms based on network coding are proposed recently in [17–19]. Authors mainly utilize the idea of network coding to reduce the energy consumption in the process of online code dissemination [17]. Law et al. [18] and Zhang and Zhang [19] further consider security of the scheme based on network coding. In [18], Authors propose a secure rateless Deluge algorithm that effectively resists pollution attacks. Zhang and Zhang propose a LR-Seluge algorithm that provides the security attributes of Seluge and is also resistant to packet loss [19]. But, after adopting the rateless encoding scheme as discussed in literature, packets are authenticated after receiving enough packets to decode them successfully. Hence, a verification delay is introduced and the proposed algorithm by them is vulnerable to DoS attacks against the verification delay. There are some papers in the literature that propose the distributed code dissemination algorithms [20–22]. The algorithms proposed by these authors assume non existent of the base stations and allow multiple users to launch code dissemination. An algorithm referred as DiCode mainly adopts proxy signature warrant technology [20]. However, in DiCode, a node is required to perform two expensive digital signature authentication operations. Another algorithm referred as SDRP utilizes a bilinear pairing cryptographic technique for multi-user license [21,22]. But, high complexity of bilinear pairing greatly affects the usefulness of the algorithm. The significant contribution of this paper is described in Section 1.

The PRXeluge adopts distributed LDO dissemination scheme and the framework is shown in Fig. 2
                     . In the proposed algorithm, three roles are included such as the service provider or the network owner, authorized smartphone users (such as contracted picture reporters), and the subscriber groups of mobile social network. As shown in Fig. 2, a general smartphone 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      wants to become an authorized user, first generates a public and private key pair 
                        
                           <
                           
                              
                                 pk
                              
                              
                                 i
                              
                           
                           ,
                           
                           
                              
                                 sk
                              
                              
                                 i
                              
                           
                           >
                        
                      via cryptographic algorithm, and then sends a request message including the 
                        
                           
                              
                                 pk
                              
                              
                                 i
                              
                           
                        
                      and other information to the service provider. After receiving and verifying the requested message, the service provider allocates a personal identity 
                        
                           
                              
                                 UID
                              
                              
                                 i
                              
                           
                        
                      to 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     . And then, according to the role of 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     , the service provider produces a conditional proxy re-signature key 
                        
                           
                              
                                 rk
                              
                              
                                 i
                              
                           
                        
                      for 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      and sends an acknowledgment packet including 
                        
                           
                              
                                 UID
                              
                              
                                 i
                              
                           
                        
                      to 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     . After receiving the acknowledgment, 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      preprocesses the sensed LDO for dissemination, generates a digital signature 
                        
                           
                              
                                 σ
                              
                              
                                 i
                              
                           
                        
                      for the final preprocessing results and generates other information such as the data version number. 
                        
                           
                              
                                 σ
                              
                              
                                 i
                              
                           
                        
                      is sent to the service provider by 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      for authentication through 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     ’s public key 
                        
                           
                              
                                 pk
                              
                              
                                 i
                              
                           
                        
                     . After the verification of authentication, 
                        
                           
                              
                                 σ
                              
                              
                                 i
                              
                           
                        
                      is digitally re-signed with 
                        
                           
                              
                                 rk
                              
                              
                                 i
                              
                           
                        
                      to generate the re-signature 
                        
                           
                              
                                 σ
                              
                              
                                 0
                              
                           
                        
                     , which is sent back to 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     . The 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      first verifies 
                        
                           
                              
                                 σ
                              
                              
                                 0
                              
                           
                        
                      based on the public key of the service provider. The 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      bootstraps the online data dissemination through 
                        
                           
                              
                                 σ
                              
                              
                                 0
                              
                           
                        
                      if the verification is found to be successful. In order to save energy consumption during online data dissemination, the XOR encoding scheme is used and each node in the subscriber group forwards the encoded packet. As shown in Fig. 2, the steps 1, 6, and 7 in rectangle are used to exploit the general public cryptographic scheme and the steps 3, 8, 9 and 10 in rectangle are used to exploit any existing sophisticated condition proxy re-signature schemes. Due to the space limitations, the proposed work in this paper provides only the framework and does not elaborate the specific implementation. In the next sections, the pre-processing of LDO and XOR network coding scheme are demonstrated.

For convenience of description, it is assumed that the authorized smartphone user is 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     . For the LDO preprocessing, PRXeluge employs a similar method as proposed in Seluge [2]. In order to ensure the self-contained characteristic of the content, LDO preprocessing methods are briefly described in this section. First, 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      divides the LDO into a series of fixed-size pages, and each page is further divided into fixed-size packets. Then, starting from the last page, denoted as PageP, the hash value of each packet in PageP is calculated and appended at the end of the corresponding packet in 
                        
                           PageP
                           -
                           1
                        
                     . This process continues until 
                        
                           Page
                           1
                        
                      is finished. After the hash values of all packets in 
                        
                           Page
                           1
                        
                      are calculated, PRXeluge builds a Merkle Hash Tree (MHT) on the basis of all these hash values. The resulting number of hash values in 
                        
                           Page
                           1
                        
                      is assumed to be M. To build the MHT, PRXeluge first combines all these M hash values into 
                        
                           AHV
                           _
                           Page
                           1
                        
                     . Afterwards PRXeluge divides 
                        
                           AHV
                           _
                           Page
                           1
                        
                      into 
                        
                           
                              
                                 2
                              
                              
                                 k
                              
                           
                        
                      segments where, k is the number of levels of complete binary tree and is the minimum value that satisfies Eq. 1.
                        
                           (1)
                           
                              
                                 
                                    M
                                    ×
                                    |
                                    H
                                    (
                                    ·
                                    )
                                    |
                                 
                                 
                                    
                                       
                                          2
                                       
                                       
                                          k
                                       
                                    
                                 
                              
                              +
                              k
                              ×
                              |
                              H
                              (
                              ·
                              )
                              |
                              ⩽
                              Maximum
                              _
                              payload
                              _
                              size
                           
                        
                     where 
                        
                           Maximum
                           _
                           payload
                           _
                           size
                        
                      is the maximum payload of a data packet. The 
                        
                           Maximum
                           _
                           payload
                           _
                           size
                        
                      is 102 for the sensor platforms that use IEEE 802.15.4 compliant radios. The hash values of new 
                        
                           
                              
                                 2
                              
                              
                                 k
                              
                           
                        
                      leaf nodes, denoted as 
                        
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 V
                              
                              
                                 
                                    
                                       2
                                    
                                    
                                       k
                                    
                                 
                              
                           
                        
                     , are calculated again. Each two newly calculated hash values are further combined into a packet, and the hash value of this packet is calculated again. This process is repeated until only one hash value is generated, which is called the root of MHT. Assuming, there are total of 48 hash values in 
                        
                           Page
                           1
                        
                      and 64-bit truncation of SHA-1 (Secure Hash Algorithm) is used as a hash function, and 
                        
                           k
                           =
                           3
                        
                      satisfy Eq. 1. PRXeluge establishes MHT as follows: First, each 6 hash values(
                        
                           6
                           =
                           48
                           /
                           
                              
                                 2
                              
                              
                                 3
                              
                           
                        
                     ) are combined to get a packet. Packets 
                        
                           H
                           (
                           
                              
                                 Pkt
                              
                              
                                 1
                                 ,
                                 1
                              
                           
                           )
                        
                      to 
                        
                           H
                           (
                           
                              
                                 Pkt
                              
                              
                                 1
                                 ,
                                 6
                              
                           
                           )
                        
                      are combined to form 
                        
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                        
                     , packets 
                        
                           H
                           (
                           
                              
                                 Pkt
                              
                              
                                 1
                                 ,
                                 7
                              
                           
                           )
                        
                      to 
                        
                           H
                           (
                           
                              
                                 Pkt
                              
                              
                                 1
                                 ,
                                 12
                              
                           
                           )
                        
                      are combined to form 
                        
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                        
                      and so on. The hash values of 
                        
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 V
                              
                              
                                 8
                              
                           
                        
                      are computed and their hash values denoted as 
                        
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 e
                              
                              
                                 8
                              
                           
                        
                      are generated. Hash values 
                        
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                        
                      and 
                        
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                        
                      are combined into a packet, and its hash value 
                        
                           
                              
                                 e
                              
                              
                                 1
                                 -
                                 2
                              
                           
                        
                      is calculated and the process is repeated until 
                        
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 8
                              
                           
                        
                      is generated. 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      digitally signs the message including the MHT root and version number of LDO with the private key 
                        
                           
                              
                                 sk
                              
                              
                                 i
                              
                           
                        
                      and sends the digital signature to the service provider. The service provider verifies the signature first. If the signature is found to be correct, the service provider resigns the signature with the proxy key 
                        
                           
                              
                                 rk
                              
                              
                                 i
                              
                           
                        
                     , and sends back re-signed digital signature packet to 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                     . 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      bootstraps data dissemination with the re-signature packets. Furthermore, PRXeluge also integrates weak authentication mechanism called MSP to avoid unnecessary digital signature authentication operation, which effectively mitigates DoS attacks against digital signature packet.

To reduce communication load involved by data dissemination, PRXeluge introduces the idea of network coding. First, the node encodes the packets for transmission and then, sends the encoded data packets. It is assumed in the proposed work that the number of neighbor nodes are n, denoted as 
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 P
                              
                              
                                 n
                              
                           
                        
                     , and a data page is divided into t fixed-size packets, denoted as 
                        
                           
                              
                                 M
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 M
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 M
                              
                              
                                 t
                              
                           
                        
                     . To record the status of neighbor nodes, a neighbor node table is first introduced. Each neighbor corresponds to a record in the table and a record contains a bit vector of length t, where each bit corresponds to a message. If the neighbor does not contain certain message, the corresponding bit is set to 1, otherwise, it is set to 0. Without loss of generality, the bit vectors of neighbor node P are denoted as 
                        
                           
                              
                                 P
                              
                              
                                 i
                              
                           
                           (
                           
                              
                                 m
                              
                              
                                 i
                                 1
                              
                           
                           ,
                           
                              
                                 m
                              
                              
                                 i
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 m
                              
                              
                                 it
                              
                           
                           )
                           
                           
                           
                              
                                 m
                              
                              
                                 ij
                              
                           
                           ∈
                           (
                           0
                           ,
                           1
                           )
                           ,
                           
                           i
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           t
                        
                     . At the end, each node maintains a neighbor node table as shown in Table 1
                     . The initial state of Table 1 is empty. After receiving Selective Negative Acknowledgment (SNACK) request from the neighbor nodes, a node first checks the table to find a corresponding record. If the corresponding record is not found, then add a record, otherwise, the corresponding record is updated.

Based on the above neighbor node table, the proposed algorithm employs XOR network coding method. The idea behind the XOR coding is: a node sends the packet 
                        
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                           ⊕
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                      once assuming 
                        
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                        
                      and 
                        
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                      are the disseminated data packet. Nodes having packet 
                        
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                        
                      can decode it and get packet 
                        
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                      by simple XOR operation of 
                        
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                           ⊕
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                           ⊕
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                     , and nodes having packet 
                        
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                      can decode it and get packet 
                        
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                        
                      by simple XOR operation of 
                        
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                           ⊕
                           
                              
                                 d
                              
                              
                                 1
                              
                           
                           ⊕
                           
                              
                                 d
                              
                              
                                 2
                              
                           
                        
                     . Therefore, with just one data packet transmission, different nodes can obtain a different packet. Hence, the number of packets transmitted is reduced. The subsections below elaborate the best XOR coding scheme based on the above neighbor node table.

For convenience of description, the following definitions are given first.
                           Definition 1
                           Encoding scheme k: this indicates the number of messages involved in XOR coding are k. For example, encoding scheme 1 means only one message is involved in XOR encoding, Encoding scheme 2 means that two messages are involved in XOR encoding, and so on. The encoding scheme is only related with the number of message involved in encoding, not the message sequence, so for situation with t messages, there are 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          t
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          t
                                       
                                       
                                          i
                                       
                                    
                                 
                               encoding schemes.

The meanings of other notations used in the paper are introduced as Table 2
                        . Based on these definitions and symbols specification, the objectives of optimal coding scheme are formulated as:
                           
                              (2)
                              
                                 max
                                 {
                                 
                                    
                                       Y
                                    
                                    
                                       k
                                    
                                 
                                 |
                                 
                                 k
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 t
                                 }
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 max
                                 {
                                 
                                    
                                       Y
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 |
                                 
                                 s
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                    
                                       k
                                    
                                 
                                 }
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                              
                           
                        s.t.
                           
                              (5)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 =
                                 k
                              
                           
                        
                        
                           
                              (6)
                              
                                 0
                                 <
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ×
                                 
                                    
                                       m
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ×
                                 
                                    
                                       m
                                    
                                    
                                       ij
                                    
                                 
                                 ,
                                 
                                 i
                                 ∈
                                 [
                                 1
                                 ,
                                 n
                                 ]
                                 ,
                                 j
                                 ∈
                                 [
                                 1
                                 ,
                                 t
                                 ]
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ×
                                 
                                    
                                       m
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 1
                                 ,
                                 
                                 1
                                 ⩽
                                 i
                                 ⩽
                                 n
                                 ,
                                 j
                                 ∈
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ⩽
                                 1
                                 |
                                 
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 ,
                                 
                                 j
                                 ∈
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       y
                                    
                                    
                                       ij
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                           
                        
                     

In the optimization goal, Eq. (2) shows that in all the coding schemes, the maximum number of all data packets, which can be successfully decoded by its neighbor nodes; Eq. (3) shows, in all encoding combinations of coding scheme k, the maximum number of all packets that are successfully decoded by its neighbor nodes; Eq. (4) describes the number of all successful decoded data packets by the neighbor nodes while adopting encoding combination s for the coding scheme k. Therefore, the proposed optimization objectives are summarized as: find an optimal encoding combination from all encoding combinations of all encoding schemes such that the number of neighbor nodes which decode a data packet successfully are maximized.

Different constraints are explained in Eqs. (5)–(9). Eq. (5) ensures that in the coding scheme k, the number of packets involved in encoding is k; Eq. (6) ensures that if a packet is successfully received by all neighbor nodes, it does not participate in encoding; Eq. (7) explains that the neighbor node is capable of decoding a packet only if the packet is selected by current encoding scheme and is unreceived by the current node; Eq. (8) demonstrates that a neighbor node is capable of decoding successfully if only one packets among all packets involved in encoding process are not successfully received by current node, otherwise, according to XOR coding theory, the node does not decode the packet correctly; Eq. (9) ensures that any neighbor node is capable of decoding successfully at most one packet, because according to the principle of XOR coding, a node is capable of decoding successfully at most a packet once. The notations used in all the above mentioned equations are described in Table 2.

Simple method for searching the optimal encoding scheme is enumeration, which means searching for all possible encoding combinations of all possible encoding schemas. As described above, the encoding scheme 1 may have 
                           
                              
                                 
                                    C
                                 
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                           
                         encoding combinations, the encoding scheme 2 may have 
                           
                              
                                 
                                    C
                                 
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                           
                         encoding combinations, and the encoding scheme k may have 
                           
                              
                                 
                                    C
                                 
                                 
                                    t
                                 
                                 
                                    k
                                 
                              
                           
                         encoding combinations. Therefore, the total number of encoding combinations of all encoding schemas:
                           
                              (10)
                              
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                    
                                       3
                                    
                                 
                                 +
                                 …
                                 +
                                 
                                    
                                       C
                                    
                                    
                                       t
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       2
                                    
                                    
                                       t
                                    
                                 
                              
                           
                        In Eq. (10), t is the number of disseminated code page’s data packets. Before data dissemination, it is a determined constant. Therefore, this problem is a P problem whose optimal solution can be found in polynomial time.

It is assumed that the nodes’ current snapshot of neighbor table is shown in Table 3
                        , and the adopted encoding scheme is 3. According to the constraint condition as described in Eq. (5), the coding combination 1 of encoding scheme 3 as vector 
                           
                              
                                 
                                    X
                                 
                                 
                                    
                                       
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              [
                              0
                              
                              1
                              
                              0
                              
                              1
                              
                              1
                              ]
                           
                         is set, which means the packets 
                           
                              
                                 
                                    M
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                              
                                 
                                    M
                                 
                                 
                                    4
                                 
                              
                              ,
                              
                              
                                 
                                    M
                                 
                                 
                                    5
                                 
                              
                           
                         are involved in encoding. According to the constraint conditions as described in Eqs. (6) and (7), all packets are successfully decoded by neighbor nodes as shown in Table 4
                        . According to the constraint as described in Eq. (8) and under the situation as shown in Table 3, 
                           
                              
                                 
                                    M
                                 
                                 
                                    3
                                 
                              
                           
                         does not participate in encoding because it is successfully received by all nodes. According to Table 4, 
                           
                              
                                 
                                    Y
                                 
                                 
                                    
                                       
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              2
                           
                         and 
                           
                              
                                 
                                    C
                                 
                                 
                                    5
                                 
                                 
                                    3
                                 
                              
                              =
                              
                                 
                                    C
                                 
                                 
                                    4
                                 
                                 
                                    3
                                 
                              
                              =
                              4
                           
                         is found out. If 
                           
                              
                                 
                                    X
                                 
                                 
                                    
                                       
                                          2
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              [
                              1
                              
                              0
                              
                              0
                              
                              1
                              
                              1
                              ]
                              ,
                              
                              
                                 
                                    X
                                 
                                 
                                    
                                       
                                          3
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              [
                              1
                              
                              1
                              
                              0
                              
                              1
                              
                              0
                              ]
                           
                         and 
                           
                              
                                 
                                    X
                                 
                                 
                                    
                                       
                                          4
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              [
                              1
                              
                              1
                              
                              0
                              
                              1
                              
                              0
                              ]
                           
                         are assumed, 
                           
                              
                                 
                                    Y
                                 
                                 
                                    
                                       
                                          2
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              2
                              ,
                              
                              
                                 
                                    Y
                                 
                                 
                                    
                                       
                                          3
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              2
                           
                         and 
                           
                              
                                 
                                    Y
                                 
                                 
                                    
                                       
                                          4
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              =
                              2
                           
                         are found out. Therefore, 
                           
                              
                                 
                                    Y
                                 
                                 
                                    3
                                 
                              
                              =
                              2
                           
                        . With the same procedure, when 
                           
                              
                                 
                                    Y
                                 
                                 
                                    2
                                 
                              
                              =
                              5
                              ,
                              
                              
                                 
                                    Y
                                 
                                 
                                    4
                                 
                              
                              =
                              0
                           
                         and 
                           
                              
                                 
                                    Y
                                 
                                 
                                    2
                                 
                              
                              =
                              5
                           
                        , then, one can determine that the corresponding encoding combination is 
                           
                              
                                 
                                    X
                                 
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              =
                              [
                              1
                              
                              1
                              
                              0
                              
                              0
                              
                              0
                              ]
                           
                        , which is the optimal encoding scheme corresponding to snapshot of neighbor as shown in Table 3.

In the process of data dissemination, if a malicious node constantly requests data packets from a node by SNACK, or continuously broadcasts fake data packets to other nodes, then the node soon runs out of energy, and stops working. For this type of attack, PRXeluge proposes a counter method. First, on the foundation of neighbor table as shown in Table 1, two additional fields Sending Counter (SC) and Receiving Counter (RC) are introduced, which respectively represent the number of packets sent to the corresponding neighbor and the number of packets received from the corresponding neighbor. The extended neighbor table is shown in Table 5
                        . If SC or RC exceed a certain threshold, then the node is marked as a malicious node and is blocked for some time, during which the node does not send or receive any message from the blocked node.


                     
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      first bootstraps data dissemination by a proxy re-signature packet that includes root node of MHT. After receiving the proxy re-signature packet, a node authenticates it through the public key of the service provider, which is preloaded on all nodes. If the authentication is found to be correct, the root node of MHT and the identification of 
                        
                           
                              
                                 user
                              
                              
                                 i
                              
                           
                        
                      are also authenticated. Furthermore, all the hash values of the page 1 is authenticated by the MHT. PRXeluge each time transmits a packet including a MHT leaf node 
                        
                           
                              
                                 V
                              
                              
                                 0
                              
                           
                        
                      and all brother nodes on every layer of the path between 
                        
                           
                              
                                 V
                              
                              
                                 0
                              
                           
                        
                      and the root. A node authenticates 
                        
                           
                              
                                 V
                              
                              
                                 0
                              
                           
                        
                      immediately after receiving the packets. For example, the packet 
                        
                           
                              
                                 V
                              
                              
                                 0
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 3
                                 _
                                 4
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 5
                                 _
                                 8
                              
                           
                        
                      is transmitted to transmit 
                        
                           
                              
                                 V
                              
                              
                                 0
                              
                           
                        
                     , where 
                        
                           |
                           |
                        
                      indicates the concatenation operator. When a node receives this packets, it calculates the hash value of the packets such as 
                        
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                           =
                           Hash
                           (
                           
                              
                                 V
                              
                              
                                 0
                                 ,
                                 1
                              
                           
                           )
                           ,
                           
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 2
                              
                           
                           =
                           Hash
                           (
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                           )
                           ,
                           
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 4
                              
                           
                           =
                           Hash
                           (
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 2
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 3
                                 _
                                 4
                              
                           
                           )
                        
                      and 
                        
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 8
                              
                           
                           =
                           Hash
                           (
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 4
                              
                           
                           |
                           |
                           
                              
                                 e
                              
                              
                                 5
                                 _
                                 8
                              
                           
                           )
                        
                      where, 
                        
                           
                              
                                 e
                              
                              
                                 1
                                 _
                                 8
                              
                           
                        
                      is the root of the hash tree. At the end, PRXeluge just compares it with the received value extracted from advertisement packet 
                        
                           
                              
                                 P
                              
                              
                                 adv
                              
                           
                        
                      that is authenticated by the digital re-signature. In this way, PRXeluge ensures that all hash values of all the packets in page 1 are authenticated correctly and immediately.

Before transmitting the data packets of LDO, the optimal encoding scheme is first determined. The MAC of the sequence number of packets involved in encoding is appended at the end of the encoded data packet, which is broadcasted. After the node receives the encoded data packet, the sequence numbers of packets involved in encoding are extracted and then the packets are decoded. Since the hash values of the data packets of 
                        
                           
                              
                                 Page
                              
                              
                                 1
                              
                           
                        
                      are correctly received in advance, all data packets in 
                        
                           
                              
                                 Page
                              
                              
                                 1
                              
                           
                        
                      are authenticated immediately. While transmitting 
                        
                           
                              
                                 Page
                              
                              
                                 i
                              
                           
                        
                     , any data packet 
                        
                           
                              
                                 Pkt
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                        
                      in 
                        
                           
                              
                                 Page
                              
                              
                                 i
                              
                           
                        
                      is authenticated immediately because the hash value of 
                        
                           
                              
                                 Pkt
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                        
                      is received reliably. Similar to the Deluge, the data pages are transmitted page by page, hence, when transmitting the data packets in 
                        
                           
                              
                                 Page
                              
                              
                                 i
                              
                           
                        
                     , all packets in 
                        
                           
                              
                                 Page
                              
                              
                                 i
                                 -
                                 1
                              
                           
                        
                      must be received reliably. Hence, all the pages are immediately authenticated and integrity of LDO is guaranteed. As a result, each node is capable of finding and deleting a forged or modified data packet as early as possible in PRXeluge.

As shown in Fig. 2, as long as the modules inside the blue rectangle use the existing sophisticated cryptographic algorithms, the security is protected by secure properties of the algorithm. The additional analysis is not needed as the security of the proposed PRXeluge is proven and validated. As in the above mentioned analysis, except for the fine access control and distributed secure properties, PRXeluge shows similar security as that of Seluge during the data dissemination. Furthermore, compared with the centralized Seluge, PRXeluge does not bring any additional load to the node in the subscriber groups. All increased computational load is taken care of by the active authorized party or by the service provider that are generally strong in terms of computation capacity and energy. Moreover, these additional cryptographic operations are generally finished before data dissemination. As a result, the additional delay is not introduced.

Finally, the performance of PRXeluge is evaluated. It is found from the security analysis as mentioned in Sections 5 and 6 that PRXeluge is capable of preventing several DoS attacks: (1) the delay-based DoS attacks are effectively prevented because data packets are instantly authenticated; (2) DoS attacks against digital signature are mitigated by the weak authentication mechanism called MSP; (3) DoS attacks based on repeated requests are effectively prevented through SC and RC. The cryptographic algorithms in PRXeluge use the existing sophisticated security algorithms. Because the security framework of PRXeluge is similar to that of Seluge, PRXeluge exhibits same performance in terms of security as that of Seluge and no further verification is done by experiments. In this section, the validity of encoding method is mainly verified.

The performance is tested on a network of MicaZ motes which includes 72 nodes. MicaZ motes uses IEEE 802.15.4 compliant radios, whose maximum payload size is 102byte. In the proposed experiments, two performance metrics are measured: dissemination latency and dissemination overhead. Dissemination latency indicates the time during which the LDO is disseminated to the whole network and dissemination overhead indicates the total number of transmitted packets by all the nodes during the LDO dissemination, including hash packets, SNACK packets and data packets. Because the sleep mechanism is not introduced and every node keep its radio on, the propagation delay is closely related to the energy consumption required by the LDO dissemination.

In the proposed experiment, two additional algorithms are implemented to compare the performance. One is Seluge [2], which does not employ any encoding strategy and the other is a revised Seluge, named Seluge_RC, which employs random encoding strategy. To investigate and compare the impact of dissemination LDO size on performance, five different LDO sizes: 5Kbytes, 10Kbytes, 20Kbytes, 30Kbytes and 40Kbytes are used. Fig. 3
                      shows the dissemination overload of three algorithms when the loss packets are not considered. As shown in Fig. 3, the number of transmitted packets almost linearly increase as a function of the LDO size in all three algorithms. The Seluge shows the largest dissemination overhead. Seluge_RC has a slightly smaller communication cost than Seluge and when the LDO size is 40Kbytes, the communication cost of Seluge_RC is 4.6% smaller than that of Seluge. However, when the LDO size is 5Kbytes, Seluge_RC has a slightly higher communication cost than Seluge. The reason is that the coding strategy is random and the performance is worse when the LDO size is smaller. The proposed algorithm exhibits better performance in terms of communication cost and is 14.3% smaller than that of Seluge when the LDO size is 40Kbytes.


                     Fig. 4
                      shows the dissemination latency with respect to LDO size within Multi-hop networks. As shown in Fig. 4, all of these three algorithms show linear scalability with respect to LDO size. It is also observed from the experiment that the latency of Seluge is the highest. Seluge_RC introduces slightly smaller delay than Seluge and is 3.8% smaller delay than that of Seluge when the LDO size is 40Kbytes. However, when the LDO size is 5Kbytes, Seluge_RC exhibits a slightly higher latency than Seluge. The reason is similar to the case of the communication cost. The proposed algorithm exhibits the smallest latency and is 12.2% smaller than that of Seluge when the LDO size is 40Kbytes.

@&#CONCLUSIONS@&#

This paper proposes a secure distributed online data dissemination algorithm based on network coding, called PRXeluge. PRXeluge is a data dissemination algorithm, which supports authorized multiple parties and has fine-grained access control. In PRXeluge, the service provider uses conditional proxy re-signature scheme to authorize any smartphone user. If the service provider finds malicious behavior of an authorized smartphone user, the service provider revokes the license at any moment. In addition, PRXeluge proposes XOR network coding scheme on the basis of Seluge security framework. Experimental results show that PRXeluge shows similar security performance as that of Seluge and PRXeluge exhibits better performance than Seluge, in terms of reduction in the transmission of data packets and data dissemination latency. Compared to the centralized scheme, PRXeluge does not bring additional load to the nodes in subscriber group. Currently, the work in the paper only gives secure data dissemination framework where, conditional proxy re-signature is introduced. The work in this paper does not give an implementation of specific cryptographic algorithms such as proxy re-signature. In the further work, novel cryptographic algorithm such as proxy re-signature will be implemented to improve certain features.

@&#ACKNOWLEDGEMENTS@&#

This work was partially supported by Grant Nos. 61472365, 61379121 and 61100214 from the National Natural Science Foundation of China and Grant No. LR12F02002 from Natural Science Fund for Distinguished Young Scholars of Zhejiang Province and Grand No. 2010R50041 from Key Innovation Team of Science and Technology Department of Zhejiang Province.

@&#REFERENCES@&#

