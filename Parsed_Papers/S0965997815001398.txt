@&#MAIN-TITLE@&#Mesh color sharpening

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new method for mesh color sharpening.


                        
                        
                           
                           Utilize the Laplace–Beltrami operator for mesh color processing.


                        
                        
                           
                           Implement five different discretizations of the Laplace–Beltrami operator.


                        
                        
                           
                           Sharpen mesh vertex color while keeping vertex positions intact.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Laplace–Beltrami operator

3D irregular mesh

Color sharpening

Operator discretization

Model scanning

3D modeling

@&#ABSTRACT@&#


               
               
                  This paper presents a novel method for mesh color sharpening using the discrete Laplace–Beltrami operator, which is an approximation of the second order derivatives on irregular 3D meshes. The one-ring neighborhood is utilized to compute the Laplace–Beltrami operator. The color of each vertex of the 3D mesh is updated by adding the Laplace–Beltrami operator of the vertex color weighted by a factor to its original value. Laplacian is commonly used in image processing to sharpen 2D images and different discretizations of the Laplace–Beltrami operator have been proposed for geometrical processing of 3D meshes. This paper utilizes several discretizations of the Laplace–Beltrami operator for sharpening 3D mesh colors and applied them to various 3D objects. This method successfully improves the visual appearance of the meshes while keeping the surface geometry intact. Experimental results of the proposed mesh color sharpening method using different discretizations of the Laplace–Beltrami operator demonstrated its effectiveness on improving the visual appearances of 3D meshes.
               
            

@&#INTRODUCTION@&#

Three dimensional (3D) meshes are widely used in many fields and applications, such as computer graphics, games, animation films, and virtual reality. 3D meshes are usually generated using one of two methods: (1) artists create the meshes from scratch with 3D modeling software, such as Autodesk Maya and Google SketchUp; and (2) the meshes are created by scanning real 3D objects. The second method is becoming more popular because of the increasing precision and processing power of 3D scanners with reduced cost at the same time.

3D scanners collect data from the shape and color appearance of a real object or environment. The collected data are later processed to generate a 3D model of the real object. A wide range of commercial 3D scanners have been developed offering varied capabilities in terms of scanning range, precision and speed. Among them, Microsoft Kinect is a motion sensing device used by Microsoft Xbox 360 and Xbox One game consoles and Windows PCs, and is becoming very popular for scanning objects for various applications. One major advantage of Kinect is its low cost with a price of $150, compared with scanners with typical prices of thousands or tens of thousands dollars. One of the best available 3D scanning applications that utilize Kinect is ReconstructMe [1]. ReconstructMe creates color meshes with each vertex of the mesh containing position, normal, and color information. To improve the quality of color meshes, two approaches can be utilized: geometrical processing and color (appearance) processing. Geometrical processing changes each vertex’s position while keeping its color information intact; on the other hand, color processing changes each vertex’s color while keeping its position (or the object shape) intact. Existing mesh processing methods have been focused on improving the geometrical properties of the meshes.

Various methods have been proposed to improve the quality of the meshes generated by 3D scanners, such as surface smoothing [2], which removes geometrical noise in the mesh using Laplacian smoothing. However, local Laplacian smoothing leads to a variety of artifacts such as geometric distortion and shrinkage due to the irregular connectivity of the mesh. Several techniques were proposed to eliminate this shrinkage problem and topological effects of smoothing [3–5]. Wang [6] proposed a sharpening method using Bilateral filtering followed by iteratively modifying the mesh’s connectivity to form singlewide sharp edges that were detected by their dihedral angles. A distance measure was defined based on normal tensor analysis [7]. This algorithm consists of two stages that require much computation time and filter only around the edge features of the model. Particular focus was also on edge sharpening. Attene et al. [8] applied a filtering approach that required subdivision of Chamfer triangles. Ohtake et al. [9] proposed polyhedral surface smoothing that is a combination of Laplacian smoothing flow and discrete mean curvature flow. Another approach for smoothing surfaces was introduced in [10] using fuzzy vector median filters for surface normal filtering in a two-step procedure. Another technique was proposed for surface fairing in [11]. In this paper, the multiscale method combined the image processing methodology based on nonlinear diffusion equations and the theory of geometric evolution problems for surface processing. This method smoothed the surface by enhancing the edges and corners of the surface. Surface fairing or removing rough features was also conducted in [12,13]. Hildebrandt and Polthier [12] proposed an algorithm which is based on a constraint that controls the spatial deviation of the surface. Shen et al. [14] applied normal filtering to improve the quality of the mesh surface and remove the noise. This geometric approach consumes much computational cost because of its feature detection stage. Since Laplacian cannot be applied to the irregular meshes due to the irregular topology of meshes, Laplace–Beltrami operator was introduced in different applications, such as computational fluid dynamics [15,16], and shape segmentation [17]. Paiva et al. [17] introduced a mesh-free discrete Laplace–Beltrami operator that is defined on point based surfaces for filtering and shape segmentation. Belkin et al. [18] proposed an algorithm to approximate the Laplace operator of a surface with point-wise convergence that is applicable to arbitrary meshed surfaces. Scale dependent Laplacian operator was utilized in [19] to improve the smoothness of surface with volume preservation. Gu et al. [20] applied discrete Laplace–Beltrami operator to determine the discrete Riemannian metric. To solve the convergence problem for numerical simulations over the surfaces, Wu et al. [21] and Xu [22] introduced a convergent algorithm of Laplace–Beltrami operator. Xiong et al. utilizes this convergent properties of Laplace–Beltrami operator for mesh surface smoothing in [23]. Wetzler et al. [24] applied Laplace–Beltrami operator as a diffusion filter and an invariant metric to obtain geometric shape matching. All of these methods used different approaches for geometric processing. The Laplace–Beltrami operator has been used only for geometrical processing, not for color processing.

Image sharpening is an important tool to improve the image quality. Image sharpening emphasizes texture and enhances the contrast of the image. Sharpening filters make the edges of an image to appear more defined by darkening the low intensity pixels and brightening the high intensity pixels. This creates a crisp edge between bright and dark portions of the image, producing more contrast. With advances in 3D scanning hardware, more and more colored meshes are being generated. Especially with the increasing availability of low-cost 3D scanners such as Microsoft Kinect, colored 3D meshes become more accessible. To the best of our knowledge, no image processing techniques such as sharpening and Laplace–Beltrami operator have been combined to improve the visual appearance of 3D colored meshes. This paper extends traditional image sharpening techniques for 2D regular images to 3D color meshes with irregular topologies. In particular, this paper utilizes several discretizations of the Laplace–Beltrami operator for mesh color sharpening. Several definitions and implementations of the Laplacian–Beltrami operator were investigated for their efficiency and effectiveness for mesh color sharpening.

Different ways to discretize the Laplace–Beltrami have been developed by defining the discrete operator polygon-wise on a triangle mesh, with the most prominent one being the cotan-operator, defined by Pinkall and Polthier [25]. Meyer et al. [26] used Voronoi area, Mayer [27] used the sum of areas of triangles over vertices, and Desbrun et al. [28] used two different approaches. One approach of Desbrun et al. paper used gradient of the normalized area and the other used the sum of cotan operator over the edges. These discretizations of the Laplace–Beltrami operator that were previously defined for computational fluid dynamics and mesh geometric processing are extended in this paper for color sharpening, thus providing several new tools for improving the quality of 3D meshes. The color of each vertex in the polygonal mesh is updated using various implementations of the Laplace–Beltrami operator. The performance of various implementations are compared and analyzed for the best approach of mesh color sharpening.

The remainder of this paper is organized as follows: Section 2 describes the techniques for image sharpening and how the Laplacian is used for image sharpening with some results. Sections 3 and 4 introduce the main algorithm of Laplace–Beltrami operator with implementations and mesh color sharpening using the Laplace–Beltrami operator. Section 5 describes experimental results and Section 6 concludes this paper.

Sharpening is commonly used in image processing to highlight transitions (or edges) in intensity. The main goal of image sharpening is to enhance the image and make the image to appear clearer and brighter. Various image sharpening filters have been proposed using the first-order and second-order derivatives. The Laplacian, which is a second-order derivative, is commonly used for image sharpening. The Laplacian operator can be defined for a function f(x, y) of two variables as follows:

                        
                           (1)
                           
                              
                                 
                                    ∇
                                    2
                                 
                                 f
                                 =
                                 
                                    
                                       
                                          ∂
                                          2
                                       
                                       f
                                    
                                    
                                       ∂
                                       
                                          x
                                          2
                                       
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∂
                                          2
                                       
                                       f
                                    
                                    
                                       ∂
                                       
                                          y
                                          2
                                       
                                    
                                 
                                 .
                              
                           
                        
                     Since the Laplacian is a derivative operator, it uses intensity discontinuity in an image and minimizes regions with slowly varying intensity levels. One implementation of Eq. (1) for the discrete Laplacian can be written as

                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          
                                             ∇
                                             2
                                          
                                          f
                                          
                                             (
                                             x
                                             ,
                                             y
                                             )
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          f
                                          (
                                          x
                                          +
                                          1
                                          ,
                                          y
                                          )
                                          +
                                          f
                                          (
                                          x
                                          −
                                          1
                                          ,
                                          y
                                          )
                                          +
                                          f
                                          (
                                          x
                                          ,
                                          y
                                          +
                                          1
                                          )
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          f
                                          (
                                          x
                                          ,
                                          y
                                          −
                                          1
                                          )
                                          −
                                          4
                                          f
                                          (
                                          x
                                          ,
                                          y
                                          )
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                     Eq. (2) is used to apply to the image as a filter mask. This filter mask can be represented as a grid which is shown in Fig. 1
                     (a). Fig. 1(b) shows an alternate implementation of the discrete Laplacian operator where each diagonal term contains additional 
                        −
                     2f(x, y) term for which 
                        −
                     8f(x, y) would be subtracted from the difference terms. Fig. 1(c) and (d) are the negatives of the previous implementations.

The Laplacian is used for image sharpening using the following formula [29]:

                        
                           (3)
                           
                              
                                 g
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 f
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 +
                                 c
                                 [
                                 
                                    ∇
                                    2
                                 
                                 f
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 ]
                              
                           
                        
                     where f(x, y) and g(x, y) are the input and sharpened images, respectively. The constant c = 
                        −
                     1 if the Laplacian filters in Fig. 1(a) and (b) are used, and c = 1 if Fig. 1(c) and (d) are used. Fig. 2
                     shows the application of this mask for both a grey scale image and a color image. The Lena image and the color of the pepper image appear brighter and sharper. The final results are images with enhanced details and significant improvement in sharpness.

The Laplacian is a second order derivative and because the pixels in an image are arranged in a rectangular grid; the discretization of the Laplacian is straightforward [29] and is computed as the second order differences along horizontal and vertical (or diagonal) directions. For most 3D meshes, no such rectangular grids exist, so imaging sharpening methods cannot be directly applied to mesh color sharpening. No such directions (horizontal, vertical, and diagonal) are defined for polygonal or triangular meshes and Eq. 2 cannot be extended directly to 3D meshes. The Laplace–Beltrami operator was proposed as the second order derivative on 3D meshes, which is to be discussed next.

The Laplace–Beltrami operator is mostly utilized in the field of differential geometry to operate on the surfaces in Euclidean spaces. It is a generalization of the second-order derivative operator Laplacian to non-flat Riemannian manifolds. Let f be a real valued function defined on a differentiable manifold M with Riemannian metric. The Laplace–Beltrami operator is defined as [30]
                     
                        
                           (4)
                           
                              
                                 Δ
                                 f
                                 :
                                 =
                                 d
                                 i
                                 v
                                 (
                                 g
                                 r
                                 a
                                 d
                                 
                                 f
                                 )
                              
                           
                        
                     where grad and 
                        
                           d
                           i
                           v
                        
                     are the gradient and divergence on the manifold M 
                     [30].

For discrete meshes, the function f on a triangular mesh T is defined by linearly interpolating the values of f(
                        
                           v
                           i
                        
                     ) at the vertices of T. This is done by choosing a base of piecewise linear hat-functions φ
                        i
                     , with value 1 at vertex 
                        
                           v
                           i
                        
                     and 0 at all the other vertices [31]. Then f is given as

                        
                           (5)
                           
                              
                                 f
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 f
                                 
                                    (
                                    
                                       v
                                       i
                                    
                                    )
                                 
                                 
                                    φ
                                    i
                                 
                                 .
                              
                           
                        
                     
                  

Discrete Laplace–Beltrami operators are usually represented as [26]
                     
                        
                           (6)
                           
                              
                                 Δ
                                 f
                                 
                                    (
                                    
                                       v
                                       i
                                    
                                    )
                                 
                                 =
                                 
                                    1
                                    
                                       d
                                       i
                                    
                                 
                                 
                                    ∑
                                    
                                       j
                                       ϵ
                                       N
                                       (
                                       i
                                       )
                                    
                                 
                                 
                                    w
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    [
                                    f
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    −
                                    f
                                    
                                       (
                                       
                                          v
                                          j
                                       
                                       )
                                    
                                    ]
                                 
                                 ,
                              
                           
                        
                     where N(i) denotes the index set of the 1-ring neighborhood of the vertex 
                        
                           
                              v
                              i
                           
                           ,
                        
                     i.e., the indices of all neighbors connected to 
                        
                           v
                           i
                        
                     by an edge. The mass di
                      is associated to the vertex i and the 
                        
                           w
                           
                              i
                              j
                           
                        
                     are symmetric edge weights. In the following subsections, several discretizations of Laplace–Beltrami operator will be discussed in detail.

Pinkall and Polthier used a constant mass in the discretization of the Laplace–Beltrami operator to compute discrete minimal surfaces [25]. The author defined the weight as follows,

                           
                              (7)
                              
                                 
                                    
                                       w
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          cot
                                          
                                             (
                                             
                                                α
                                                
                                                   i
                                                   j
                                                
                                             
                                             )
                                          
                                          +
                                          cot
                                          
                                             (
                                             
                                                β
                                                
                                                   i
                                                   j
                                                
                                             
                                             )
                                          
                                       
                                       2
                                    
                                    ,
                                 
                              
                           
                        where αij
                         and βij
                         denote the two angles opposite to the edge (i, j) as shown in the Fig. 3
                        .

Since this discretization uses constant mass, the overall weight is dependent on the cotangent value. The algorithm starts from a vertex of the mesh and applies the process around its 1-ring neighborhood. This 1-ring neighborhood consists of faces or triangles. For each edge, the cotangent of the opposite angles is calculated. This is the weight calculation according to the Eq. (7). This weight is then updated for each vertex in the 1-ring neighborhood using Eq. (6). This process is continued until it computes each vertex of the mesh.

A different geometric discretization was suggested by Meyer et al. [26], for triangular meshes. Their approach utilized the Voronoi area. If P, Q and R with circumcenter O is a non-obtuse triangle, as shown in Fig. 4
                        , a+b+c=π/2 can be obtained from the properties of perpendicular bisectors. So, we can write, 
                           
                              a
                              =
                              π
                              /
                              2
                              -
                              ∠
                              Q
                           
                        and 
                           
                              c
                              =
                              π
                              /
                              2
                              -
                              ∠
                              R
                           
                        .

The Voronoi area for point P can be computed as below:

                           
                              (8)
                              
                                 
                                    
                                       1
                                       8
                                    
                                    
                                       
                                          (
                                          |
                                          P
                                          R
                                          |
                                       
                                       2
                                    
                                    cot
                                    ∠
                                    Q
                                    +
                                    
                                       
                                          |
                                          P
                                          Q
                                          |
                                       
                                       2
                                    
                                    
                                       cot
                                       ∠
                                       R
                                       )
                                       .
                                    
                                 
                              
                           
                        
                     

Meyer et al. used the areas for the whole 1-ring neighborhood to compute the Voronoi area of the vertex 
                           
                              v
                              i
                           
                        as follows:

                           
                              (9)
                              
                                 
                                    
                                       A
                                       
                                          V
                                          o
                                          r
                                          o
                                          n
                                          o
                                          i
                                       
                                    
                                    =
                                    
                                       1
                                       8
                                    
                                    
                                       ∑
                                       
                                          j
                                          ϵ
                                          N
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       (
                                       cot
                                       
                                          α
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       cot
                                       
                                          β
                                          
                                             i
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       
                                          ∥
                                          
                                             v
                                             i
                                          
                                          −
                                          
                                             v
                                             j
                                          
                                          ∥
                                       
                                       2
                                    
                                    .
                                 
                              
                           
                        After computing the area of the 1-ring neighborhood, the weight is updated as follows:

                           
                              (10)
                              
                                 
                                    
                                       w
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       1
                                       
                                          2
                                          
                                             A
                                             i
                                          
                                       
                                    
                                    
                                       (
                                       cot
                                       
                                          α
                                          
                                             i
                                             j
                                          
                                       
                                       +
                                       cot
                                       
                                          β
                                          
                                             i
                                             j
                                          
                                       
                                       )
                                    
                                    ,
                                    i
                                    ≠
                                    j
                                    ,
                                    j
                                    ϵ
                                    N
                                    
                                       (
                                       i
                                       )
                                    
                                    ,
                                 
                              
                           
                        where N(i) is the 1-ring neighborhood of 
                           
                              
                                 v
                                 i
                              
                              ,
                           
                        and Ai
                         is the Voronoi area of the vertex 
                           
                              v
                              i
                           
                        . The author cautioned that this expression for the Voronoi finite-volume area does not hold in the presence of obtuse angles [26].

Experiments showed that the numerical quality of this operator is equivalent to the finite difference operators for regular sampling [26]. The Voronoi regions of each sample point minimize the bound on the error (created by local averaging of the mean curvature normal) due to spatial averaging, since they contain the closest points to each sample [28]. That is why the numerical estimates acquired through this is optimized and require few extra computations. This approach degrades gracefully if irregularity in mesh is increased. This process is implemented in two steps. First, the Voronoi area of each vertex is calculated. This Voronoi area is summed up for the whole 1-ring neighborhood of the vertex. Second, the weight is updated using this Voronoi area and the cotangent of two opposite angles of an edge.

Mayer et al. developed a method to compute the Laplacian of a function defined on a triangulated surface [27]. The spatial discretization triangulates the surface, and approximates any function which is defined on the surface by its values of the vertex. For a function f on surface S, Green’s formula can be written as,

                           
                              (11)
                              
                                 
                                    
                                       ∫
                                       
                                          
                                             D
                                             
                                                ɛ
                                             
                                          
                                          
                                             (
                                             z
                                             )
                                          
                                       
                                    
                                    Δ
                                    f
                                    
                                       (
                                       x
                                       )
                                    
                                    d
                                    x
                                    =
                                    
                                       ∫
                                       
                                          ∂
                                          
                                             D
                                             
                                                ɛ
                                             
                                          
                                          
                                             (
                                             z
                                             )
                                          
                                       
                                    
                                    
                                       ∂
                                       n
                                    
                                    f
                                    
                                       (
                                       s
                                       )
                                    
                                    d
                                    s
                                    .
                                 
                              
                           
                        Here, where D
                        ε(z) is a small disk at a point z on the surface S and n is the intrinsic outer normal of the boundary of the small disk and it is tangential to the surface. Mayer [27] discretized and replaced the disk of the triangulated surface by the 1-ring neighborhood of the vertex 
                           
                              v
                              i
                           
                        and provided the following approximation:

                           
                              (12)
                              
                                 
                                    Δ
                                    f
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    =
                                    
                                       1
                                       
                                          A
                                          (
                                          
                                             v
                                             i
                                          
                                          )
                                       
                                    
                                    
                                       ∑
                                       
                                          j
                                          ϵ
                                          N
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       
                                          
                                             d
                                             
                                                i
                                                j
                                             
                                          
                                          +
                                          
                                             d
                                             
                                                i
                                                ,
                                                j
                                                +
                                                1
                                             
                                          
                                       
                                       2
                                    
                                    .
                                    
                                       
                                          f
                                          
                                             (
                                             
                                                v
                                                j
                                             
                                             )
                                          
                                          −
                                          f
                                          
                                             (
                                             
                                                v
                                                i
                                             
                                             )
                                          
                                       
                                       
                                          ∥
                                          
                                             v
                                             i
                                          
                                          −
                                          
                                             v
                                             j
                                          
                                          ∥
                                       
                                    
                                    .
                                 
                              
                           
                        Here, 
                           
                              A
                              (
                              
                                 v
                                 i
                              
                              )
                           
                        is the sum of areas of triangles around the vertex 
                           
                              
                                 v
                                 i
                              
                              ,
                           
                        and for two consecutive vertices 
                           
                              v
                              j
                           
                        and 
                           
                              v
                              
                                 (
                                 j
                                 +
                                 1
                                 )
                              
                           
                        on the 1-ring neighborhood of 
                           
                              
                                 v
                                 i
                              
                              ,
                           
                        
                        dij
                         and 
                           
                              d
                              
                                 i
                                 ,
                                 j
                                 +
                                 1
                              
                           
                        are the distances between them respectively.

We can write this approximation in the following way:

                           
                              (13)
                              
                                 
                                    Δ
                                    f
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    =
                                    
                                       1
                                       
                                          A
                                          (
                                          
                                             v
                                             i
                                          
                                          )
                                       
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          N
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       
                                          ∥
                                          
                                             v
                                             a
                                          
                                          −
                                          
                                             v
                                             j
                                          
                                          ∥
                                          +
                                          ∥
                                          
                                             v
                                             b
                                          
                                          −
                                          
                                             v
                                             j
                                          
                                          ∥
                                       
                                       
                                          2
                                          ∥
                                          
                                             v
                                             i
                                          
                                          −
                                          
                                             v
                                             j
                                          
                                          ∥
                                       
                                    
                                    
                                       (
                                       f
                                       
                                          (
                                          
                                             v
                                             j
                                          
                                          )
                                       
                                       −
                                       f
                                       
                                          (
                                          
                                             v
                                             i
                                          
                                          )
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        Here, 
                           
                              A
                              (
                              
                                 v
                                 i
                              
                              )
                           
                        is the sum of areas of triangles around vertex 
                           
                              
                                 v
                                 i
                              
                              ,
                           
                        and a, b ∈ Ni
                          ∩  Nj
                        .


                        Eq. (13) is derived from Eq. (11) by approximating 
                           
                              
                                 ∫
                                 
                                    
                                       D
                                       
                                          ɛ
                                       
                                    
                                    
                                       (
                                       z
                                       )
                                    
                                 
                              
                              Δ
                              f
                              
                                 (
                                 x
                                 )
                              
                              d
                              x
                           
                        , ∂
                           n
                        
                        f(s) and dswith 
                           
                              Δ
                              f
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              A
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                        , 
                           
                              
                                 f
                                 
                                    (
                                    
                                       v
                                       j
                                    
                                    )
                                 
                                 −
                                 f
                                 
                                    (
                                    
                                       v
                                       i
                                    
                                    )
                                 
                              
                              
                                 ∥
                                 
                                    v
                                    i
                                 
                                 −
                                 
                                    v
                                    j
                                 
                                 ∥
                              
                           
                        and 
                           
                              
                                 
                                    ∥
                                    
                                       v
                                       a
                                    
                                    −
                                    
                                       v
                                       j
                                    
                                    ∥
                                    +
                                    ∥
                                    
                                       v
                                       b
                                    
                                    −
                                    
                                       v
                                       j
                                    
                                    ∥
                                 
                                 2
                              
                              ,
                           
                        respectively. This algorithm is used to calculate the area of triangles around each vertex and discretized Green’s formula of Riemannian manifold. Here, the distance between a vertex and its neighbor vertex is also taken into account.

Desbrun et al. [28] found the (area normalized) cotangent Laplacian by computing the area gradient explicitly in the discrete setting. They used two approaches for the Laplace–Beltrami operator. The first approach uses the cotangent formula of each opposite angles and the sum of the cotangent of every angles and the second approach computes the gradient of 1-ring neighborhood area and use the sum of the areas of each triangle. Eq. (14) is the normalized version of the computed weight. Desbrun defined the weight as:

                           
                              (14)
                              
                                 
                                    
                                       w
                                       i
                                    
                                    =
                                    
                                       
                                          cot
                                          
                                             α
                                             i
                                          
                                          +
                                          cot
                                          
                                             β
                                             i
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                j
                                                ϵ
                                                N
                                                (
                                                i
                                                )
                                             
                                          
                                          
                                             (
                                             cot
                                             
                                                α
                                                j
                                             
                                             +
                                             cot
                                             
                                                β
                                                j
                                             
                                             )
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

This algorithm is based on very basic, uniform approximations of the Laplacian. The second approach of Desbrun et al. used the gradient of the 1-ring area with respect to its center vertex. For a non-obtuse triangle, Desbrun also considered 1-ring neighboring vertices of the vertex 
                           
                              v
                              i
                           
                        as shown in Fig. 3. The area A is computed for a small region of a point p. Then the sum of the small areas of the triangles around 
                           
                              v
                              i
                           
                        are computed and denoted as 
                           
                              A
                              (
                              
                                 v
                                 i
                              
                              )
                           
                        . The overall approximation can be computed by as follows:

                           
                              (15)
                              
                                 
                                    Δ
                                    f
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    =
                                    
                                       3
                                       
                                          A
                                          (
                                          
                                             v
                                             i
                                          
                                          )
                                       
                                    
                                    
                                       ∑
                                       
                                          j
                                          ϵ
                                          N
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       
                                          cot
                                          
                                             α
                                             j
                                          
                                          +
                                          cot
                                          
                                             β
                                             j
                                          
                                       
                                       2
                                    
                                    
                                       |
                                       f
                                       
                                          (
                                          
                                             v
                                             j
                                          
                                          )
                                       
                                       −
                                       f
                                       
                                          (
                                          
                                             v
                                             i
                                          
                                          )
                                       
                                       |
                                    
                                    ,
                                 
                              
                           
                        where N(i) is the index set of the 1-ring neighboring vertices of vertex 
                           
                              v
                              i
                           
                        . αj
                        and βj
                         are the angles opposite to an edge as shown in the Fig. 3. This discretization achieves a good sharpening effect with respect to the shape of the geometry, as no drift happens and only geometric properties are used.

The previous section discussed several discretizations of the Laplace–Beltrami operator, including Pinkall, Meyer, Mayer, and two methods proposed by Desbrun. Developed for other types of applications, none of these discetizations has been utilized for color sharpening on irregular surface meshes. The color of each vertex of a 3D mesh contains three components: red, green, and blue and each component can be considered as a function defined on the mesh surface. In this work, each color component is treated and processed separately. The Laplace–Beltrami operator is calculated for each color component of a vertex and then that color component is updated by adding its Laplace–Beltrami operator weighted by a factor to its original value. This operation is repeated for all color components of all vertices.

The 1-ring neighborhood of a vertex is used to calculate the Laplace–Beltrami operator in all discretizations. Fig. 5
                      shows the 1-ring neighborhood of a vertex. If vertex 
                        
                           v
                           0
                        
                     has different color than its surrounding vertices, the method searches for the 1-ring neighborhood of each vertex and computes its associated weights and updates each color component of the vertex using the Laplace–Beltrami operator. These weights vary with different discretizations, thus having different impact on the meshes. As discussed in Section 3, Pinkall and Desbrun discretizations compute cotangent of angles, Mayer discretization utilizes the sum of areas of the triangles around vertices, whereas Meyer discretization uses the Voronoi area to calculate weight factors.

The overall system structure of the proposed mesh color sharpening method is illustrated in Fig. 6
                     . The 3D object is first scanned using a 3D scanner such as Microsoft Kinect. The input raw data are usually in the form of a point cloud from which a 3D mesh is then generated that typically consists of triangles. The 1-ring neighborhood is built for all vertices to facilitate fast processing and computing. These two steps establish the topology of the mesh. The mesh color sharpening phase processes all vertices in the 1-ring neighborhood of the center vertex. First, the Laplace–Beltrami operator of a neighboring vertex is computed. Then the change caused by that neighboring vertex is computed. Finally, the center vertex color is updated. This process is repeated for all three color components (RGB) of all vertices of the 3D mesh.

The various mesh color sharpening methods were implemented in MeshLab [32], an open source 3D mesh processing software package. MeshLab is connected by a central skeleton framework and a large set of independent plugins. This plug-in based architecture can be used to implement new functionalities. Meshlab also has some components that use the core data structure and basic algorithms provided by the VCG Library. VCG Library is a portable C++ templated library to implement algorithms for simplical complexes. All proposed mesh color sharpening methods were implemented as a plug-in C++ based on these data structures and template library.

@&#RESULTS AND DISCUSSIONS@&#

Several experiments were conducted to assess the performance of different implementations of the Laplace–Beltrami operator for mesh color sharpening using a wide range of 3D models. The Coca Cola can shown in Fig. 7
                      is a textured model. Fig. 7(b) is the result of conversion from texture to vertex color. After the conversion, the color is distorted. The model in Fig. 7(b) was used as an input to the mesh color sharpening. After applying the Laplace–Beltrami operator for mesh color sharpening, Pinkall, Meyer, Mayer and Desbrun-1 have similar performances. Mayer discretization performed better than Pinkall, Meyer, and Desbrun-1, as it recovered the Coca Cola label better than these methods. Desbrun-2 achieved the best performance and it produced a result that looks even better than the original model (Fig. 7(a)).

To further demonstrate the performance of the proposed mesh color sharpening algorithms, an artificial model cube (Fig. 8
                     
                     
                     (a)) was generated with the 3D modeling software Maya. Each face of the cube has a checkered pattern of red and blue squares. The cube was then blurred in MeshLab to generate the artificial input model shown in Fig. 8(b), which was then processed by different mesh color sharpening algorithms. Fig. 8(b) was generated by replacing the color of each vertex by the average of its neighbors’ colors. The Laplace–Beltrami operator using five different discretizations was then applied to the fuzzy mesh, Fig. 8(b), to improve the visual appearance of the mesh color and the results are shown in Fig. 8 (c), (d), (e), (f), and (g) respectively. It is clear that all five discretizations improved the sharpness of the mesh color to different extents. The edges in the cube model become blurry and thicker after the smoothing operation as shown in Fig. 8(b). All of the color sharpening methods sharpen the cube but Meyer (Fig. 8(d)) and Desbrun-2 (Fig. 8(g)) performed better than other three discretizations.


                     Fig. 9 shows more results using different models, including a cube with butterfly texture, a reindeer and a doll. The first row is a cube with a butterfly texture generated using Google SketchUp. The second row is a scanned model of a reindeer toy in a low light environment using Microsoft Kinect. The last row is a toy generated using the scanner under natural lighting condition. The original cube with the butterfly texture is dark and lacks details. After applying mesh color sharpening with different discretizations of the Laplace–Beltrami operator, the quality of the cube is improved significantly.

In particular, mesh color sharpening using the Desbrun-1 discretization of the Laplace–Beltrami operator produced stunning results (Fig. 9, 1st row, 5th column). It appears more vivid with visible veins on the leaf and crisp patterns on the butterfly wing. The background appears to have more depth as well. The reindeer model was captured under low light condition and it appears very dark, fuzzy, and dull. All mesh color processing methods improved the visual appearance of the reindeer model significantly with more sharpness. The wrinkles of the cloth on the reindeer are clearly visible, as are the eyes of the reindeer and the scarf it wears. The color variations around the reindeer’s nose are more prominent. The face and bottom of the girl doll model are severely contaminated with undesired red and black spots and patches. All mesh color sharpening method using different discretizations of the Laplace–Beltrami operator improve the quality of mesh to varied extents. The result produced by the Meyer discretization (Fig. 9, 3rd row, 3rd column) is almost perfect. It removed completely the undesired red contamination on the face and black contamination on the bottom, while enhancing details overall. The Pinkall discretization (Fig. 9, 3rd row, 2nd column) also produced good results with minor red color contamination on the face remaining. Other discretizations were not able to remove the color contaminations completely, but still produced results better than the contaminated input model. It is worth to emphasize that all the mesh color sharpening methods proposed in the paper have been applied to the 3D meshes, not 2D images.


                     Fig. 10 shows some of the objects and their corresponding mesh structures. Based on the experimental results presented in the paper, mesh color sharpening using different discretizations of the Laplace–Beltrami operator had varied performances on different 3D objects, while overall Desbrun-2 discretization achieved good performance on all models. All the mesh color sharpening methods have been implemented and incorporated into the open source software MeshLab.

It should be kept in mind that the computational cost is also critical for practical applications. Table 1
                      shows the computation time of mesh color sharpening using different discretizations of the Laplace–Beltrami operator on different 3D models. The butterfly, reindeer, and doll has 24, 30338, 29103 vertices and 12, 44850, 56554 faces, respectively.

@&#CONCLUSION@&#

This paper proposed a novel method for sharpening mesh colors using different discretizations of the Laplace–Beltrami operator and applied it to color 3D meshes. The Laplace–Beltrami operator is a second-order derivative operator defined for functions on surfaces. This paper implemented mesh color sharpening using different discretizations of the Laplace–Beltrami operator, including Pinkall, Meyer, Mayer, Desbrun-1, and Desbrun-2 discretizations, and applied to various kinds of 3D models. All mesh color sharpening methods improved the visual appearance of the 3D models. Different discretizations of the Laplace–Beltrami operator had varied performances of mesh color sharpening on different meshes, while the Desbrun-2 discretization achieved good performance on all 3D models in the experiments. Future research is needed to investigate the relationship between the mesh color sharpening performance and mesh structures, such as triangle density and shape. It is also worth noting that mesh color sharpening methods discussed in this paper only changed the visual appearance (vertex colors) of the meshes, not the geometrical shapes.

@&#REFERENCES@&#

