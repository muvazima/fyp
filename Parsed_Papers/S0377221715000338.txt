@&#MAIN-TITLE@&#Job-shop production scheduling with reverse flows

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We provide a linear model for the job-shop scheduling problem with reverse flows.


                        
                        
                           
                           We present a new heuristic to solve the 3-machine case.


                        
                        
                           
                           The heuristic offers goods results, especially when the two flows are balanced.


                        
                        
                           
                           We suggest a hybrid approach to solve the m-machine case.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Scheduling

Job-shop

Reverse flows

Heuristics

Linear programming

@&#ABSTRACT@&#


               
               
                  In this paper, we conduct a study of the job-shop scheduling problem with reverse flows. This NP-hard problem is characterized by two flows of jobs that cover the same machines in opposite directions. The objective is to minimize the maximal completion time of the jobs (i.e., the makespan).
                  We start by analyzing the complexity and identifying particular cases of the problem. Then, we provide a mathematical model that we use in conjunction with a solver to determine the computational times. These times are often too long because the problem is NP-hard. Thus, in this paper, we present a new heuristic method for solving the NP-hard 3-machine case. We evaluate the performance of this heuristic by computing several lower bounds and conducting tests on a Taillard-based benchmark. These tests give satisfying results and show that the heuristic ensures good performance when the two flows have comparable numbers of jobs. Then, we suggest a hybrid method that consists of a combination between a heuristic and a solver-based procedure to address the m-machine problem.
               
            

@&#INTRODUCTION@&#

Growing environmental concerns and other economic challenges have led many companies to take into account the return and recycling of their end-of-life products (Amaro & Barbosa-Povoa, 2008). This is reflected by a new type of physical flow in supply chains: reverse flows. In classical supply chains, the flows move from the suppliers to the plants, and the finished products are then delivered to customers. In contrast, the end-of-life products move from their typical final destination (customers, in most cases) back to the manufacturer, which decides whether the products should be reintroduced to the production process or sent to waste disposal systems, such as incinerators. Over the last 15 years, research activities on reverse logistics have made visible progress. Material recycling has become an important issue in a large number of areas: the glass industry (Salema, Barbosa-Povoa, & Novais, 2010), electronic devices (Krikke, Bloemhof-Ruwaard, & Van Wassenhove, 2003), carpet materials (Realff, Ammons, & Newton, 2004), etc.

Reverse flows
                      can also be considered within a single production unit, as is the case in the assembly/disassembly plants (Brennan, Gupta, & Taleb, 1994) that handle products having reverse sequences in their operating process. However, despite applications in various industrial sectors (the automotive industry, electronic devices, weapon systems, etc.), the literature on this type of reverse flow is less extensive. Most of the research deals with the return of products in a supply chain (Krikke, Bloemhof-Ruwaard, & Van Wassenhove, 2003; Salema, Barbosa-Povoa, & Novais, 2009), where the optimization criteria are often economic and the proposed solutions concern long-term planning problems (i.e., establishing the role of each supply chain entity in terms of production).

In this paper, we study one of these factory configurations, specifically the case where the operating range of the products to disassembly is exactly the opposite of the one to assembly and products of both flows use the same machines. After a brief literature review on flow-shop and job-shop scheduling, we provide a mathematical formulation and analyze the complexity of the problem. Then, we determine various particular cases that can be solved by known methods, and we identify dominance rules for this problem. After setting the limits of exact solutions using a mixed integer linear programming (MILP) model, we present an algorithm based on the Nawaz, Enscore and Ham (NEH) approach (Nawaz, Enscore, & Ham, 1983) to solve the NP-hard 3-machine case. The performance of this method is evaluated by computing lower bounds and carrying out an experimental study on a Taillard-based benchmark. Then, we develop a hybrid approach based on the NEH heuristic and mathematical optimization to solve the m-machine problem.

The problem we address in this study consists of a workshop where n jobs must be scheduled on m machines. Only two operating ranges are available here: the first one skims through the machines in the order M1, M2, …, Mm (direct jobs), and the second one covers them in the opposite direction (reverse jobs). We define E1 as the set of direct jobs and E2 as the set of reverse jobs (Fig. 1).

The other assumptions for this problem are as follows:

                        
                           •
                           All jobs are independent and available for processing at time 0.

There is only one machine of each type.

All machines are continuously available.

Each machine can process at most one job at a time, and each job can be processed only on one machine at a time.

The processing of a given job on a machine cannot be interrupted once started (no preemption is allowed).

The aim then consists of finding the best scheduling sequence of n jobs on m machines to minimize the completion time of the last job on the last machine (the makespan). We give below an illustrative example (Ex1) with three direct (J1, J2 and J3) and three reverse (J4, J5 and J6) jobs to schedule on three machines. Table 1
                      displays the durations of the jobs on each machine, and Fig. 2 shows a feasible solution.

@&#LITERATURE REVIEW@&#

As mentioned, most of the existing research deals with reverse flows in supply chains. Major works concern the design of these supply chains and the planning decisions involved. Initially, forward and reverse flows were treated separately as a two-echelon problem, but this may result in higher costs due to the design of a reverse network independently of the forward chain (Uster, Easwaran, Akcali, & Cetinkaya, 2007). Recent research has attempted to address the two flows simultaneously. Cardoso, Barbosa-Povoa, and Relvas (2013) developed a mixed integer linear programming formulation for the design and planning of supply chains with reverse flows and studied its applicability to a European supply chain case study. Salema, Barbosa-Povoa, and Novais (2010) validated a multi-period and multi-product network model for a real Portuguese glass company. The supply chain is made up of factories, warehouses, customers and sorting centers, and the glass returns to the factories after use.

In this paper, we focus on the reverse flows within an assembly/disassembly unit and address the operational (short-term) decisions. Disassembly problems are an important part of the research on product recovery activities. Kim, Lee, and Xirouchakis (2007) present a literature review on the disassembly planning problems. Brennan, et al. (1994) review the development of methodologies that address the disassembly operations planning. Kim, Lee, Xirouchakis, and Kwon (2009) provide a branch-and-bound algorithm to satisfy the demand of end-of-use product components over a horizon time by determining the quantity and timing for the disassembly of these parts. Kizilkaya and Gupta (1998) present a Flexible Kanban System technique to control material flow in a disassembly environment. Some articles dealing with the disassembly scheduling focused on the quality of the components for reuse. Wan and Gonnuru (2013) used a radio-frequency identification method to track data throughout a product's lifecycle, and they then proposed a genetic algorithm that provides a disassembly sequence to maximize the benefits by taking into account the recovery value and the disassembly cost. Ilgin and Gupta (2011) worked on the sensors implanted in products. They evaluated the impact of the information provided by these sensors on the performance of a washing machine disassembly line. Among the other works dealing with the sequencing and scheduling aspects in the disassembly problems, we can mention the research of Adenso-Diaz, Garcia-Carbajal, and Gupta (2008) in which the authors present a path-relinking-based heuristic that seeks the optimal disassembly sequence plan; Duta, Filip, and Popescu (2008), which provides a genetic algorithm for finding the disassembly sequence with the best financial income; and McGovern and Gupta (2007), where a genetic algorithm is also developed for disassembly line balancing problems. We also note that the particular problem we are dealing with can be perceived as a particular case of the job-shop problem or as two combined flow-shop problems. The literature on these optimization problems is abundant. Below, we give a brief summary of the main characteristics of these two problems, which could be very useful in solving ours.

The job-shop problem consists of a workshop where a set of n independent jobs must visit a set of m machines. Every job uses a number of machines for a certain amount of time and can have any number of operations (the most common approaches assume that a job has at least one operation and at most m, one on each machine). There is a precedence relation between the operations of the same job. The problem is NP-hard for m > 2 (Garey, Johnson, & Sethi, 1976). Jackson's algorithm, based on Johnson's rule, provides optimal solutions in polynomial time for the 2-machine problem (Jackson, 1956). Blazewicz, Domschke, and Pesch (1996) present a survey on the solution techniques available for solving the job-shop problem, but no approximation algorithms with guaranteed performance exist to solve the general case.

In the flow-shop problem, the flow of work is unidirectional; all of the jobs must visit the machines in the same order. The literature on this problem is more abundant. Gupta and Stafford (2006) provide a review on the evolution of flow-shop scheduling problems and the possible approaches for their solution over the last 50 years. Ziaee and Sadjadi (2007) describe various mathematical models reflecting the flow-shop constraints. Finding the optimal scheduling sequence for this problem is NP-hard for m exceeding 2, except for some particular cases for m = 3 when the second machine is dominated by either the first or the third one (Sotskov, 1991). The 2-machine flow-shop problem is solved by Johnson's algorithm (Johnson, 1954). An extension of this algorithm can be used for solving the 3-machine problem, and many other heuristics have been developed to solve the general case (m > 3); the most well-known are the algorithm of Nawaz, Enscore and Ham (NEH) (Nawaz et al., 1983); the algorithm of Campbell, Dudek and Smith (CDS) (Campbell, Dudek, & Smith, 1970); Dannenbring's algorithm (Dannenbring, 1977); Palmer's algorithm (Palmer, 1965); and Gupta's algorithm (Gupta, 1972).

In this section, we present a mathematical model for the job-shop problem with reverse flows. We also analyze its complexity and its particular cases, and we use a solver to set the computational time limits.

Our problem assumes characteristics from both job-shop and flow-shop problems. Many mathematical models exist for these two problems in the literature (Fisher, Lageweg, Lenstra, & Rinnooy Kan, 1983; Ziaee & Sadjadi, 2007). Blazewicz, Dror, and Weglarz (1991) present a survey that compiles a large number of mathematical formulations for machine scheduling. We have drawn on these different works to develop a specific formulation for our problem.

To define the problem formally, we introduce the following notations:

                           
                              •
                              
                                 J = {j
                                 1, …, jn
                                 }: The set of jobs.
                                    
                                       -
                                       E1 = {j
                                          1, …, js
                                          }: The set of direct jobs.

E2 = {j
                                          
                                             s + 1, …, jn
                                          }: The set of reverse jobs.


                                 j: The job index.


                                 k: The machine index.


                                 i: The position index.


                                 
                                    
                                       x
                                       
                                          j
                                          i
                                       
                                       k
                                    
                                 : Equal to 1 if job j is assigned to the ith position on machine k; otherwise, it is equal to 0.


                                 okj
                                 : The operation of job j processed on machine k.


                                 tkj
                                 : The beginning time of operation okj
                                 .


                                 pkj
                                 : The duration of operation okj
                                 .


                                 C
                                 max: The makespan.


                                 M: A large positive number.

In our problem, the objective is to minimize the maximum completion time of all jobs on all machines (i.e., the makespan). We denote as (F1) the mathematical model below:

                           
                              
                                 
                                    Min
                                    
                                       C
                                       max
                                    
                                 
                              
                           
                        subject to

                           
                              (1)
                              
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       x
                                       
                                          j
                                          i
                                       
                                       k
                                    
                                    =
                                    1
                                    
                                    for
                                    
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    
                                    and
                                    
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    m
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       x
                                       
                                          j
                                          i
                                       
                                       k
                                    
                                    =
                                    1
                                    
                                    for
                                    
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    
                                    and
                                    
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    m
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       t
                                       
                                          j
                                          1
                                       
                                    
                                    ≤
                                    M
                                    
                                       (
                                       
                                          1
                                          −
                                          
                                             x
                                             
                                                j
                                                1
                                             
                                             1
                                          
                                       
                                       )
                                    
                                    
                                    ∀
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    s
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       t
                                       
                                          j
                                          m
                                       
                                    
                                    ≤
                                    M
                                    
                                       (
                                       
                                          1
                                          −
                                          
                                             x
                                             
                                                j
                                                1
                                             
                                             m
                                          
                                       
                                       )
                                    
                                    
                                    ∀
                                    j
                                    =
                                    s
                                    +
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       t
                                       
                                          k
                                          j
                                       
                                    
                                    +
                                    
                                       p
                                       
                                          k
                                          j
                                       
                                    
                                    −
                                    
                                       t
                                       
                                          (
                                          
                                             k
                                             +
                                             1
                                          
                                          )
                                          j
                                       
                                    
                                    ≤
                                    0
                                    
                                    for
                                    
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    m
                                    −
                                    1
                                    
                                    and
                                    
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    s
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       t
                                       
                                          k
                                          j
                                       
                                    
                                    +
                                    
                                       p
                                       
                                          k
                                          j
                                       
                                    
                                    −
                                    
                                       t
                                       
                                          (
                                          
                                             k
                                             −
                                             1
                                          
                                          )
                                          j
                                       
                                    
                                    ≤
                                    0
                                    
                                    for
                                    
                                    k
                                    =
                                    2
                                    ,
                                    …
                                    ,
                                    m
                                    
                                    and
                                    
                                    j
                                    =
                                    s
                                    +
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       t
                                       
                                          j
                                          m
                                       
                                    
                                    +
                                    
                                       p
                                       
                                          j
                                          m
                                       
                                    
                                    ≤
                                    
                                       C
                                       max
                                    
                                    +
                                    M
                                    
                                       (
                                       
                                          1
                                          −
                                          
                                             x
                                             
                                                j
                                                n
                                             
                                             m
                                          
                                       
                                       )
                                    
                                    
                                    ∀
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    s
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       t
                                       
                                          j
                                          1
                                       
                                    
                                    +
                                    
                                       p
                                       
                                          j
                                          1
                                       
                                    
                                    ≤
                                    
                                       C
                                       max
                                    
                                    +
                                    M
                                    
                                       (
                                       
                                          1
                                          −
                                          
                                             x
                                             
                                                j
                                                n
                                             
                                             1
                                          
                                       
                                       )
                                    
                                    
                                    ∀
                                    j
                                    =
                                    s
                                    +
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                t
                                                
                                                   k
                                                   q
                                                
                                             
                                             +
                                             M
                                             
                                                (
                                                
                                                   1
                                                   −
                                                   
                                                      x
                                                      
                                                         q
                                                         (
                                                         
                                                            i
                                                            +
                                                            1
                                                         
                                                         )
                                                      
                                                      k
                                                   
                                                
                                                )
                                             
                                             ≥
                                             
                                                t
                                                
                                                   k
                                                   j
                                                
                                             
                                             +
                                             
                                                p
                                                
                                                   k
                                                   j
                                                
                                             
                                             −
                                             M
                                             
                                                (
                                                
                                                   1
                                                   −
                                                   
                                                      x
                                                      
                                                         j
                                                         i
                                                      
                                                      k
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                             
                                             ∀
                                             j
                                             ,
                                             
                                             q
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             n
                                             ,
                                             
                                             k
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             m
                                             ,
                                             
                                             i
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             n
                                             −
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       x
                                       
                                          j
                                          i
                                       
                                       k
                                    
                                    ∈
                                    
                                       {
                                       
                                          0
                                          ,
                                          1
                                       
                                       }
                                    
                                 
                              
                           
                        
                     


                        Eqs. (1) and (2) ensure that each job is assigned to one and only one position in the scheduling sequence on each machine. Eqs. (3) and (4) ensure that the first and the last machines begin processing at time 0. M1 starts with a direct job, and Mm starts with a reverse one.

Inequalities (5) and (6) reflect the precedence constraints between the operations of a job. For a direct job, the operation processed on machine k must precede the operation processed on machine k + 1. For the reverse jobs, it is the opposite; the operation processed on machine k must precede the operation processed on machine k − 1. Constraints (7) and (8) ensure that the makespan is equal to the ending time of the last completed job. Finally, constraint (9) reflects that a machine can process at most one job at a time.

We can consider many particular cases of the job-shop problem with reverse flows:

                           
                              •
                              
                                 The case of an empty flow: This is the most obvious case that we can consider. When one of the flows (either the direct or the reverse) is empty, the issue becomes a flow-shop problem.


                                 The 2-machine case: This is another well-known scheduling problem. When our production unit contains only two machines, the issue becomes a classical 2-machine job-shop problem, which can be solved to optimality and in polynomial time using Jackson's algorithm (Jackson, 1956).


                                 Other particular cases: Other cases that we can study are those based on particular durations, for instance, when all of the jobs have the same duration on the machines, or when each flow has its own duration. These cases will be considered in our experiments.

The problem that we study is a job-shop problem made up of two flow-shop problems. We mentioned above that the 2-machine problem can be solved in polynomial time using Jackson's algorithm (Jackson, 1956). We also indicated that the flow-shop problem, which is NP-hard for m ≥  3 (Garey et al., 1976), is a particular case of our problem. Thus, we can deduce that the job-shop problem with reverse flows, which is more general than the flow-shop problem, is NP-hard for m ≥  3 as well.

Due to the complexity of our problem and the factorial explosion in the number of possible solutions, the running times of all known exact algorithms are often too long. We used the LINGO11 solver on instances randomly generated with job durations taken within the interval [1, 99] and on some particular cases with job durations taken within the interval [1, 9] . We performed the tests on a computer with a dual-core Intel Core processor and 4GB of memory. As expected, the computational times quickly became too long. Using the mathematical model (F1), it often takes more than 3 hours to overcome the (6 jobs/3 machines) instances and more than 18 hours for (8 jobs/3 machines). For the instances based on particular job durations, even if that time greatly decreases (approximately 5 minutes for (6 jobs/3 machines)), the exact computation proceeds no further, exceeding 8 hours to solve the (8 jobs/3 machines) instances.

Solving the illustrative example (Ex1) with LINGO11 and the model (F1) took nearly 5 hours. Its optimal solution is available in Fig. 3 (see Table 1 for the job durations).

For the job-shop problem with reverse flows, we can define a specific form of dominant solutions. Let us state the following property:

                        Property 1
                        
                           For any job-shop scheduling problem where two flows of jobs cover the machines in opposite directions, there exists an optimal solution where:
                           
                              
                                 -
                                 
                                    All of the direct jobs precede the reverse jobs on the first machine (M1).
                                 


                                    All of the reverse jobs precede the direct jobs on the last machine (Mm).
                                 

Let us consider a scheduling solution that does not satisfy this property. This means that there is at least one reverse job that precedes a direct job on M1, or at least one direct job that precedes a reverse job on Mm.□

Let us consider the latter case: A direct job j
                     1 precedes a reverse job j
                     2 on Mm. We can always exchange these two jobs without increasing the makespan. Indeed, moving forward the first operation of job j
                     2 does not affect its other operations on the other machines, nor does delaying the last operation of job j
                     1. The latter would be delayed by a period at most equal to the duration of j
                     2 on Mm. Therefore, the makespan does not increase.

The same reasoning applies if a reverse job precedes a direct job on M1, and this procedure can be repeated until a solution is obtained where all of the direct jobs precede the reverse jobs on the first machine and all of the reverse jobs precede the direct jobs on the last machine.

This property can be useful to reduce the search space. To take this into account in the mathematical formulation, we replace Eqs. (1) and (2) of model (F1) by:

                        
                           (1)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    k
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 n
                                 
                                 and
                                 
                                 k
                                 =
                                 2
                                 ,
                                 …
                                 ,
                                 m
                                 −
                                 1
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    k
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 n
                                 
                                 and
                                 
                                 k
                                 =
                                 2
                                 ,
                                 …
                                 ,
                                 m
                                 −
                                 1
                              
                           
                        
                     and we add the following equations:

                        
                           (11)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    s
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    1
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 s
                              
                           
                        
                     
                     
                        
                           (12)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    s
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    1
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 s
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       s
                                       +
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    1
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 j
                                 =
                                 s
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 n
                              
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       s
                                       +
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    1
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 i
                                 =
                                 s
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 n
                              
                           
                        
                     
                     
                        
                           (15)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       n
                                       −
                                       s
                                    
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    m
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 j
                                 =
                                 s
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 n
                              
                           
                        
                     
                     
                        
                           (16)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       s
                                       +
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    m
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 n
                                 −
                                 s
                              
                           
                        
                     
                     
                        
                           (17)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       n
                                       −
                                       s
                                       +
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    m
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 j
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 s
                              
                           
                        
                     
                     
                        
                           (18)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    s
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    m
                                 
                                 =
                                 1
                                 
                                 for
                                 
                                 i
                                 =
                                 n
                                 −
                                 s
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 n
                              
                           
                        
                     
                  


                     Eqs. (11)–(14) ensure that all of the direct jobs precede the reverse jobs on the first machine, and Eqs. (15)–(18) ensure that all of the reverse jobs precede the direct jobs on the last machine. Eqs. (1) and (2) ensure that each job is assigned to one and only one position on the other machines. We denote as (F2) this second formulation.

Using the solver LINGO11 with the second mathematical model (F2), the computational times significantly decrease. The (6 jobs/3 machines) instances can now be solved within 10 minutes, compared with 4 hours when using model (F1). However, the computational time of the (8 jobs/3 machines) instances is still far too long. It decreases from 18 hours to 8 hours on average. Table 2 displays the times achieved by this mathematical formulation.

Considering the particular cases, the computational times also decreased with the model (F2). The (6 jobs/3 machines) instances are now solved within 1 minute, compared with 5 minutes on average with the previous model (F1). However, the (8 jobs/3 machines) instances remain unsolved, exceeding 8 hours in most cases.

This reduction in the computational times is because the dominance rules greatly reduce the search space. For example, for the (6 jobs/3 machines) instances with three direct and three reverse jobs, the number of possible combinations of jobs on the first machine (and also on the third) decreases from 6! = 720 to 3!*3! = 36 (of course, most of the exact algorithms such as branch-and-bound do not explore all possible solutions and have their own process to eliminate those that surely cannot be optimal).


                     Fig. 4
                      shows the evolution of the computational times obtained with the model (F2), depending on the number of jobs and machines. We notice that, like for the classical flow-shop and job-shop problems, the increase in the number of jobs affects the computational time more clearly than the increase in the number of machines. With the model based on the dominance property, the limit on the number of jobs is eight when the number of machines does not exceed three (solved in more than 8 hours). The limit on the number of machines is five when the number of jobs does not exceed six (solved in approximately 4 hours).

The computational times of exact algorithms quickly become too long for our problem. As seen in Section 5, solving the (8 jobs/3 machines) instances requires more than 8 hours. Thus, it is clear that we need a heuristic method that can reach satisfactory solutions for the large-sized instances in a smaller amount of time.

The complexity of the problem and the lack of works dealing with it in the literature imply that it may be difficult to find a direct solution method for the general case. The closest problem is the flow-shop, for which many heuristics have been developed. Among the most known are NEH, CDS, Palmer and Dannenbring. Over the last 20 years, many comparative studies have been conducted to determine which one of these methods generates the best solutions. Most of these studies consider the heuristic of Nawaz, Enscore and Ham (NEH) (Nawaz et al., 1983) as the best for minimizing the makespan in the permutation flow-shop problem (Park, Pegden, & Enscore, 1984; Taillard, 1990; Turner & Booth, 1987;). In recent years, some authors claimed to develop new methods that could outperform NEH, but Kalczynski & Kamburowski (2005) showed that these claims are not justified.

In what follows, we introduce a new heuristic based on the NEH principle to solve the NP-hard 3-machine case of the job-shop with reverse-flows problem.

The NEH method
                         consists of finding the priority order by sorting the jobs according to their decreasing total processing times, 
                           
                              
                                 p
                                 j
                              
                              =
                              
                                 ∑
                                 
                                    k
                                    =
                                    1
                                 
                                 m
                              
                              
                                 p
                                 
                                    k
                                    j
                                 
                              
                           
                        . Later, the first unscheduled job in this order is inserted in the best position among all possible positions of the current subsequence of already scheduled jobs. The process ends when all jobs are scheduled (Framinan, Leisten & Rajendran, 2003). We give below its main steps:

NEH algorithm

                           
                              (1)
                              For each job (j = 1, …n), compute the total processing time 
                                    
                                       
                                          p
                                          
                                             j
                                             =
                                          
                                       
                                       
                                          ∑
                                          
                                             k
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          p
                                          
                                             k
                                             j
                                          
                                       
                                       .
                                    
                                 
                              

Arrange the jobs according to the decreasing values of pj
                                 .

Find the scheduling of the first two jobs that minimizes the makespan.

For j = 3, …n, insert the j
                                 th job of the list in the position k(k = 1, …, j) of the current schedule that leads to the best makespan.

We suggest using a similar approach that consists of sorting the jobs according to their total durations and finding the best scheduling by trying multiple insertions to solve the 3-machine job-shop with reverse flows problem. First, let us introduce the following property:

                           Property 2
                           
                              For the 3-machine problem, we can always find optimal solutions where the jobs of a particular flow (direct or reverse) are processed on the machines in the same order.
                           

Let us consider a schedule that does not respect this property (Fig. 5): For instance, i and j are direct jobs, and i directly precedes j on M1 while j precedes i on M2. We denote as dkj
                               the ending date of job j on machine k. Thus, we have: d
                              1i
                               ≤ t
                              1j
                              , d
                              1j
                               ≤ t
                              2j
                              , d
                              2j
                               ≤ t
                              2i
                              .□

By exchanging the positions of i and j on M1, the precedence constraints between the operations of a particular job are still respected (Fig. 6): we moved j forward on M1, so we still have d
                        1j
                         ≤ t
                        2j
                         and i is delayed by at most p
                        1j
                         (the duration of j on M1), so its ending date does not exceed the former d
                        1j
                        . We have d
                        1j
                         ≤ d
                        2j
                         and d
                        2j
                         ≤ t
                        2i
                        , so d
                        1i
                         ≤ t
                        2i
                         is still true.

The same reasoning can be applied to M2 and M3, and also for the reverse flow. Thus, for the 3-machine job-shop problem with reverse flows, we can always find optimal solutions where the jobs of a particular flow are processed on the machines in the same order.

This property, combined with the dominance rule, when applied to the 3-machine problem, puts the conflict between the two flows on the second machine (M2). This leads to scheduling solutions in the following form:

                           
                              On M1: σ
                                 D(π)⋅σ
                                 R(π)

On M2: π
                              

On M3: σ
                                 R(π)⋅σ
                                 D(π)

Taking into account Properties 1 and 2, we can state the following algorithm:


                        Algorithm
                     

Step 1: Initialization

                           
                              -
                              Arrange the (s) direct jobs by decreasing sums of their total processing times in the list T1
                                 .

Arrange the (n − s) reverse jobs by decreasing sums of their total processing times in the list T
                                 2.

Build the list L by taking the jobs alternatively from T
                                 1 and T
                                 2. Let L = i
                                 1, …, in
                                 .

Step 2: Scheduling

                           
                              -
                              Pick the first two jobs, i
                                 1 and i
                                 2, of L. Compute the C
                                 max of the permutations i
                                 1
                                 i
                                 2 and i
                                 2
                                 i
                                 1 on M2 by considering on the other machines that:

                                    
                                       °
                                       the jobs of a particular flow are processed in the same order.

the direct (resp. reverse) jobs precede the reverse (resp. direct) jobs on M1 (resp. M3).

Keep the schedule with the shortest C
                                 max in the lists A
                                 2, B
                                 2, andC
                                 2 representing the sequences of jobs on M1, M2 and M3, respectively. k = 3.

Insert job ik
                                  in all possible positions in the list B
                                 
                                    k − 1 (positions1, 2, …, k), and compare the C
                                 max of the permutations by taking into account the two properties mentioned above. Keep the best schedule in the lists Ak, Bk
                                 , andCk
                                 .

If k = n, stop. Otherwise, let k: =k + 1 and go back to the previous sub-step.

The final lists An, Bn, Cn
                                  respectively represent the sequences of jobs as they are processed on M1, M2 and M3.

The complexity of this algorithm is O(n
                        3). The program includes three nested loops: the first one takes the ordered jobs one by one, the second one finds the optimal position of each job in the scheduling sequence and the third loop computes the makespan. However, this complexity can be optimized, as Taillard (1990) showed that NEH complexity can be improved from O(mn
                        3) to O(mn
                        2).

In order to assess the performance of the proposed heuristic, we start by testing it on the same set of small instances that were solved with the mixed integer linear programming (MILP) model and then compare the solutions obtained. The results of the tests are available in Table 3
                        . Instance details are given in the Appendix.

Out of the 17 tests carried out on the (4 jobs/3 machines, 6 jobs/3 machines) and (8 jobs/3 machines) instances, the solution reached by the heuristic is equal to that found by the MILP model for seven of the tests (i.e., the optimal solution was obtained 41.2 percent of the time). The average relative gap between them is approximately 4.35 percent. Compared to the mathematical models, which may take minutes or even hours to solve the instances, the solutions provided by the heuristic are all found instantly.

To assess the performance of the heuristic on larger instances, we need to calculate suitable lower bounds on the makespan. Indeed, heuristics generate sub-optimal solutions, and for large-sized instances, we cannot quickly compute optimal solutions to compare with. Thus, it is important to find high-performing lower bounds to estimate the relative gap. Below, we give a way to calculate lower bounds for the 3-machine job-shop problem with reverse flows.


                        Notations:
                        
                           
                              -
                              E1: Direct jobs.

E2: Reverse jobs.


                                 ai, bi, ci
                                 : The duration of job i, respectively, on M1, M2 and M3.

The machine M1 ends its processing at the earliest at time f1, when all of the reverse jobs move on immediately after the direct jobs, without any waiting time:

                           
                              
                                 
                                    f
                                    1
                                    =
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          E
                                          1
                                       
                                    
                                    
                                       a
                                       i
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          E
                                          2
                                       
                                    
                                    
                                       a
                                       i
                                    
                                 
                              
                           
                        
                     

M3 ends its processing at the earliest at time f3, when all of the direct jobs move on immediately after the reverse jobs:

                           
                              
                                 
                                    f
                                    3
                                    =
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          E
                                          2
                                       
                                    
                                    
                                       c
                                       i
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          E
                                          1
                                       
                                    
                                    
                                       c
                                       i
                                    
                                 
                              
                           
                        
                     

M2 starts its processing at the earliest when the shortest job leaves its first machine (either M1 or M3). It ends at the earliest when all of the other jobs move on immediately after it. We denote this instant as f2:

                           
                              
                                 
                                    f
                                    2
                                    =
                                    Min
                                    
                                       (
                                       
                                          Mi
                                          
                                             n
                                             
                                                i
                                                ∈
                                                E
                                                1
                                             
                                          
                                          
                                             (
                                             
                                                a
                                                i
                                             
                                             )
                                          
                                          ,
                                          Mi
                                          
                                             n
                                             
                                                i
                                                ∈
                                                E
                                                2
                                             
                                          
                                          
                                             (
                                             
                                                c
                                                i
                                             
                                             )
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          E
                                          1
                                          ∪
                                          E
                                          2
                                       
                                    
                                    
                                       b
                                       i
                                    
                                 
                              
                           
                        
                     

In the best case, we can consider that the last job to be processed on M2 is the one that has the lowest duration on its last machine (either M1 or M3). f4 represents its earliest ending date. Thus, here, f4 is a better bound than f2:

                           
                              
                                 
                                    f
                                    4
                                    =
                                    f
                                    2
                                    +
                                    Min
                                    (
                                    
                                       Mi
                                       
                                          n
                                          
                                             i
                                             ∈
                                             E
                                             1
                                          
                                       
                                       
                                          (
                                          
                                             c
                                             i
                                          
                                          )
                                       
                                       ,
                                       Mi
                                       
                                          n
                                          
                                             i
                                             ∈
                                             E
                                             2
                                          
                                       
                                       
                                          (
                                          
                                             a
                                             i
                                          
                                          )
                                       
                                    
                                    )
                                 
                              
                           
                        
                     

We can also consider other bounds. Let i
                        0 be the direct job with the highest total duration on the machines. Then, each other direct job i has to be scheduled either before it (in that case, the makespan increases by at least ai
                        , when the two other operations are done in hidden time) or after it (in which case the makespan increases by at least ci
                        , when the two other operations are done in hidden time).

Thus, for each job, we consider the shortest duration:

                           
                              
                                 
                                    f
                                    5
                                    =
                                    Ma
                                    
                                       x
                                       
                                          i
                                          ∈
                                          E
                                          1
                                       
                                    
                                    
                                       (
                                       
                                          
                                             a
                                             i
                                          
                                          +
                                          
                                             b
                                             i
                                          
                                          +
                                          
                                             c
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          E
                                          1
                                          ∖
                                          i
                                       
                                    
                                    min
                                    
                                       (
                                       
                                          
                                             a
                                             j
                                          
                                          ,
                                          
                                             c
                                             j
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

The same reasoning applies to the reverse jobs:

                           
                              
                                 
                                    f
                                    6
                                    =
                                    Ma
                                    
                                       x
                                       
                                          i
                                          ∈
                                          E
                                          2
                                       
                                    
                                    
                                       (
                                       
                                          
                                             a
                                             i
                                          
                                          +
                                          
                                             b
                                             i
                                          
                                          +
                                          
                                             c
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          E
                                          2
                                          ∖
                                          i
                                       
                                    
                                    min
                                    
                                       (
                                       
                                          
                                             a
                                             j
                                          
                                          ,
                                          
                                             c
                                             j
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

The lower bound that we use is equal to the highest among these different values: 
                           
                              
                                 
                                    L
                                    .
                                    B
                                    .
                                    =
                                    Max
                                    (
                                    
                                       f
                                       1
                                       ,
                                       f
                                       3
                                       ,
                                       f
                                       4
                                       ,
                                       f
                                       5
                                       ,
                                       f
                                       6
                                    
                                    )
                                 
                              
                           
                        
                     

We evaluated the performance of these lower bounds by carrying out tests with the LINGO11 solver. For 15 randomly generated instances, the lower bound matched the optimal solution 11 times (a 73 percent rate). The overall average relative gap between the solutions and the lower bounds is approximately 2.24 percent. Fig. 7
                         illustrates the average relative gap (the y-axis values are percentages) between the optimal solutions and the lower bounds for the instances solved by LINGO. Every average gap is based on five tests.

We consider again the illustrative example (Ex1) shown in Table 1. Its lower bound is given in Table 4
                         and is equal to the optimal solution (27). It reaches this value for f4. Alternately, the heuristic returns a solution of 28 instantly (Fig. 8
                        ).

We tested the heuristic that we developed on a Taillard-based benchmark (Taillard, 1989). We used the (15 jobs/15 machines) Taillard instances for job-shop and the (20 jobs/5 machines, 50 jobs/5 machines, 100 jobs/5 machines) and (200 jobs/10 machines) instances for flow-shop. For each instance, we took only the first three values for each job, corresponding to its durations on the first three machines (as our heuristic can only solve the 3-machine problem), and we varied the number of jobs of each flow as given below:

                              
                                 •
                                 15-job instances: (13 direct/2 reverse jobs, 11 direct/4 reverse jobs, 9 direct/6 reverse jobs, 8 direct/7 reverse jobs).

20-job instances: (17 direct/3 reverse jobs, 14 direct/6 reverse jobs, 10 direct/10 reverse jobs).

50-job instances: (45 direct/5 reverse jobs, 40 direct/10 reverse jobs, 35 direct/15 reverse jobs, 30 direct/20 reverse jobs, 25 direct/25 reverse jobs).

100-job instances: (90 direct/10 reverse jobs, 75 direct/25 reverse jobs, 60 direct/40 reverse jobs, 50 direct/50 reverse jobs).

200-job instances: (180 direct/20 reverse jobs, 160 direct/40 reverse jobs, 125 direct/75 reverse jobs, 100 direct/100 reverse jobs).

We carried out 10 tests for each case, so in total, 200 tests have been performed. For each test, we computed the relative gap between the solution found by the heuristic and the lower bound. Then, we estimated the optimality rate for each battery of tests (i.e., how many times the solution was equal to the lower bound); this rate may be lower than the real one because the lower bound may, in many cases, be lower than the optimal makespan. All of the solutions, for all of these instances, were found instantly by the heuristic.

@&#EXPERIMENTAL RESULTS@&#

From Figs. 9
                            and 10
                           , we note that for the 15-job and 20-job instances, the more balanced the flows are, the lower is the relative gap between the solution and the lower bound. It decreases from 3 percent for (13 direct/2 reverse jobs) instances to 2 percent for (8 direct/7 reverse jobs) instances and from 2.3 percent for (17 direct/3 reverse jobs) to 0.42 percent for (10 direct/10 reverse jobs). The rate of optimal solutions is also higher when the two flows have comparable numbers of jobs; it increases from 10 percent to 30 percent and from 60 percent to 80 percent for the same instances.

For the 50-job instances, the tests are not in line with the previous results. The relative gap increases from 0.95 percent to 2.51 percent between (40 direct/10 reverse jobs) and (30 direct/20 reverse jobs) instances and then decreases to 0.39 percent when the two flows are balanced (Fig. 11
                           ). The rate of optimal solutions reaches 60 percent for (25 direct/25 reverse jobs) instances, compared with an average of 27.5 percent for the other instances.

For the 100-job test, we can make the same remark as for the 15- and 20-job instances: the relative gap decreases by four times, from 1.08 percent to 0.19 percent, as illustrated in Fig. 12
                           . The optimality rate also reaches its best score (60 percent) for (50 direct/50 reverse jobs) instances. The 200-job test gives nearly the same results with a relative gap decreasing from 0.57 percent to 0.12 percent, with only one peak at 0.74 percent for the (160 direct/40 reverse jobs) instances (Fig. 13
                           ). The 200-job instances also give a high rate of optimal solutions with a score of 50 percent for the (180 direct/20 reverse jobs, 160 direct/40 reverse jobs) and (125 direct/75 reverse jobs) instances and 60 percent when we move to the (100 direct/100 reverse jobs) instances.

According
                            to the tests carried out, we can say that our heuristic offers better solutions (in terms of optimal solution rate and relative gap) when the numbers of direct and reverse jobs are close. This can be explained by the fact that when one flow clearly dominates the other, its jobs could face significant waiting times on their last two machines. We calculated the lower bound by minimizing the waiting times, so the gap with the solution may be greater. However, when the numbers of direct and reverse jobs are close, M2 receives more jobs from both sides (M1 and M3), and then the heuristic can more efficiently fill the waiting times.

On the 200 tests conducted, the heuristic gave very satisfying results. It generated an average gap of 1.17 percent and optimal solutions for 42.3 percent of the tests. Table 5 displays the results of the tests according to the increase in the number of jobs. The best results are obtained with 20-job instances (70 percent optimal solutions) followed by the 200-job instances, which offers the best average gap (0.44 percent). The 100-job tests had the second-best average gap (0.68 percent).

The limit of the heuristic that we have developed is that there is no way it can be directly extended to support the m-machine problem. The dominance property, when applied to the 3-machine case, puts the conflict between the flows on only one machine (M2). The heuristic cannot address a conflict that occurs on more machines, as is the case in the m-machine problem.

As an alternative approach, we suggest combining a suitable heuristic that gives a preliminary solution (or a preliminary order of the jobs) with a solver. Because solving the problem with an exact algorithm takes far too long and there are no known heuristics that are effective, these hybrid approaches are useful to reduce the computational time and obtain approximate solutions.

A suitable heuristic here should be a high-performing method to solve the flow-shop problem. In our experiments, we used the NEH heuristic, which is, as already mentioned in this article, considered the best for minimizing the makespan in the flow-shop problem (Kalczynski & Kamburowski, 2005). This heuristic is applied separately on the two flows to obtain a preliminary job arrangement. Then, we insert this preliminary order into the LINGO program to reduce the search space.

These are the main steps of our hybrid method:

                        
                           (1)
                           Divide the problem into two flow-shop problems (one for each flow of jobs).

Solve each flow-shop problem using the NEH heuristic.

Reconsider the main problem.

Insert into the LINGO program:
                                 
                                    •
                                    the order of the direct jobs and the order of the reverse jobs obtained by NEH.

a statement that the order of each flow cannot be changed.

Solve the entire problem with LINGO.

This method decreases the computational time for the 3-machine problem (less than 1 minute for six jobs and approximately 3 hours for eight jobs) and can often quickly solve 6-job instances for the 5-machine problem. However, the optimality of the solution is no longer guaranteed because some job arrangements are fixed from the beginning. Table 6
                     
                      compares the results of this method and those of the exact mathematical model (F2 – which ensures optimality) in terms of computational time and solution quality.

For 9 of the 20 tests (45 percent), the solution given by the hybrid method matched the one provided by LINGO. The average gap between the solutions obtained by the two methods is approximately 4.09 percent. Details of these tests are available in the Appendix. Overall, combining NEH with a solver cannot go further than (8 jobs/5 machines) instances, which often take more than 4 hours.

@&#CONCLUSION@&#

In this article, we studied the job-shop problem with reverse flows, which consists of a workshop where two flows of jobs cover m machines in opposite directions. These types of production units are used in various industrial sectors (electronic devices, the automotive industry, etc.), especially assembly/disassembly plants (Brennan et al., 1994). Our work includes both theoretical and experimental studies. We provided a mathematical model, analyzed the complexity of the problem and identified various particular cases that can be solved by existing methods. We also defined a specific form of the dominant solutions, leading to a substantial reduction in search space and computational time.

We conducted various tests with a solver to fix the computational time limits for the MILP model, and we provided a new heuristic method to solve the NP-hard 3-machine case. This heuristic is based on the NEH principle (Nawaz et al., 1983), which is commonly regarded as the best for solving the flow-shop problem (Kalczynski & Kamburowski, 2005). For 200 tests carried out on instances of 15, 20, 50, 100 and 200 jobs, it generated an average gap of 1.17 percent between the solutions obtained and the lower bounds, and it obtained optimal solutions in 42.3 percent of the cases. In these tests, we noticed that the heuristic offers better results when the two flows are balanced.

This heuristic cannot be directly extended to the m-machine problem, as it puts the conflict between the flows on only one machine. To solve the general case, we presented a hybrid method consisting of combining a heuristic (NEH) that gives a preliminary order of the jobs with the LINGO solver. This approach reduced the computational times for the 3-machine instances and solved the (6 jobs/5 machines) problems within 1 minute but did not go further than the (8 jobs/5 machines) instances, which were solved in more than 4 hours. It also gave optimal solutions on 45 percent of the 20 completed tests and had an average gap of approximately 4.09 percent.

As future works, we can consider several aspects. The solutions that we obtained for the 3-machine problem are of good quality and can be used as initial solutions for improvements with other algorithms (e.g., metaheuristics, such as tabu search or simulated annealing). Other variants of the heuristic, with other job sorting criteria, can also be considered.

Much research remains to be performed to solve the m-machine case. We can think about how to adapt various satisfying job-shop methods to our problem. Efficient heuristics should be able to address conflicts between the flows on every machine.

Future research may also include the addition of new constraints to the problem (e.g., set-up times, release dates) and the examination of other methods, either exact or heuristic.

Below, we give the detailed instances of the tests of Tables 3 and 6. The column of job durations can be read as follows: duration of job 1 on machine 1, duration of job 1 on machine 2, …, duration of job 1 on machine m, duration of job 2 on machine 1, duration of job 2 on machine 2, etc. The cells marked with the * symbol indicate that we interrupted the LINGO solver because the time became too long and that the solution reached may not be optimal. All of the solutions provided by the heuristic were found instantly (Tables 7 and 8).

@&#REFERENCES@&#

