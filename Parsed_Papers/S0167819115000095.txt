@&#MAIN-TITLE@&#SpiNNaker: Enhanced multicast routing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We implemented 4 multicast routing algorithms for SpiNNaker.


                        
                        
                           
                           The two most complex algorithms allow for different implementation details.


                        
                        
                           
                           We explored the effects of these implementation details.


                        
                        
                           
                           The exploration allowed for more effective implementation of the algorithms.


                        
                        
                           
                           The enhanced implementations are better suited to be used in production.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multicast route generation

Massively-parallel processing

Triangular toroidal mesh

Neuromimetic architecture

Spiking neural network simulation

Low-power architecture

@&#ABSTRACT@&#


               
               
                  The human brain is a complex biological neural network characterised by high degrees of connectivity among neurons. Any system designed to simulate large-scale spiking neuronal networks needs to support such connectivity and the associated communication traffic in the form of spike events. This paper investigates how best to generate multicast routes for SpiNNaker, a purpose-built, low-power, massively-parallel architecture. The discussed algorithms are an essential ingredient for the efficient operation of SpiNNaker since generating multicast routes is known to be an NP-complete problem. In fact, multicast communications have been extensively studied in the literature, but we found no existing algorithm adaptable to SpiNNaker. The proposed algorithms exploit the regularity of the two-dimensional triangular torus topology and the availability of selective multicast at hardware level. A comprehensive study of the parameters of the algorithms and their effectiveness is carried out in this paper considering different destination distributions ranging from worst-case to a real neural application. The results show that two novel proposed algorithms can reduce significantly the pressure exerted onto the interconnection infrastructure while remaining effective to be used in a production environment.
               
            

@&#INTRODUCTION@&#

The SpiNNaker neuromimetic architecture system is a biologically-inspired massively-parallel architecture based on a custom-made multicore System-on-Chip (SoC). SpiNNaker targets the simulation, in biological real-time, of very large-scale spiking neural networks, with more than 109 neurons. To put this number in context, it roughly represents 1% of the human brain, a small primate [22], ten mice [23] or one thousand bees [34].

Spiking neural networks communicate by means of spike events which occur when a neuron is stimulated beyond a given threshold and discharges an electrical impulse. These spikes are communicated to all connected neurons, with typical fan-outs of the order of 103 
                     [14]. At a realistic biological firing rate of 10Hz, there could be more than 1010 neuron firings per second, which can replicate up to 1013 communication events per second in the largest SpiNNaker configuration. Thus, an essential problem inherent to the simulation of spiking neural networks is how to distribute large numbers of small packets very widely amongst up to the million processors featured by SpiNNaker in an efficient way and with minimal latency.

Previous work demonstrated the benefits of using a pure multicast architecture, rather than a more conventional unicast or point-to-point one, for this kind of application through both analytical [38] and empirical [39] evaluations. However, constructing multicast routes from a source to a set of destinations is known to be an NP-complete problem [31]. For this reason, adequate routing algorithms are essential for SpiNNaker operation. We present and evaluate a collection of routing algorithms and compare them with each other. Our evaluation considers a range of traffic patterns: non-local traffic as a worst case, centroid-based clustered traffic as a general case with varying degrees of locality and real neural traffic from a thalamocortical column model. The baseline algorithms are based upon well-known, oblivious routing algorithms used in point-to-point communications. The other two novel algorithms present an intelligent behaviour as they use exploration to substantially reduce the number of network resources employed to perform the multicast communication. This paper performs exhaustive analysis of the latter two algorithms by investigating the different implementation decisions, how they influence their performance and what the involved tradeoffs are.

The construction of large-scale versions of SpiNNaker is ongoing and is expected to culminate with the million-core system in the following months. Some prototypes and production systems have already been designed and fabricated. Back in 2010 a first batch of test chips (two cores and a fully functional router) were produced and successfully demonstrated running spiking neural nets. This was followed in 2011 by the production of small quantities of full-fledged SpiNNaker chips with 18 ARM cores and the development of small boards, able to house four SpiNNaker chips and to support inter-board communications. These boards, due to their low-power design, have been used as control devices for robotic systems [12], providing them with real-time stimulus–response behaviour [17].

As shown in Fig. 1
                         we have a reached most milestones in the path towards the full-fledged SpiNNaker: a 48-chip board has been designed and large numbers of them have been produced and can be interconnected to construct increasingly large machines. One board forms a 103-core machine, one rack frame with 24 boards forms the 104 one, a cabinet with five of these frames (120 boards) has just been put together and forms the 105 machine. The final expansion will be to put ten of these cabinets together to conform the full-fledged, million-core SpiNNaker machine. As we approach the largest configurations of the system, the route generation is becoming an increasingly important aspect of the machine’s operation, and so the proposed algorithms aim to meet this requirement.

Aside from the hardware, an extensive collection of system software and application libraries is already offered to operate SpiNNaker and new features are developed and released frequently. Among all the software involved in SpiNNaker, is especially important the PyNN [13] frontend. This is a domain specific language devised to define spiking neural networks and which is widely used within the neuroscientist community. The PyNN/SpiNNaker combination exploits the flexibility of the SpiNNaker architecture and decouples neural applications from the actual hardware, allowing users to rapidly develop and simulate spiking neural networks without any knowledge of the intricacies of the underlying system. Thanks to this transparency for the end-user, the adoption of SpiNNaker as a simulation platform is rapidly growing within the cognitive computing community.

@&#RELATED WORK@&#

The development of artificial neural network-based computing systems has remained a topic of interest for decades as it is believed they could help to understand how the brain operates—still a mystery for science. Here we review the most notable projects in this area and highlight the absence of related systems considering the use of multicast communications even when it seems to be a natural candidate due to the high connectivity shown by biological neural networks.

In the eighties and nineties the Connectionist Machine family of supercomputers came out from the MIT. Although they were designed as general purpose parallel machines, simulating neural models was one of the target applications [24]. Connectionist Machines featured specialized interconnection networks for data and control communications but did not include multicast—only a broadcast mechanism for system-level synchronization.

Later on, in the early nineties a team at U.C. Berkeley worked on the Connectionist Network Supercomputer, a system specifically tailored for neural computation [5]. The system had a target size of 128 nodes (scalable to 512) arranged as a 2D mesh. Nodes included a router to communicate but multicast was not supported, based on the expectation that the system would rely on spatial locality to improve performance. To our knowledge, a prototype of the node was built (under the codename T0), but the system never operated as a network, only a few experiments using up to five nodes in a bus configuration were performed [41], never scaling up to the target system size.

The Blue Brain project [33] and the early stages of SyNAPSE [4] have somewhat similar applications to SpiNNaker and target similar application scales. However they do not contemplate the development of a custom-made architecture, but rather rely on a general-purpose massively-parallel system: IBM Blue Gene systems [20]. This family of supercomputers is composed of tens of thousands of compute nodes, each having several PowerPC processors. Blue Gene’s main interconnect is point-to-point which, as we show in this paper, might not be the most efficient way of dealing with the high connectivity of neural models.

The SyNAPSE project [16] follows a broad approach to neural modelling and is not restricted to using Blue Gene supercomputers—their stated aim is to ‘develop electronic neuromorphic machine technology that scales to biological levels’. The project also involves creating custom hardware and even research into less conventional technologies such as memristors [35]. No indication has been made, however, towards investigating ways to handle the high connectivity inherent to spiking neural networks, not to mention in using multicast-based communication architectures.

Finally, the FACETS project [18] is creating a faster-than-real-time custom hardware system for simulations of large (but unspecified) size networks of biologically-inspired neurons. Its distinctive characteristic is that it relies on analogue circuits to implement neural dynamics. Communication is based on digital logic, circuit-switched synchronous communications with no support for multicast communication. Again, the high connectivity of the neural models is not addressed at hardware-level which could end up limiting the scalability of the system.

Outside of the field of neural networks simulation, there is plenty of research on multicast communication strategies. However, none of those strategies could be employed in SpiNNaker because they are devised with rather different purposes and architectures in mind. To our knowledge, the most prolific areas in which research related to multicast route generation is carried out are those of communication networks (Internet Protocol networks, or simply IP networks) and multistage networks for high performance computing systems.

In the field of IP networks, topologies are mostly irregular and hence the multicast algorithms are not devised to exploit network regularity, as those proposed in this paper do. In fact, in that kind of network, topology discovery and exploration are the most significant parts of the research [8,45].

In multistage networks for high performance computing systems the construction of multicast routes focuses on minimizing the interactions between concurrent multicast communications in order to increase network throughput [6,9]. Reducing network or routing table utilisation, however, are not considered in these areas of research.

Research on multicast for mesh-like topologies similar to the one in SpiNNaker was quite common in the nineties [30,40,47] but had several limitations that discourage their use for SpiNNaker. Firstly, only wormhole switching was considered whereas SpiNNaker uses store and forward. Secondly, most proposals were based on the use of virtual channels, a facility not available in SpiNNaker due to its area constraints. Finally, the main concern of those studies was deadlock avoidance; reducing network utilisation was merely a secondary issue, at best. Given that SpiNNaker already has a built-in deadlock avoidance scheme and scarcity in terms of network resources (both routing tables and bandwidth) a different approach is desirable.

More recently, interest in multicast communications has emerged again with the generalisation of Networks-on-Chip in MPSoCs and manycore systems [26,48]. Some of the limitations of previous work still apply but, in addition, they typically require the addition of specific microarchitectural router features which are not directly applicable to SpiNNaker. The following section will discuss SpiNNaker architecture and how its design is adjusted to meet very tight power and area constraints.

The main foundations of SpiNNaker’s design philosophy were to reduce power consumption, to improve reliability by means of high redundancy and to provide a flexible architecture, general enough to run a wide range of applications [42]: from the simulation of neural non-spiking neural models—e.g. Multilayer Perceptron [43]—to a wide variety of applications completely unrelated to neural networks—e.g. discrete simulation, many-body interaction or others.

Each SpiNNaker SoC (depicted in Fig. 2
                     ) contains 18 low-power general-purpose ARM968 cores, each running an independent event-driven neural process, which responds to events generated by different on-chip modules: timer, communications controller and DMA controller, among others. The chip is packaged together with a 128MB SDRAM, whose primary function is to store synaptic information. Detailed simulations of the chip confirmed that each core can support up to around 1000 neurons in biological real-time [27].

Although the SpiNNaker architecture could be scaled up to 65,536 nodes (256×256), for practical reasons the largest SpiNNaker under construction will house 57,600 nodes (240×240)—creating a system with over a million computing cores. The nodes are interconnected using a two-dimensional triangular torus as depicted in Fig. 3
                        . Neurons are modelled in software and their spikes generate packets that propagate through the on- and inter-chip communication fabric relying on custom-made on-chip multicast routers [19,49]. The primary role of this router is to direct neural event packets to those chips and cores containing destination neurons. One remarkable characteristic of the router is that it is used to perform both inter- and intra-chip communications. It has 18 ports for the cores plus six external ports to communicate with adjacent chips. To avoid the high complexity intrinsic to crossbar-based designs, the SpiNNaker router uses a simpler architecture in which ports are hierarchically merged into a single pipelined queue so that only one packet can use the routing engine at once (see Fig. 2). The routing engine is not expected to become a bottleneck as it has much higher bandwidth than the transmission ports (8Gbps vs. 250Mbps). This means, router load will be very low so it barely affects the pace at which packets are processed. The router supports point-to-point and multicast communications using small packets of 40 bits. The multicast engine reduces the pressure at the injection ports and the number of packets traversing the network [38,39].

Following the Address Event Representation protocol [32], packets do not contain any information about their destination(s), only an identifier of the neuron that has fired. The information necessary to deliver a neural packet to all the relevant cores and chips is compressed and distributed across the 1024-word routing table within each router. To minimize the impact of such an exiguous resource and allow the system to perform complex routing, routing tables offer a masked associative route look-up and routers are designed to perform a default routing—which requires no entry in the routing table—by sending the packet to the port opposite to the one the packet comes from, i.e. if a packet comes from the North it will be sent to the South. As routing tables have a limited number of entries, keeping their utilisation low is essential for the proper operation of SpiNNaker, for this reason, routing table entries will be one of the figures of merit in the following evaluations. Note that the routing tables need to be filled before starting the neural simulation and, consequently, fast multicast routing algorithms would be preferred to reduce set-up time as long as they are able to keep network resources below the limits of SpiNNaker. Routing tables are not intended to remain static during long simulations. They can be modified dynamically in real-time to accommodate scenarios of congestion or even failures in the interconnection network. For the sake of simplicity this scenario has not been considered in the evaluations that follow.

Network flow-control is very simple. When a packet arrives at the router, one or more output ports are selected according to the information stored in the routing table and the packet is transmitted through all of them. Deadlock- and livelock-avoidance are based on packet dropping mechanisms which were studied during the design phases of the architecture [37].

The design of the network fabric was scaled assuming some degree of locality of spike traffic—most destination neurons are proximate to the transmitting neuron—as is typically seen in the brain [7,21]. The inter-node connections were designed to support sustained bandwidths of 1Gbps. However their self-timed nature made them more sensitive to latency than was, in principle, anticipated. This reason, together with the decision of using low-power chip technologies has affected negatively the communications of SpiNNaker. The actual maximum link bandwidth attained by the real chip has been measured to be reduced to roughly 250Mbps. We will use this figure later on to derive the number of neurons that a system can support during our experimental work.

SpiNNaker is designed to simulate spiking neural networks using simple spiking neural models widely accepted by the neuroscientist community. The classic Leaky Integrate and Fire (LIF) model [28] and the more complex Izhikevich model [25] are fully supported by SpiNNaker.

Neurophysiology has provided a deep and clear understanding of the physical operation of biological spiking neurons [14]. Neurons have a membrane potential which fluctuates over time and which is affected by each received signal. Whenever an excitatory signal is received the membrane potential is increased; in contrast, if the signal is inhibitory the membrane potential is reduced. When the membrane potential exceeds a given threshold, the neuron discharges and fires a spike which affects similarly all neurons sharing a synaptic connection, typically in the order of the thousands. The high connectivity of the neurons exacerbates the spike distribution problem.

In biological neural networks, connectivity is typically split into two different categories (see Fig. 4
                        ): short-range and long-range projections. Short-range projections include the connections to closely located neurons. Long-range projections connect neurons with remote areas of the brain. In general a long-range projection is connected to several neurons in the same distant area. In the experiments that follow we will use a destination distribution which is consistent with this behaviour—a collection of destinations clustered around a number of centroids which model long-range projections.

In this section we describe the four algorithms to generate multicast routes considered in this research work. As explained above, we did not find any previous algorithm in the literature that can be applied directly to SpiNNaker because multicast routes are generated often with rather different objectives and restrictions.

For this reason our starting point was to consider and to adapt oblivious routing algorithms typically used in unicast interconnects [10]. Dimension order routing (DOR), which is typically the baseline multicast routing in cube-like topologies [30], was our first approach. Further we implemented longest dimension first routing (LDFR), another well-known algorithm and a good candidate because, as we will see later on, it favours route overlapping. Also, we devised two novel, more sophisticated algorithms which make intelligent decisions by exploring how to connect different branches of the multicast tree to avoid inefficient parallel branches.

In the algorithmic definitions below, all the functions have comprehensible names and will not be discussed unless required for a proper explanation of the algorithm. In all cases, source represents the node for which the multicast route is being generated, destinations contains the destination set and route stores the multicast route under construction. All the proposed algorithms work in a greedy fashion: they start with an empty route and build the multicast route by adding links in a destination-by-destination basis as determined by the algorithm. More elaborated algorithms with backtracking facilities or randomised search could be proposed, but as the generation time is an important concern we have tried to keep things as simple as practically possible. Exemplar multicast routes generated with each algorithm are shown in Fig. 5
                     . Note that in all the discussions following, we consider the diagonal a third, non-orthogonal dimension (namely, W). Note also that the algorithms presented here are focused on SpiNNaker’s triangular torus topology (see Fig. 2 again), but are not restricted to it. The proposed algorithms are general enough so they could be extended to any mesh-like topology—e.g. the 3D torus topologies implemented in IBM BlueGene/L [1] and BlueGene/P [3] and Cray’s XT supercomputers [44], the 5D topology in IBM’s BlueGene/Q [36] or the 6D Tofu interconnect in the K computer [2].

Dimension Order Routing (DOR) is, by far, the most common routing strategy used in mesh-like interconnection networks. For this reason it was the first algorithm implemented in SpiNNaker and the one that has been used in the small-scale simulations run up to date (using a few 48-chip boards). However, as we will see later, this algorithm may not be adequate because of the high number of parallel branches it generates (as easily appreciated in Fig. 5). For this reason we aim to replace it with a better-suited routing algorithm for the scaled up versions of SpiNNaker. The DOR description is very simple: follow a path from the source to each destination travelling dimensions in order (in our implementation we first advance through X, then through Y and then through W but, as the topology is vertex symmetric, any order of dimensions would lead to similar results). This will result in only shortest paths being considered with most communications sharing dimension X. The algorithmic definition of this strategy is shown in Algorithm 1. Function dor returns the collection of links traversed from source to d using dimension order.
                           
                              
                                 
                                 
                                    
                                       
                                          Algorithm 1. Multicast route generation with DOR
                                       
                                    
                                 
                                 
                                    
                                       
                                          Input:The location of the source node (source)
                                    
                                    
                                       
                                          
                                          
                                          
                                          A collection of locations for the destination nodes (destinations).
                                    
                                    
                                       
                                          Output: The generated route.
                                    
                                    
                                       
                                          
                                          
                                          
                                          route=Ø
                                    
                                    
                                       
                                          
                                          
                                          
                                          for each destination d in destinations
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          path
                                          =dor (source, d)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          for each link l in path
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          if l is not in route
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          add (l, route)
                                    
                                    
                                       
                                          
                                          
                                          
                                          return route
                                       
                                    
                                 
                              
                           
                        
                     

Longest Dimension First Routing (LDFR) is the first replacement for DOR implemented in SpiNNaker [11]. It uses another classic algorithm which also ensures shortest paths. In LDFR, routes are generated travelling first in the dimensions with more hops. This favours the sharing of resources in all the dimensions and reduces the number of inefficient parallel branches which, in turn, results in lighter use of the communications infrastructure (compare Fig. 5(a) and (b)). Note that if two dimensions have the same number of hops, one of them will be chosen at random. The definition of this strategy (see Algorithm 2) is similar to DOR’s, but using a different routing function, ldfr which returns the links traversed using longest first routing.
                           
                              
                                 
                                 
                                    
                                       
                                          Algorithm 2. Multicast route generation with LDFR
                                       
                                    
                                 
                                 
                                    
                                       
                                          Input:The location of the source node (source)
                                    
                                    
                                       
                                          
                                          
                                          
                                          A collection of locations for the destination nodes (destinations).
                                    
                                    
                                       
                                          Output: The generated route.
                                    
                                    
                                       
                                          
                                          
                                          
                                          route=Ø
                                    
                                    
                                       
                                          
                                          
                                          
                                          for each destination d in destinations
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          path
                                          =ldfr (source, d)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          for each link l in path
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          if l is not in route
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          add (l, route)
                                    
                                    
                                       
                                          
                                          
                                          
                                          return route
                                       
                                    
                                 
                              
                           
                        
                     

Enhanced Shortest Path Routing (ESPR) is a more complex strategy, but is still restricted to use shortest path routes. Each destination, d, looks for the closest route segment, c, (the source, an already considered destination or a bypassed node) reachable using a shortest path towards the source and adds the route from c to d (using longest first routing) to the solution. If no intermediate route segment is found, then c will default to be the source. ESPR creates similar multicast routes to those produced by the LDFR strategy but reduces the number of inefficient parallel branches when several nodes are close to each other as can be seen clearly in the bottom branches of Fig. 5(b) and (c) (highlighted with a red dotted square for the sake of clarity). Algorithm 3 shows ESPR’s pseudo-code. There are some implementation decisions that have a clear impact on the performance of this algorithm: whether the destinations are sorted or not by proximity to the source and whether connection is restricted to some types of route segment only. Section 7 evaluates in detail and discusses the effects of these two decisions allowing us to improve the effectiveness of ESPR.
                           
                              
                                 
                                 
                                    
                                       
                                          Algorithm 3. Multicast route generation with ESPR
                                       
                                    
                                 
                                 
                                    
                                       
                                          Input:The location of the source node (source)
                                    
                                    
                                       
                                          
                                          
                                          
                                          A collection of locations for the destination nodes (destinations).
                                    
                                    
                                       
                                          
                                          
                                          
                                          The sorting method to use, if any (sort)
                                    
                                    
                                       
                                          
                                          
                                          
                                          The type of valid route points (connect)
                                    
                                    
                                       
                                          Output: The generated route.
                                    
                                    
                                       
                                          
                                          
                                          
                                          route=Ø
                                    
                                    
                                       
                                          
                                          
                                          
                                          sort(destinations)
                                    
                                    
                                       
                                          
                                          
                                          
                                          for each destination d in destinations
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          c
                                          =closest (source, d, connect)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          path = ldfr (c, d)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          for each link l in path
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          if l is not in route
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          add (l, route)
                                    
                                    
                                       
                                          
                                          
                                          
                                          return route
                                       
                                    
                                 
                              
                           
                        
                     

The last strategy, called Neighbour Exploring Routing (NER), expands the exploration to all directions, not restricting to go towards the source. Each destination, d, looks for the closest route segment, s, in its surroundings and adds the route between s and d to the solution. This way, as each node is connected to its closest route segment, the requirements in terms of network resources should be reduced drastically. Algorithm 4 shows the pseudo-code definition of this strategy. Function surroundings performs the search for the closest route point. It explores around a destination (first at distance one, then two, and so on within the given range) for a valid route point. As with ESPR, the efficiency of this algorithm is affected by the sorting, the type of valid route segments and, also, the exploration range. These parameters are explored in detail in Section 7 in order to enable the best implementation possible of NER.
                           
                              
                                 
                                 
                                    
                                       
                                          Algorithm 4. Multicast route generation with NER
                                       
                                    
                                 
                                 
                                    
                                       
                                          Input:The location of the source node (source)
                                    
                                    
                                       
                                          
                                          
                                          
                                          A collection of locations for the destination nodes (destinations).
                                    
                                    
                                       
                                          
                                          
                                          
                                          The sorting method to use, if any (sort)
                                    
                                    
                                       
                                          
                                          
                                          
                                          The range to explore (range)
                                    
                                    
                                       
                                          
                                          
                                          
                                          The type valid connection points (connect)
                                    
                                    
                                       
                                          Output: The generated route.
                                    
                                    
                                       
                                          
                                          
                                          
                                          route=Ø
                                    
                                    
                                       
                                          
                                          
                                          
                                          sort(destinations)
                                    
                                    
                                       
                                          
                                          
                                          
                                          for each destination d in destinations
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          s=surroundings (d, range, connect)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          path
                                          =ldfr (s, d)
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          for each link l in path
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          if l is not in route
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          add (l, route)
                                    
                                    
                                       
                                          
                                          
                                          
                                          return route
                                       
                                    
                                 
                              
                           
                        
                     

From the example multicast trees shown in Fig. 5 the differences in terms of number of network resources employed by each of the algorithms are already apparent. We will proceed now to evaluate how they will behave when generating routes for the largest possible SpiNNaker configuration (256×256 nodes) and workloads covering a wide range of scenarios, some of them far beyond the most extreme configurations expected. We will study configurations having between 1 and 2048 different destination nodes. Given the high number of neurons we can multiplex within a chip, the high locality nature of the traffic and the neural network generation procedure implemented in SpiNNaker [11] the number of destination nodes should not exceed the tens very often. The cases with above one hundred destination nodes should be considered worst-case.

As discussed in Section 3, there are several important figures of merit: (i) use of network resources, (ii) number of entries in the routing tables, (iii) compute time required to construct the multicast routes. In our results, we show average values obtained from executing the algorithms for 200,000 different random samples for each configuration. All the samples remained the same across the different experiments. The experimental platform was a 64-core AMD Opteron(TM) Processor 6276 with 256GB of RAM with low (but non-zero) background load. Time measurements are precise and reliable but hindered by sample-generation and stat-capturing instrumentation. This instrumentation is algorithm-independent and should not affect the discussions significantly.

Our study starts with a worst-case scenario in which destinations are selected without any locality or clustering. This will stress the communications fabric because of the large distances and the low resource sharing. This traffic model represents system configurations in which the allocation of populations to chips is very poor and, therefore, the intense pressure exerted on the communication fabric can be used as a motivation for an effective allocation policy for irregular and/or unstructured neural nets. In this model, we select randomly a distance, and then a destination at that distance from the source. Note that this does not create a uniform distribution of destinations but empirical comparison showed that the destination distribution is similarly challenging to a pure uniform distribution but the experimentation time is reduced considerably.

A more refined model is the centroid-based traffic model which resembles neural communications (as explained in Section 3.2) and, in addition, provides a flexible workload capable of varying the degree of locality of communications. In this model each centroid defines the centre of a long-range projection and has a 5% of probability of being chosen by destinations. In other words, destinations will be clustered around the source and around each of the centroids—see Fig. 6
                        , where the probability distribution of a 4-centroid example is shown. The location of each centroid is selected uniformly with a single restriction: they have to be located at a distance of, at least, 32 hops from the source node to ensure that the centroids are actually located in a remote area of the network. In this paper we considered four and ten centroids, with 20% and 50% probability, respectively, of destinations belonging to long-range projections. Once a destination is assigned to a centroid or to the area around the source, it selects randomly a node using an exponential distribution of the distance, so that closer nodes are more likely to be selected. Selecting the same node more than once is not permitted so, if a node has been selected before, a new destination will be chosen.

We close our experimentation with a simplified biologically-inspired thalamocortical model [46] based on cortical columns. Cortical columns [15] are hypothesised to support the information-processing carried out by the cortex and offer a good demonstration for scalable neural systems. In addition, they provide a good model to exercise the capabilities of the routing algorithms. The model is rather simple: columns are divided into layers with high levels of connectivity within. Some of the layers may be connected to the same layer in physically adjacent columns, typically with higher connectivity to closer columns.

A high-level depiction of the model used in our evaluation can be seen in Fig. 7
                        . Fig. 7(a) shows a five-layer cortical columns in which circles represent populations—with the number of neurons within—, whereas arrows represent the projections: solid for short-range and dotted blue for long-range projections. The structure of the long-range projections between different cortical columns can be seen in Fig. 7(b) in which the circles represent cortical columns, and the arrows represent the projections among them. All the cortical columns follow the same structure of projections. For the sake of completeness we considered three scenarios with increasing connectivity: connections to neighbours (i) at distance one, (ii) at distance one or two, (iii) at distances one, two or three. Note that four columns fit in a SpiNNaker chip and that columns are allocated sequentially from the pool of columns. This means that all the populations in a column will be located in the same chip, so short-range connections will not generate any remote node destination. Similarly, a small fraction of the long range connections will be between columns located within the same chip. The rest of long-range projections will either be located in remote areas of the network (distance>125) or just around the source (distance<3). For a more detailed explanation of the thalamocortical model please refer to [11]. Note that this model generates the least demanding patterns of all the traffic models considered in our study and requires, at most 20 destination nodes.

@&#PERFORMANCE EVALUATION@&#

As discussed there are three implementation details which may have a substantial effect on the performance and effectiveness of ESPR and NER algorithms. In the previous paper, we made these decisions arbitrarily without further justification or evaluation. This section builds upon that and performs a comprehensive analysis of the tradeoffs involved and helps to understand better the algorithms and to look for the best implementation. We will close this section by comparing these enhanced implementations against the two oblivious algorithms (DOR and LDFR).

Given that the routes are created incrementally, the order in which we process the destinations will have a definite impact on the efficiency of routes generated by ESPR and NER. A priori, processing the destinations from the closest to the furthest seems preferable because it would facilitate remote destinations to find a connection point once the closer ones are placed and will also minimize the incidence of backwards connections in NER.

In our first implementation [39], we took this into consideration and assumed destination nodes were sorted as a precondition in NER. To comply with this condition we naïvely implemented a simple iterative bubble sort (bsort in the plots). This seemed appropriate because the routing will normally be dealing with small number of destinations and because the ultimate goal of the routing algorithms is to be offloaded to SpiNNaker whose cores have quite limited resources. This discouraged the use of recursive algorithms (such as quicksort or merge sort) as they will quickly deplete the small local memories just to maintain the application stack. However, bubblesort is known [29] not to perform quite well with randomly distributed data such as most of the destination distributions employed in this study. For this reason we also consider here insertion sort (isort) which should get higher performance.
                           1
                           Note that performing an analysis of the wide range of existing sorting algorithms is outside of the scope of this paper.
                        
                        
                           1
                         Even when this algorithm generally performs better, the sorting can still dominate generation time. For this reason, we considered a simpler solution: rather than performing a full sort of the destinations, we decided to use a bucket approach to simplify sorting. The original idea was to split the destinations into a few buckets and then sort the buckets, but then we decided to take advantage of the distance being a discrete variable. This way we can have a bucket for each possible distance (bkt1) so that the sorting step is avoided completely, effectively transforming an O(n
                        2) problem into O(n). We tried several bucket configurations with and without sorting and we found this to be always the best option in every aspect. For the sake of simplicity, we do not plot other bucket configurations here.

As expected, sorting can help to reduce the consumed resources—both bandwidth (Fig. 8
                        ) and routing table entries (Fig. 9
                        )—as it favours connections to closer areas to the multicast trees. This difference is increasingly noticeable as the number of destinations grows and can reach a saving of 20% in terms of bandwidth and 5% reduction of the routing table entries for ESPR. The other algorithm (NER) seems to be influenced less by sorting but still benefits from it, especially in terms of routing entries. If we look at the route generation times in Fig. 10
                        , we can see how the use of the sorting functions can become quite prohibitive for large number of destinations. Although, as explained above, very large numbers of destinations are not expected in the target application, we deem it good practice to get ride of them and use the bucket approach instead. The bucket version gets the benefits of sorting but, at the same time, is generally able to generate routes faster than the nosort version. This is easily explained by the fact that bkt1 commonly has a connecting segment closer than nosort, and so the exploration step finalizes earlier. These results motivate the use of bkt1 in the final implementation and, hence, it will be the only one considered in the graphs hereafter.

Another important implementation detail is where to connect to when exploring. There exist three possibilities, in increasingly restrictive order: (i) connect to any route point, even if that implies adding an extra routing table entry—marked as any, in the plots—, (ii) connect only to nodes in which there is already a routing entry—entries –, (iii) connect to other destination nodes only—nodes.


                        Figs. 11–13
                        
                        
                         show the number of traversed links, the employed routing table entries and the route generation time, respectively. We can see that differences are not as significant now (mostly below 8%) as they were in the previous case. In general we can see that the less restrictive the connection policy is the faster the generation and the fewer the links used are but at the cost of more routing table entries. This can be explained by the fact that a more restrictive a policy will need to discard more possibilities for connection, so that the exploration step will take longer and connections may not be made to the closest segments. Again NER seems to be affected less than ESPR by this implementation decision.

In this set of experiments, it is worth mentioning the special pathological case in the Thalamocortical model (in Fig. 11(d)). We can see that when the model has connections with neighbours at distance three, ESPR is significantly harmed by the two restrictive policies (node and entries). This is because, preventing connections to parts of the multicast tree that do not have a routing table favours the kind of the parallel branches we are aiming to avoid (see Fig. 5 again). In this specific case, two long parallel branches are not prevented by the node and entries policies, which can otherwise be prevented by the non-restrictive any policy. This, together with the overall lower network requirement and faster route generation, tips the balance in favour of the latter. Consequently, we decided to use the any policy in the final implementation and will stick to it in the following evaluations.

Given that NER looks for connection points in all directions, the range at which it looks for connecting segments also has an impact on the algorithm efficiency. Intuitively, a greater range means a larger space to explore, so routes will be generated more slowly. On the other hand, a larger exploration area anticipates a potentially better route. However, given that connections are not restricted to go towards the source, it may happen that sometimes a poor direction is taken. This is especially true if the destinations are not sorted as the closer connection segment is likely to be in the opposite direction of the source. The longer the range is, the larger can be the impact of one of these poor decisions. For this reason we need to investigate which are the appropriate values for this parameter and what tradeoffs are entailed.


                        Figs. 14–16
                        
                        
                         show the number of traversed links, the employed routing table entries and the route generation time, respectively. From there, the first thing we can notice is that the number of routing table entries is barely affected by the range. Shorter ranges can require slightly more entries for large sets of destinations, but in general, this resource seems to be rather independent from the range, so we can discard it from the discussion. From the perspective of the number of links employed, it seems that range values above 20 can generally offer good results. It is noticeable that, as we move towards higher locality traffic, the effects of the range are diluted: with uniform the difference can be up to 40%, this goes down to 10% for 10-centroid model, further down to 5% for 4-centroid model and becomes completely undistinguishable for the thalamocortical model. If we focus on route generation time, range 20 tends to remain quite competitive in most cases. Ranges 30 and 40 seem acceptable as well for all cases but uniform. Longer ranges would require quite longer generation times. Overall, values between 20 and 30 seem to be the sweet spot for this parameter. Given the small differences between their results, doing a fine-grained evaluation between these two values would not add extra value to this research so, for the final evaluation below, we will stick to the value of 20 we arbitrarily selected in our previous paper.

This subsection will evaluate the four explained algorithms against each other. Recapitulating from above, we consider four different algorithms. The baseline are two simple oblivious algorithms: DOR, typically the first routing algorithm considered when dealing with multicast in cube-like topologies, which traverses all dimension in order (XYW), and LDFR which traverses the dimension with more hops first and which was previously shown to be more efficient [39]. Further we have proposed two exploration-based algorithms that explore around the destinations either towards the source (ESPR) or in any direction (NER). As per the analyses above, we will consider implementations of these two algorithms in which the destinations are sorted using a bucket approach, use the non-restrictive any connection policy and, in the case of NER, the exploration range is 20.


                        Figs. 17–19
                        
                        
                         show the number of traversed links, the employed routing table entries and the route generation time for each algorithm under the different destination distributions. From the figures we can gather that the two proposed algorithms (ESPR and NER) can reduce significantly (up to four times less) the number of traversed links at small cost in terms of routing entries or execution time. With the uniformly distributed distances model and large numbers of destinations, the price to pay is substantial enough (up to 30% increase in routing entries for both ESPR and NER and 80% increase in terms of generation time for NER). For other configurations, the differences in generation time and entries are consistently below a mere 5% and, in fact, sometimes even outperform the baseline algorithms. Considering that this second case resembles better the kind of traffic we could expect from actual neural traffic, it is safe to say that the two proposed algorithms are better suited for multicast route generation in SpiNNaker than the baseline algorithms.

Focusing on the algorithms individually, we can see that DOR, the arguably ubiquitous algorithm, is the worst performing of all the studied algorithms. This should serve to discourage our colleagues from using this straightforward extension of a typical point-to-point routing algorithm to build multicast routes upon. LDFR, also based on an oblivious point-to-point routing algorithm outperforms it in almost every aspect and so should be preferable as the first implementation step for future architectures. ESPR can consistently reduce network load much further than LDFR while keeping generation time and table entries low. Finally NER can reduce traffic even further but may slow down route generation significantly when dealing with destination distributions with high fan-out and low locality. As this is not expected to be a very common scenario in the real system and given that it is the one reducing bandwidth demands the most, NER is the best candidate to be included in SpiNNaker’s operational workflow.

@&#CONCLUSIONS AND FUTURE WORK@&#

The main contribution of this paper is the description of four routing algorithms to construct multicast trees for mesh-like topologies, such as the one in SpiNNaker, and the evaluation of them against a comprehensive number of performance metrics related to the most sensitive resources of SpiNNaker’s communications infrastructure using a reasonable collection of traffic models. Our results show that generating multicast routes using DOR, one of the most frequently used algorithms for mesh-like topologies, and the first one that was implemented on SpiNNaker, is counterproductive because it demands the highest network resources both in terms of bandwidth and routing entries. Using DOR may be required to prevent deadlock in some systems, but as for SpiNNaker, it has its own deadlock-avoidance mechanism built-in into the router. Consequently it was substituted by LDFR, another oblivious routing algorithm which proved to be a well-rounded solution as the multicast routes can be generated very quickly while keeping resource requirements low and balanced.

More sophisticated strategies, which look for routes in their surroundings, have also been considered. ESPR searches for connections using shortest paths; whereas NER searches in all the surroundings even if no shortest path is used. These two strategies can further reduce the network requirements but required some fine-tuning in order to make them competitive—especially in terms of generation time. First we found that sorting the destinations based on their distance to the source is desirable as it favours building a more effective multicast tree. We also found that restricting the connection points during the exploration phase may help reduce a little the number of routing table entries, but may end up resulting in inefficient parallel branches. Finally we investigated the effect that the exploration range may have in the NER algorithm and found that relatively short ranges (between 20 and 30) should be enough to generate efficient multicast routes without slowing down the generation process significantly. A comparison of the four algorithms suggests that NER seems to be the best candidate to be used for the largest configurations of SpiNNaker.

In this paper these four mechanisms have been described and implemented in the context of the SpiNNaker topology, but they are general enough to be employed in other mesh-like topologies. For example we could adapt the presented algorithms to the 3D tori implemented in state-of-the-art massively parallel processors such as the IBM’s BlueGene or the Cray’s XT families. This adaptation is straightforward simply by using 3D torus routing functions while keeping the strategy formulations, as they can use the diagonal as the Z dimension of a 3D topology.

@&#ACKNOWLEDGEMENTS@&#

The SpiNNaker project is supported by the UK Engineering and Physical Sciences Research Council (EPSRC), through Grant EP/G015740/1, and also by ARM. Dr Luján holds a Royal Society University Research Fellowship. Steve Temple, Luis Plana and Steve Furber are supported by ERC Advanced Grant no. 320689. Dr. Javier Navaridas is supported by the UK Engineering and Physical Sciences Research Council (EPSRC), through Grant EP/K015680/1.

@&#REFERENCES@&#

