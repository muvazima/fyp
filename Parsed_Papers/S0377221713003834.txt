@&#MAIN-TITLE@&#Dynamic decision making for graphical models applied to oil exploration

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We consider a sequential DP problem for oil and gas exploration.


                        
                        
                           
                           Prospects are correlated through graphical models (BN or MRF).


                        
                        
                           
                           We develop approximated strategies for solving large problems.


                        
                        
                           
                           We use heuristic strategies as benchmark for results comparison.


                        
                        
                           
                           We show the benefits in terms of expected revenues and discuss the results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Bayesian Networks

Dynamic programming

Graphical model

Heuristics

Petroleum exploration

@&#ABSTRACT@&#


               
               
                  We present a framework for sequential decision making in problems described by graphical models. The setting is given by dependent discrete random variables with associated costs or revenues. In our examples, the dependent variables are the potential outcomes (oil, gas or dry) when drilling a petroleum well. The goal is to develop an optimal selection strategy of wells that incorporates a chosen utility function within an approximated dynamic programming scheme. We propose and compare different approximations, from naive and myopic heuristics to more complex look-ahead schemes, and we discuss their computational properties. We apply these strategies to oil exploration over multiple prospects modeled by a directed acyclic graph, and to a reservoir drilling decision problem modeled by a Markov random field. The results show that the suggested strategies clearly improve the naive or myopic constructions used in petroleum industry today. This is useful for decision makers planning petroleum exploration policies.
               
            

@&#INTRODUCTION@&#

This paper considers the problem of sequential decision making, where the outcome of one decision will influence the others. Our motivation and main applications are from oil and gas exploration, where a petroleum company must evaluate a set of potential drilling prospects. For each prospect, we may either drill or not. There is a cost of drilling, but revenues if the well discovers oil or gas. The prospects are statistically dependent, and drilling at one prospect gives information that is used to update the probability of success at other prospects. The goal is to find an optimal drilling sequence, including when to stop drilling and abandon the remaining prospects.

The optimization of the expected utility function is a trade-off between two factors: the direct reward from the exploitation, and the indirect gain of learning, or exploration, that helps us make informed future decisions. The balance between the two is controlled by a discounting factor. With no discounting, the problem becomes a maximization of the value of information, whereas a high discounting factor leads to a greedy search where only immediate gain counts.

In the oil industry prospects are typically evaluated one-by-one. The implicit working assumption is then independence between prospects, and a greedy search is optimal. As petroleum companies are now forced to look for smaller volumes, gains can be achieved by joint modeling of prospects. Recent work by VanWees et al. (2008) and Martinelli et al. (2011) use Bayesian Networks (BNs) to capture the geological dependencies between prospects, while Bhattacharjya et al. (2010) study the effect of various data acquisition schemes for reservoir units modeled by a Markov random field (MRF). Dependence means that we can update the probability model after exploring the most lucrative prospect. We can next go for the second best prospect, conditional on the outcome of the first, and so on. This line of thinking leads to a myopic (conditional greedy) approach, which uses the dependence in the model for forward learning about the prospects. As is common in sequential decision making, this forward selection approach can be improved by taking the expected value over all possible future drilling scenarios into account, which leads to the optimal solution given by a dynamic program (DP).

Our goal with the current paper is to compare various dynamic strategies for the large BN model in Martinelli et al. (2011) and on the MRF in Bhattacharjya et al. (2010). This challenge of constructing drilling strategies for dependent prospects has not been studied much, except certain special cases: Kokolis et al. (1999) describe a similar problem with a focus towards decision making under uncertainty and the technical risks connected to a project. Smith and Thompson (2008) analyze the consequences of dependent versus independent prospects, and give drilling guidelines that are optimal in special situations. In Bickel and Smith (2006) and Bickel et al. (2008) DP is used to compute the optimal sequences and profits from six dependent prospects. The big challenge which we address here is that related to the combinatorial increase in the number of scenarios. DP is not tractable when the number of prospects gets large.

A possible solution to large problems is offered by approximate DP methods, see Bertsekas and Tsitsiklis (1996) and Powell (2008). The optimization function is then replaced with a statistical model that captures the impact of decisions now on the future. For our graphical representation of dependent prospects it is not obvious how to find a statistical model that approximates the future value function. Instead we study look-ahead policies, where a DP is used for a finite future horizon and heuristics approximate the continuation value (CV). We also apply pruning of the decision tree, i.e. we ignore unlikely branches to reduce the combinatorial problem. The sequential decisions are thus made according to a rolling-horizon algorithm, where we pick one prospects at a time, update the probabilities, look-ahead using DP and select again. Similar strategies are discussed in Chapter 8 of Powell (2007). An application of such strategies to wind energy is presented in Zhou et al. (2012). Our methods are different because of the statistical modeling based on a BN and MRF. The operations research community have been interested in research ideas at this interface (Meisel and Mattfeld, 2010) in diverse applications, see e.g. Falzon (2006) for military operations. Moreover, the field of learning within BNs is quite active, see e.g. Dearden et al. (1999), Heckerman (1999) or Sucar et al. (2012), but there has been little focus on the sequential selection of nodes, which is our focus for the petroleum prospect selection problem.

Note that when considering a set of independent prospects, the optimal sequential decisions are offered by Gittins indeces (Gittins, 1979), used for a petroleum example by Benkherouf and Bather (1988). In our model the correlation is much more complex, and the actions influence the model probabilities in a complicated manner. Branch and bound methods are non-heuristic in the sense that they produce lower and upper bounds for the values (Goel et al., 1979). In practice the gap between bounds can be wide, and in our context we will typically lack monotonicity when computing the best (discounted) sequence. See Brown and Smith (submitted for publication) for promising work in this direction, using the BN that we consider here as an example. See also Ryzhov et al. (2012) for continuous examples in this context, with statistical dependence.

We have no theoretical restrictions on the underlying statistical model for dependence. There is a practical requirement that conditional distributions can be computed fast, since many of these conditionals will be evaluated when designing a strategy. For comparing strategies, it is advantageous if we can easily simulate from the models. The BNs and MRFs we consider here are fast to update and easy to simulate from.

The paper develops as follows: In Section 2 we motivate by introducing the notation and statistical model for the oil and gas exploration examples. In Section 3 we present the DP algorithm for our problem. In Sections 4 and 5 we propose the various heuristic strategies, and the algorithms used to evaluate the properties of the sequential exploration strategies. In Section 6 we provide results for a small BN model and the BN case study of 25 prospects in the North Sea. In Section 7 we analyze a MRF for a oil reservoir represented on a 5×20 lattice.

We consider a set of N prospects. These N prospect nodes are a subset of the total M nodes in a graph. The remaining M
                     −
                     N auxiliary nodes impose the specified dependency structure in the model, but are not observable. For every node i
                     =1,…, M we have a discrete random variable x
                     
                        i
                     
                     ∈{1,…, k
                     
                        i
                     }. In the examples below we use k
                     
                        i
                     
                     =
                     k, and k
                     =3. The random vector of all variables is x
                     =(x
                     1,…, x
                     
                        M
                     ), where the N first components correspond to the prospect variables. We model the probability distribution of x by a BN or a MRF. We will next motivate our problem description via our main case study.

The BN in our main example is defined via a directed graph, which means the joint probability model p(x) is the product of conditional distributions 
                        
                           p
                           
                              
                                 
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                       
                                          pa
                                       
                                    
                                 
                              
                           
                        
                     , for all nodes i
                     =1,…, M, and 
                        
                           
                              
                                 x
                              
                              
                                 i
                              
                              
                                 pa
                              
                           
                        
                      denotes the set of outcomes at parent nodes of i. Fig. 1
                      shows the directed graph connecting parent nodes to nodes via edges. The graph contains N
                     =25 prospect nodes, while there are M
                     =42 nodes in total.

The graph in Fig. 1 is built from the causal large scale geological processes required to make sufficient amounts of oil and gas, see Martinelli et al. (2011). The model intends to translate geological prior knowledge into an expert system; this step is common in other fields, such as biology or reliability (see Lacave and Diez (2002) for a review), but is new in the hydrocarbon (HC) exploration context. The network reflects the geology behind the HC formation and migration in a sector of the Norwegian part of the North Sea. In the geological literature this process goes under the name of charge or source formation, and is one of the relevant factors for the HC accumulation. Other key-factors are the presence of a reservoir, i.e. a porous rock that can hold the HC, and the presence of a trap structure, that presents the HC from leaking out. These three main elements are generally regarded as independent (Gluyas and Swarbrick, 2003) by the industry, and their risk is assessed separately. In this geographical part of the North Sea, the risk connected to trap and reservoir is small, and we will therefore focus our attention on the source part.


                     Fig. 1 contains three different kinds of nodes: we can see four K-nodes that represent kitchens, i.e. areas where the hydrocarbon (HC) generation has been or still is in place, and where the migration of HC started. The P-nodes represent geological macro-regions able to store HC. Finally, the bottom numbered nodes, 1,…, 25 are prospect nodes where the oil and gas company considers drilling wells. The node outcomes are discrete with three possibilities (k
                     =3), correspondent to dry, oil or gas. The edge structure, which were defined by geologists with much experience on the particular basin and petroleum system, are likely migration paths for the HC through geological time. In this form, the edge structure seems to be rather well known. The conditional probability tables (CPT) were specified in a collaborative effort between the geologist and ourselves. The CPT encode the migration arrows into quantitative assessments of the probability of success at a child node given the parents. The realistic parameterization is based on geological and geophysical rules, and attempts to keep the number of tuning parameters low. Each migration path is characterized by just two parameters, one representing the probability of HC flow between the two nodes, and one representing the probability of a gas flow, given that a HC flow is in place. This split is due to a working assumption of abundant gas being able to squeeze out the oil, since its density is lower than that of oil. Further background for this network is provided in Martinelli et al. (2011). Noteably, Martinelli et al. (2011) did not consider the interesting operational research problem of sequential exploration of the dependent prospects, which is our focus here.

Examples of evidence propagation are shown in Fig. 2
                     . Here we display the difference between the marginal probability of the oil and the conditional probability of oil after at observation (or evidence) in prospect 14 (top) or 10 (bottom). On the left we show the effect of dry evidence, on the right the effect of oil evidence. We note that oil probabilities in the prospects close to evidence nodes are either boosted (right) or lowered (left). We further note that the differences are higher for unlikely evidence: For example, the effect of a dry evidence in prospect 14 (left, top) is bigger than the effect of oil evidence (right, top), since this latter event has 45% probability of occurrence, while the former has just the 10% probability (see Table 4).

The motivation for our current paper is the ability to construct dynamic exploration strategies for the 25-node BN. But, note that the particular type of dependency structure is not critical. However, for our purposes of sequential design we require many updates of the probability model, based on evidence such as that demonstrated in Fig. 2. Fast updating of the conditional probabilities becomes important for computational reasons. BNs are fast to update using for instance the junction tree algorithm, see e.g. Lauritzen and Spiegelhalter (1988) and Cowell et al. (2007). This was used to construct the results of Fig. 2. To demonstrate a larger span of probability models, we use a MRF example in Section 7. This application is for a lattice of cells in a specific reservoir in the North Sea. The MRF model is defined over neighborhoods on the lattice, where p(x
                     
                        i
                     ∣x
                     −i
                     )=
                     p(x
                     
                        i
                     ∣x
                     
                        j
                     ; j
                     ∈
                     N
                     
                        i
                     ), and x
                     −i
                      is the vector of all variables except x
                     
                        i
                     , while N
                     
                        i
                      is the neighborhood of node i. Again we need fast updating, and moderate size MRFs can be computed recursively by forward–backward algorithms (Reeves and Pettitt, 2004). Moreover, we will use Monte Carlo samples to generate realistic future scenarios. It is easy to draw samples x
                     =(x
                     1,…, x
                     
                        M
                     )∼
                     p(x) from the BNs and MRFs we consider.

Given a probabilistic model with a certain dependence structure, we want to develop a drilling strategy, i.e. a dynamic road map that leads us through the exploration phase of the prospects. Since the prospects are dependent, the outcome of one changes the probability of success in the others (see Fig. 2). The strategy of continued drilling thus entails a sequential updating of the probability model. When building such strategies, we make certain assumptions about the way decisions are made. First, we assume that the decision maker selects one node at a time. Without this assumption, the problem would grow to allow all orders of two-tuples, three-tuples, etc. Second, we assume that there are fixed revenues and costs associated with each prospect. If we choose to explore a prospect, we have to pay a drilling cost, but for certain outcomes of the node variable, we receive a revenue. For instance, if the outcome is oil, we get the fixed revenues associated with this outcome. These revenues and costs typically change from prospect to prospect. Finally, we assume the utility function contains separate parts for each prospect, without any shared costs between them. Various extensions of these assumptions are possible, but makes the presentation much harder. We discuss useful practical extensions in the context of the application in Section 6.3.

To describe this sequential decision problem mathematically we follow the notation of Bickel and Smith (2006) which seems to be the useful here. We let ω
                     
                        i
                      be the observable in node i
                     =1,…, N. If node i is not yet observed, we set ω
                     
                        i
                     
                     =− for the empty set. If we choose to observe node i, ω
                     
                        i
                      is the actual outcome of the random variable x
                     
                        i
                      at this node. For instance, in Fig. 2 (top) we observe prospect 14, and set ω
                     14
                     =1 (left) for dry evidence and ω
                     14
                     =3 (right) for oil evidence. Initially, before acquiring any observables, we have 
                        ω
                     
                     =(−,…, −). The conditional probabilities of a node i given evidence are p(x
                     
                        i
                     
                     =
                     j∣
                        ω
                     ), j
                     =1,…, k, where the empty elements (−) of 
                        ω
                      are unobserved and marginalized out. Fig. 2 shows the difference between marginal probabilities (with no evidence) and the conditional probabilities for all nodes i given evidence vector 
                        ω
                      empty except entries 14 (top) and 10 (bottom).

The CV associated with the state vector 
                        ω
                      is denoted v(
                        ω
                     ). This is the expected future value of all currently unobserved states, given the observed non-empty states in 
                        ω
                     . One objective is to find the initial value before any nodes have been explored, i.e. v(
                        ω
                     
                     0) where 
                        ω
                     
                     0
                     ={−, −,…, −}. This initial value is in theory given exactly by DP, which is explained in Section 3. As an integral part of the DP algorithm one must evaluate the values v(·) of all possible combinations of evidence. This becomes impossible when we have many nodes in the graph. We have N
                     =25 prospects for the BN shown in Fig. 1, which is too large for exact DP evaluation. We instead construct forward selection strategies approximating v(·) to different accuracies. These proposed strategies are presented in Section 5, using building blocks from Section 4 for the CV.

In our context DP recursively explores backwards all the possible sequences that may occur, and it uses these evaluations to select the best dynamic decisions. See e.g. Bickel and Smith (2006) for a similar application of DP. By the word sequence we mean each of the possible situations that may arise. Sequences are indexed by adding one element ω
                        
                           i
                        
                        ∈{1,…, k} at a time to the evidence vector 
                           ω
                        
                        =(ω
                        1,…, ω
                        
                           N
                        ). With N
                        =4 prospects, the state 
                           ω
                        
                        ={−,1,−, 2} means that the node 1 has not yet been explored, node 2 has been observed to be in state 1, node 3 has not yet been explored, and node 4 has been observed to be in state 2. Two different scenarios may correspond to this sequence: (i) when node 2 is explored before node 4 and (ii) when node 4 is explored before 2. This order is of course relevant when we have only explored node 2, and consider observing node 4, or vice versa, but once both node 2 and 4 have been explored, the evidence vector 
                           ω
                         is identical, and we no longer distinguish between these two scenarios (except for discounting purposes).

The decision tree in Fig. 3
                         visualizes the sequential strategy for six nodes. It works in the following way:
                           
                              1.
                              First, decide which node, if any, to observe first.

Then, depending on the outcome x
                                 
                                    i
                                 
                                 ∈{1,…, k}, which node to observe next, if any, and so on.

Note that the sequential selections typically depend on the outcome of the previously selected nodes. This occurs because the conditioning 
                           ω
                         largely influences the conditional probabilities for models with statistical dependence. DP solves the tree by working backwards:
                           
                              1.
                              First, decide whether to drill the last prospect, conditional on the first N
                                 −1 observables.

Then, decide which prospect to drill if there are two nodes left, and so on, until the initial empty set.

In order to pursue this strategy, we have to maximize a certain utility function. We use maximum profit here, and the CV v(
                           ω
                        ) represents the expected revenues of future cash flows given that we are in state 
                           ω
                        . Initially, the vector of observables is empty: 
                           ω
                        
                        0
                        ={−,−,…,−}. The maximization is among all possible free states:
                           
                              (1)
                              
                                 v
                                 (
                                 
                                    
                                       ω
                                    
                                    
                                       0
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                          ∈
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                
                                                   k
                                                
                                             
                                          
                                          p
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          j
                                          )
                                          
                                             
                                                
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   +
                                                   δ
                                                   
                                                      
                                                         
                                                            max
                                                         
                                                         
                                                            s
                                                            ∈
                                                            N
                                                            -
                                                            1
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                  
                                                                  
                                                                     l
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                            
                                                            p
                                                            (
                                                            
                                                               
                                                                  x
                                                               
                                                               
                                                                  s
                                                               
                                                            
                                                            =
                                                            l
                                                            |
                                                            
                                                               
                                                                  x
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            =
                                                            j
                                                            )
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           r
                                                                        
                                                                        
                                                                           s
                                                                        
                                                                        
                                                                           l
                                                                        
                                                                     
                                                                     +
                                                                     …
                                                                  
                                                               
                                                            
                                                            ,
                                                            0
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          0
                                       
                                    
                                 
                                 ,
                              
                           
                        where the second and the subsequent maximizations are over all nodes not yet considered. Here, δ is a discounting factor that depends on the specific case and on the inclination of the decision maker. The 
                           
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                           
                         are revenues or costs of node i with outcome j. When all the sites have been drilled, the CV is v(·,·,…, ·)=0, and we can proceed backwards, one step at a time, to extract the DP solution. Eq. (1) can be rewritten (Bickel and Smith, 2006), and it can be seen as a maximization over all free nodes and 0 (not exploring any further). This means that v(
                           ω
                        )=max
                           i
                        {0, v
                        
                           i
                        (
                           ω
                        )}, where:
                           
                              (2)
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 ω
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    
                                       
                                          p
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          j
                                          |
                                          ω
                                          )
                                          
                                             
                                                
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   +
                                                   δ
                                                   ·
                                                   v
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  ω
                                                               
                                                               
                                                                  i
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        Here 
                           
                              
                                 
                                    ω
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                              =
                              {
                              
                                 
                                    ω
                                 
                                 
                                    -
                                    i
                                 
                              
                              ,
                              
                                 
                                    ω
                                 
                                 
                                    i
                                 
                              
                              =
                              j
                              }
                           
                         means adding one element to the evidence vector, and 
                           
                              v
                              
                                 
                                    
                                       
                                          
                                             ω
                                          
                                          
                                             i
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           
                         is the CV of the state 
                           
                              
                                 
                                    ω
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                           
                        , i.e. 
                           
                              v
                              
                                 
                                    
                                       
                                          
                                             ω
                                          
                                          
                                             i
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                              =
                              
                                 
                                    max
                                 
                                 
                                    l
                                    ≠
                                    i
                                 
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             v
                                          
                                          
                                             l
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      ω
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        .

The main problem with the optimal DP solution is the exponential growth of the number of scenarios that have to be considered. Bickel and Smith (2006) derives the computational cost for a non-recombining tree, i.e. a tree ignoring the order of the observed nodes. Then,
                           
                              
                                 Number
                                 
                                 of
                                 
                                 possible
                                 
                                 scenarios
                                 
                                 in
                                 
                                 a
                                 
                                 non
                                 -
                                 recombining
                                 
                                 tree
                                 :
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          0
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   N
                                                
                                             
                                             
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       k
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 N
                                 -
                                 i
                                 +
                                 1
                                 )
                                 .
                              
                           
                        This entails an order of 104 scenarios for six nodes (Bickel and Smith, 2006), and 1015 when N
                        =25 nodes. The computational cost (proportional to the number of scenarios) is therefore in the order of 
                           
                              
                                 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                              !
                              
                                 
                                    k
                                 
                                 
                                    N
                                    /
                                    2
                                 
                              
                           
                        . Bickel and Smith (2006) suggest to save the local results of the computations in order to reduce the number of configurations to consider. Say, for the purposes of the CV, it does not matter whether we drilled first one well or another, given that we observe their outcomes. Nonetheless, the exact procedure remains unfeasible when N increases. Furthermore, the discounting factor δ makes the use of classical non-recombining algorithms impossible.

Because of the rapid growth in scenarios, one must look for approximate solutions. The problem shares some features with that of a chess game. The player has to choose among all the possible moves she can carry out, and at the same time must consider all the possible replies of her opponent, and the consequential replies of herself, and so on. What is done in practical chess algorithms is to limit the search to a reasonable amount of moves forward, and to evaluate the best move in that “restricted match”, see Shannon (1950) and Feldmann et al. (1994).

Similarly, we push the search through a certain number of steps, figuring out some rules to approximate the CV of the scenarios. The resulting strategies are so-called look-ahead type, where we use DP to look at a small horizon of the future. This is explained in detail in Section 5. Our approximations of the CV are based on naive heuristics or myopic heuristics that are further described in Section 4. These heuristics are not using any of the future information. Chapter 8 of Powell (2007) discuss such policies for approximate DP. We apply them to our problem of sequential exploration of prospects. Since we restrict attention to exploring one prospect at the time, we apply so-called rolling horizon strategies combined with look-ahead to select one prospect at a time (Section 5).

We now present heuristic strategies that have shown useful on their own, but for our purposes will play a part in the approximation for the CV at various stages of the DP equations. For sake of presentation we apply these heuristics to the initial problem in this section, i.e. we have no evidence and 
                        ω
                     
                     =
                     
                        ω
                     
                     0 is the empty vector. In Section 5 the heuristics are used to approximate the CV, we then condition on the current evidence 
                        ω
                      with non-empty entries corresponding to the observed nodes.

The naive strategy ignores the dependence among nodes. Therefore, the selection strategy is pre-determined based on a priori knowledge, and does not depend on the sequential outcomes. The expected marginal profits or intrinsic values 
                           
                              
                                 
                                    IV
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    =
                                    1
                                 
                                 
                                    k
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                                 
                                    j
                                 
                              
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              =
                              j
                              )
                           
                         can be ranked from largest to smallest, and the prospects are chosen according to:
                           
                              (3)
                              
                                 
                                    
                                       i
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 =
                                 arg
                                 
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                       
                                    
                                 
                                 {
                                 
                                    
                                       IV
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 0
                                 }
                                 ,
                                 
                                    
                                       i
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                                 =
                                 arg
                                 
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                          ⧹
                                          
                                             
                                                i
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 
                                 {
                                 
                                    
                                       IV
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 0
                                 }
                                 …
                                 .
                              
                           
                        This means we select the prospect with highest a priori intrinsic value first, then the second highest a priori value, etc. We stop when no more intrinsic values are positive.

The value is then estimated as a discounted sum of a priori intrinsic values:
                           
                              (4)
                              
                                 
                                    
                                       v
                                    
                                    
                                       N
                                    
                                 
                                 (
                                 ω
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       δ
                                    
                                    
                                       l
                                       -
                                       1
                                    
                                 
                                 
                                    max
                                 
                                 {
                                 
                                    
                                       IV
                                    
                                    
                                       
                                          
                                             i
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                    
                                 
                                 ,
                                 0
                                 }
                                 ,
                              
                           
                        where subscript N is used to indicate Naive. This approach, though being very simple (the computational cost is linear in N), still captures a large part of the value if the correlation between nodes is small. The main problem is that disregarding correlation effects can lead to focused attention on nodes that are a priori appealing but may no longer be valuable given the evidence of the previous steps. Disregarding correlations means that the algorithm does not react to new data, so it is neither sequential nor looking ahead.

A second natural approach is represented by the myopic strategy (Bollapragada and Morton, 1999). According to this strategy, the best sequence is computed step-by-step in a forward selection scheme. The conditional probabilities in the different nodes are now updated, given the previous outcomes. This represents an intuitive sequential strategy, but it only exploits the dependence in the graph through the past, without considering what the future might bring.

The strategy for finding the first best prospect coincides with the naive approach:
                           
                              (5)
                              
                                 
                                    
                                       i
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 =
                                 arg
                                 
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                r
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                          p
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          j
                                          )
                                          ,
                                          0
                                       
                                    
                                 
                                 .
                              
                           
                        Given an outcome 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                         at this first selected node i
                        (1), the second myopic node is then chosen as:
                           
                              (6)
                              
                                 
                                    
                                       i
                                    
                                    
                                       (
                                       2
                                       
                                          
                                             j
                                          
                                          
                                             1
                                          
                                       
                                       )
                                       |
                                       
                                          
                                             x
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   (
                                                   1
                                                   )
                                                
                                             
                                          
                                       
                                       =
                                       
                                          
                                             j
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 =
                                 arg
                                 
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                          ⧹
                                          
                                             
                                                i
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                r
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                          p
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          j
                                          |
                                          
                                             
                                                x
                                             
                                             
                                                
                                                   
                                                      i
                                                   
                                                   
                                                      (
                                                      1
                                                      )
                                                   
                                                
                                             
                                          
                                          =
                                          
                                             
                                                j
                                             
                                             
                                                1
                                             
                                          
                                          )
                                          ,
                                          0
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       j
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 k
                                 .
                              
                           
                        Now, the second best choice, therefore, involves k different maximizations, depending on the outcome of 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        . For the third selection, we condition on the outcome of node i
                        (1) and i
                        (1), which means k
                        2 possible condition sets. Thus, using a myopic strategy leads to a decision tree with 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    N
                                 
                              
                              
                                 
                                    k
                                 
                                 
                                    i
                                 
                              
                           
                         scenarios.

The myopic approach approximates the value by
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   1
                                                
                                             
                                             =
                                             
                                                max
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               j
                                                               =
                                                               1
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      p
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            
                                                               
                                                                  i
                                                               
                                                               
                                                                  (
                                                                  1
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                      =
                                                      j
                                                      )
                                                      ,
                                                      0
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   2
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         max
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        l
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     r
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           x
                                                                        
                                                                        
                                                                           
                                                                              
                                                                                 i
                                                                              
                                                                              
                                                                                 (
                                                                                 2
                                                                                 j
                                                                                 )
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     l
                                                                  
                                                               
                                                               p
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           i
                                                                        
                                                                        
                                                                           (
                                                                           2
                                                                           j
                                                                           )
                                                                        
                                                                     
                                                                  
                                                               
                                                               =
                                                               l
                                                               |
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           i
                                                                        
                                                                        
                                                                           (
                                                                           1
                                                                           )
                                                                        
                                                                     
                                                                  
                                                               
                                                               =
                                                               j
                                                               )
                                                               ,
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             p
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   
                                                      
                                                         i
                                                      
                                                      
                                                         (
                                                         1
                                                         )
                                                      
                                                   
                                                
                                             
                                             =
                                             j
                                             )
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   M
                                                
                                             
                                             (
                                             ω
                                             )
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      N
                                                   
                                                
                                             
                                             
                                                
                                                   δ
                                                
                                                
                                                   i
                                                   -
                                                   1
                                                
                                             
                                             
                                                
                                                   v
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where subscript M is used to indicate Myopic. The complexity of designing an entire strategy with this myopic approach is of order k
                        
                           N
                        . This remains considerably high, keeping in mind that we are just using a small part of the information. One way of evaluating the myopic strategy is by Monte Carlo sampling x
                        1, …, x
                        
                           B
                        
                        ∼
                        p(x). For each of the B samples the decision is given by the past outcomes, say 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                 
                                 
                                    b
                                 
                              
                              =
                              j
                           
                        , 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          (
                                          2
                                          j
                                          )
                                       
                                    
                                 
                                 
                                    b
                                 
                              
                              =
                              l
                              ,
                              …
                           
                        , and different samples would follow different branches of the decision tree. One could also imagine truncating the myopic evaluation and using the (conditional) naive approach from a certain branch on. We will discuss such approaches in more depth in the next section, when we study more refined forward selection strategies applying the heuristics for the CV at every stage. The myopic algorithm can be seen as a sequential version of the naive algorithm. Correlations with earlier observations are used to update the probabilities, but it does not look ahead. For a given set of probabilities, the myopic and the naive approach will always choose the same first node, but then the myopic diverges as it updates with new information.

We next propose look-ahead strategies that apply a depth n forward search combining DP with approximations of the CV. The depth n can be chosen by the user. It will depend on the desired accuracy and on the available time and computation power. The methods considered in the previous section have the common goal of providing an approximation to the CV at each stage.

In our oil and gas prospect application, there is typically no need to push the forward–backward selection procedure until the very last node. The oil and gas company is most interested in deciding the first few prospects to drill. In this way the depth n approach seems reasonable. On the other hand, the approximations we consider apply heuristics for the CV, and the resulting sequences are not necessarily optimal.

Consider the n first branches of a decision tree, and assume we approximate the CVs at each leaf node of this depth-n tree. In our approach the CV is approximated by a naive or myopic strategy. The approximate CVs are required when we run a restricted n-steps DP. We thus propose to assign a large contribution to the first n
                        <
                        N decisions, and a smaller contribution to the remaining N
                        −
                        n. This entails that we solve the depth-n decision tree with approximate leaf-node values. As outputs we get to select the best node for this strategy, i.e. the one with highest expected value when the CVs are approximated after n branches. The complexity of the algorithm depends on the size n chosen in the approximation, and it is of order 
                           
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                              !
                              
                                 
                                    k
                                 
                                 
                                    n
                                    /
                                    2
                                 
                              
                              (
                              N
                              -
                              n
                              )
                           
                         when approximating the CV with the naive heuristic. The strategy is the following:
                           
                              •
                              Starting point: no nodes have been observed yet: 
                                    ω
                                 
                                 ={−,−,…,−}.

The n first branches of the decision tree are evaluated with DP, i.e. v(
                                    ω
                                 )=max{v
                                 1(
                                    ω
                                 ),…, v
                                 
                                    N
                                 (
                                    ω
                                 )}, over all nodes N. At each step v
                                 
                                    i
                                 (
                                    ω
                                 ) is computed according to Eq. (2), with an approximate CV for each of the depth-n branches.

The decision vector has n observed components and N
                                 −
                                 n still empty (not observed). We define the decision vector at this stage 
                                    ω
                                 
                                 ∗. For instance, if N
                                 =6 and n
                                 =2, with observations x
                                 2
                                 =2 and x
                                 6
                                 =1, then 
                                    ω
                                 
                                 ∗
                                 ={−,2,−,−,−,1}.

For each leaf-node in the depth-n tree the CV v(
                                    ω
                                 
                                 ∗) is approximated using the naive approach introduced in Section 4. Now conditional on 
                                    ω
                                 
                                 ∗:
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                N
                                             
                                          
                                          (
                                          
                                             
                                                ω
                                             
                                             
                                                ∗
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                   -
                                                   n
                                                
                                             
                                          
                                          
                                             max
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            j
                                                            =
                                                            1
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   p
                                                   (
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   =
                                                   j
                                                   |
                                                   
                                                      
                                                         ω
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   ,
                                                   0
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 We can also fix an order for the N
                                 −
                                 n prospects, based of their intrinsic values, in order to discount the values in a particular way. One may also pursue other approaches in this last step, such as a myopic approximation of the CV, but this is much more time-consuming.


                                 v
                                 
                                    N
                                 (
                                    ω
                                 
                                 ∗) represents the approximated CV after n steps, and it is finally used for computing the original v
                                 
                                    i
                                 (
                                    ω
                                 ).

This algorithm is both sequential, since the next decision depends on previous observations, and it looks ahead, so that correlations influence the next choice. However, in the truncated depth n version, it stops looking ahead after some steps, and use heuristics to approximate the CV.

We next combine different look-ahead searches and forward selection strategies. We suggest the idea depicted in Fig. 4
                        , where one first runs a look-ahead search of depth n. Next, the best node is selected. Given the outcome of this node, a second search of depth n is performed, and so on. We call these strategies Depth n (in the following Dpt n) rolling horizon look-ahead (RHLA) strategies (see Le and Day (1982) and Alden and Smith (1992)). It is interesting to note that a Dpt 0 strategy coincides with a full naive or myopic approach (depending on the approximation chosen for the CV), while a Dpt N
                        −1 strategy coincides with a full evaluation of the decision tree, and therefore with the DP presented in Eq. (1).

This RHLA strategy is a forward selection, but it partially accounts for future scenarios in its look-ahead length-n DP procedure. In the RHLA strategy we explore the tree up to a certain fixed depth n, but we draw conclusions just about the first best site. Since at every step we rerun the strategy, we can incorporate at this step the outcome of the sample, instead of exploring all the possible combinations of evidence. This algorithm is thus both sequential and looking ahead for all decisions.

The resulting algorithm has the same computational complexity as the myopic strategy, with an additional factor due to the complexity of the look-ahead strategy itself. In total we have a complexity of 
                           
                              
                                 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                              !
                              
                                 
                                    k
                                 
                                 
                                    n
                                    /
                                    2
                                 
                              
                              (
                              N
                              -
                              n
                              )
                              ·
                              
                                 
                                    k
                                 
                                 
                                    N
                                 
                              
                           
                        . Note that this strategy can always be computed in a forward selection manner. It is however much harder to evaluate the strategy, for instance to compute the associated value, or the variability in the computed sequences over different outcomes. For a small number of nodes N, one can compute the values probabilistically for different depths n RHLA strategies. For larger dimensions we suggest to use Monte Carlo sampling to evaluate the different strategies. We then draw samples from the graphical model with joint distribution p(x). We run the RHLA depth n procedure to select nodes, and for each step in the forward selection we plug in the outcomes according to the relevant sample at that node. This approach mimics what would happen in hypothetical scenarios, and we can say that we are playing the game.
                           Algorithm 1
                           Evaluating a rolling horizon look-ahead strategy of depth n 
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                
                                                   ω
                                                
                                                =[−,−,…,−]
                                             # Dynamic programming outcome vector
                                          
                                          
                                             
                                                y
                                                =0
                                             # Rolling horizon counter
                                          
                                          
                                             
                                                val
                                                =0
                                             # Value counter
                                          
                                          
                                             
                                                seq
                                                =[]
                                             # Best sequence vector
                                          
                                          
                                             Sample s
                                                ∼
                                                p(x)
                                             # Current sample
                                          
                                          
                                             
                                                while
                                                #[ω
                                                
                                                   i
                                                
                                                ={−}]>0 do
                                             
                                             
                                          
                                          
                                             
                                                [v,j]=
                                                f(
                                                   ω
                                                ,1)
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                v
                                                >0 then
                                             
                                             # CV positivity condition
                                          
                                          
                                             
                                                
                                                ω
                                                
                                                   j
                                                
                                                =
                                                s
                                                
                                                   j
                                                
                                             
                                             # Set sampled outcome s
                                                
                                                   j
                                                 at selected node j
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      val
                                                      +
                                                      =
                                                      
                                                         
                                                            δ
                                                         
                                                         
                                                            y
                                                         
                                                      
                                                      ·
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            j
                                                         
                                                         
                                                            
                                                               
                                                                  s
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             # Discounting of revenues
                                          
                                          
                                             
                                                
                                                seq
                                                
                                                   y+1
                                                =
                                                j
                                             
                                             # Selected node is j
                                             
                                          
                                          
                                             
                                                
                                                else
                                             
                                             
                                          
                                          
                                             
                                                
                                                break
                                             
                                             
                                          
                                          
                                             
                                                end if
                                             
                                             
                                          
                                          
                                             
                                                y ++
                                             
                                          
                                          
                                             
                                                end while
                                             
                                             
                                          
                                          
                                             
                                                return 
                                                val
                                             
                                             
                                          
                                          
                                             
                                                return 
                                                seq
                                             
                                             
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                                function [v,j]=
                                                f(
                                                   ω
                                                ,d)
                                             # Input: Current state, current depth
                                          
                                          
                                             
                                                if #[ω
                                                
                                                   i
                                                
                                                ={−}]==0 then
                                             
                                             # Last iteration condition, stop
                                          
                                          
                                             
                                                j=0
                                             
                                          
                                          
                                             
                                                v=0
                                             
                                          
                                          
                                             
                                                else if 
                                                d
                                                ⩽
                                                n
                                             
                                             # “Depth n” condition, continue DP
                                          
                                          
                                             
                                                
                                                for 
                                                i: ω
                                                
                                                   i
                                                
                                                ={−} do
                                             
                                             
                                          
                                          
                                             
                                                
                                                for 
                                                l
                                                =1:k 
                                                do
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      [
                                                      v
                                                      ,
                                                      j
                                                      ]
                                                      =
                                                      f
                                                      (
                                                      
                                                         
                                                            ω
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      ,
                                                      d
                                                      +
                                                      1
                                                      )
                                                   
                                                
                                             
                                             # DP iteration at next depth level
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      +
                                                      δ
                                                      ·
                                                      v
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            l
                                                            =
                                                            1
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      {
                                                      p
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      =
                                                      l
                                                      |
                                                      ω
                                                      )
                                                      ·
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            l
                                                         
                                                      
                                                      }
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                             
                                          
                                          
                                             
                                                
                                                v
                                                =max
                                                   i
                                                {v
                                                
                                                   i
                                                ,0}
                                             
                                          
                                          
                                             
                                                
                                                j
                                                =arg max{v
                                                
                                                   i
                                                }
                                             
                                          
                                          
                                             
                                                else
                                             
                                             # Reached depth n, compute naive CV
                                          
                                          
                                             
                                                
                                                j
                                                =0
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      v
                                                      (
                                                      ω
                                                      )
                                                      =
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            i
                                                            :
                                                            
                                                               
                                                                  ω
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            =
                                                            {
                                                            -
                                                            }
                                                         
                                                      
                                                      max
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                  
                                                                  
                                                                     l
                                                                     =
                                                                     1
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               
                                                                  
                                                                     r
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     l
                                                                  
                                                               
                                                               ·
                                                               p
                                                               (
                                                               
                                                                  
                                                                     x
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               =
                                                               l
                                                               |
                                                               ω
                                                               )
                                                               ,
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                end if
                                             
                                             
                                          
                                          
                                             
                                                end function
                                             
                                             
                                          
                                       
                                    
                                 
                              
                           

Given one realization from the graphical model, the pseudo-algorithm is presented in Algorithm 1. The algorithm presents two parts: The first constitutes the core of the algorithm from where we call the recursion. The second one presents the recursive function itself. In the core we find a while loop that is necessary to terminate the algorithm when all the nodes have been explored and an if condition that breaks the process if none of the nodes presents a positive CV. In the recursive function we have an if condition that ensures that the correct depth is achieved, and a for loop that goes through all the not-yet-explored nodes. When running a RHLA strategy on small examples (cfr. Section 6.1) there is the possibility to run a RHLA for every possible evidence, spanning the whole sample space. By averaging the revenues and costs collected through the strategy, we get a value that coincides (exact and myopic case) or approximates (RHLA case) the estimated final value. In large examples (cfr. Section 6.2) this is not possible and we estimate the final values through a Monte Carlo sampling procedure.

Recall that this Monte Carlo evaluation was also suggested for myopic strategies, following exactly the same principle, but getting every time the new best choice using a myopic strategy and not a look-ahead one. In this way we can get a fair comparison between a complex sequential strategy (RHLA), a simpler yet sequential strategy (rolling horizon myopic), and a simple non-sequential strategy (naive).

The look-ahead strategies share the idea of choosing a priori the depth n of the search tree. This choice must be done before running an approximation. In practice, we choose n based on the available computation time.

The problem is that we often explore branches of the decision tree that are useless for designing an optimal strategy, and we do not privilege enough branches that can give a stronger contribution to the value. We next design adaptive strategies based on tree-pruning, accounting for the value of the different branches. These idea is inspired by similar ideas applied in contiguous fields, like the chess computer-based algorithms.

We prune the branches of the tree that are very unlikely. In this way we do not have to explore all the combinations, and we reduce the complexity of the algorithm. We define threshold parameter ε such that
                           
                              
                                 if
                                 
                                 P
                                 
                                    
                                       
                                          
                                             
                                                ω
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 <
                                 ε
                                 
                                 then
                                 
                                 v
                                 
                                    
                                       
                                          
                                             
                                                ω
                                             
                                             
                                                i
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 ≈
                                 v
                                 
                                    
                                       
                                          
                                             
                                                ω
                                             
                                             
                                                i
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        and we use one of the methods described in Section 4 in order to approximate the CV.

A more refined approach is to decide which branches to explore based on the value of the nodes. This reduces the number of nodes to explore. The method can either be based on the intrinsic value of the individual node under consideration or a look-ahead evaluation of depth 1.

The pseudo-algorithm is the following:
                           
                              •
                              
                                 
                                    ω
                                 
                                 0
                                 ={−,−,…,−}

for i
                                 =1: N+ we order the segments on the basis on an approximate CV, that can be either of the following:
                                    
                                       –
                                       
                                          Intrinsic value: 
                                             
                                                v
                                                (
                                                
                                                   
                                                      ω
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                =
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      k
                                                   
                                                
                                                
                                                   
                                                      r
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      k
                                                   
                                                
                                                p
                                                (
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      i
                                                   
                                                
                                                =
                                                j
                                                )
                                             
                                          
                                       


                                          Look-ahead Dpt 1 value:
                                             
                                                v
                                                (
                                                
                                                   
                                                      ω
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                =
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      k
                                                   
                                                
                                                p
                                                (
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      i
                                                   
                                                
                                                =
                                                j
                                                )
                                                
                                                   
                                                      
                                                         
                                                            
                                                               r
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         +
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               s
                                                               =
                                                               2
                                                            
                                                            
                                                               N
                                                            
                                                         
                                                         max
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        l
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                  
                                                                  
                                                                     
                                                                        δ
                                                                     
                                                                     
                                                                        s
                                                                     
                                                                  
                                                                  
                                                                     
                                                                        r
                                                                     
                                                                     
                                                                        (
                                                                        s
                                                                        )
                                                                     
                                                                     
                                                                        l
                                                                     
                                                                  
                                                                  p
                                                                  (
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        (
                                                                        s
                                                                        )
                                                                     
                                                                  
                                                                  =
                                                                  l
                                                                  |
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                  
                                                                  =
                                                                  j
                                                                  )
                                                                  ,
                                                                  0
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       

Keep only the N
                                 −
                                 N
                                 prun maximum nodes with the highest values and move to the second level of depth in a RHLA framework. For the N
                                 prun nodes with minimum values, use the approximated values already computed (Intrinsic or Look-ahead Dpt 1).

In practice, N
                        prun cannot be too small (too many paths to explore), nor too large (we risk to abandon paths that may result being interesting). We will use the pruning strategies to speed up the computations on large graphs.

@&#RESULTS@&#

We first study a small BN model, where the exact DP solution is available. This allows us to compare the suggested strategies with the exact solution. This synthetic study also anticipates the behavior of the approximations on the BN case study from the North Sea, with 25 prospects. Finally, we analyze a MRF model for an oil reservoir. We construct sequential exploration schemes and interpret the results of different strategies.

We are first interested in exploring the accuracy and the results of our methods on a small BN example (Fig. 5
                        ). We use a small DAG with M
                        =12 nodes.

The nodes denoted K1, K2, P1, P2, P3 and P4 are auxiliary nodes that cannot be drilled; their role in the network is consistent with the model presented in Section 2.

The cost and revenues and marginal probabilities are summarized in Table 1
                        . We designed the DAG to have large variabilities both in the likelihood of finding HC and in the related volumes (revenues). The intrinsic values, i.e. the marginal a priori values of the prospect, are all very close to 0: this makes the case harder to solve. The conditional probabilities defined by the edges are based on geological reasoning and explained in details in Martinelli et al. (2011). These edges impose some learning in the model, once we collect evidence.

In this small case we can compare the result of approximate strategies with the exact DP solution. The discounting parameter δ is fixed, here and in the next simulations, to a realistic value of 0.99, as suggested in (Bickel and Smith, 2006). In Table 2
                         we present the result of strategies up to the third best choice for the naive and myopic strategies, for exact DP and for Dpt n strategies, up to n
                        =4. According to the exact strategy, if oil or gas is found in the first segment chosen (in this case, number 6), the suggestion is to keep drilling in the same area (under P4 node) with segment number 5. If the well reports a negative result, it makes sense to immediately explore another part of the field. The naive approach does not take this dichotomy into account because the sequence is fixed a priori. The myopic approach uses a different strategy for the oil/gas and the dry case, but since the depth of the search is in this case short-sighted, the conclusion is to stop drilling immediately after a dry well.

In addition to comparing strategies, we study the computational time and the final value approximation v(
                           ω
                        
                        0). We notice that, despite slightly different strategies, the final value approximations are quite close to the exact one for Dpt 2 or even Dpt 1, with a much smaller computational time. The final value approximations reported in the table are found when optimizing the strategy for the Dpt 1–4 algorithms. In practice their value will be higher, since the actual approximations are not based on using a naive strategy at the end, but instead apply RHLA to run new Dpt n searches. We therefore believe that the best comparison is not much about comparing values, but more about comparing the proposed strategies on real scenarios.

Since the dimension of the problem is relatively small, we can directly span the whole sample space and compute all RHLA strategies exactly, as anticipated in Section 5.2. This is the approach adopted in Table 3
                        . Here we compare the evaluation of the different strategies (naive, myopic and different depths of look ahead strategies) on the whole sample space generated by the BN of reference. We therefore test 36
                        =729 combinations of evidence on the nodes of interest, and we compute the likelihood of these scenarios by summing out the outcome at the top nodes. In this way, we can compute exactly the probability distribution of the final values, the mean performance of the strategies, and the risk for the different strategies. The risk is the standard deviation of the outcome distribution, not to be confused with the standard error which is often reported for estimates.

The result tells us that, when applied in practice on this simple test case, the two simple strategies perform extremely poorly, while the look ahead strategies perform significantly better. In particular, Dpt 2 and Dpt 3 perform almost as good as Dpt 4 (which in this case corresponds exactly to the Exact Strategy), with a significant reduction in the computational time. An interesting argument in favor of the look-ahead strategies can also be made considering the risk in the second row of Table 3. We observe an increasing risk between the simpler strategies and the look-ahead strategies. We first note that the risk of the revenues distribution under the naive strategy just reflects the variance of the marginal a priori distribution for prospects 3, 4 and 6:
                           
                              
                                 
                                    
                                       σ
                                    
                                    
                                       N
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       12.664
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            3
                                                         
                                                      
                                                      +
                                                      δ
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            j
                                                         
                                                         
                                                            4
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            δ
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            j
                                                         
                                                         
                                                            6
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                          ·
                                          p
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                3
                                             
                                          
                                          =
                                          i
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                4
                                             
                                          
                                          =
                                          j
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                6
                                             
                                          
                                          =
                                          k
                                          )
                                       
                                    
                                 
                              
                           
                        Furthermore, we can relate the low risk of the myopic strategy to a spike on the value ’−1’, that corresponds to the loss for a likely (p
                        =0.8) dry observation in segment 3 (see Table 1). Since a dry outcome at the first site in the myopic strategy would imply quitting the search, we are ultimately left with a high number of scenarios whose revenues’ outcome is simply −1. If we remove these scenarios, the risk actually reduces from myopic to Dpt 1 to Dpt 4, providing another argument in favor of these strategies. A lower risk coincides with a more certain outcome, which is desirable when investing. In some situation this reduced risk can be almost as important as a high final value.

We next study the BN model developed for 25 HC prospects in the North Sea, see Fig. 1 in Section 2. The network includes the same characteristics as the small test study, but there are now 25 possible drilling locations. The marginal probabilities are given in Table 4
                        . Similar to the previous model, the DAG has a three-level structure representing the geological mechanisms. For decision making we are interested in the bottom nodes of the network, that represent identified prospects whose volumes and costs are assumed known. The corresponding revenues and costs (in Million USD) are listed in Table 4. In this real case, there are still some nodes where the probability of success (and consequently the intrinsic value) may change substantially given the outcome in other nodes. However, some nodes would be drilled or not drilled in any event, no matter the strategy.

Given the BN model we are interested in identifying a drilling sequence that gives maximum profit under some criterion. Table 5
                         shows the results of comparing the naive, myopic and three depth (Dpt) level heuristic strategies. Note that the final value approximations are now quite close to each other for all algorithms considered. The dynamic decisions depend less on the strategy than in the synthetic case in the previous section. Still, there is a clear increase of about 3000 Million USD when using the Dpt 3 strategy rather than the naive one. We have again run the different strategies on a number of simulated scenarios (Table 6
                        ). Since the computational time required by the RHLA strategy is order of hours per step, we have considered a sample size of 200 and followed the algorithm described in Section 5.2. For the same reason we will focus from now on in a comparison between simple strategies, such as naive or myopic, and two RHLA strategies, namely Dpt 1 and Dpt 2.

The Dpt strategies appear to perform better on average than the myopic one. The risk again represents the standard deviation of the outcomes. This appears smaller for the Dpt n strategies than for myopic, so the increased value is not due to increased risk. We construct confidence intervals for the differences of the mean values in strategies. Since the evaluations are done on identical samples, differences in values have relatively less variety than that shown by the risks. The confidence intervals for differences in expected values are based on 
                           
                              
                                 
                                    d
                                 
                                 
                                    ¯
                                 
                              
                              =
                              
                                 
                                    1
                                 
                                 
                                    B
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    b
                                    =
                                    1
                                 
                                 
                                    B
                                 
                              
                              
                                 
                                    d
                                 
                                 
                                    b
                                 
                              
                           
                        , and d
                        
                           b
                        
                        =strat2
                           b
                        
                        −strat1
                           b
                         is the difference in strategy 2 and strategy 1 values in run number b. Under Gaussian assumptions 
                           
                              
                                 
                                    d
                                 
                                 
                                    ¯
                                 
                              
                              ∼
                              N
                              
                                 
                                    
                                       E
                                       (
                                       strat
                                       2
                                       )
                                       -
                                       E
                                       (
                                       strat
                                       1
                                       )
                                       ,
                                       
                                          
                                             s
                                          
                                          
                                             d
                                          
                                          
                                             2
                                          
                                       
                                       /
                                       B
                                    
                                 
                              
                           
                        , where E(strat2)−
                        E(strat1) is the true expected difference which we want to construct a confidence interval for, and s
                        
                           d
                         is the standard deviation of differences d
                        1,…, d
                        
                           B
                        . Then, the 90% confidence intervals are as follows: (12,474) between Dpt1 and myopic, (137,201) between Dpt 2 and Dpt 1, and (188,635) between Dpt 2 and myopic. All confidence intervals are positive, indicating that Dpt 1 has significantly higher mean value than myopic, and Dpt 2 has significantly higher mean value than Dpt 1. Using bootstrap sampling (Efron and Tibshirani, 1994) instead of Gaussian assumptions, we get similar 90% confidence intervals: (−6,490) between Dpt 1 and myopic, (133,199) between Dpt 2 and Dpt 1, and (144,640) between Dpt 2 and myopic. Here, there is of course added variability in the bootstrap scheme too. In conclusions, the Dpt 1 strategy gives higher values than myopic, but it is not extremely clear for our example. There is however a significant improvement going from Dpt 1 to Dpt 2.

It is particularly important to investigate the reason of this improvement in value. A first hint is given by the last three lines of Table 6. Here we can notice that more complex strategies suggest in general to drill more than simpler strategies. The typical case is that whenever an area is found dry, the intrinsic values for all the segments around drop, and just long-sight strategies can look for the potential remaining values. Nonetheless, a higher number of drilled sites translates into an effective improvement of the result just if the newly drilled sites have a positive outcome. This is the case that we are considering, since among the 1.49 sites more drilled with Dpt 2 strategy, just 0.13 are on average dry, while an outstanding 1.36 are found gas or oil.


                        Fig. 6
                         shows what happens to all the 25 prospects when explored with different strategies, and over replicates of Monte Carlo scenarios. The display shows the empirical marginal probabilities of oil or gas (top) and dry (bottom) in black coloured bars. These should be compared with the grey (myopic) and white (Dpt 1) bars which indicate the proportion of times we observe oil or gas (top) versus dry (bottom), given that a strategy lets us drill a prospect. All these proportions are obtained from a sample of numerical experiments. Recall that prospect 15 is the first selected using a Dpt 1 strategy. For this prospect the marginal is then of course identical to the Monte Carlo proportions with Dpt 1. The same holds for prospect 18 and the Myopic strategy. For most other prospects there will be differences since the outcomes of the earlier selected prospects tend to guide our sequential decisions of drilling or not. Note that prospects 3, 11 and 13 are not drilled in any of the Monte Carlo runs, and therefore it is not possible to compute grey or white bars here. Prospect 2 is never drilled under a Myopic strategy, but it is sometimes drilled using Dpt 1. When a Dpt 1 strategy chooses to drill prospect 2, it turns out to be oil or gas. This occurs because the associated Monte Carlo outcomes at the dependent prospects are lucrative, and we have much information indicating that prospect 2 is most likely oil or gas. In a situation with non-lucrative Monte Carlo outcomes at other prospects, a Dpt 1 strategy suggests not to drill prospect 2. For prospect 14 and 23 we similarly drill only in the most lucrative Monte Carlo scenarios, for both Myopic and Dpt 1 strategies. The Dpt 1 strategy still has benefits in economical terms for prospect 14, since we are drilling in a larger proportion of the Monte Carlo runs (see Table 7
                        , bottom rows). At many prospects (e.g. 6, 7, 8, 9, 20) the proportion of a positive discovery is higher for the Dpt 1 approach than the myopic approach. Table 7 tells us that we are drilling prospect 8 a smaller number of times with the Dpt 1 strategy, but with higher efficiency. For prospect 20, we increase both the accuracy and the percentage of drilled times, resulting in a strong economical return. Ultimately, the difference between different policies is due to the sequential nature of the decisions being made, where the next drilling decision is made based on the current posterior, which depends on the true probabilities of containing oil and gas through the previous belief updates. In Fig. 6 we aggregate the outcome of drilling decisions over time periods and we therefore lose the sequential dimension of the problem. In contrast, the values presented in Table 6 are average values discounted over time according to the sequence chosen.

We finally consider (Table 8
                        ) what happens in single scenarios, i.e. what are the results when “playing the game” on a few samples with different strategies (myopic, Dpt 1 and Dpt 2). We see that the myopic approach performs either brilliantly (sample 2) or extremely poorly (samples 1 and 3), while the revenues guaranteed by the other two approaches are, in a way, more stable: this is consistent with the type of approach, since we understand that being more long-sighted correspond to being more cautious in our decision. The difference in the revenue variances recorded in the two samples confirms this statement, with a strong decrease recorded when comparing myopic strategy with RHLA strategies.

If we look closer, we discover other signs that agree with this statement. The first 5 sites picked by a myopic approach are all on the left part of the network. In simple words, we start our search from the left side (prospect 18), and keep exploring the same side for a long period as long as the results are positive. The Dpt 1 approach suggests to jump 3 times between the left and the right side of the network just in the first five picks (15 and 22, then 18, then 12, then 24), even if the results are very good: this means that while we consolidate the strength of a part of the network, we also explore if other parts of the networks are likewise strong. This way of exploring has the further benefit, in this particular case, to allow a longer series of straight good results (seven versus five). The myopic strategy seems to perform better in very lucrative scenarios, and this is consistent with the theoretical definition of myopic strategy, that goes for the best first. In an hypothetical scenario of all prospects containing oil, the myopic strategy would be difficult to beat, and this situation is very similar to the one drawn in the second sample.

In summary we learnt that there are clear differences in the suggested drilling strategies for the naive, myopic and Dpt n computations. A myopic strategy gives a large improvement over the naive strategy in our network, and this will always be the case as long as the prospects are dependent and not obviously profitable or unprofitable. The extra gain from running Dpt n strategies is in this 25 prospect case seen as a larger payoff in money for the computing time spent. The Dpt n strategies also suggest other drilling locations. In a practical setting, our recommendation is to run a Dpt n search with as large n as computationally feasible. Note that this can be done stepwise. In many situations we only need to identify the first prospect, and can wait for the result there before computing the next. This is the practical exploration scenario a petroleum company faces.

The model proposed in Section 2 and originally presented in Martinelli et al. (2011) captures quite well the desired correlation between different parts of the networks, and efficiently translates the geological knowledge into a formalized expert system. However, the underlying assumptions are quite strong, and we next discuss some possible extensions.

One simplicity is that of three possible outcomes: dry, gas and oil. This further implies that an exploration well provides perfect information about the revenues of the prospect. In a recent work (Martinelli et al., 2012a) we relax this assumption by allowing a more realistic sample space with different outcomes for various categories of nodes, and six possible outcomes for the exploration wells. In the real case study in Martinelli et al. (2012a) the number of nodes is small, but the arguments are possible to re-use for the currently suggested approximations applicable with many nodes.

Another possible extension is that of shared costs. The prospects are tied together in the BN via their common parent node. In Martinelli et al. (2012a) we rewrite the utility function of the DP for shared costs. Such extensions are also possible for large networks.

Finally, there is a problem with the elicitation of the BN, i.e. the definition of the network structure. Since the source migration is a spatial phenomenon, the identification of the edges and physical paths can be acceptable, but for other risk factors (reservoir presence, trap seal, …) a data-driven process would be desirable. A broader discussion of this topic and useful methodologies for elicitation are presented in Martinelli et al. (submitted for publication), where scenarios are generated from geological basin modeling software, and these are used as training sets for learning the BN.

In the section we apply our sequential exploration technique on a larger dataset, where the current knowledge consists of geological knowledge combined with seismic data. The data and the case study are explained in Bhattacharjya et al. (2010). The MRF model has three colours, which are oil saturated sand (x
                     
                        i
                     
                     =1), brine saturated sand (x
                     
                        i
                     
                     =2) and shale (x
                     
                        i
                     
                     =3). We use a lattice representation of the field, with 20×5 cells, i.e. M
                     =
                     N
                     =100.

The prior model is a categorical first-order MRF (Besag, 1974):
                        
                           
                              p
                              (
                              x
                              )
                              ∝
                              exp
                              
                                 
                                    
                                       β
                                       ·
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                ∼
                                                j
                                             
                                          
                                       
                                       I
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       +
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                N
                                             
                                          
                                       
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                              ,
                           
                        
                     where i
                     ∼
                     j denotes the sum over all neighbouring lattice nodes (north, east, south, and west). The parameter β imposes spatial interaction. The α
                     
                        i
                      terms are set from a priori geological knowledge (Bhattacharjya et al., 2010). We work with a highly correlated MRF (β
                     =0.8).

The seismic data y are incorporated in the MRF model x through a Gaussian likelihood model (Eidsvik et al., 2004). At each cell bivariate seismic data, shown in Fig. 7
                      are modeled by:
                        
                           
                              p
                              (
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              |
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              )
                              ∼
                              N
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               μ
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         (
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               μ
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         (
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               0.06
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                      
                                                         -
                                                         0.007
                                                      
                                                   
                                                   
                                                      
                                                         -
                                                         0.007
                                                      
                                                      
                                                         
                                                            
                                                               0.17
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              ,
                           
                        
                     where 
                        μ
                     
                     
                        1
                     
                     =(0.03,0.08,0.02) and 
                        μ
                     
                     
                        2
                     
                     =(−0.21,−0.15,0).

The posterior model is defined by:
                        
                           
                              p
                              (
                              x
                              |
                              y
                              )
                              ∝
                              p
                              (
                              x
                              )
                              
                                 
                                    
                                       ∏
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       100
                                    
                                 
                              
                              p
                              (
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              |
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              )
                              .
                           
                        
                     This posterior is a MRF with new α
                     
                        i
                      terms which now also depend on the data values.

As was done in Bhattacharjya et al. (2010), we assign a fixed cost of 2million USD for drilling a dry well (state 2 or 3), while we have a potential revenue of 5million USD when finding an oil saturated sand (state 1). Before drilling we have the situation represented in Fig. 7. In the top row we see the bivariate seismic data, in the bottom row we see the prior geological knowledge and the posterior oil saturated sand probability.

The combinatorial complexity prevents us from running a full search, therefore we try different levels of approximations, from the myopic strategy to more complex depth searches. We present in Fig. 8
                      the results of myopic, Dpt 1 and Dpt 2 strategies. While the first myopic strategy reproduces the same pattern that we observe in the posterior probability of oil (bottom right, Fig. 7), the second Dpt 1 strategy shows a different pattern. The sites on the eastern part of the basin, those that get the higher expected revenues (due to a strong prior probability of oil sand), are not anymore selected in the first step, because they are surrounded by sites with low profitability. On the other hand, the central sites, whose profitability was not that high, but overall good over a large area, are privileged by a Dpt 1 strategy. The same behaviours appear in the bottom part of Fig. 8, that report the best first and second choice for Dpt 2 strategy. We can further note that the expected final values increase with more complex strategies.

For a petroleum company that wants to explore a reservoir zone, we expect the drilling strategy to depend heavily on the amount of data available (seismic data and well data in the neighborhood of the reservoir), and the cost of establishing new infrastructure. In this example we built the first element into the MRF model and the second as part of the case-specific utility function. In our situation, the Dpt n strategies clearly select different drilling locations than the myopic approach. This kind of information is useful in an appraisal stage of a reservoir unit.

The paper proposes a new approximate solution to sequential decision making for graphical models. The approach applies heuristic procedures to approximate the optimization function at different stages of the algorithm. Pruning strategies are also proposed in order to speed up the computation by cutting the less valuable branches of the decision tree. The methodology is applied to case studies from the petroleum industry. First, a BN model for 25 prospects in the North Sea (Martinelli et al., 2011) is solved. Second, a MRF with 100 lattice cells for a local reservoir is studied. In both cases, we construct approximate drilling sequences. We show how sequential decision making, coupled with a statistical model for the dependence of the field, can yield strategies very different from those based on independent or myopic searches.

We recommend running a strategy of depth n, where n is as large as computationally feasible. In practice a petroleum company would often wait for the outcome of the first well(s) to continue its exploration strategy. It is also possible to run different depth searches and see if results are very dissimilar. In practice the petroleum company can test the depth n strategies over different utility functions, various kinds of risk behavior, and a range of cost and revenue inputs. This means only minor edits to inputs parameters in our implemented algorithms, and provides helpful guidelines when selecting the final exploration policy.

The applications do not limit the scope and the merit of the developed algorithms. One can use the methodology to other selection problems on graphical models. Nodes could for example correspond to clinical tests, in a problem where the practitioners make sequential decisions. Also, generic variable selection problems or design of experiments for graphs could be envisioned utilizing the same instruments. Some of these applications may focus on the harder optimization problem of static subset selection rather than sequential selection one at a time like we have done here.

We believe that there is large potential for interplay between operational research and recent development for computing multivariate statistical models. The current paper is just one example. Here, the search is built on heuristic strategies, and we have made no attempts to justify the approximation as the optimal solution. It would be interesting to study these problems from a more theoretical perspective, merging knowledge from both operations research, decision theory and statistics.

@&#ACKNOWLEDGMENTS@&#

We thank the Statistics for Innovation (SFI2) research center in Oslo, that partially financed GMs scholarship through the “FindOil” project. We acknowledge David Brown and Jim Smith, Duke University, for interesting and useful discussions on this topic. We thank the editor and three anonymous reviewers for their work on this paper.

@&#REFERENCES@&#

