@&#MAIN-TITLE@&#Investigation of the severity level of diabetic retinopathy using supervised classifier algorithms

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A method for investigating the severity of diabetic retinopathy is proposed.


                        
                        
                           
                           Earlier diagnosis of the disease prevents vision loss in diabetic patients.


                        
                        
                           
                           The exudates are the major symptoms and are detected via a segmentation algorithm.


                        
                        
                           
                           The degree of severity is assessed using the SVM and PNN classifier algorithms.


                        
                        
                           
                           The SVM classifier is found to provide better results than the PNN classifier.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Diabetic retinopathy

Exudates

Score computation

Neighbourhood component labelling

SVM classifier

Probabilistic neural network

@&#ABSTRACT@&#


               
               
                  Diabetic retinopathy is a condition that occurs in individuals with several years of diabetes mellitus and causes a characteristic group of lesions in the retina and progressively damages it. Detecting retinal fundus diseases in advance helps ophthalmologists to apply proper treatments that may cure the disease or decrease its severity and thus protect patients from vision loss. Diabetic retinopathy is usually diagnosed by ophthalmologists using dilated images that are captured by pouring a chemical solution into the patient’s eye, which causes inconvenience and irritation to the patient. In this paper, we propose a method to detect lesion exudates automatically with the aid of a non-dilated retinal fundus image to help ophthalmologists diagnose the disease. The exudates from the low contrast images are detected and localised using a neighbourhood based segmentation technique. A support vector machine (SVM) and probabilistic neural network (PNN) classifiers are proposed to assess the severity of the disease, and the results are compared with the same segmentation technique. The average classification accuracy for the SVM and PNN classifiers are determined to be 97.89% and 94.76%, respectively.
               
            

@&#INTRODUCTION@&#

Diabetic retinopathy (DR) is reported to be the most frequent cause of blindness worldwide in individuals aged 20–74years. The occurrence of retinopathy is strongly related to the duration of diabetes. During the first two decades of diabetes, nearly all patients with type 1 diabetes and over 60% of patients with type 2 diabetes have retinopathy [1]. Diabetic retinopathy starts with mild non-proliferative abnormalities, which are distinguished by improved vascular permeability, severe non-proliferative diabetic retinopathy (NPDR), and vascular closure, and ends with proliferative diabetic retinopathy (PDR), which is characterised by the growth of new blood vessels on the retina and the posterior surface of the vitreous. Approximately 21% of diabetes patients have retinopathy at the time of first diagnosis of diabetes, and the percentage increases with time [1].

Diabetic retinopathy occurs under conditions of high blood glucose or sugar over a long period of time. The major symptoms of this disease are microaneurysms (MAs), haemorrhages and exudates. Microaneurysms, the primary abnormalities occurring in the eye of the disease, are focal dilatations of the retinal capillaries, which are identified as tiny and dark red spots appearing either alone or in groups. Haemorrhages occur in the deeper layers of the retina, when blood leaks from the retinal vessels. These haemorrhages are often called ‘blot’ haemorrhages because of their round shape. Some of the diabetic retinopathy patient’s blood vessels may swell and leak fluid, while for other patients, abnormal new blood vessels grow on the surface of the retina. The signals sent by the retina for nourishment triggers the growth of new irregular and brittle blood vessels. These blood vessels develop along the retina and the surface of the clear and vitreous gel, which fills the inner recesses of the eye; however, they have thin and brittle walls. If these blood vessels leak blood or watery fluid, severe vision loss and even blindness can occur. The leakage of watery fluid from the fragile or abnormal blood vessels is called an exudate. These exudates are classified as hard and soft exudates. The preliminary stage of the exudates involves hard exudates, which have a yellowish colour, while the severe stage of the exudates involves soft exudates, which appear as cotton wool. Earlier detection of this disease helps ophthalmologists to provide the appropriate treatment and thus protects the patient from vision loss.

Diabetic retinopathy exhibits few visual or ophthalmic symptoms until the visual loss increases. Currently, laser photocoagulation is regarded as an effective treatment technique against diabetic retinopathy because laser photocoagulation hinders the progression of retinopathy, thereby controlling the loss of vision; however, it does not restore the lost vision. Moreover, the chemicals used for laser photocoagulation may cause blindness. To detect the diabetic retinopathy at an earlier stage, patients with diabetes should be evaluated using an automatic detection technique. The use of digital non-mydriatic images is the preferred automated technique towards the examination and detection of diabetic retinopathy.

The algorithm proposed in this paper improves the performance and the classification accuracy. The method consists of the following steps: preprocessing, ROI extraction, exudates detection, feature extraction and severity measurement by using SVM and PNN classifiers. Based on the preprocessing and ROI extraction, the exudates were detected. After the detection of exudates, the features of the exudate-detected images were determined and the severity level of the disease is measured by using both SVM and PNN classifiers.

Generally, the classifier consists of two types: supervised and unsupervised. The supervised classifier requires training data for each time testing to provide good results. The unsupervised classifier does not require training data each time testing is performed. Once the data are trained, the classification can be performed at any time; however, the result may or may not be good. The classification algorithm used for recognising the disease must provide accurate results because the proposed work deals with the health condition of a diabetic patient. To enable accurate classification, the supervised type of SVM and PNN classifiers are used. These classifiers are flexible regarding the choice of a similarity function and are also able to handle large feature spaces. Both of the classifiers considered have two working modes, viz. the training and testing modes. The severity of the disease is identified in the testing mode based on the features extracted for the particular image. Before the feature extraction, the features of all of the normal and abnormal images are trained. Finally, the performances of the classifiers are compared.

@&#LITERATURE REVIEW@&#

Tang et al. [2] detected haemorrhages during splat feature classification by extracting features, such as colour, spatial location, interactions with neighbouring splats, texture information and shape. Splat feature classification can be obtained by dividing the image into a number of splats. The wrapper approach was used to choose the best possible subset of splat features. Deepak and Sivaswamy [3] suggested the use of a motion pattern technique for the detection of macular edema. Two single-class classifiers, such as Gaussian and Principal Component Analysis Data Description classifiers were used to locate the lesions in the eye. The rigorousness was assessed by the Symmetry measure. Agurto et al. [4] developed instantaneous amplitude and frequency characteristics of a retinal image for lesion detection.

Lazar and Hajdu [5] identified retinal microaneurysms with the help of directional cross-section profiles, where each profile was analysed by extracting the features, such as size, height and shape. Naive Bayes classification was also used to eliminate false candidates by evaluating the statistical measures of those feature sets. Ram et al. [6] proposed two clutter rejection methods to discriminate the MAs from the non-MAs by using similarity computation. Goatman et al. [7] proposed a vessel detection approach on the optic disc (OD) based on watershed lines and ridge strength measurement and also used the SVM classifier to distinguish normal and abnormal vessels on the OD. Antal and Hajdu [8] proposed a method for detecting lesions formed due to diabetic retinopathy. The output of multiple classifiers was obtained after performing pre-processed methods and candidate extractors.

Giancardo et al. [9] used a new method to detect macula swelling by analysing multiple view retinal fundus images. The method had three stages, viz. a preprocessing technique, registering multiple retinal fundus views and dense pyramidal optical flow. The dense pyramidal optical flow was calculated to build a naive height map of the macula. Osare et al. [10] used computational intelligence and pattern recognition to analyse the diabetic retinal fundus image along with machine learning techniques.

Sopharak et al. [11] used the Fuzzy C-Means (FCM) clustering technique for detecting pixels of the exudates in the fundus image. Giancardo et al. [12] introduced a methodology for diagnosing macular edema by using a new set of features based on colour. Wavelet decomposition was mainly used for automatic lesion segmentation, which was used to automatically train a classifier to diagnose the disease.

Sopharak et al. [13] adopted the FCM clustering technique for the segmentation of exudates, in which morphological operators were used for the reconstruction of the original image. Ali et al. [14] proposed a novel statistical-atlas based method for the segmentation of exudates. The test fundus image was first warped onto the atlas co-ordinate to obtain a distance map that has a mean atlas image showing the candidate lesions. Post-processing techniques were introduced for the final segmentation of the exudates. A detailed survey of the algorithms and the results were obtained for the automated identification of diabetic retinopathy (DR) stages by using fundus photographs [15]. Quellec et al. [16] generated an optimal set of filters to distinguish the lesions. Priya et al. [17] proposed a method to diagnose DR, and the performances of SVM and PNN were analysed. The region of interest (ROI) was segmented using the FCM means algorithm. Six mathematical features were extracted for the classification of the disease. Ranamuka and Meegama [18] detected hard exudates via mathematical morphology and an adaptive fuzzy logic algorithm.

A system was used involving preprocessing to standardise colour and enhance contrast, segmentation to reveal possible lesions and their classification by an artificial neural network [19]. A sensitivity and specificity of 94.8% and 52.8%, respectively, were obtained, and no cases of sight-threatening retinopathy were missed. A new hybrid classifier [20] was proposed as an ensemble, composed of both the Gaussian Mixture Model (GMM) and m-Medoids based classifiers. Mookiah et al. [21] compared an automated screening system for the detection of normal and abnormal images using the decision tree, SVM and PNN classifiers. They achieved an accuracy of 88.46%, 77.56% and 96.15% for the decision tree, SVM and PNN classifiers, respectively. When compared to the above methods, the proposed work provides improved performance and classification accuracy with more images.

In this paper, Section 2 addresses the preprocessing and segmentation of the input image, the feature extraction, the severity level assessment of the disease DR and the performance analysis of the classifier algorithm. Section 3 discusses the results obtained, and Section 4 concludes the proposed work.

@&#METHODOLOGY@&#

In this proposed automated system, exudates are detected as follows: (i) preprocessing corrects the problem of illumination variation that occurred during image acquisition; (ii) ROI extraction results in the segmentation of the exudates from the preprocessed image; (iii) feature extraction captures the global characteristics of fundus images and discriminates the normal images from the images of the exudates; (iv) SVM and PNN classification assess the severity level of disease; and (v) comparison of the results between the SVM classifier and the PNN classifier and comparison of the results of the proposed method with the results of previously published works. The flow diagram of the proposed method is shown in Fig. 1
                     .

Non-mydriatic retinal cameras are used only in the medical field for retinal image acquisition. In this paper, the detection of exudates is performed using an automated screening system. The system requires non-mydriatic digital fundus photographs as the input. The MESSIDOR database has a collection of 1200 images, in which 800 images have a dilation and 400 images do not have a dilation. In those 400 non-dilated images, a dataset of 370 digital fundus images was selected in the age group of 25–65years. The evaluation of the SVM and PNN classifiers was performed on those sets of input images in which 150 images are used for training and 220 images are used for testing. The images in the dataset are acquired using a colour video 3D CCD camera on a Topcon TRC NW6 non-mydriatic retinograph with a 45 degree field of view. These images are used not only for the detection of exudates but also for the analysis of efficacy of the segmentation technique using the SVM and PNN classifiers.

A non-dilated low contrast retinal image is given as the input to the preprocessing stage. In the preprocessing step, some of the problems arising due to a blurred image or the non-clarity of images are rectified. This preprocessing encompasses three steps: (i) colour space conversion, (ii) filtering, and (iii) contrast enhancement.

Colour space conversion is the translation of the represented colour from one basis to another. The digital retinal fundus images of a patient were obtained from MESSIDOR database. The images are stored in the JPEG format (.jpg) with a size of 2240×1488 at 24 bits. For the translation, the HSV (Hue (H), Saturation (S), and Value (V)) colour space is used. The HSV colour space is generated by examining the RGB colour cube along the grey axis (the axis joining the black and white vertices), resulting in a hexagonally shaped colour palette. This colour system is based on cylindrical coordinates, thereby making conversion from RGB to HSV similar to mapping the RGB coordinate values to the cylindrical coordinates function. Hue values make a linear transition from high to low. The HSV colour space is best for image processing techniques, such as equalization, histograms and filtering. Because the exudates can be differentiated only by intensity, the intensity component alone is extracted from the HSV model.

For image processing, a high degree of noise reduction in an image must be performed before performing higher level processing steps. The median filter is a nonlinear filtering technique that is used to remove noise from images for improving the results of later processing. The median filter is particularly useful to reduce the speckle noise and the salt and pepper noise. The median filter is effective for suppressing isolated noise without blurring sharp edges because it is a simple edge-preserving smoothing filter. If the spatial noise distribution in the image is not symmetrical within the window, then the median filter changes the intensity mean value of the input image. The median filter applied to the HSV image results in an unacceptable variation. The median filter may be applied prior to segmentation to reduce the amount of noise in the images to calculate the median pixel values. The preferable size of the median filter is always 3×3.

Image enhancement is used for obtaining a good quality image by removing uneven illumination. Contrast enhancement is performed via the method of histogram equalization. Histograms are simple to calculate by using software and lend themselves to economic hardware implementations; as a result, histograms are a popular tool for real-time image processing. A histogram provides a convenient summary of the intensities in an image and provides more insight regarding the image contrast and brightness. Contrast limited adaptive histogram equalization (CLAHE) is a technique used to improve the local contrast of an image. The CLAHE algorithm separates an image into contextual regions and applies the histogram equalization to every region. The CLAHE algorithm provides a uniform distribution of used grey values and thus enables the hidden features of the image to become more visible. The original and enhanced images are shown in Fig. 2
                           .

After the completion of the preprocessing steps, the image is applied to the segmentation process, i.e., extraction of the ROI. Before segmenting the image, the unwanted portion of the image should be eliminated. Here, the OD and macula of an eye image have intensity values similar to those of the exudates; therefore, the ROI containing macula and OD can be eliminated.

OD detection is a primary step in the development of an automated screening system for diabetic retinopathy. In coloured fundus images, the OD appears as a bright yellowish or white region. Because the detection of exudates is the main purpose of the screening, the OD must be removed prior to the screening process because it appears with same intensity, contrast and colour as the other features in the retinal image. The OD is differentiated as the largest circular high contrast area. The blood vessels also appear with high contrast, but the sizes of these areas are much smaller than the area of the OD. Thus, the OD and macula are detected and masked.

Mask generation aims at labelling the pixels belonging to the region of interest in the entire image. The masking process can be performed by smudging the original image and subtracting the smudged image from the original image. Then, the mask is added to the original image. After this process, an OD-eliminated image can be obtained.

The process of classifying and placing sharp discontinuities in an image is called edge detection. The discontinuities are immediate changes in the pixel concentration that distinguish the boundaries of objects. The edge detection approach is a fundamental tool for image segmentation. Edge detection transforms the original images into edge images obtained from the changes of the grey tones in the image.

Kirsch edge detection is used to remove blood vessels by using threshold values. The Kirsch operator is a nonlinear edge detector that determines the maximum edge strength in a few pre-determined directions. The masks of this Kirsch technique are defined by considering a single mask and rotating it to the eight main compass directions: north, northwest, west, southwest, south, southeast, east and northeast. The Kirsch edge detection algorithm identifies the presence of an edge and the direction of the edge. The Kirsch edge detection algorithm uses a 3×3 table called the convolution table to store a pixel [i, j] and its neighbours while calculating its derivatives. The edge detection algorithm moves across the image in a convolution-style algorithm. The edge-detected image is shown in Fig. 3
                           .

Score computation is a method used for the detection of exudates that is performed by connected component labelling based on a neighbourhood approach. The aim of the neighbourhood connected component labelling analysis is to identify the large-sized bonded foreground region in an image. The relevant region is identified using the neighbourhood component labelling operation. The labelling can be performed by assigning a single label to each maximally connected foreground region of pixels. Once the region boundaries are detected, it is very useful to remove the regions that are not separated by a boundary. If any pixel set is not separated by a boundary, then it is referred to as cell connected. Each maximal region of the connected pixels is called a connected component. A set of connected components partitions an image into segments. Eight neighbour connected component analysis [22] is used for detecting exudate pixels by discarding all other pixels. The analysis connects the neighbour pixel to the centre pixel having the same intensity value by labelling them.

The connected components labelling operator scans the image by moving along a row until it comes to point p (where p denotes the pixel to be labelled at any stage in the scanning process), for which V
                           ={1}. When point p is reached, the operator examines the four neighbours of p, which have already been encountered in the scan (i.e., the neighbours (i) to the left of p, (ii) above p, (iii) one of the upper diagonal terms, and (iv) the other upper diagonal term). Based on this information, the labelling of p occurs as follows:
                              
                                 •
                                 If all four neighbours are 0, assign a new label to p, else.

If only one neighbour has V
                                    ={1}, assign its label to p, else.

If more than one of the neighbours have V
                                    ={1}, assign one of the labels to p and make a note of the equivalences.

After the completion of a scan, the equivalent label pairs are sorted into equivalence classes and a unique label is assigned to each class. As a final step, a second scan is performed through the image, during which each label is replaced by the label assigned to its equivalence classes.

Neighbour connected component labelling starts by determining the non-background neighbours. If any of the neighbouring pixels is not labelled yet,then the label countis increased and the pixel is set to the current pixel; also, it is set as the parent to itself. Next the algorithm moves to the next pixel that has a neighbour, which is already labelled, and assigns the pixel’s label to that of the neighbour. This process is repeated until all of the neighbouring pixels are labelled.The label count is increasedand assigned to the pixel and again located its parent in relation to itself. When neighbours have different labels, any one of the labels is selected and is set to the current pixel. Similarly, segmented results are obtained for moderately and severely affected images, as shown in Figs. 4 and 5
                           
                           , respectively.

Features are the observable patterns in the image that provide information about the image. The accuracy of the classification depends on the feature extraction stage. Texture features are able to isolate normal and abnormal lesions with masses and microcalcification. The input features required for the SVM classifier are extracted using the Grey Level Co-occurrence Matrix (GLCM). The matrix contains information about the positions of pixels having similar grey level values. The matrix can make use of the distance vector. The GLCM is represented as G[i, j], which is used to calculate all of the pairs of pixels separated by the distance vector having grey levels at i and j. Based on the analysed matrix and the texture information, the parameters, such as correlation, contrast, cluster prominence, cluster shade, energy, entropy, homogeneity and maximum probability, are obtained. The parameters can be obtained using the expressions listed below:
                           
                              (1)
                              
                                 Contrast
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       (
                                       i
                                       -
                                       j
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 Correlation
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       (
                                       i
                                       -
                                       μ
                                       )
                                       (
                                       j
                                       -
                                       μ
                                       )
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 Cluster
                                 
                                 prominence
                                 =
                                 sgn
                                 (
                                 B
                                 )
                                 |
                                 B
                                 
                                    
                                       |
                                    
                                    
                                       
                                          
                                             1
                                          
                                          
                                             4
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 Cluster
                                 
                                 shade
                                 =
                                 sgn
                                 (
                                 A
                                 )
                                 |
                                 A
                                 
                                    
                                       |
                                    
                                    
                                       
                                          
                                             1
                                          
                                          
                                             3
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 Energy
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             ij
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 Entropy
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 ln
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                                 )
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 Homogeneity
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             p
                                          
                                          
                                             ij
                                          
                                       
                                    
                                    
                                       1
                                       +
                                       
                                          
                                             (
                                             i
                                             -
                                             j
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 Maximum
                                 
                                 probability
                                 =
                                 max
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                                 )
                              
                           
                        where Pi
                        
                        ,
                        
                           j
                         is the probability of element
                        i, j
                        of the normalised symmetrical GLCM, N is the number of grey levels in the image, and μ is the GLCM mean (being an estimate of the intensity of all of the pixels in the relationships that contributed to the GLCM), estimated by using the Eq. (9)
                        
                           
                              (9)
                              
                                 μ
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       ip
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                     


                        σ
                        2
                        =Variance of the intensities of all of the reference pixels in the relationships that contributed to the GLCM, estimated as,
                           
                              (10)
                              
                                 
                                    
                                       σ
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       (
                                       i
                                       -
                                       μ
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 A
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             (
                                             i
                                             +
                                             j
                                             -
                                             2
                                             μ
                                             )
                                          
                                          
                                             3
                                          
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ij
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             3
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         2
                                                         (
                                                         1
                                                         +
                                                         c
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             3
                                          
                                       
                                    
                                 
                                 ;
                                 
                                 B
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ,
                                          j
                                          =
                                          0
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             (
                                             i
                                             +
                                             j
                                             -
                                             2
                                             μ
                                             )
                                          
                                          
                                             4
                                          
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ij
                                          
                                       
                                    
                                    
                                       4
                                       
                                          
                                             σ
                                          
                                          
                                             4
                                          
                                       
                                       
                                          
                                             (
                                             1
                                             +
                                             c
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 C
                                 =
                                 Correlation feature
                              
                           
                        
                        
                           
                              
                                 Sgn
                                 (
                                 X
                                 )
                                 =
                                 Sign of the real number
                              
                           
                        
                        
                           
                              
                                 X
                                 =
                                 -
                                 1
                                 
                                 for
                                 
                                 X
                                 <
                                 0
                              
                           
                        
                        
                           
                              
                                 X
                                 =
                                 0
                                 
                                 for
                                 
                                 X
                                 =
                                 0
                              
                           
                        
                        
                           
                              
                                 X
                                 =
                                 1
                                 
                                 for
                                 
                                 X
                                 >
                                 0
                              
                           
                        
                     


                        Table 1
                         presents the ranges of each feature for normal, NPDR and PDR images. The extracted features are applied to the SVM classifier to determine the severity of the disease. All of the features are combined and given to the classifier to reduce the redundancy, the uncertainty and the ambiguity so that the classifier can provide superior classification.

After the detection of exudates, the normal and abnormal images are separated by using the SVM classifier. SVM minimises the empirical risk and prevents the over-fitting problem; as a result, a good performance can be achieved. After segmenting the regions of the exudates in the colour retinal images, the segmented image is processed using the SVM classifier. This classifier is used to evaluate the training data to determine the best approach to classify images into different cases, such as moderate or severe. The classification is performed using MATLAB software, where the conditional programming method is used for classification

The SVM classifier consists of three layers: input, hidden and output. Fig. 6
                         
                        [23] shows the architecture of the SVM classifier.

To classify the disease, the relevant features of each and every normal and abnormal image should be extracted. Next, the extracted features of all of the normal and abnormal images are combined to form a matrix, which is saved as a matrix file. This matrix file is the input to the classifier, and then, the training mode is also saved as a matrix file because it is required for the classifier testing mode.

Subsequently, for testing an image, the relevant features of the test image are extracted and combined to form a matrix file. Before this matrix file is input into the SVM classifier, the matrix file of the training mode is loaded to determine the severity of the disease. The Radial Basis Kernel function is described in Eq. (11).
                           
                              (11)
                              
                                 
                                    
                                       K
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          f
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                 
                                 
                                    
                                       β
                                    
                                    
                                       f
                                    
                                 
                                 
                                    
                                       e
                                    
                                    
                                       
                                          
                                             -
                                             
                                                
                                                   γ
                                                
                                                
                                                   f
                                                
                                             
                                             
                                                
                                                   χ
                                                
                                                
                                                   f
                                                
                                                
                                                   2
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   f
                                                
                                             
                                             ,
                                             
                                                
                                                   y
                                                
                                                
                                                   f
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    χ
                                 
                                 
                                    2
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                              =
                              ∑
                              
                                 
                                    
                                       
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       
                                          2
                                       
                                    
                                 
                                 
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          y
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                         and γf is a Kernel parameter. SVM classifies the normal and abnormal images based on this Kernel function. Further, the abnormal images are classified as moderately affected or severely affected.

A feed forward neural network, called the probabilistic neural network (PNN) classifier, is derived from the Bayesian network, and a statistical algorithm called Kernel Fisher discriminant analysis is used. A probabilistic neural network is predominantly a classifier that maps any input pattern to a number of classifications. After detecting the exudates, the detected image is analysed using the PNN classifier to detect the severity level of diabetic retinopathy. In PNN, the operations are organised into a multilayered feed forward network with four layers, that is, the input, pattern, summation and output layers, which are shown in Fig. 7
                         
                        [24].

The algorithm of the PNN is given below:
                           
                              
                                 Step 1: Feed the input image features into input nodes.


                                 Step 2: Feed the trained image features in pattern nodes obtained from the Kernel given in Eq. (12)
                              


                        
                           
                              
                                 Step 3: Comparison of the input image features for each group of pattern nodes. From this comparison, the summation layer computes the conditional probabilities by using a combination of the previously computed densities.


                        
                           
                              
                                 Step 4: At each class output node, sum all of the images with similar features to those of the input.


                                 Step 5: Find maximum value of all of the added functional values at the output nodes using Eq. (14).

After completing five steps, the severity level (whether it is moderate or severe) of the diabetic retinopathy are found at the output layer.

Two performance measurement parameters of sensitivity and specificity are measured by using the formulae given in Eqs. (15) and (16).
                           
                              (15)
                              
                                 Sensitivity
                                 =
                                 TP
                                 /
                                 (
                                 TP
                                 +
                                 FN
                                 )
                              
                           
                        
                        
                           
                              (16)
                              
                                 Specificity
                                 =
                                 TN
                                 /
                                 (
                                 TN
                                 +
                                 FP
                                 )
                              
                           
                        
                     


                        
                           
                              •
                              True positive (TP)=Correctly identified.

False positive (FP)=Incorrectly identified.

True negative (TN)=Correctly rejected.

False negative (FN)=Incorrectly rejected.

Sensitivity refers to the ability of the classifier to identify positive results, and specificity refers to the ability of the classifier to identify negative results.

In this work, classification based on the extracted features is performed by using the SVM classifier. For training the classifier, 150 images (50 normal and 100 abnormal images) are used. For testing, a set of 220 images (65 normal and 155 abnormal images) are taken, and the proportion of the data used for testing to the data for training is 60/40. Next, the extracted features are used by the SVM for classifying the images into normal and abnormal images. Amongst the abnormal images, the SVM classifier can classify whether an image is moderately or severely affected. The same set of images is also tested using the PNN classifier to evaluate the classifier accuracy for the same segmentation technique.

@&#RESULTS AND DISCUSSION@&#

The SVM and PNN classifiers are trained and tested with normal and abnormal images. Based on the extracted features, the classifiers are used to classify the input images into normal or abnormal. The abnormality is also further classified as moderate and severe to assess the severity of the disease. The classification accuracy of the SVM classifier and that of the PNN classifier for all of the normal and abnormal images are calculated; the results are presented in Table 2
                     . The results indicate that the SVM classifiers are able to identify all of the normal classes; however, the PNN classifier misclassified one normal image as an abnormal image. In the case of abnormality, both classifiers are able to identify their class, with an average accuracy of more than 94%. The sensitivity and specificity for the SVM and PNN classifiers are measured; the performance analysis is presented in Table 3
                     . The resultant parameters, such as accuracy, sensitivity and specificity of classifiers, in our proposed work are compared with those of the previously published papers regarding the cases of DR of two classes as well as three classes [25]. The comparison is presented in Table 4
                     .

The comparison of the classifier accuracy between the SVM and PNN is shown in Fig. 8
                     . The detection of diabetic retinopathy is achieved with a sensitivity of more than 96% and with a specificity of more than 98% by both classifiers with the same segmentation method. Our proposed segmentation method provided the best result for both the classifiers compared to the other segmentation methods. This level of accuracy that was enabled by our proposed method can help ophthalmologists to diagnose the disease very easily. The segmentation technique used in this method is simpler and accurately detects the ROI. Because this proposed method uses non-dilated retinal input images, the patients do not suffer from eye irritation due to mydriasis. The present work can be improved in the future as follows: that the severity of the disease may be measured based on the accumulation of the exudates with respect to the distance from the fovea and the number of features used for classification may be increased.

@&#CONCLUSION@&#

A method was developed using the MATLAB 2012 and Microsoft Visual basic 6.0 platforms to detect exudates from non-mydriatic, low-contrast, retinal digital images of retinopathy patients. The proposed system is a very simple technique that enables ophthalmologists to detect the exudates in a very short time of inspection. Moreover, the proposed technique is inexpensive and does not require trained experts. The quality of the images provided and used in the hospital is very low, making it very difficult for ophthalmologists to perform visual manual grading. The image quality is first improved via the method of illumination equalization. This method is intended to help ophthalmologists performing the diabetic retinopathy screening process to detect symptoms more easily using low contrast images. The preprocessing steps of green channel extraction, median filtering and histogram equalization are applied on the non-dilated retinal fundus images. Further, a comparison of the SVM and PNN classification approaches on the images was performed. The features were extracted from GLCM and fed to both of the classifiers. The SVM and PNN classifiers were used to classify the test image, whether it is a normal or abnormal image. Further, these classifiers were also used to classify the abnormality, whether it is moderate or severe. Although the SVM and PNN classifiers and the GLCM feature extraction method are very familiar and have been already used by the other authors, the novelty of this proposed method is the segmentation of exudates using connected component labelling based on the neighbourhood approach. The segmentation of the exudates will be useful for ophthalmologists to diagnose diabetic retinopathy with high accuracy and to apply the proper treatment to the patients. In summary, the proposed method is a preliminary diagnosis tool or decision support system for use by ophthalmologists that does not affect the vision of the patients, and the high accuracy of the proposed method demonstrates the degree to which the use of image processing can replace the tedious and strenuous work of image interpretation at various hospitals.

@&#REFERENCES@&#

