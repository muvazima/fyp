@&#MAIN-TITLE@&#Binary trees as a computational framework

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We present a new set of algorithms for performing arithmetic computations using binary trees.


                        
                        
                           
                           Our arithmetic algorithms have average time and space complexity comparable to traditional operations on bitstrings.


                        
                        
                           
                           Our results are implemented using Haskell instances isomorphic to natural numbers.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Arithmetic computations with binary trees

Gödel System T types

Modeling computational abstractions with functional programming

Computations with balanced parenthesis languages

@&#ABSTRACT@&#


               
               
                  We present a new set of algorithms for performing arithmetic computations on the set of natural numbers, represented as ordered rooted binary trees. We show formally that these algorithms are correct and discuss their time and space complexity in comparison to traditional arithmetic operations on bitstrings.
                  Our binary tree algorithms follow the structure of a simple type language, similar to that of Gödel's System T.
                  Generic implementations using Haskell's type class mechanism are shared between instances shown to be isomorphic to the set of natural numbers. This representation independence is illustrated by instantiating our computational framework to the language of balanced parenthesis languages.
                  The self-contained source code of the paper is available at http://logic.cse.unt.edu/tarau/research/2012/jtypes.hs.
               
            

In this paper
                        1
                     
                     
                        1
                        This paper is an extended and improved version of [1].
                      we focus on computing with binary trees, seen as a minimalist type language
                        
                           (1)
                           
                              τ
                              =
                              τ
                              →
                              τ
                              |
                              e
                           
                        
                     where e represents an empty leaf node.

Choosing the simplest possible type language as a foundation for data and code representations is partly motivated by the use of type theory as a constructive alternative to conventional predicate calculus based axiomatizations. This has resulted in powerful proof assistants like Coq [2], based entirely on constructive formalizations of type theory [3]. For instance, one can use the isomorphism between types and natural numbers that provides a total ordering on types, as a generic means to provide termination proofs for type inference algorithms and type-based proof systems.

Our main result deals with the set of natural numbers, on which we establish an isomorphism to our binary tree type using a bijection based on a pairing function (Section 2). Given this new representation, we provide algorithms for the successor and predecessor functions (Section 4), including a formal proof of their correctness and a general strategy for proving that the other arithmetic operations built upon them are also sound. Then, using these functions we describe a simple but inefficient specification of arithmetic operations using Gödel's recursor (Section 5). We immediately follow this with a larger, more efficient set of arithmetic operations on binary trees (Section 6). We offer a detailed discussion on the time and space complexity of the algorithms, including a proof that the successor and predecessor functions (used as building blocks for the other operations) have constant average running time. As well, we define a total ordering relation on the binary tree type, isomorphic with that of natural numbers (Section 8). We also show that arithmetic operations can be performed on succinctly represented members of the Catalan family, such as parenthesis languages (Section 9).

Finally, we provide a brief survey of related work (Section 10), comments on further work and practical applications (Section 11) as well as our conclusions (Section 12).

In this paper we will use a subset of the non-strict functional language Haskell to provide executable specifications of mathematical functions and data types.

We mention, for the benefit of the reader unfamiliar with the language, that a notation like f x y stands for 
                        f
                        (
                        x
                        ,
                        y
                        )
                     , [t] represents sequences of type t and a type declaration like f ::
                     
                     s -> t -> u stands for a function 
                        f
                        :
                        s
                        ×
                        t
                        →
                        u
                      (modulo Haskell's “currying” operation, given the isomorphism between the function spaces 
                        s
                        ×
                        t
                        →
                        u
                      and 
                        s
                        →
                        t
                        →
                        u
                     ). Our Haskell functions are always represented as sets of recursive equations guided by pattern matching, conditional to constraints (boolean relations following 
                        |
                      and before the = symbol). Locally scoped helper functions are defined in Haskell after the where keyword, using the same equational style. The composition of functions f and g is denoted f .
                     
                     g. It is also customary in Haskell to write f=g instead of f x=g x (“point-free” notation). The use of Haskell's “call-by-need” evaluation also allows us to work with infinite sequences, like the 
                        [
                        
                           0
                        
                        ‥
                        ]
                      list notation, corresponding to the set of natural numbers 
                        N
                     .

In this paper we use Haskell's type class mechanism to provide implementations of primitive operations that can be refined by instances that override these operations with potentially more efficient equivalents.

The class PureTypes assumes only the Read/Show superclasses needed for input/output. An instance of this class is required to implement the following primitive operations:
                        
                           
                              
                                 class
                                 
                                 (Read
                                 
                                 n,
                                 
                                 Show
                                 
                                 n)=>PureTypes
                                 
                                 n
                                 
                                 where
                              
                              
                              
                                 empty
                                 
                                 :: n
                              
                              
                              
                                 isEmpty
                                 
                                 :: n −>Bool
                              
                              
                              
                                 arrow
                                 
                                 :: n−>n−>n
                              
                              
                              
                                 from,
                                 
                                 to
                                 
                                 :: n−>n
                              
                           
                        
                     The PureTypes type class also provides to its instances generic implementations of the following derived operations:
                        
                           
                              
                                 isArrow
                                 
                                 :: n−>Bool
                              
                              
                                 isArrow=not
                                 
                                 .
                                 
                                 isEmpty
                              
                              
                                 eq :: n −>n−>Bool
                              
                              
                                 eq
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEmpty
                                 
                                 y=True
                              
                              
                                 eq
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x
                              
                              
                              |
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 y=False
                              
                              
                                 eq
                                 
                                 x
                                 
                                 y=eq
                                 
                                 (from
                                 
                                 x)
                                 
                                 (from
                                 
                                 y)
                              
                              
                              &
                              &
                              
                              
                                 eq
                                 
                                 (to
                                 
                                 x)
                                 
                                 (to
                                 
                                 y)
                              
                           
                        
                     
                  

While one could also have derived equality from the Haskell Eq class, we have defined it here to clarify our assumptions. The following properties allow testing the properties connecting these operations:
                        
                           
                              
                                 pure_type_prop1
                                 
                                 ::
                                 
                                 (PureTypes
                                 
                                 n)=>n −>Bool
                              
                              
                                 pure_type_prop2
                                 
                                 ::
                                 
                                 (PureTypes
                                 
                                 n)=>n −>n −>Bool
                              
                              
                                 pure_type_prop1
                                 
                                 z=isEmpty
                                 
                                 z
                              
                              
                              |
                              
                              |
                              
                              
                                 eq
                                 
                                 z
                                 
                                 (arrow
                                 
                                 (from
                                 
                                 z)
                                 
                                 (to
                                 
                                 z))
                              
                              
                                 pure_type_prop2
                                 
                                 x
                                 
                                 y=eq
                                 
                                 x
                                 
                                 (from
                                 
                                 z)
                              
                              
                              &
                              &
                              
                              
                                 eq
                                 
                                 y
                                 
                                 (to
                                 
                                 z)
                              
                              
                              
                                 where
                                 
                                 z=arrow
                                 
                                 x
                                 
                                 y
                              
                           
                        
                     
                  

It is convenient at this point, as we target multiple Haskell instances, to provide a polymorphic converter between two different instances of the type class PureTypes. The function view will allow converting between two different PureTypes instances, generically
                        
                           
                              
                                 view :: (PureTypes
                                 
                                 a,PureTypes
                                 
                                 b)=>a−>b
                              
                              
                                 view
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x=empty
                              
                              
                                 view
                                 
                                 x=arrow
                                 
                                 (view
                                 
                                 (from
                                 
                                 x))
                                 
                                 (view
                                 
                                 (to
                                 
                                 x))
                              
                           
                        
                     
                  

We can build an instance of the type class PureTypes as a rooted ordered binary tree type, implemented by the type data T. We can see these binary trees as a representation of System T types with an empty base type or simply as the free magma of rooted ordered binary trees with one generator, representing empty leaves
                        
                           
                              
                                 infixr
                                 
                                 5 :−>
                              
                                 data
                                 
                                 T=E
                              
                              |
                              
                                 T :−>T
                                 
                                 deriving
                                 
                                 (Read,
                                 
                                 Show)
                              
                              
                                 instance
                                 
                                 PureTypes
                                 
                                 T
                                 
                                 where
                              
                              
                              
                                 empty=E
                              
                              
                              
                                 isEmpty
                                 
                                 E=True
                              
                              
                              
                                 isEmpty
                                 _=False
                              
                              
                              
                                 arrow=(:−>)
                              
                              
                              
                                 from
                                 
                                 E=undefined
                              
                              
                              
                                 from
                                 
                                 (x :−>_)=x
                              
                              
                              
                                 to
                                 
                                 E=undefined
                              
                              
                              
                                 to
                                 
                                 (_ :−>y)=y
                              
                           
                        
                     We can now specialize the generic instance transformer “view” simply by specifying its target type as T
                     
                        
                           
                              
                                 t :: (PureTypes
                                 
                                 a)=>a−>T
                              
                              
                                 t=view
                              
                           
                        
                     
                  

Through a possible Haskell language extension one could think about using arrow and empty as patterns when occurring on the left side of a definition and as data constructors when occurring on the right side of a definition in a way similar to the handling of data constructors :-> and E.

We will next define another instance where arrow, from and to are implemented as computations on natural numbers.

After adding the type synonym 
                        
                           
                              
                                 type
                                 
                                 N=Integer
                              
                           
                        
                     we observe that standard arithmetic provides an alternative instance described in terms of the constructors and destructors of the type class PureTypes
                     
                        
                           
                              
                                 instance
                                 
                                 PureTypes
                                 
                                 N
                                 
                                 where
                              
                              
                              
                                 empty=0
                              
                              
                              
                                 isEmpty
                                 
                                 0=True
                              
                              
                              
                                 isEmpty
                                 _=False
                              
                              
                              
                                 arrow
                                 
                                 x
                                 
                                 y=(2
                              
                              
                                 
                                    
                                 
                                 
                                    ^
                                 
                              
                              
                                 x)*(2*y+1)
                              
                              
                              
                                 from
                                 
                                 x
                              
                              
                              |
                              
                              
                                 x>0
                              
                              
                              
                              
                                 =if
                                 
                                 odd
                                 
                                 x
                                 
                                 then
                                 
                                 0
                                 
                                 else
                                 
                                 1+(from
                                 
                                 (x
                              
                              
                              ‘
                              
                                 div
                              
                              ‘
                              
                              
                                 2))
                              
                              
                              
                                 from
                                 _=undefined
                              
                              
                              
                                 to
                                 
                                 x
                              
                              
                              |
                              
                              
                                 x>0
                              
                              
                              
                              
                                 =if
                                 
                                 odd
                                 
                                 x
                                 
                                 then
                                 
                                 (x−1)
                              
                              
                              ‘
                              
                                 div
                              
                              ‘
                              
                              
                                 2
                                 
                                 else
                                 
                                 to
                                 
                                 (x
                              
                              
                              ‘
                              
                                 div
                              
                              ‘
                              
                              
                                 2)
                              
                              
                              
                                 to
                                 _=undefined
                              
                           
                        
                     By specializing the generic instance transformer view to target type N we obtain
                        
                           
                              
                                 n :: (PureTypes
                                 
                                 a)=>a−>N
                              
                              
                                 n=view
                              
                           
                        
                     
                  

The following examples illustrate the use of n and t as transformers between the data types N and T
                     
                        
                           
                              
                                 *SystemT>t
                                 
                                 42
                              
                              
                                 (E :−>E) :−>((E :−>E) :−>((E :−>E) :−>E))
                              
                              
                                 *SystemT>n
                                 
                                 it
                              
                              
                                 42
                              
                              
                                 *SystemT>t
                                 
                                 2012
                              
                              
                                 ((E :−>E) :−>E) :−>(E :−>(E :−>
                              
                              
                                 ((E :−>E) :−>(E :−>(E :−>(E :−>(E :−>E)))))))
                              
                              
                                 *SystemT>n
                                 
                                 it
                              
                              
                                 2012
                              
                           
                        
                     
                  

Perhaps the most interesting item to note from our definition of the instance 
                        
                           N
                        
                      is the 
                        
                           arrow
                        
                      constructor. The corresponding operation on Tsimply creates a single tree from two trees and likewise we need a way to construct a single number from two. Pairing functions come to mind, and in fact the bijection we have defined is based on the pairing function
                        
                           (2)
                           
                              f
                              (
                              x
                              ,
                              y
                              )
                              =
                              
                                 
                                    2
                                 
                                 
                                    x
                                 
                              
                              (
                              2
                              y
                              +
                              1
                              )
                              −
                              1
                              .
                           
                        
                     
                     Fig. 1
                      shows the natural number eight as a binary tree constructed in this fashion. Note that our modification to the pairing function means that we do not map zero and instead deal with it programmatically; this has the advantage of ensuring that the successor and predecessor functions that we define in the following section are inverses.

We may now use this interpretation to proceed with building an implementation of Peano arithmetic; first however, we offer an explicit proof that the data types T and N are isomorphic.

The definition of PureTypes given in the previous section does not, by itself, guarantee its instances are isomorphic; instead it offers a convenient mechanism under which to define such instances while avoiding repetitive complex logic. In the following proofs we show that T and N are indeed isomorphic, under the transformation provided by view. We now switch to a mathematical notation, using subscripts to indicate the instance to which a particular operation belongs.

The definitions of n and t, given by view, are
                        
                           (3)
                           
                              t
                              (
                              z
                              )
                              =
                              
                                 
                                    arrow
                                 
                                 
                                    T
                                 
                              
                              (
                              t
                              (
                              
                                 
                                    from
                                 
                                 
                                    N
                                 
                              
                              (
                              z
                              )
                              )
                              ,
                              t
                              (
                              
                                 
                                    to
                                 
                                 
                                    N
                                 
                              
                              (
                              z
                              )
                              )
                              )
                           
                        
                     
                     
                        
                           (4)
                           
                              n
                              (
                              v
                              )
                              =
                              
                                 
                                    arrow
                                 
                                 
                                    N
                                 
                              
                              (
                              n
                              (
                              
                                 
                                    from
                                 
                                 
                                    T
                                 
                              
                              (
                              v
                              )
                              )
                              ,
                              n
                              (
                              
                                 
                                    to
                                 
                                 
                                    T
                                 
                              
                              (
                              v
                              )
                              )
                              )
                              .
                           
                        
                     Note that arrow and from/to exhibit an inverse relationship by definition: they may also be thought of as constructors and destructors. More specifically (omitting the type subscripts as the equations are the same)
                        
                           (5)
                           
                              arrow
                              (
                              from
                              (
                              x
                              )
                              ,
                              to
                              (
                              x
                              )
                              )
                              =
                              x
                           
                        
                     
                     
                        
                           (6)
                           
                              from
                              (
                              arrow
                              (
                              x
                              ,
                              y
                              )
                              )
                              =
                              x
                           
                        
                     
                     
                        
                           (7)
                           
                              to
                              (
                              arrow
                              (
                              x
                              ,
                              y
                              )
                              )
                              =
                              y
                              .
                           
                        
                     An examination of the code for T reveals that these equations are true trivially; for N we rely on the bijective
                        2
                     
                     
                        2
                        
                           
                              
                                 
                                    arrow
                                 
                                 
                                    N
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                              =
                              
                                 
                                    2
                                 
                                 
                                    x
                                 
                              
                              (
                              2
                              y
                              +
                              1
                              )
                            is bijective between 
                              N
                              ×
                              N
                            and 
                              N
                              −
                              {
                              0
                              }
                            as a result of the fundamental theorem of arithmetic; all of the twos dividing a number are factored out, leaving the odd part.
                      property of the pairing function given in (2). Finally note that in the following proofs, as in Eqs. (3) and (4), x, y, z, and 0 are of type N; v and E are of type T. 
                        Proposition 1
                        
                           n 
                           and 
                           t 
                           define homomorphisms between types 
                           N 
                           and 
                           T.

Proving this requires showing that all operations of PureTypes are preserved under n and t. Given that empty indicates the identity element and that isEmpty is trivial, we show that arrow, from, and to are unchanged by simply applying the previous definitions (only t is shown here, a nearly identical argument applies to n).
                              
                                 
                                    t
                                    (
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    )
                                    )
                                    ,
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    3
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    x
                                    )
                                    ,
                                    t
                                    (
                                    y
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    6
                                    )
                                    
                                    and
                                    
                                    (
                                    7
                                    )
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    z
                                    )
                                    )
                                    =
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    ,
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    3
                                    )
                                    =
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    6
                                    )
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    z
                                    )
                                    )
                                    =
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    ,
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    3
                                    )
                                    =
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    7
                                    )
                                    
                                    □
                                 
                              
                           
                        


                           n 
                           and 
                           t 
                           are inverses.

Here as in other proofs to follow, we use structural induction, where after showing the property holds for our “base” elements, we assume the property holds for the recursive substructures (from and to). The base cases for inversion are
                              
                                 
                                    n
                                    (
                                    t
                                    (
                                    0
                                    )
                                    )
                                    =
                                    n
                                    (
                                    E
                                    )
                                    =
                                    0
                                    t
                                    (
                                    n
                                    (
                                    E
                                    )
                                    )
                                    =
                                    t
                                    (
                                    0
                                    )
                                    =
                                    E
                                    ,
                                 
                              
                           and the induction hypotheses are
                              
                                 (8)
                                 
                                    ∀
                                    z
                                    ′
                                    
                                       
                                          <
                                       
                                       
                                          N
                                       
                                    
                                    z
                                    ,
                                    
                                    n
                                    (
                                    t
                                    (
                                    z
                                    ′
                                    )
                                    )
                                    =
                                    z
                                    ′
                                 
                              
                           
                           
                              
                                 (9)
                                 
                                    ∀
                                    v
                                    ′
                                    
                                       
                                          <
                                       
                                       
                                          T
                                       
                                    
                                    v
                                    ,
                                    
                                    t
                                    (
                                    n
                                    (
                                    v
                                    ′
                                    )
                                    )
                                    =
                                    v
                                    ′
                                    .
                                 
                              
                           Note the subscripts on the 
                              <
                            relation: for N, this is the normal ordering on natural numbers, and for T it should be read “is a subtree of”. Because from
                           
                              N
                           (z) and to
                           
                              N
                           (z) are both less than z, and from
                           
                              T
                           (v) and to
                           
                              T
                           (v) are subtrees of v, (8) and (9) imply the following statements:
                              
                                 (10)
                                 
                                    n
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    =
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                 
                              
                           
                           
                              
                                 (11)
                                 
                                    n
                                    (
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    =
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                 
                              
                           
                           
                              
                                 (12)
                                 
                                    t
                                    (
                                    n
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    )
                                    )
                                    =
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                 
                              
                           
                           
                              
                                 (13)
                                 
                                    t
                                    (
                                    n
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    )
                                    )
                                    =
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    .
                                 
                              
                           These, combined with Proposition 1, allow us to show
                              
                                 
                                    n
                                    (
                                    t
                                    (
                                    z
                                    )
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    n
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    z
                                    )
                                    )
                                    )
                                    ,
                                    n
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    z
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    4
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    n
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    ,
                                    n
                                    (
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    homomorphism
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    ,
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    z
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    10
                                    )
                                    
                                    and
                                    
                                    (
                                    11
                                    )
                                    =
                                    z
                                    
                                    by
                                    
                                    (
                                    5
                                    )
                                 
                              
                           
                           
                              
                                 
                                    t
                                    (
                                    n
                                    (
                                    v
                                    )
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    n
                                    (
                                    v
                                    )
                                    )
                                    )
                                    ,
                                    t
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          N
                                       
                                    
                                    (
                                    n
                                    (
                                    v
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    3
                                    )
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    t
                                    (
                                    n
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    )
                                    )
                                    ,
                                    t
                                    (
                                    n
                                    (
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    )
                                    )
                                    )
                                    
                                    by
                                    
                                    homomorphism
                                    =
                                    
                                       
                                          arrow
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    
                                       
                                          from
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    ,
                                    
                                       
                                          to
                                       
                                       
                                          T
                                       
                                    
                                    (
                                    v
                                    )
                                    )
                                    
                                    by
                                    
                                    (
                                    12
                                    )
                                    
                                    and
                                    
                                    (
                                    13
                                    )
                                    =
                                    v
                                    
                                    by
                                    
                                    (
                                    5
                                    )
                                    .
                                    
                                    □
                                 
                              
                           
                        

Consequently, code expressed exclusively in terms of arrow, from, to, empty, and isEmpty in our type classes can be safely shared between instances N and T.

As the first step of an implementation of Peano arithmetic we define the successor and predecessor functions s and p in a class extending PureTypes, and formally prove they are correct
                        
                           
                              
                                 class
                                 
                                 PureTypes
                                 
                                 n=>PeanoArith
                                 
                                 n
                                 
                                 where
                              
                              
                              
                                 s,p :: n−>n
                              
                              
                                 s
                                 
                                 z
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 z=arrow
                                 
                                 empty
                                 
                                 empty
                              
                              
                                 s
                                 
                                 z
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 (from
                                 
                                 z)=arrow
                                 
                                 (s
                                 
                                 (from
                                 
                                 st)
                                 
                                 (to
                                 
                                 st)
                                 
                                 where
                              
                              
                              
                                 st=s
                                 
                                 (to
                                 
                                 z)
                              
                              
                                 s
                                 
                                 z=arrow
                                 
                                 empty
                                 
                                 (arrow
                                 
                                 (p
                                 
                                 (from
                                 
                                 z))
                                 
                                 (to
                                 
                                 z))
                              
                              
                                 p
                                 
                                 z
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 (from
                                 
                                 z)
                              
                              
                              &
                              &
                              
                              
                                 isEmpty
                                 
                                 (to
                                 
                                 z)=empty
                              
                              
                                 p
                                 
                                 z
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 (from
                                 
                                 z)=arrow
                                 
                                 (s
                                 
                                 (from
                                 
                                 (to
                                 
                                 z)))
                              
                              
                              
                              
                              
                                 (to
                                 
                                 (to
                                 
                                 z))
                              
                              
                                 p
                                 
                                 z=arrow
                                 
                                 empty
                                 
                                 (p
                                 
                                 (arrow
                                 
                                 (p
                                 
                                 (from
                                 
                                 z))
                                 
                                 (to
                                 
                                 z)))
                              
                           
                        
                     
                     
                        Proposition 3
                        
                           For any 
                           x 
                           of type 
                           N, s x=x + 1 and 
                           p x= 
                           x −1, where the latter holds provided 
                           
                              x
                              >
                              0
                           .

If we carefully describe the computations on instance N using mathematical notation, we can easily prove that the operations are correct. As s and p are mutually recursive, we conduct our proof using simultaneous structural induction. For convenience we first introduce several new notations for our operations on the type N. First we denote the arrow operation on N as 
                              
                                 
                                    〈
                                    x
                                    ,
                                    y
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          x
                                       
                                    
                                    (
                                    2
                                    y
                                    +
                                    1
                                    )
                                    ,
                                 
                              
                           calling 
                              〈
                              x
                              ,
                              y
                              〉
                            the pairing of x and y. From this pairing we define the from and to operations as projection functions respectively
                              
                                 
                                    
                                       
                                          π
                                       
                                       
                                          x
                                       
                                    
                                    =
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    z
                                    )
                                    
                                       
                                          π
                                       
                                       
                                          y
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                z
                                                )
                                             
                                          
                                          z
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                    .
                                 
                              
                           The notation 
                              
                                 
                                    ν
                                 
                                 
                                    p
                                 
                              
                              (
                              z
                              )
                            is called the (additive) p-adic valuation or the p-adic order of z, and is used here as a succinct way to write “the highest power of 2 that divides z” [6].


                           Basis: Given an empty instance which is zero by definition, the function s “pairs” two empty instances: 
                              
                                 
                                    〈
                                    0
                                    ,
                                    0
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          0
                                       
                                    
                                    [
                                    2
                                    (
                                    0
                                    )
                                    +
                                    1
                                    ]
                                    =
                                    1
                                    .
                                 
                              
                           Similarly, p acts on the inverse – given that both from and to are empty, the empty instance (zero) is returned – so our base case holds on both s and p.


                           Case
                           1 (Induction). (from z) is empty. In this instance, z is an odd number because for any y used in the pairing to construct z we have 
                              
                                 
                                    〈
                                    0
                                    ,
                                    y
                                    〉
                                    =
                                    (
                                    2
                                    y
                                    +
                                    1
                                    )
                                 
                              
                           which is the definition of an odd number. Now, to show that s and p act as expected, we write them using our new notation which is easily manipulated algebraically.

Starting with s, we note that (s (to z)) is used in both arguments to the arrow operation, so we assign its value to an intermediate variable m 
                           
                              
                                 
                                    m
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                z
                                                )
                                             
                                          
                                          z
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                    +
                                    1
                                    .
                                 
                              
                           If we then let l and r be the first and second arguments of the arrow operation respectively, they may be written in terms of m:
                              
                                 
                                    l
                                    =
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    m
                                    )
                                    +
                                    1
                                    r
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                m
                                                )
                                             
                                          
                                          m
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                    .
                                 
                              
                           Now, we simply perform the pairing (the application of arrow) and back substitute for m
                           
                              
                                 
                                    〈
                                    l
                                    ,
                                    r
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    2
                                    r
                                    +
                                    1
                                    )
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          )
                                          +
                                          1
                                       
                                    
                                    [
                                    
                                       2
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            ν
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      (
                                                      m
                                                      )
                                                   
                                                
                                                m
                                                -
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       1
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          )
                                          +
                                          1
                                       
                                    
                                    [
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          )
                                       
                                    
                                    m
                                    ]
                                    =
                                    2
                                    m
                                    =
                                    2
                                    [
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                
                                                
                                                   -
                                                   
                                                      
                                                         ν
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   z
                                                   )
                                                
                                             
                                             z
                                             -
                                             1
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       1
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                       
                                    
                                    z
                                    +
                                    1
                                 
                              
                           Finally, recall that we have established z as an odd number, meaning there is no power of 2 that divides it. With 
                              
                                 
                                    ν
                                 
                                 
                                    2
                                 
                              
                              (
                              z
                              )
                              =
                              0
                           , the equation reduces to 
                              z
                              +
                              1
                           .

We handle p in the same fashion, letting the m be the value of (to x) and l and r the first and second arguments of arrow
                           
                              
                                 
                                    m
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                z
                                                )
                                             
                                          
                                          z
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                    l
                                    =
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    m
                                    )
                                    +
                                    1
                                    r
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                m
                                                )
                                             
                                          
                                          m
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           Perform the pairing
                              
                                 
                                    
                                       
                                          2
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    2
                                    r
                                    +
                                    1
                                    )
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          )
                                          +
                                          1
                                       
                                    
                                    [
                                    
                                       2
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            ν
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      (
                                                      m
                                                      )
                                                   
                                                
                                                m
                                                -
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       1
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          +
                                          1
                                          )
                                       
                                    
                                    [
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          m
                                          )
                                       
                                    
                                    m
                                    ]
                                    =
                                    2
                                    m
                                    =
                                    2
                                    [
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                
                                                
                                                   -
                                                   
                                                      
                                                         ν
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   z
                                                   )
                                                
                                             
                                             z
                                             -
                                             1
                                          
                                          
                                             2
                                          
                                       
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                       
                                    
                                    z
                                    −
                                    1
                                    ,
                                 
                              
                           which reduces to 
                              z
                              −
                              1
                           .


                           Case
                           2 (Induction). (from z) is not empty. Here, we recall that a number n is even if there exists another number k such that 
                              n
                              =
                              2
                              k
                           . Again, if we consider the pairing 
                              〈
                              x
                              ,
                              y
                              〉
                            used to construct z and the fact that 
                              x
                              >
                              0
                            (otherwise it would be covered by the previous case), we see that z is indeed a factor of 2.

For s we again assign the arguments of the inner arrow operation to l and r respectively and let m be their pairing
                              
                                 
                                    l
                                    =
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    z
                                    )
                                    −
                                    1
                                    r
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                z
                                                )
                                             
                                          
                                          z
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    m
                                    =
                                    〈
                                    l
                                    ,
                                    r
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    2
                                    r
                                    +
                                    1
                                    )
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                          −
                                          1
                                       
                                    
                                    [
                                    
                                       2
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            ν
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      (
                                                      z
                                                      )
                                                   
                                                
                                                z
                                                -
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       1
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                          −
                                          1
                                       
                                    
                                    [
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                       
                                    
                                    z
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    z
                                 
                              
                           Perform the pairing for the outer arrow operation:
                              
                                 
                                    〈
                                    0
                                    ,
                                    m
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          0
                                       
                                    
                                    [
                                    2
                                    (
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    z
                                    )
                                    +
                                    1
                                    ]
                                    =
                                    z
                                    +
                                    1
                                    .
                                 
                              
                           Conveniently, 
                              
                                 
                                    ν
                                 
                                 
                                    2
                                 
                              
                              (
                              z
                              )
                            in the exponent cancels out.

The final case for p is handled in the same way
                              
                                 
                                    l
                                    =
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    z
                                    )
                                    −
                                    1
                                    r
                                    =
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                -
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                z
                                                )
                                             
                                          
                                          z
                                          -
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    m
                                    =
                                    〈
                                    l
                                    ,
                                    r
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          l
                                       
                                    
                                    (
                                    2
                                    r
                                    +
                                    1
                                    )
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                          −
                                          1
                                       
                                    
                                    [
                                    
                                       2
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      -
                                                      
                                                         
                                                            ν
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      (
                                                      z
                                                      )
                                                   
                                                
                                                z
                                                -
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       1
                                    
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                          −
                                          1
                                       
                                    
                                    [
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          z
                                          )
                                       
                                    
                                    z
                                    ]
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    z
                                 
                              
                           
                           
                              
                                 
                                    〈
                                    0
                                    ,
                                    m
                                    〉
                                    =
                                    
                                       
                                          2
                                       
                                       
                                          0
                                       
                                    
                                    [
                                    2
                                    (
                                    
                                       
                                          2
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    z
                                    −
                                    1
                                    )
                                    +
                                    1
                                    ]
                                    =
                                    z
                                    −
                                    1
                                    .
                                    
                                    □
                                 
                              
                           
                        

The strategy employed here to show that s and p are correct is easily applied to the other arithmetic operations we have defined in the following section. One simply expands out the definition in terms of the base PureTypes operations arrow, from, and to, and then plugs in the mathematical notation given by instance N. Note also that because the operations s and p are defined entirely in those terms, the isomorphism between N and T holds here as well.

Now, recall that for the Peano axioms to be satisfied on a triple 
                        (
                        N
                        ,
                        
                           
                              n
                           
                           
                              0
                           
                        
                        ,
                        f
                        )
                      where N is a non-empty set, 
                        
                           
                              n
                           
                           
                              0
                           
                        
                        ∈
                        N
                     , and 
                        f
                        :
                        N
                        →
                        N
                     , the following three properties must hold [7]:
                        
                           1.
                           If 
                                 x
                                 ∈
                                 N
                               then 
                                 f
                                 (
                                 x
                                 )
                                 ≠
                                 
                                    
                                       n
                                    
                                    
                                       0
                                    
                                 
                              .

If 
                                 x
                                 ,
                                 y
                                 ∈
                                 N
                               and 
                                 f
                                 (
                                 x
                                 )
                                 =
                                 f
                                 (
                                 y
                                 )
                               then x=y.

If 
                                 M
                                 ⊆
                                 N
                               such that 
                                 
                                    
                                       n
                                    
                                    
                                       0
                                    
                                 
                                 ∈
                                 M
                               and 
                                 x
                                 ∈
                                 M
                                 ⇒
                                 f
                                 (
                                 x
                                 )
                                 ∈
                                 M
                              , then M=N.

We will also state the induction principle on the initial algebra [8] of binary trees of type T. 
                        Proposition 4
                        
                           Let P(x) be a predicate about the terms of 
                           T. If P holds for the generator 
                           
                              E
                              ∈
                              
                                 T
                              
                            
                           and from P (x) and P(y) one can conclude 
                           
                              P
                              (
                              x
                              :
                              →
                              y
                              )
                           , then P holds for all terms of 
                           T.

We instantiate the successor/predecessor definitions for the algebra T rewritten with the helper functions d and h, all mutually recursive:
                        
                           
                              
                                 s
                                 
                                 E=E :−>E
                              
                              
                              −−1 −−
                              
                                 s
                                 
                                 (E :−>y)=d
                                 
                                 (s
                                 
                                 y)
                              
                              
                              −−2 −−
                              
                                 s
                                 
                                 z=E :−>(h
                                 
                                 z)
                              
                              
                              −−3 −−
                              
                                 p
                                 
                                 (E :−>E)=E
                              
                              
                              −−1’ −−
                              
                                 p
                                 
                                 (E :−>y)=d
                                 
                                 y
                              
                              
                              −−3’ −−
                              
                                 p
                                 
                                 z=E :−>(p
                                 
                                 (h
                                 
                                 z))
                              
                              
                              −−2’ −−
                              
                                 d
                                 
                                 (a :−>b)=(s
                                 
                                 a) :−>b
                              
                              
                              −−4 −−
                              
                                 h
                                 
                                 (a :−>b)=(p
                                 
                                 a) :−>b
                              
                              
                              −−4’ −−
                           
                        
                     
                  

The intuition behind these operations is their conventional arithmetic interpretation, as 0 for E, 
                        λ
                        x
                        .
                        λ
                        y
                        .
                        
                           
                              2
                           
                           
                              x
                           
                        
                        (
                        2
                        y
                        +
                        1
                        )
                      for 
                        :
                        →
                     , 
                        λ
                        x
                        .2
                        x
                      for d (assuming 
                        x
                        >
                        0
                     ) and 
                        λ
                        x
                        .
                        x
                        /
                        2
                      (assuming x even and 
                        x
                        >
                        0
                     ) for h.

The first and second properties hold by virtue of the fact that the s and p operations are inverses, for which we also give a simple direct proof. 
                        Proposition 5
                        
                           Let 
                           
                              T
                            
                           be the set of terms of the initial algebra 
                           T 
                           and 
                           
                              
                                 
                                    T
                                 
                                 
                                    +
                                 
                              
                              =
                              T
                              −
                              {
                              E
                              }
                           . Then 
                           s:
                              T
                              →
                              
                                 
                                    T
                                 
                                 
                                    +
                                 
                              
                            
                           is a bijection and 
                           p:
                              
                                 
                                    T
                                 
                                 
                                    +
                                 
                              
                              →
                              T
                            
                           is its inverse.

We will proceed by induction on the structure of the terms of T. Observe that f is the inverse of f’ if and only if 
                              ∀
                              u
                              ∈
                              T
                              ,
                              ∀
                              v
                              ∈
                              
                                 
                                    T
                                 
                                 
                                    +
                                 
                              
                              ,
                              f
                              
                              u
                              =
                              v
                              ⟺
                              f
                              ′
                              v
                              =
                              u
                           . We will show this for the base case and the inductive steps for both s and p as well as d and h.

Observe that if s and p are inverses, then d and h are also inverses (on their respective domains). This reduces to showing that 
                              d
                              
                              y
                              =
                              z
                              ⟺
                              h
                              
                              z
                              =
                              y
                           , or equivalently, that 
                              d
                              (
                              a
                              :
                              →
                              b
                              )
                              =
                              c
                              :
                              →
                              d
                              ⟺
                              h
                              (
                              c
                              :
                              →
                              d
                              )
                              =
                              a
                              :
                              →
                              b
                           , which further reduces to 
                              (
                              s
                              
                              a
                              )
                              :
                              →
                              b
                              =
                              c
                              :
                              →
                              d
                              ⟺
                              (
                              p
                              :
                              →
                              c
                              )
                              :
                              →
                              d
                              =
                              a
                              :
                              →
                              b
                            and 
                              s
                              
                              a
                              =
                              c
                              ⟺
                              p
                              
                              c
                              =
                              a
                           , which holds based on the inductive hypothesis for s and p.

We can now start our main induction proof, by case analysis. Observe that rules k and k’ are such that rule -- k -- is the unique match for function f if and only if rule -- k’ -- is the unique match for function 
                              f
                              ′
                           .

We will show that 
                              s
                              
                              u
                              =
                              v
                              ⟺
                              p
                              
                              v
                              =
                              u
                           , assuming it holds inductively for all 
                              a
                              ,
                              b
                            such that 
                              v
                              =
                              a
                              :
                              →
                              b
                           . Note that case k corresponds to the application of rules -- k -- and -- k’ -- in the definitions of s and p
                           
                              
                                 1.
                                 
                                    
                                       s
                                       
                                       u
                                       =
                                       s
                                       
                                       E
                                       =
                                       E
                                       :
                                       →
                                       E
                                       =
                                       v
                                       ⟺
                                       p
                                       
                                       v
                                       =
                                       p
                                       (
                                       E
                                       :
                                       →
                                       E
                                       )
                                       =
                                       E
                                       =
                                       u
                                    .


                                    
                                       s
                                       
                                       u
                                       =
                                       s
                                       
                                       (
                                       E
                                       :
                                       →
                                       y
                                       )
                                       =
                                       d
                                       
                                       (
                                       s
                                       
                                       y
                                       )
                                       =
                                       v
                                       ⟺
                                       s
                                       
                                       y
                                       =
                                       h
                                       
                                       v
                                    
                                 


                                    
                                       p
                                       
                                       v
                                       =
                                       E
                                       :
                                       →
                                       y
                                     where 
                                       y
                                       =
                                       p
                                       
                                       (
                                       h
                                       
                                       v
                                       )
                                       
                                       ⟺
                                       s
                                       
                                       y
                                       =
                                       h
                                       
                                       v
                                    , given that d and h are inverses under the inductive hypothesis covering their calls to s and p.


                                    
                                       v
                                       =
                                       s
                                       
                                       u
                                       ⟺
                                       v
                                       =
                                       E
                                       :
                                       →
                                       y
                                     where 
                                       y
                                       =
                                       h
                                       
                                       u
                                    
                                 


                                    
                                       u
                                       =
                                       p
                                       
                                       v
                                       ⟺
                                       v
                                       =
                                       E
                                       :
                                       →
                                       y
                                     where 
                                       u
                                       =
                                       d
                                       
                                       y
                                    , which holds, given that d and h are inverses under the inductive hypothesis covering their calls to s and p.□

Given that the instance N is an interpretation of Peano's axioms, one can establish a correspondence between proofs of program properties through the isomorphisms n and t between N and T that transport successors and predecessors. As well, given that N can be seen as a model of the free successor algebra with one generator
                        3
                     
                     
                        3
                        Also called Peano Algebra.
                      and T a model for the free magma of (rooted, ordered) binary trees with empty leaves, the operations n and t provide the two sides of an isomorphism between these two free objects.

After adding T and N as instances of PeanoArith one can observe experimentally that they agree on s and p
                     
                        
                           
                              
                                 instance
                                 
                                 PeanoArith
                                 
                                 T
                              
                              
                                 instance
                                 
                                 PeanoArith
                                 
                                 N
                              
                              
                                 *SystemT>map
                                 
                                 t
                                 
                                 [0..4]
                              
                              
                                 [E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E),
                              
                              
                              
                                 ((E :−>E) :−>E) :−>E]
                              
                              
                                 *SystemT>map
                                 
                                 s
                                 
                                 it
                              
                              
                                 [E :−>E, (E :−>E) :−>E,E :−>(E :−>E),
                              
                              
                              
                                 ((E :−>E) :−>E) :−>E,
                              
                              
                              
                                 E :−>((E :−>E) :−>E)]
                              
                              
                                 *SystemT>map
                                 
                                 n
                                 
                                 it
                              
                              
                                 [1,2,3,4,5]
                              
                              
                                 *SystemT>map
                                 
                                 p
                                 
                                 it
                              
                              
                                 [0,1,2,3,4]
                              
                              
                                 *SystemT>map
                                 
                                 t
                                 
                                 it
                              
                              
                                 [E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E),
                              
                              
                              
                                 ((E :−>E) :−>E) :−>E]
                              
                           
                        
                     
                  

Starting with our successor and predecessor functions from Section 4, we proceed along the lines of Tait's definition of Gödel's recursor [9] and define some basic arithmetic functions:
                        
                           
                              
                                 class
                                 
                                 PeanoArith
                                 
                                 n=>GoedelArith
                                 
                                 n
                                 
                                 where
                              
                              
                              
                                 recursor :: (n −>n −>n) −>n −>n −>n
                              
                              
                              
                                 recursor
                                 
                                 f
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x=y
                              
                              
                              
                                 recursor
                                 
                                 f
                                 
                                 x
                                 
                                 y=f
                                 
                                 (p
                                 
                                 x)
                                 
                                 (recursor
                                 
                                 f
                                 
                                 (p
                                 
                                 x)
                                 
                                 y)
                              
                           
                        
                     After defining the (simpler) iterator itr
                     
                        
                           
                              
                              
                                 itr :: (n −>n) −>n −>n −>n
                              
                              
                              
                                 itr
                                 
                                 f
                                 
                                 t
                                 
                                 u=recursor
                                 
                                 g
                                 
                                 t
                                 
                                 u
                                 
                                 where
                              
                              
                              
                              
                                 g
                                 _ y=f
                                 
                                 y
                              
                           
                        
                     one can specify addition (recAdd), multiplication (recMul) and exponentiation (recPow) as follows:
                        
                           
                              
                              
                                 recAdd,
                                 
                                 recMul,
                                 
                                 recPow :: n −>n −>n
                              
                              
                                 recAdd=itr
                                 
                                 s
                              
                              
                                 recMul
                                 
                                 x
                                 
                                 y=itr
                                 
                                 f
                                 
                                 y
                                 
                                 empty
                                 
                                 where
                                 
                                 f
                                 
                                 y=recAdd
                                 
                                 x
                                 
                                 y
                              
                              
                                 recPow
                                 
                                 x
                                 
                                 y=itr
                                 
                                 f
                                 
                                 y
                                 
                                 (s
                                 
                                 empty)
                                 
                                 where
                                 
                                 f
                                 
                                 y=recMul
                                 
                                 x
                                 
                                 y
                              
                           
                        
                     
                  

In a co-inductive style, we can generate the infinite stream of natural numbers and their twin T trees by applying s:
                        
                           
                              
                              
                                 allFrom :: n−>[n]
                              
                              
                              
                                 allFrom
                                 
                                 k=k : allFrom
                                 
                                 (s
                                 
                                 k)
                              
                              
                              
                                 allOf :: [n]
                              
                              
                              
                                 allOf=allFrom
                                 
                                 empty
                              
                           
                        
                     After adding the “twin” instances
                        
                           
                              
                                 instance
                                 
                                 GoedelArith
                                 
                                 T
                              
                              
                                 instance
                                 
                                 GoedelArith
                                 
                                 N
                              
                           
                        
                     one can try out these operations as follows:
                        
                           
                              
                                 *SystemT>recMul
                                 
                                 5
                                 
                                 10
                              
                              
                                 50
                              
                              
                                 *SystemT>recPow
                                 
                                 5
                                 
                                 3
                              
                              
                                 125
                              
                              
                                 *SystemT>recAdd
                                 
                                 (E :−>E)
                                 
                                 (E:−>(E:−>E))
                              
                              
                                 ((E :−>E) :−>E) :−>E
                              
                              
                                 *SystemT>take
                                 
                                 5
                                 
                                 (allFrom
                                 
                                 0)
                              
                              
                                 [0,1,2,3,4]
                              
                              
                                 *SystemT>take
                                 
                                 5
                                 
                                 (allFrom
                                 
                                 E)
                              
                              
                                 [E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E), ((E :−>E) :−>E) :−>E]
                              
                           
                        
                     
                  

While these algorithms are correct and serve as an executable specification, they are extremely slow as they are all expressed in terms of iterated successor operations. Our refinement in the next section focuses on efficient arithmetic operations in the form of a type class extending PeanoArith.

We start with a few operations that, by deepening the analogy with their twin instance N, will provide a view of T objects as binary numbers. This view will ensure that arithmetic operations can be performed in the two instances within reasonable asymptotic time and space complexity bounds. We first define recognizers for “odd” and “even” objects:
                        
                           
                              
                                 class
                                 
                                 PeanoArith
                                 
                                 n=>TreeArith
                                 
                                 n
                                 
                                 where
                              
                              
                              
                                 one :: n
                              
                              
                              
                                 one=arrow
                                 
                                 empty
                                 
                                 empty
                              
                              
                              
                                 isOdd,isEven :: n−>Bool
                              
                              
                              
                                 isOdd
                                 
                                 x=isArrow
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEmpty
                                 
                                 (from
                                 
                                 x)
                              
                              
                              
                                 isEven
                                 
                                 x=isArrow
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isArrow
                                 
                                 (from
                                 
                                 x)
                              
                           
                        
                     We also add two constructors that build such “even” and “odd” objects:
                        
                           
                              
                              
                                 makeOdd,makeEven :: n−>n
                              
                              
                              
                                 makeOdd
                                 
                                 x=arrow
                                 
                                 empty
                                 
                                 x
                              
                              
                              
                                 makeEven=s
                                 
                                 .
                                 
                                 makeOdd
                              
                           
                        
                     A destructor that reverses the action of both constructors follows:
                        
                           
                              
                              
                                 trim :: n−>n
                              
                              
                              
                                 trim
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 (from
                                 
                                 x)=to
                                 
                                 x
                              
                              
                              
                                 trim
                                 
                                 x=p
                                 
                                 (arrow
                                 
                                 (p
                                 
                                 (from
                                 
                                 x))
                                 
                                 (to
                                 
                                 x))
                              
                           
                        
                     Using the “twin instance” method, we can test that they do indeed, on integers, what we expect:
                        
                           
                              
                                 *SystemT>map
                                 
                                 t
                                 
                                 [0..3]
                              
                              
                                 [E, E :−>E, (E :−>E) :−>E, E :−>(E :−>E)]
                              
                              
                                 *SystemT>map
                                 
                                 isOdd
                                 
                                 it
                              
                              
                                 [False,True,False,True]
                              
                              
                                 *SystemT>map
                                 
                                 isOdd
                                 
                                 [0..3]
                              
                              
                                 [False,True,False,True]
                              
                              
                                 *SystemT>makeOdd
                                 
                                 3
                              
                              
                                 7
                              
                              
                                 *SystemT>makeEven
                                 
                                 3
                              
                              
                                 8
                              
                              
                                 *SystemT>trim
                                 
                                 7
                              
                              
                                 3
                              
                              
                                 *SystemT>trim
                                 
                                 8
                              
                              
                                 3
                              
                           
                        
                     The last examples show that makeOdd and makeEven work on instance N as if implemented by 
                        λ
                        x
                        .2
                        x
                        +
                        1
                      and 
                        λ
                        x
                        .2
                        x
                        +
                        2
                      while trim works by undoing their action. We can now implement addition as follows:
                        
                           
                              
                              
                                 add :: n−>n−>n
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x=y
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 y=x
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 y=makeEven
                              
                              
                              
                              
                                 (add
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y))
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 y=makeOdd
                              
                              
                              
                              
                                 (s
                                 
                                 (add
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y)))
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 y=makeOdd
                              
                              
                              
                              
                                 (s
                                 
                                 (add
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y)))
                              
                              
                              
                                 add
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 y=makeEven
                              
                              
                              
                              
                                 (s
                                 
                                 (add
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y)))
                              
                           
                        
                     Subtraction, under the assumption that the second operand is not larger than the first, is implemented in a similar way. Note that termination of both is immediate by structural induction as trim operations are always applied on the right side of the recursive rules to both arguments
                        
                           
                              
                              
                                 sub :: n−>n−>n
                              
                              
                              
                                 sub
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 y=x
                              
                              
                              
                                 sub
                                 
                                 y
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 y
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 x=p
                                 
                                 (makeOdd
                              
                              
                              
                              
                                 (sub
                                 
                                 (trim
                                 
                                 y)
                                 
                                 (trim
                                 
                                 x)))
                              
                              
                              
                                 sub
                                 
                                 y
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 y
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 x=p
                                 
                                 (p
                                 
                                 (makeOdd
                              
                              
                              
                              
                                 (sub
                                 
                                 (trim
                                 
                                 y)
                                 
                                 (trim
                                 
                                 x))))
                              
                              
                              
                                 sub
                                 
                                 y
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 y
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 x=makeOdd
                              
                              
                              
                              
                                 (sub
                                 
                                 (trim
                                 
                                 y)
                                 
                                 (trim
                                 
                                 x))
                              
                              
                              
                                 sub
                                 
                                 y
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 y
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 x=p
                                 
                                 (makeOdd
                              
                              
                              
                              
                                 (sub
                                 
                                 (trim
                                 
                                 y)
                                 
                                 (trim
                                 
                                 x)))
                              
                           
                        
                     Efficient multiplication takes advantage of the fact that it falls back to addition on the left branches (selected by from), given that they represent exponents of 2 and that 
                        
                           
                              2
                           
                           
                              x
                           
                        
                        
                           
                              2
                           
                           
                              y
                           
                        
                        =
                        
                           
                              2
                           
                           
                              x
                              +
                              y
                           
                        
                     . While it proceeds otherwise as traditional multiplication, this results in falling back to addition on “sparse numbers” containing large blocks of zeros
                        
                           
                              
                              
                                 multiply :: n−>n−>n
                              
                              
                              
                                 multiply
                                 
                                 x _
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x=empty
                              
                              
                              
                                 multiply
                                 _ x
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x=empty
                              
                              
                              
                                 multiply
                                 
                                 x
                                 
                                 y=arrow
                              
                              
                              
                              
                                 (add
                                 
                                 (from
                                 
                                 x)
                                 
                                 (from
                                 
                                 y))
                                 
                                 (add
                                 
                                 a
                                 
                                 m)
                                 
                                 where
                              
                              
                              
                              
                              
                                 (tx,ty)=(to
                                 
                                 x,to
                                 
                                 y)
                              
                              
                              
                              
                              
                                 a=add
                                 
                                 tx
                                 
                                 ty
                              
                              
                              
                              
                              
                                 m=double
                                 
                                 (multiply
                                 
                                 tx
                                 
                                 ty)
                              
                           
                        
                     Similarly, the power operation falls back to multiplication on the left branches of the recursive rules
                        
                           
                              
                              
                                 pow :: n−>n−>n
                              
                              
                              
                                 pow
                                 _ y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 y=one
                              
                              
                              
                                 pow
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 y=
                              
                              
                              
                              
                                 multiply
                                 
                                 x
                                 
                                 (pow
                                 
                                 (multiply
                                 
                                 x
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y))
                              
                              
                              
                                 pow
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 y
                              
                              
                              
                              
                                 =multiply
                                 
                                 x
                              
                              ’
                              
                              
                                 (pow
                                 
                                 x
                              
                              ’
                              
                              
                                 (trim
                                 
                                 y))
                                 
                                 where
                              
                              
                              
                              
                              
                                 x
                              
                              ’
                              
                                 =multiply
                                 
                                 x
                                 
                                 x
                              
                           
                        
                     The following special cases have even more efficient implementations:
                        
                           
                              
                              
                                 half,double :: n−>n
                              
                              
                              
                                 double=p
                                 
                                 .
                                 
                                 makeOdd
                              
                              
                              
                                 half=trim
                                 
                                 .
                                 
                                 s
                              
                              
                              
                                 exp2 :: n−>n
                              
                              
                              
                                 exp2
                                 
                                 x=arrow
                                 
                                 x
                                 
                                 empty
                              
                           
                        
                     Note the simplicity of exp2 which is clearly a constant time operation when working on instance T. A left inverse of exp2, the integer binary logarithm log2 can be implemented as follows:
                        
                           
                              
                              
                                 log2 :: n−>n
                              
                              
                              
                                 log2
                                 
                                 x
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 (to
                                 
                                 x)=from
                                 
                                 x
                              
                              
                              
                                 log2
                                 
                                 x=add
                                 
                                 (from
                                 
                                 x)
                                 
                                 (s
                                 
                                 (log2
                                 
                                 (to
                                 
                                 x)))
                              
                           
                        
                     After adding
                        
                           
                              
                                 instance
                                 
                                 TreeArith
                                 
                                 T
                              
                              
                                 instance
                                 
                                 TreeArith
                                 
                                 N
                              
                           
                        
                     we can try out and note the agreement on various arithmetic operations between the “twin” views
                        
                           
                              
                                 *SystemT>t
                                 
                                 3
                              
                              
                                 E :−>(E :−>E)
                              
                              
                                 *SystemT>
                                 n
                                 
                                 (add
                                 
                                 (t
                                 
                                 3)
                                 
                                 (t
                                 
                                 4))
                              
                              
                                 7
                              
                              
                                 *SystemT>n
                                 
                                 (multiply
                                 
                                 (t
                                 
                                 3)
                                 
                                 (t
                                 
                                 4))
                              
                              
                                 12
                              
                              
                                 *SystemT>n
                                 
                                 (sub
                                 
                                 (t
                                 
                                 101)
                                 
                                 (t
                                 
                                 100))
                              
                              
                                 1
                              
                              
                                 *SystemT>n
                                 
                                 (pow
                                 
                                 (t
                                 
                                 3)
                                 
                                 (t
                                 
                                 4))
                              
                              
                                 81
                              
                              
                                 *SystemT>map
                                 
                                 exp2
                                 
                                 [0..7]
                              
                              
                                 [1,2,4,8,16,32,64,128]
                              
                           
                        
                     
                  

We can start our analysis by making a general statement about the runtime and space complexity of all our arithmetic operations.
                        4
                     
                     
                        4
                        As discussed at the end of the section, we describe our algorithms in terms of a number n rather than a bit size n.
                      In one way or another each operation recurses on its subtrees, so if we wish to examine complexity in terms of the natural number n represented by any particular tree we look at how n decomposes down to empty leaf nodes. Our best and worst case scenarios correspond to a tree that is composed only of left subtrees or right subtrees respectively. In the former case, we are able to maximize 
                        
                           
                              ν
                           
                           
                              2
                           
                        
                        (
                        n
                        )
                      which yields a number of the form 
                        
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      
                                                         
                                                            ·
                                                         
                                                         
                                                            
                                                               
                                                                  ·
                                                               
                                                               
                                                                  
                                                                     
                                                                        ·
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          ︸
                                       
                                    
                                 
                                 
                                    n
                                    
                                    times
                                 
                              
                              or
                              
                              2
                              ↑
                              ↑
                              n
                           
                        
                     an operation known as tetration (the latter denotation uses Knuth's “up arrow” representation [10]). At each recursion we are taking 
                        lg
                        
                        n
                     , which gives us 
                        O
                        (
                        
                           
                              lg
                           
                           
                              ⁎
                           
                        
                        n
                        )
                      where 
                        
                           
                              lg
                           
                           
                              ⁎
                           
                        
                        n
                      is the following function. 
                        Definition 1
                        The iterated logarithm, 
                              
                                 
                                    
                                       
                                          lg
                                       
                                       
                                          ⁎
                                       
                                    
                                    n
                                    =
                                    {
                                    
                                       
                                          
                                             
                                                0
                                             
                                             
                                                if
                                                
                                                n
                                                ≤
                                                1
                                             
                                          
                                          
                                             
                                                1
                                                +
                                                
                                                   
                                                      lg
                                                   
                                                   
                                                      ⁎
                                                   
                                                
                                                (
                                                lg
                                                
                                                n
                                                )
                                             
                                             
                                                if
                                                
                                                n
                                                >
                                                1
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           is the number of times the logarithm must be applied successively before the result is less than or equal to one [11].

This function, which grows very slowly, gives a very efficient representation.

The latter case is for numbers of the form 
                        
                           
                              2
                           
                           
                              k
                           
                        
                        −
                        1
                      which as a bitstring would be a string of all 1s. Here, at each recursion we are merely cutting n in half which is 
                        O
                        (
                        lg
                        
                        n
                        )
                     . Most of the natural numbers will be somewhere between these two extremes so it is perhaps more useful to examine what happens in the average case.

In Section 4 we showed that the successor and predecessor algorithms were correct by examining their equivalent mathematical notation, and here we will do the same by examining the recurrences they represent. Note that d represents the constant-time work done by the arrow operation on type T
                        
                           
                              
                                 S
                                 (
                                 n
                                 )
                                 =
                                 S
                                 (
                                 
                                    
                                       
                                          
                                             
                                                2
                                             
                                             
                                                −
                                                
                                                   
                                                      ν
                                                   
                                                   
                                                      2
                                                   
                                                
                                                (
                                                n
                                                )
                                             
                                          
                                          n
                                          −
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 )
                                 +
                                 S
                                 (
                                 
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                
                                                
                                                   −
                                                   
                                                      
                                                         ν
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   n
                                                   )
                                                
                                             
                                             n
                                             −
                                             1
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       1
                                    
                                    )
                                 
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 S
                                 (
                                 n
                                 )
                                 =
                                 P
                                 (
                                 
                                    
                                       ν
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 n
                                 )
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                                 P
                                 (
                                 n
                                 )
                                 =
                                 S
                                 (
                                 
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                
                                                
                                                   −
                                                   
                                                      
                                                         ν
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   n
                                                   )
                                                
                                             
                                             n
                                             −
                                             1
                                          
                                          
                                             2
                                          
                                       
                                    
                                    )
                                 
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 P
                                 (
                                 n
                                 )
                                 =
                                 P
                                 (
                                 
                                    
                                       ν
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 n
                                 )
                                 )
                                 +
                                 P
                                 (
                                 
                                    
                                       
                                          2
                                       
                                       
                                          
                                             
                                                ν
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          n
                                          )
                                          −
                                          1
                                       
                                    
                                    (
                                    
                                       2
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      −
                                                      
                                                         
                                                            ν
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      (
                                                      n
                                                      )
                                                   
                                                
                                                n
                                                −
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       1
                                    
                                    )
                                 
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                              
                           
                        
                     

After some basic algebraic reductions, including the fact that 
                           
                              
                                 ν
                              
                              
                                 2
                              
                           
                           =
                           0
                         when n is odd, we get a better picture of the algorithm's behavior
                           
                              
                                 S
                                 (
                                 n
                                 )
                                 =
                                 S
                                 (
                                 
                                    
                                       
                                          n
                                          −
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 )
                                 +
                                 S
                                 (
                                 
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    
                                       
                                          
                                             n
                                             +
                                             1
                                          
                                          
                                             2
                                          
                                       
                                    
                                    )
                                 
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 S
                                 (
                                 n
                                 )
                                 =
                                 P
                                 (
                                 
                                    
                                       ν
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 n
                                 )
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                                 P
                                 (
                                 n
                                 )
                                 =
                                 S
                                 (
                                 
                                    
                                       
                                          ν
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    
                                       
                                          
                                             n
                                             −
                                             1
                                          
                                          
                                             2
                                          
                                       
                                    
                                    )
                                 
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 P
                                 (
                                 n
                                 )
                                 =
                                 P
                                 (
                                 
                                    
                                       ν
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 n
                                 )
                                 )
                                 +
                                 P
                                 (
                                 n
                                 /
                                 2
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                              
                           
                        
                     

At this point it is much easier to see intuitively why s and p are efficient on average: each has a case where we take 
                           
                              
                                 ν
                              
                              
                                 2
                              
                           
                           (
                           n
                           )
                         which drastically reduces the size of the input (or the amount of “work”) to its subsequent recursive call; even falling into these cases only once or twice can quickly lead to termination.

We now adjust our equations into inequalities that are easier to manipulate, by replacing some arguments with larger values; most notably we replace 
                           
                              
                                 ν
                              
                              
                                 2
                              
                           
                           (
                           n
                           )
                         with 
                           lg
                           
                           n
                        , which is the largest value that function could assume
                           
                              
                                 S
                                 (
                                 n
                                 )
                                 ≤
                                 S
                                 (
                                 n
                                 /
                                 2
                                 )
                                 +
                                 S
                                 (
                                 lg
                                 
                                 n
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 S
                                 (
                                 n
                                 )
                                 ≤
                                 P
                                 (
                                 lg
                                 
                                 n
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                                 P
                                 (
                                 n
                                 )
                                 ≤
                                 S
                                 (
                                 lg
                                 
                                 n
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 odd
                                 )
                                 P
                                 (
                                 n
                                 )
                                 ≤
                                 P
                                 (
                                 lg
                                 
                                 n
                                 )
                                 +
                                 P
                                 (
                                 n
                                 /
                                 2
                                 )
                                 +
                                 d
                                 
                                 (
                                 if
                                 
                                 n
                                 
                                 is
                                 
                                 even
                                 )
                              
                           
                        We can combine each pair of inequalities into one that represents the expected running time by noting that a random number n is equally likely to be even or odd
                           
                              
                                 E
                                 [
                                 S
                                 (
                                 n
                                 )
                                 ]
                                 ≤
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 [
                                 E
                                 [
                                 S
                                 (
                                 n
                                 /
                                 2
                                 )
                                 ]
                                 +
                                 E
                                 [
                                 S
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 ]
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 E
                                 [
                                 P
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 +
                                 d
                                 E
                                 [
                                 P
                                 (
                                 n
                                 )
                                 ]
                                 ≤
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 [
                                 E
                                 [
                                 P
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 +
                                 E
                                 [
                                 P
                                 (
                                 n
                                 /
                                 2
                                 )
                                 ]
                                 ]
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 E
                                 [
                                 S
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 +
                                 d
                              
                           
                        We can clearly re-write this as one equation
                           
                              (14)
                              
                                 E
                                 [
                                 T
                                 (
                                 n
                                 )
                                 ]
                                 ≤
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 [
                                 E
                                 [
                                 T
                                 (
                                 n
                                 /
                                 2
                                 )
                                 ]
                                 +
                                 E
                                 [
                                 T
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 ]
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 E
                                 [
                                 T
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 +
                                 d
                                 =
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 [
                                 E
                                 [
                                 T
                                 (
                                 n
                                 /
                                 2
                                 )
                                 ]
                                 ]
                                 +
                                 E
                                 [
                                 T
                                 (
                                 lg
                                 
                                 n
                                 )
                                 ]
                                 +
                                 d
                                 .
                              
                           
                        Now, using the standard substitution method for such recurrences, we can easily prove the asymptotic complexity of the two operations.

In the following, we will adopt the notation used in [11] for functional iteration. The notation 
                           
                              
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       i
                                       )
                                    
                                 
                                 n
                              
                           
                        will represent the binary logarithm iteratively applied i times, where 
                           i
                           ≥
                           0
                         and 
                           
                              
                                 lg
                              
                              
                                 (
                                 0
                                 )
                              
                           
                           n
                           =
                           n
                        . It is important to note that many authors use a similar notation, without the superscript in parenthesis, to denote exponentiation of a function; the two should not be confused. For example, 
                           
                              
                                 lg
                              
                              
                                 (
                                 2
                                 )
                              
                           
                           n
                         is 
                           lg
                           
                           lg
                           
                           n
                        .

We will show that the s and p operations are 
                           O
                           (
                           
                              
                                 lg
                              
                              
                                 (
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 n
                                 −
                                 1
                                 )
                              
                           
                           n
                           )
                        , that is, the binary logarithm iterated one less time than 
                           
                              
                                 lg
                              
                              
                                 ⁎
                              
                           
                           n
                        . Our proof will require a simple lemma.
                           5
                        
                        
                           5
                           Recall another notational convention: the logarithm function is applied only to the term immediately following. 
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 n
                                 −
                                 1
                               is 
                                 (
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 n
                                 )
                                 −
                                 1
                               and not 
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 (
                                 n
                                 −
                                 1
                                 )
                              .
                         
                        
                           Lemma 1
                           
                              For all 
                              
                                 n
                                 >
                                 2
                              , 
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       −
                                       1
                                       )
                                    
                                 
                                 n
                                 ≤
                                 2
                              .

The proof follows from the definition of the iterated logarithm, which tells us that 
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       )
                                    
                                 
                                 n
                                 ≤
                                 1
                              . Taking each side of this inequality as a power of 2 yields the desired result
                                 
                                    
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             )
                                          
                                       
                                       n
                                       ≤
                                       1
                                       ⟺
                                       
                                          
                                             2
                                          
                                          
                                             
                                                
                                                   lg
                                                
                                                
                                                   (
                                                   
                                                      
                                                         lg
                                                      
                                                      
                                                         ⁎
                                                      
                                                   
                                                   n
                                                   )
                                                
                                             
                                             n
                                          
                                       
                                       ≤
                                       
                                          
                                             2
                                          
                                          
                                             1
                                          
                                       
                                       ⟺
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                       n
                                       ≤
                                       2
                                       ,
                                    
                                 
                              as long as 
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 n
                                 ≥
                                 1
                               which is guaranteed when 
                                 n
                                 >
                                 2
                              .□


                              Eq. 
                              (14) 
                              is 
                              
                                 O
                                 (
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       −
                                       1
                                       )
                                    
                                 
                                 n
                                 )
                              .

We aim to show by induction that 
                                 E
                                 [
                                 T
                                 (
                                 n
                                 )
                                 ]
                                 ≤
                                 c
                                 
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       −
                                       1
                                       )
                                    
                                 
                                 n
                                 −
                                 b
                               for 
                                 n
                                 ≥
                                 
                                    
                                       n
                                    
                                    
                                       0
                                    
                                 
                               where b, c, and n
                              0 are some positive constants. Our induction hypothesis is
                                 
                                    
                                       E
                                       [
                                       T
                                       (
                                       n
                                       /
                                       2
                                       )
                                       ]
                                       ≤
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                       n
                                       /
                                       2
                                       −
                                       b
                                       E
                                       [
                                       T
                                       (
                                       lg
                                       
                                       n
                                       )
                                       ]
                                       ≤
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                       (
                                       lg
                                       
                                       n
                                       )
                                       −
                                       b
                                       .
                                    
                                 
                              Noting that 
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       −
                                       1
                                       )
                                    
                                 
                                 (
                                 lg
                                 
                                 n
                                 )
                                 =
                                 
                                    
                                       lg
                                    
                                    
                                       (
                                       
                                          
                                             lg
                                          
                                          
                                             ⁎
                                          
                                       
                                       n
                                       )
                                    
                                 
                                 n
                               and substituting into the original inequality yields
                                 
                                    
                                       E
                                       [
                                       T
                                       (
                                       n
                                       )
                                       ]
                                       ≤
                                       
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                       
                                       (
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                       n
                                       /
                                       2
                                       −
                                       b
                                       )
                                       +
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             )
                                          
                                       
                                       n
                                       −
                                       b
                                       +
                                       d
                                       =
                                       c
                                       [
                                       
                                          
                                             
                                                
                                                   
                                                      lg
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            lg
                                                         
                                                         
                                                            ⁎
                                                         
                                                      
                                                      n
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                                n
                                                /
                                                2
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                lg
                                             
                                             
                                                (
                                                
                                                   
                                                      lg
                                                   
                                                   
                                                      ⁎
                                                   
                                                
                                                n
                                                )
                                             
                                          
                                          n
                                       
                                       ]
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       ≤
                                       c
                                       [
                                       
                                          
                                             
                                                
                                                   
                                                      lg
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            lg
                                                         
                                                         
                                                            ⁎
                                                         
                                                      
                                                      n
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                                n
                                                /
                                                2
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          1
                                       
                                       ]
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       
                                       (
                                       by
                                       
                                       Definition
                                       
                                       1
                                       )
                                       ≤
                                       c
                                       [
                                       1
                                       +
                                       1
                                       ]
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       
                                       (
                                       by
                                       
                                       Lemma
                                       
                                       1
                                       )
                                       =
                                       2
                                       c
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       .
                                    
                                 
                              It now remains to show that 
                                 
                                    
                                       2
                                       c
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       ≤
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                       n
                                       −
                                       b
                                    
                                 
                              by choosing our constants appropriately. Our use of Lemma 1 requires 
                                 n
                                 >
                                 2
                              , which also allows the reduction: 
                                 
                                    
                                       2
                                       c
                                       −
                                       
                                          
                                             3
                                             b
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       d
                                       ≤
                                       2
                                       c
                                       −
                                       b
                                       .
                                    
                                 
                              This statement holds for any positive c and any 
                                 b
                                 ≥
                                 2
                                 d
                              , but we must also show that a base case holds; selecting 
                                 
                                    
                                       n
                                    
                                    
                                       0
                                    
                                 
                                 =
                                 4
                               requires us to show that 
                                 E
                                 [
                                 T
                                 (
                                 4
                                 )
                                 ]
                               meets the same conditions. We have, based on the recurrence, 
                                 E
                                 [
                                 T
                                 (
                                 1
                                 )
                                 ]
                                 =
                                 d
                              , 
                                 E
                                 [
                                 T
                                 (
                                 2
                                 )
                                 ]
                                 =
                                 5
                                 d
                                 /
                                 2
                              , and 
                                 E
                                 [
                                 T
                                 (
                                 4
                                 )
                                 ]
                                 =
                                 19
                                 d
                                 /
                                 4
                              . We must show
                                 
                                    
                                       19
                                       d
                                       /
                                       4
                                       ≤
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             
                                                
                                                   lg
                                                
                                                
                                                   ⁎
                                                
                                             
                                             4
                                             −
                                             1
                                             )
                                          
                                       
                                       4
                                       −
                                       b
                                       =
                                       c
                                       
                                       
                                          
                                             lg
                                          
                                          
                                             (
                                             1
                                             )
                                          
                                       
                                       4
                                       −
                                       b
                                       =
                                       2
                                       c
                                       −
                                       b
                                       ,
                                    
                                 
                              which holds when 
                                 c
                                 ≥
                                 27
                                 d
                                 /
                                 4
                              , completing the proof.□

An immediate consequence of this proof is that for a random natural number n, the expected running time of s n and p n is 
                           O
                           (
                           1
                           )
                        . Our result of 
                           O
                           (
                           
                              
                                 lg
                              
                              
                                 (
                                 
                                    
                                       lg
                                    
                                    
                                       ⁎
                                    
                                 
                                 n
                                 −
                                 1
                                 )
                              
                           
                           n
                           )
                         is actually a tighter upper bound, that more accurately describes the behavior of 
                           E
                           [
                           T
                           (
                           n
                           )
                           ]
                        . Another way to interpret this result is to imagine the asymptotic boundary changing as we pass each tetration of 2, as shown in Table 1
                        .

Finally, the authors also verified this result empirically by running the s operator on every natural number up to 
                           
                              
                                 2
                              
                              
                                 31
                              
                           
                           −
                           1
                         and counting the number of recursive s and p calls that were made. Fig. 2
                        , which is scaled logarithmically along the x-axis, shows a portion of these results for 
                           2
                           ↑
                           ↑
                           3
                           <
                           n
                           ≤
                           2
                           ↑
                           ↑
                           4
                        . The plot at the top shows how the average number of recursive calls changes as s is applied to increasing n versus 
                           lg
                           
                           lg
                           
                           lg
                           
                           n
                        .

Informally, and without proof, we extend our reasoning to some of the higher order operations we have implemented. As we build an arithmetic operation of the next highest order (starting with s and p), the upper bound is increased by a factor of 
                           lg
                           
                           n
                        . For example, examining the recurrence representing the add operation would show that there are four cases, depending on whether the inputs are even or odd. Three of these cases adjust their inputs so that they are both even (which includes performing some constant number of s and p operation) and call the fourth case, which recursively reduces both inputs by half. In other words, the recurrence would look something like 
                           T
                           (
                           n
                           )
                           =
                           T
                           (
                           n
                           /
                           2
                           )
                           +
                           O
                           (
                           1
                           )
                        , making the add operation 
                           O
                           (
                           lg
                           
                           n
                           )
                        . By the same reasoning, multiply is 
                           O
                           (
                           lg
                           
                           n
                           
                           lg
                           
                           n
                           )
                        .

In comparing our results to traditional operations on bit strings, two important considerations must be kept in mind. The first, to reiterate, is that the results in this section are the expected or average running times, based on the assumption that n is chosen at random. As mentioned previously, operations on some numbers, like those of the form 
                           2
                           ↑
                           ↑
                           n
                         are very efficient while others are notably worse – although all running times are sub-linear.

Second, running time on primitive arithmetic operations is most often discussed in terms of bit complexity 
                        [12], so a simple conversion is needed to make a true “apples-to-apples” comparison of the runtime complexities given here: m bits can represent a number of size 
                           
                              
                                 2
                              
                              
                                 m
                              
                           
                           −
                           1
                        ; taking the traditional multiplication algorithm as an example, its bit complexity of 
                           O
                           (
                           
                              
                                 m
                              
                              
                                 2
                              
                           
                           )
                         expressed in terms of the value of a number n is 
                           O
                           (
                           lg
                           
                           n
                           
                           lg
                           
                           n
                           )
                        , equivalent to our estimate for multiply.

In spite of these caveats, there is a respectable result: the expected runtime of our tree-based arithmetic algorithms have the same asymptotic complexity as their traditional bitstring counterparts.

Finally, given that the traditional bitstring representation of a number n consumes exactly 
                           lg
                           
                           n
                         bits, asymptotically our storage is also quite efficient – this is because the structure effectively “compresses” any repeated strings of zero in the traditional representation.

We conclude our arithmetic related work by defining a total order, provided as a new class Ordered. Comparison proceeds by case analysis, the interesting cases being when the order relation is strengthened from EQ to LT or GT. Termination of the algorithm is ensured by the fact that at each recursive step the trim operation makes the arguments smaller
                        
                           
                              
                                 class
                                 
                                 TreeArith
                                 
                                 n=>Ordered
                                 
                                 n
                                 
                                 where
                              
                              
                              
                                 cmp :: n−>n−>Ordering
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEmpty
                                 
                                 y=EQ
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEmpty
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 not(isEmpty
                                 
                                 y)=LT
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 not(isEmpty
                                 
                                 x)
                              
                              
                              &
                              &
                              
                              
                                 isEmpty
                                 
                                 y=GT
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 y=
                              
                              
                              
                              
                                 cmp
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y)
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 y=
                              
                              
                              
                              
                                 cmp
                                 
                                 (trim
                                 
                                 x)
                                 
                                 (trim
                                 
                                 y)
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isOdd
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isEven
                                 
                                 y=
                              
                              
                              
                              
                                 downeq
                                 
                                 (cmp
                                 
                                 (trim
                                 
                                 x)
                              
                              
                              
                              
                              
                                 (trim
                                 
                                 y))
                                 
                                 where
                              
                              
                              
                              
                              
                              
                                 downeq
                                 
                                 EQ=LT
                              
                              
                              
                              
                              
                              
                                 downeq
                                 
                                 b=b
                              
                              
                              
                                 cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 isEven
                                 
                                 x
                              
                              
                              &
                              &
                              
                              
                                 isOdd
                                 
                                 y=
                              
                              
                              
                              
                                 upeq
                                 
                                 (cmp
                                 
                                 (trim
                                 
                                 x)
                              
                              
                              
                              
                              
                                 (trim
                                 
                                 y))
                                 
                                 where
                              
                              
                              
                              
                              
                              
                                 upeq
                                 
                                 EQ=GT
                              
                              
                              
                              
                              
                              
                                 upeq
                                 
                                 b=b
                              
                           
                        
                     Boolean comparison operators are defined as follows:
                        
                           
                              
                              
                                 lt,
                                 
                                 gt :: n−>n−>Bool
                              
                              
                              
                                 lt
                                 
                                 x
                                 
                                 y=LT==cmp
                                 
                                 x
                                 
                                 y
                              
                              
                              
                                 gt
                                 
                                 x
                                 
                                 y=GT==cmp
                                 
                                 x
                                 
                                 y
                              
                           
                        
                     With the help of our comparison operations, we can now implement efficient division and remainder operations (returned as a pair):
                        
                           
                              
                              
                                 div_and_rem :: n−>n−>(n,n)
                              
                              
                              
                                 div_and_rem
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 lt
                                 
                                 x
                                 
                                 y=(empty,x)
                              
                              
                              
                                 div_and_rem
                                 
                                 x
                                 
                                 y
                              
                              
                              |
                              
                              
                                 gt
                                 
                                 y
                                 
                                 empty=(add
                                 
                                 (exp2
                                 
                                 qt)
                                 
                                 u,v)
                                 
                                 where
                              
                              
                              
                              
                                 divstep
                                 
                                 n
                                 
                                 m=(q,
                                 
                                 sub
                                 
                                 n
                                 
                                 n
                              
                              ’
                              
                                 )
                                 
                                 where
                              
                              
                              
                              
                              
                                 q=try_to_double
                                 
                                 n
                                 
                                 m
                                 
                                 empty
                              
                              
                              
                              
                              
                                 n
                              
                              ’
                              
                                 =multiply
                                 
                                 (exp2
                                 
                                 q)
                                 
                                 m
                              
                              
                              
                              
                                 (qt,rm)=divstep
                                 
                                 x
                                 
                                 y
                              
                              
                              
                              
                                 (u,v)=div_and_rem
                                 
                                 rm
                                 
                                 y
                              
                              
                              
                              
                                 try_to_double
                                 
                                 x
                                 
                                 y
                                 
                                 k
                              
                              
                              |
                              
                              
                                 lt
                                 
                                 x
                                 
                                 y=p
                                 
                                 k
                              
                              
                              
                              
                                 try_to_double
                                 
                                 x
                                 
                                 y
                                 
                                 k=try_to_double
                                 
                                 x
                                 
                                 (double
                                 
                                 y)
                                 
                                 (s
                                 
                                 k)
                              
                           
                        
                     and the two separate operations as first and second projections:
                        
                           
                              
                              
                                 divide,remainder :: n−>n−>n
                              
                              
                              
                                 divide
                                 
                                 n
                                 
                                 m=fst
                                 
                                 (div_and_rem
                                 
                                 n
                                 
                                 m)
                              
                              
                              
                                 remainder
                                 
                                 n
                                 
                                 m=snd
                                 
                                 (div_and_rem
                                 
                                 n
                                 
                                 m)
                              
                           
                        
                     After adding
                        
                           
                              
                                 instance
                                 
                                 Ordered
                                 
                                 T
                              
                              
                                 instance
                                 
                                 Ordered
                                 
                                 N
                              
                           
                        
                     empirical agreement on sorting between the “twin” views illustrates that they are order-isomorphic
                        
                           
                              
                                 *SystemT>map
                                 
                                 t
                                 
                                 [3,1,1,4,2]
                              
                              
                                 [E :−>(E :−>E), E :−>E, E :−>E,
                              
                              
                              
                                 ((E :−>E) :−>E) :−>E, (E :−>E) :−>E]
                              
                              
                                 *SystemT>sortBy
                                 
                                 cmp
                                 
                                 it
                              
                              
                                 [E :−>E, E :−>E, (E :−>E) :−>E, E :−>(E :−>E),
                              
                              
                              
                                 ((E :−>E) :−>E) :−>E]
                              
                              
                                 *SystemT>map
                                 
                                 n
                                 
                                 it
                              
                              
                                 [1,1,2,3,4]
                              
                           
                        
                     
                  

To hint towards the generality of the representation mechanisms described so far, we conclude by interpreting our type classes as a balanced parenthesis languages, a member, together with binary trees (and a few dozen other data types) of the Catalan family of combinatorial structures [13]. We chose it partly because it provides a succinct, 1-bit per parenthesis representation resulting in a total average size of about twice that of a bitstring representation. We define a data type for lists of left and right parenthesis L and R
                     
                        
                           
                              
                                 data
                                 
                                 Par=L
                              
                              
                              |
                              
                              
                                 R
                                 
                                 deriving
                                 
                                 (Eq,Read,Show)
                              
                              
                                 data
                                 
                                 Pars=Pars
                                 
                                 [Par]
                                 
                                 deriving
                                 
                                 (Eq,Read,Show)
                              
                           
                        
                     Next we define it as an instance of PureTypes by defining arrow, from and to operations that work directly on balanced parenthesis lists
                        
                           
                              
                                 instance
                                 
                                 PureTypes
                                 
                                 Pars
                                 
                                 where
                              
                              
                              
                                 empty=Pars
                                 
                                 [L,R]
                              
                              
                              
                                 arrow
                                 
                                 (Pars
                                 
                                 x)
                                 
                                 (Pars
                                 
                                 (L:xs))=Pars
                                 
                                 (L : x
                                 
                                 ++
                                 
                                 xs)
                              
                              
                              
                                 from=fst
                                 
                                 .
                                 
                                 from_to
                              
                              
                              
                                 to=snd
                                 
                                 .
                                 
                                 from_to
                              
                              
                              
                                 isEmpty
                                 
                                 (Pars
                                 
                                 [L,R])=True
                              
                              
                              
                                 isEmpty_=False
                              
                           
                        
                     The implementation of from and to uses a “parser”-like function from_to that extracts them as a pair of parenthesis lists:
                        
                           
                              
                                 from_to
                                 
                                 (Pars
                                 
                                 (c:cs))
                              
                              
                              |
                              
                              
                                 c==L=
                              
                              
                              
                                 (Pars
                                 
                                 (L:fs),Pars
                                 
                                 (L:ts))
                                 
                                 where
                              
                              
                              
                              
                                 (fs,ts)=parexpr
                                 
                                 cs
                              
                              
                                 parexpr
                                 
                                 (c:cs)
                              
                              
                              |
                              
                              
                                 c==L=parlist
                                 
                                 cs
                                 
                                 where
                              
                              
                              
                                 parlist
                                 
                                 (c:cs)
                              
                              
                              |
                              
                              
                                 c==R=([R],cs)
                              
                              
                              
                                 parlist
                                 
                                 (c:cs)=(c:fs++ts,cs2)
                                 
                                 where
                              
                              
                              
                              
                                 (fs,cs1)=parexpr
                                 
                                 (c:cs)
                              
                              
                              
                              
                                 (ts,cs2)=parlist
                                 
                                 cs1
                              
                           
                        
                     Conversion to and from this parenthesis language representation and the natural number or binary tree view is automated by simply specifying the type of the conversion operation par
                     
                        
                           
                              
                                 par :: (PureTypes
                                 
                                 a)=>a−>Pars
                              
                              
                                 par=view
                              
                           
                        
                     By adding instance declarations to various classes, arithmetic operations become readily available on balanced parenthesis languages
                        
                           
                              
                                 instance
                                 
                                 PeanoArith
                                 
                                 Pars
                              
                              
                                 instance
                                 
                                 TreeArith
                                 
                                 Pars
                              
                              
                                 instance
                                 
                                 Ordered
                                 
                                 Pars
                              
                           
                        
                     For instance, one can convert from this parenthesis language representation to natural numbers and back as follows:
                        
                           
                              
                                 *SystemT>par 2012
                              
                              
                                 Pars
                                 
                                 [L,L,L,L,R,R,R,L,R,L,R,L,L,R,R,L,R,L,R,L,R,L,R,R]
                              
                              
                                 *SystemT>n
                                 
                                 it
                              
                              
                                 2012
                              
                           
                        
                     One can also perform arithmetic operations with them, and observe that they correspond to their natural number equivalents
                        
                           
                              
                                 *SystemT>add
                                 
                                 (Pars
                                 
                                 [L,L,R,L,R,R])
                                 
                                 (Pars
                                 
                                 [L,L,L,R,R,R])
                              
                              
                                 Pars
                                 
                                 [L,L,R,L,L,R,R,R]
                              
                              
                                 *SystemT>n
                                 
                                 (Pars
                                 
                                 [L,L,R,L,R,R])
                              
                              
                                 3
                              
                              
                                 *SystemT>n
                                 
                                 (Pars
                                 
                                 [L,L,L,R,R,R])
                              
                              
                                 2
                              
                              
                                 *SystemT>n
                                 
                                 Pars
                                 
                                 [L,L,R,L,L,R,R,R]
                              
                              
                                 *SystemT>n
                                 
                                 (Pars
                                 
                                 [L,L,R,L,L,R,R,R])
                              
                              
                                 5
                              
                           
                        
                     Note that if represented as bitstrings (with 0 standing for L and 1 standing for R), parenthesis languages can be seen as a succinct data type on which arithmetic operations can be directly performed.

@&#RELATED WORK@&#

Gödel's System T 
                     [14] can be considered an important ancestor of modern type systems. We refer the reader to [9,15,16] for salient revisitings of its formal properties, its connection to the logical foundations of mathematics and computer science, as well as an assessment of its historical impact.

The techniques described in this paper originate in the data transformation framework described in [17–19]. In contrast to the work described in those papers which can be seen as “an existence proof” that arithmetic computations can be performed with objects like System T types, we show it constructively here. Moreover, we lift our conceptual framework to a generic type class which turns out to have natural numbers and System T types as “twin” instances.

This work is novel in its practical application of a pairing function as a computational mechanism. Such functions are most often used only to make general arguments about counting or cardinality, e.g. [20–22] – although some exceptions exist, such as [23] (notably their use as a multi-dimensional array indexing tool) or [24], which (implicitly) uses a pairing function as an example of a mapping between natural numbers and higher order abstract syntax terms.

An emulation of Peano and conventional binary arithmetic operations in Prolog is given in [25]. Arithmetic computations with types expressed as C++ templates are described in [26] and in online articles by Oleg Kiselyov using Haskell's type inference mechanism. However, the mechanism advocated there is basically the same as [25] and does not involve structural recursion on tree types like in this paper.

In [27] a similar type class based specification of arithmetic operations is given in terms of an abstraction of bijective base-2 arithmetic as bitstacks with two successor functions o and i corresponding to 
                        λ
                        x
                        .2
                        x
                        +
                        1
                      and 
                        λ
                        x
                        .2
                        x
                        +
                        2
                     . However by contrast to Section 15 of [27] where a binary tree instance similar to data T is shown implementing the s and p arithmetic operations, this paper uses a type class abstraction of the System T types to express computations directly. Note also that while isomorphic data structures allow for transporting operations from one type to another, those operations are not necessarily efficient (Section 5).

Trees are ubiquitous in computer science and their use as a foundational data type has been discussed and explored before. What distinguishes this work from others is not the construction of such trees but rather the computations and operations performed on the trees after they are constructed. Contrast this to [28] or [29], both of which use a similar tree based data type to represent natural numbers. The former only discusses the construction (based on prime factorization) while the latter emphasizes (type) theory; instead this work introduces similar concepts in order to lay the groundwork for applications, e.g. unconventional arithmetic. The work undertaken in [30] does introduce arithmetic operations on trees but lacks the bijection to natural numbers and any examination of the computational efficiency.

Efficient number representations and arithmetic operations in the lambda calculus are the subject of [31], which examines representing numbers in a binary-number inspired lambda notation as opposed to the traditional Church numerals, but clearly different from our replacement of the underlying binary number notation by trees. Perhaps the most closely related work with regard to unconventional arithmetic is in [32], which introduces integer decision diagrams that decompose a number into three parts: 
                        n
                        =
                        g
                        +
                        
                           
                              x
                           
                           
                              p
                           
                        
                        d
                      where 
                        
                           
                              x
                           
                           
                              p
                           
                        
                        =
                        
                           
                              2
                           
                           
                              
                                 
                                    2
                                 
                                 
                                    p
                                 
                              
                           
                        
                        ,
                        0
                        ≤
                        g
                        <
                        
                           
                              x
                           
                           
                              p
                           
                        
                        ,
                        0
                        <
                        d
                        <
                        
                           
                              x
                           
                           
                              p
                           
                        
                     . Contrast this additive representations to our multiplicative one which, while more radical, is arguably simpler. The computational advantages outlined are similar: “sparse” numbers are represented more efficiently and algorithms operate in comparable asymptotic bounds.

This paper is an extended and improved version of [1]. It adds Sections 3, 5, 7 and 11, which include several new algorithms (e.g. operations with Gödel's recursor and log2) and a significant number of new use cases. A new inductive proof that the successor and predecessor are inverses on our binary tree data type as well as a study of their average case complexity are added. Also included are expanded explanations of various algorithms and proofs and a detailed comparison with related work.

@&#FUTURE WORK@&#

The results contained in this work provide several avenues for practical applications and further work. Arithmetic and ordering, expressed generically in terms of a type class abstracting away operations on binary trees have been implemented with efficient time and space complexity bounds which provides the basis for an arithmetic computation package. A key advantage here is that very large numbers may be represented in binary tree form that would overflow computer memory when implemented with conventional bitstring arithmetic.

It is clear that the choice of our pairing function for the binary tree dictates which numbers are represented with large or small trees; further research could investigate how different pairing functions or tree construction strategies could map smaller trees to particular types of numbers, the idea being that while not all calculations would be efficient, those of specialized interest could be.

In this work, the authors did not attempt to aggressively optimize the tree-based arithmetic operations, rather, the focus was on showing that such operations were possible within reasonable asymptotic bounds. An obvious next step would be to attempt such an optimization, including an analysis and comparison to existing arithmetic packages.

As well, parallelization of these algorithms has not been explored. Similar to applications of the powerlist algebra outlined in [33], the recursive nature of our tree based representation lends itself to concurrent calculations, likely offering an overall improvement in runtime performance.

As a more theoretical exercise, one could envision a memory management system that relies on the fact that our binary trees are isomorphic to other structures as well, such as sequences, sets, multisets, digraphs, etc. (see [34,32]) and store one canonical representation of all isomorphic instances, at the cost of encoding/decoding.

@&#CONCLUSION@&#

The results described in this paper have been made possible by extending the techniques introduced in [17–19,27] that allow observing the internal working of recursive definitions through isomorphisms transporting operations between fundamental data types. The isomorphism between the free magma of binary trees with empty leaves and the free successor algebra generated by 0 (Peano algebra) has materialized as a type class defining generically their arithmetic operations and ordering relations. By defining new instances of this type class (e.g. balanced parenthesis languages) we have also shown that our computations can be instantiated to alternative, possibly succinctly represented data types. We have laid the foundation for a new arithmetic paradigm by performing computations directly with trees – and shown they have reasonable time and space complexities. At the same time we have uncovered the possibility of a unified representation of types and data by interpreting these trees as a type language.

@&#ACKNOWLEDGMENT@&#

We thank the NSF (research grant 1018172) for support.

@&#REFERENCES@&#

