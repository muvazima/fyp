@&#MAIN-TITLE@&#Design of automated negotiation mechanisms for decentralized heterogeneous machine scheduling

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We study decentralized scheduling with heterogeneous machines and competing job sets.


                        
                        
                           
                           The jobs belong to self-interested stakeholders with private preference information.


                        
                        
                           
                           We present a metaheuristic-inspired negotiation protocol with various building blocks.


                        
                        
                           
                           The protocol achieves (near) Pareto efficient outcomes and low aggregate social cost.


                        
                        
                           
                           The limitedly informed protocol performs similar to informed centralized approaches.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Group decisions and negotiations

Scheduling

Negotiation protocol

Mechanism design

Complex contracts

@&#ABSTRACT@&#


               
               
                  We consider a hard decentralized scheduling problem with heterogeneous machines and competing job sets that belong to different self-interested stakeholders (agents). The determination of a beneficial solution, i.e., a respective contract in terms of a common schedule, is particularly difficult due to information asymmetry and self-interested behavior of the involved agents. The agents intend to minimize their individual costs that consist of tardiness cost and their share of the machine operating cost. The aim of this study is to find socially beneficial outcomes by means of negotiation mechanisms that comply with decentralized information and conflicting interests. For this purpose, we present an automated negotiation protocol, which is inspired by metaheuristics, along with a set of optional building blocks. In the protocol, new solutions are iteratively generated, as mutations of a single provisional contract, and proposed to the agents, while feasible rules with quotas restrict the acceptance decisions of the agents. The computational experiments show that the protocol—without central information and subject to strategic behavior—can achieve high quality solutions which are very close to results from centralized multi-criteria procedures. Particular building block configurations yield improved outcomes. Concluding, the considered scheduling problem enhances standard scheduling models by incorporating multiple stakeholders, nonlinear cost functions, and machine operating cost, whereas the presented negotiation approach contributes to the methodology and practice of collaborative decision making.
               
            

@&#INTRODUCTION@&#

Planning and scheduling face new challenges these days. As companies are often strongly integrated within supply networks, related decisions are not exclusively subject to a single company’s own preferences but increasingly depend on the interaction with, e.g., suppliers, subcontractors, or customers (Dawande, Geismar, Hall, & Sriskandarajah, 2006). Consequently, decision making becomes a collaborative task. Since the stakeholders have their very own preferences and objectives, planning and scheduling must consider strategic behavior (Kersten & Mallory, 1990). For example, decision makers that compete for shared machine resources may not be willing to disclose private information or may provide biased information such as exaggerated needs to work toward higher individual profits to the detriment of the overall allocation efficiency (Klein, Faratin, Sayama, & Bar-Yam, 2003). Thus, revealed information can be incomplete or misleading and, hence, is a fruit of a poisonous tree for a central authority. As a consequence, a traditional centralized scheduling approach may not be effective in obtaining high quality solutions. Since Operational Research is generally concerned with analytical methods for decision making, the issue of collaborative decision making within a group of autonomous decision makers is highly relevant. In multi-party situations, there is usually no single fully-informed authority that is entitled to hierarchically allocate resources and determine the courses of action for the whole system. Thus, a decentralized group decision making procedure is needed which takes into account strategic behavior of self-interested parties and restricted availability of information.

In this paper, we focus on decentralized decision problems on the level of operations management (in particular scheduling problems), which are characterized by recurring decision tasks as well as the potential and need for a formalized and automated decision support procedure. Thus, it is appropriate to devise and apply an automated negotiation approach. At this, decision making entities are represented by autonomous non-cooperative software agents. In contrast to human negotiators, software agents can easily negotiate for millions of rounds to find a mutually agreed upon solution (also called contract). Respective negotiations may be regarded as decentralized search processes which aim to iteratively enhance a contract from a contract space (search space). A major challenge of negotiations are complex contract spaces, which are characterized by multiple interdependent issues that lead to many local optima as well as a vast nonlinear search space (Fink, 2004; Klein et al., 2003). A negotiation procedure is defined by a protocol that controls the observable actions of the agents and related interactions. Such procedures work without requiring the parties to reveal full information on preferences. The rules of the protocol should work toward finding a contract that achieves pursued criteria such as Pareto-efficiency and social welfare.

Hence, this paper introduces a novel decentralized scheduling problem that incorporates competing job sets that are connected to multiple self-interested agents, machine operating costs, particularly energy costs, as well as tardiness costs. Extending conventional scheduling assumptions, we argue that both cost functions may be nonlinear and decisions are to be made by finding a multi-lateral contract. The assumption of nonlinearity in tardiness costs rests upon several considerations: firstly, in some scenarios, tardiness may induce a base cost—e.g., due to missing a strict deadline. Secondly, it might be that a small tardiness can mostly be offset by countermeasures, but the more tardiness occurs the higher the cost are (increasing marginal cost). Thirdly, the opposite can occur; missing a due date induces an immediate high penalty but the cost converges to an upper bound (decreasing marginal cost)—e.g., a product cannot be delivered to a customer anymore. Furthermore, energy costs have drawn the interest of managers and researchers in recent years. For instance, while they have always constituted a large part of operational costs for energy-intensive industries, rising energy prices and increasing power consumption of hardware have turned energy into a major cost driver for providers of IT infrastructure as well (Chen et al., 2005). The fact that energy consumption does not necessarily increase linearly with workload adds an additional computational challenge to scheduling approaches that include energy costs (Bodenstein, Schryen, & Neumann, 2012), as do dynamic tariff schemes that compensate industrial customers for reducing their consumption during peak times (Braithwait & Hansen, 2011; Mohsenian-Rad, Wong, Jatskevich, Schober, & Leon-Garcia, 2010). We include these determinants of energy costs into our negotiation scheme to provide a realistic representation of total expenditures. Concerning the nonlinearity of machine operating costs, empirical work has shown that, e.g., computing components’ energy consumption is nonlinearly increasing or decreasing subject to their utilization (Bodenstein et al., 2012). Similarly, vessels’ fuel consumption follows an approximate cubic function subject to their speed (Tierney, Áskelsdóttir, Jensen, & Pisinger, 2014). Furthermore, machine pools tend to be heterogeneous and of mixed efficiency, as broken machines are replaced by more advanced ones, while other older machines are still in place (Heath, Diniz, Carrera, Meira, & Bianchini, 2005).

The aim of this paper is twofold. Firstly, we want to advance the knowledge on generic decentralized negotiation procedures for complex contract spaces. For this purpose we describe, enhance, and analyze negotiation mechanisms with different building blocks for achieving beneficial outcomes. Secondly, we introduce and solve the considered multi-agent machine scheduling problem by means of a negotiation protocol with problem-specific operators. For this purpose, we incorporate characteristics of restricted information availability and strategic behavior of autonomous agents in a decentralized scheduling situation. The findings from this study contribute to the methodology and practice of decision support for hard decentralized scheduling problems with information asymmetry and multiple self-interested agents. For such kinds of problems, for the first time, we devise a rich framework of mainly generic negotiation mechanisms which is applied for challenging problem instances with up to 19 agents.

The remainder of this paper is structured as follows: After this introduction, we formally define the considered multi-agent scheduling problem and give illustrative examples for applications. Afterward, we give an overview of related work and introduce the devised negotiation-based solution mechanism. The protocol is evaluated in a computational study which is subsequently presented together with a discussion of results. Finally, we conclude the paper and present future work.

A set of non-preemptable jobs 
                           
                              J
                              =
                              {
                              1
                              ,
                              …
                              
                              ,
                              j
                              ,
                              …
                              
                              ,
                              J
                              }
                           
                         which originate from a set of competing agents 
                           
                              I
                              =
                              {
                              1
                              ,
                              …
                              
                              ,
                              i
                              ,
                              …
                              
                              ,
                              I
                              }
                           
                         has to be scheduled on a set of machines 
                           
                              M
                              =
                              {
                              1
                              ,
                              …
                              
                              ,
                              m
                              ,
                              …
                              
                              ,
                              M
                              }
                           
                        . Each job j has an associated agent aj
                         (
                           
                              ∈
                              I
                           
                        ), a standardized processing time 
                           
                              
                                 p
                                 j
                                 s
                              
                              ,
                           
                         a resource consumption per time slot rj
                         (in terms of a single resource type), a release time sj
                        , and a due date dj
                         (
                           
                              
                                 p
                                 j
                                 s
                              
                              ,
                              
                                 r
                                 j
                              
                              ,
                              
                                 s
                                 j
                              
                              ,
                              
                                 d
                                 j
                              
                              ≥
                              0
                           
                        ). Without loss of generality, we assume a discrete planning horizon with 
                           
                              T
                              =
                              {
                              1
                              ,
                              …
                              ,
                              
                                 t
                                 max
                              
                              }
                           
                         as set of all time slots and 
                           
                              
                                 p
                                 j
                                 s
                              
                              ,
                           
                         
                        sj
                        , and dj
                         as non-negative integer values. We assume that 
                           
                              
                                 p
                                 j
                                 s
                              
                              ,
                              
                                 r
                                 j
                              
                              ,
                           
                         and sj
                         are publicly known, whereas dj
                         is just known to agent aj
                        .

The M machines are heterogeneous and have three relevant characteristics: (1) a capacity cap
                           m
                        , which is the maximal resource provision by a machine m per time slot, (2) an operating speed os
                           m
                        , which determines the speed of job processing, and (3) an operating cost function E
                        
                           t,m
                        , which determines the cost at time t subject to the machine’s utilization u
                        
                           t,m
                         (as described below). All machines have to fulfill the capacity constraint which is 
                           
                              0
                              ≤
                              
                                 u
                                 
                                    t
                                    ,
                                    m
                                 
                              
                              ≤
                              1
                              ,
                              ∀
                              t
                              ∈
                              T
                              ,
                              ∀
                              m
                              ∈
                              M
                              .
                           
                         The machines’ parameters are public information, i.e., all parties are aware of them.

The key decision variable of the problem is the schedule π which determines the start time (σj
                        ) and assigned machine (μj
                        ) for each job:

                           
                              (1)
                              
                                 
                                    π
                                    =
                                    {
                                    
                                       (
                                       
                                          σ
                                          1
                                       
                                       ,
                                       
                                          μ
                                          1
                                       
                                       )
                                    
                                    ,
                                    …
                                    
                                    ,
                                    
                                       (
                                       
                                          σ
                                          J
                                       
                                       ,
                                       
                                          μ
                                          J
                                       
                                       )
                                    
                                    }
                                    .
                                 
                              
                           
                        
                     

The time pj
                        (π) required for the processing of a job j on a machine 
                           
                              m
                              =
                              
                                 μ
                                 j
                              
                           
                         is determined by a machine’s operating speed os
                           m
                        , the job’s standardized processing time 
                           
                              
                                 p
                                 j
                                 s
                              
                              ,
                           
                         and a standardized operating speed 
                           
                              os
                              ¯
                           
                        : 
                           
                              
                                 p
                                 j
                              
                              
                                 (
                                 π
                                 )
                              
                              =
                              
                                 ⌈
                                 
                                    
                                       os
                                       ¯
                                    
                                    
                                       os
                                       
                                          μ
                                          j
                                       
                                    
                                 
                                 *
                                 
                                    p
                                    j
                                    s
                                 
                                 ⌉
                              
                           
                         (if 
                           
                              
                                 os
                                 
                                    μ
                                    j
                                 
                              
                              =
                              
                                 os
                                 ¯
                              
                              ,
                           
                         then 
                           
                              
                                 p
                                 j
                              
                              
                                 (
                                 π
                                 )
                              
                              =
                              
                                 p
                                 j
                                 s
                              
                           
                        ). The completion time fj
                         of a job j is determined by its start and processing time: 
                           
                              
                                 f
                                 j
                              
                              =
                              
                                 σ
                                 j
                              
                              +
                              
                                 p
                                 j
                              
                              
                                 (
                                 π
                                 )
                              
                           
                        . As the problem includes release times, the start time must not be earlier than the release time of a job, that is 
                           
                              
                                 σ
                                 j
                              
                              ≥
                              
                                 s
                                 j
                              
                              ,
                              ∀
                              j
                              ∈
                              J
                              .
                           
                        
                     

The objective of an agent i is the minimization of his or her total cost which consists of two components: machine operating costs and tardiness costs. The agents use the same measuring commodity (numéraire; e.g., monetary units).

The operating cost E
                        
                           t,m
                         for a given machine m at a given time slot t is subject to the three non-negative parameters 
                           
                              
                                 α
                                 m
                                 E
                              
                              ,
                              
                                 β
                                 m
                                 E
                              
                              ,
                              
                                 γ
                                 m
                                 E
                              
                              ,
                           
                         the machine utilization 
                           
                              
                                 u
                                 
                                    t
                                    ,
                                    m
                                 
                              
                              
                                 (
                                 π
                                 )
                              
                              =
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          J
                                          :
                                          
                                             μ
                                             k
                                          
                                          =
                                          m
                                          ∧
                                          
                                             σ
                                             k
                                          
                                          ≤
                                          t
                                          <
                                          
                                             f
                                             k
                                          
                                       
                                    
                                    
                                       r
                                       k
                                    
                                 
                                 
                                    cap
                                    m
                                 
                              
                              ,
                           
                         and a tariff Γ(t): 
                           
                              
                                 E
                                 
                                    t
                                    ,
                                    m
                                 
                              
                              
                                 (
                                 
                                    u
                                    
                                       t
                                       ,
                                       m
                                    
                                 
                                 )
                              
                              =
                              
                                 [
                                 
                                    α
                                    m
                                    E
                                 
                                 *
                                 
                                    
                                       (
                                       
                                          u
                                          
                                             t
                                             ,
                                             m
                                          
                                       
                                       )
                                    
                                    
                                       β
                                       m
                                       E
                                    
                                 
                                 +
                                 
                                    γ
                                    m
                                    E
                                 
                                 *
                                 Θ
                                 
                                    (
                                    
                                       u
                                       
                                          t
                                          ,
                                          m
                                       
                                    
                                    )
                                 
                                 ]
                              
                              *
                              Γ
                              
                                 (
                                 t
                                 )
                              
                              ,
                           
                         with Θ as the Heaviside function: 
                           
                              Θ
                              (
                              •
                              )
                              =
                              1
                              :
                              •
                              >
                              0
                              ;
                              Θ
                              (
                              •
                              )
                              =
                              0
                              :
                              •
                              ≤
                              0
                           
                        .

The overall operating costs of the machines are given by

                           
                              (2)
                              
                                 
                                    EC
                                    
                                       (
                                       π
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ∑
                                       
                                          m
                                          ∈
                                          M
                                       
                                    
                                    
                                       E
                                       
                                          t
                                          ,
                                          m
                                       
                                    
                                    
                                       (
                                       
                                          u
                                          
                                             t
                                             ,
                                             m
                                          
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

The overall operating costs EC have to be split among the set of agents 
                           
                              I
                              ,
                           
                         i.e., each agent i has to cover a share EC
                           i
                         with 
                           
                              
                                 ∑
                                 
                                    i
                                    ∈
                                    I
                                 
                              
                              
                                 EC
                                 i
                              
                              =
                              EC
                           
                        . Different cost allocation schemes are discussed later on.

The tardiness Tj
                         of a job j depends on the completion time fj
                         and the due date dj
                        : 
                           
                              
                                 T
                                 j
                              
                              =
                              
                                 max
                                 {
                                 
                                    f
                                    j
                                 
                                 −
                                 
                                    d
                                    j
                                 
                                 ;
                                 0
                                 }
                              
                              .
                           
                         Only if a job is tardy, there arises a tardiness cost TC
                           j
                        (Tj
                        ). This function TC
                           j
                        (Tj
                        ) can be nonlinear and is represented by 
                           
                              
                                 
                                    TC
                                    j
                                 
                                 
                                    (
                                    
                                       T
                                       j
                                    
                                    )
                                 
                                 =
                                 
                                    α
                                    j
                                    w
                                 
                                 *
                                 
                                    
                                       (
                                       
                                          T
                                          j
                                       
                                       )
                                    
                                    
                                       β
                                       j
                                       w
                                    
                                 
                                 +
                                 
                                    γ
                                    j
                                    w
                                 
                                 *
                                 Θ
                                 
                                    (
                                    
                                       T
                                       j
                                    
                                    )
                                 
                              
                              ,
                           
                         with 
                           
                              
                                 α
                                 j
                                 w
                              
                              ,
                              
                                 β
                                 j
                                 w
                              
                              ,
                              
                                 γ
                                 j
                                 w
                              
                              ≥
                              0
                           
                         and only known to the job’s owner aj
                        . The total tardiness cost of an agent i is given by 
                           
                              
                                 TTC
                                 i
                              
                              
                                 (
                                 π
                                 )
                              
                              =
                              
                                 ∑
                                 
                                    j
                                    ∈
                                    J
                                    :
                                    
                                       a
                                       j
                                    
                                    =
                                    i
                                 
                              
                              
                                 TC
                                 j
                              
                              
                                 (
                                 
                                    T
                                    j
                                 
                                 )
                              
                              .
                           
                         Finally, we obtain an agent i’s overall objective, minimization of his or her individual cost Ci
                         consisting of tardiness and operating cost:

                           
                              (3)
                              
                                 
                                    
                                       min
                                       π
                                    
                                    
                                    
                                    
                                       C
                                       i
                                    
                                    =
                                    
                                       TTC
                                       i
                                    
                                    
                                       (
                                       π
                                       )
                                    
                                    +
                                    
                                       EC
                                       i
                                    
                                    
                                       (
                                       π
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

Since we are in a group decision situation, the agents decide according to their individual objectives, i.e., a central authority can neither determine the schedule nor instruct how they must decide or behave. The outcome depends on the applied negotiation protocol P. Consequently, we define that the schedule is determined by a contract c that is the outcome of a negotiation NP
                         subject to a protocol P:

                           
                              (4)
                              
                                 
                                    π
                                    ←
                                    c
                                    =
                                    
                                       N
                                       P
                                    
                                    
                                       (
                                       J
                                       ,
                                       I
                                       ,
                                       M
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

The task of mechanism design for facilitating the planning process is to find an effective negotiation protocol P for a given objective. The outcome of a negotiation protocol should ideally be Pareto-efficient (Jennings et al., 2001; Zhang, Song, Chen, & Hong, 2011), i.e., no agent can reduce his or her individual cost without increasing another agent’s cost. For nonlinear search spaces, strict achievement of Pareto-efficiency cannot be expected. Therefore, a reasonable objective is to find a protocol P that minimizes the Euclidean distance d(•, •) to the closest Pareto-efficient solution:

                           
                              (5)
                              
                                 
                                    
                                       min
                                       P
                                    
                                    
                                    
                                    
                                       min
                                       
                                          
                                             π
                                             *
                                          
                                          ∈
                                          ParetoSet
                                       
                                    
                                    d
                                    
                                       (
                                       π
                                       ,
                                       
                                          π
                                          *
                                       
                                       )
                                    
                                 
                              
                           
                        Since assessing Pareto-efficiency may be computationally infeasible in case of a considerable number of agents, we consider as a further evaluation measure the minimization of social cost (maximization of social welfare):

                           
                              (6)
                              
                                 
                                    
                                       min
                                       P
                                    
                                    
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       (
                                       
                                          TTC
                                          i
                                       
                                       
                                          (
                                          π
                                          )
                                       
                                       +
                                       
                                          EC
                                          i
                                       
                                       
                                          (
                                          π
                                          )
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        Such a cost optimum is itself a Pareto-efficient solution. The aggregate cost represent the social welfare function (or in this case, the social loss) which is also a usual criterion of multi-party optimization (Harsanyi, 1955; Myerson, 1981). We expect a protocol P to deliver near Pareto-efficient solutions for a small agent count and a preferably high social welfare, i.e., low aggregate costs.

The introduced scheduling problem is complex due to the decentralized decision situation and the nonlinear objective functions in addition to the fact that the included single-agent problems are already 
                           NP
                        -hard as a simplified version:

                           Proposition 1
                           
                              The single agent version of the presented problem is
                              
                                 NP
                              
                              -hard.
                           

The considered problem contains the well-known 
                           NP
                        -hard single machine total weighted tardiness problem (SMTWTP), which was proven to be 
                           NP
                        -hard by Lenstra, Kan, and Brucker (1977), as a special case. We obtain the SMTWTP, if we set 
                           
                              M
                              =
                              1
                           
                        ; 
                           
                              I
                              =
                              1
                           
                        ; 
                           
                              
                                 s
                                 j
                              
                              =
                              0
                              ,
                           
                        
                        
                           
                              
                                 r
                                 j
                              
                              =
                              1
                              ,
                           
                        
                        
                           
                              
                                 β
                                 j
                                 w
                              
                              =
                              1
                              ,
                           
                        
                        
                           
                              
                                 γ
                                 j
                                 w
                              
                              =
                              0
                              ,
                           
                         ∀j ∈ J; 
                           
                              
                                 cap
                                 1
                              
                              =
                              1
                              ;
                              
                                 os
                                 1
                              
                              =
                              
                                 os
                                 ¯
                              
                              ;
                              Γ
                              
                                 (
                                 t
                                 )
                              
                              =
                              0
                              ,
                           
                         and let the one and only agent decide about the procedure P minimizing TTC
                           i
                        . Consequently, the presented problem is 
                           NP
                        -hard as well.□

In this section, we present two illustrative application examples from the domains of (1) production and (2) high-performance scientific computing services.

In classical production scheduling, the machines can represent, e.g., industrial robots or workshops. We argue that such machines may have nonlinear operating cost functions for two reasons: firstly, present fixed costs are associated to nonlinear average variable costs (see Varian, 2010, Ch. 21); secondly, a lot of technical procedures of machines and relationships of machine components are nonlinear (see Vergnano et al., 2012). The agents can be interpreted differently: for instance, they can represent (1) different departments within a company (e.g., the production and the prototype engineering department), (2) different companies using shared resources (e.g., a joint venture sharing a factory), or (3) large customers (e.g., in a supply chain). The jobs can be production orders with an announced fulfillment date. There is very little empirical work about tardiness cost functions. Nevertheless, Cook, Tanner, and Lawes (2012) showed empirically that the perceived inconvenience and propensity to switch airlines of air travelers is indeed nonlinearly increasing with delay time or, in other words, with fulfillment tardiness.

Our second example refers to job scheduling for high-performance computing (HPC)—e.g., in the academic domain. The computing infrastructure of research organizations and universities generally includes HPC machines which are used by several researchers or research groups. Commonly, computers in data centers are heterogeneous, since failed components are replaced with newer and better ones and expansions in capacity and performance favor state-of-the-art components (Heath et al., 2005). This heterogeneity results in varying levels of power consumption among the different types of machines for a given utilization. However, previous research has shown that this power consumption is often nonlinear and best approximated by an allometric function (Bodenstein et al., 2012). In a scientific computing scenario, the agents represent the different stakeholders that share computing resources (e.g., researchers, institutes, departments, or even universities). The individual entities are almost exclusively interested in getting their jobs done (Kraus, 2001). In this scenario, typical jobs are simulations or optimization procedures. The tardiness cost function is arguably not linear: for instance, in the critical phase before a project deadline, the cost may be exponentially increasing, because the risk of missing the deadline rises (see Kraus, Wilkenfeld, & Zlotkin, 1995). To conclude, the management of HPC services involves multi-agent machine scheduling problems with nonlinear operating and tardiness costs as well.

Concluding, the presented problem model reflects the circumstances of many real-world application scenarios. The findings of the later presented negotiation procedures can be applied within a decision support system to support reaching agreements in intercompany scheduling.

@&#RELATED WORK@&#

This section surveys related work that studies multi-agent scheduling approaches as well as related negotiation methods for complex contract spaces.

Firstly, there are several papers that analyze the computational complexity of multi-agent scheduling: Baker and Smith (2003) proof 
                        NP
                     -hardness of two-agent single machine problems with various individual objective functions. Similarly, Leung, Pinedo, and Wan (2009) consider the complexity of different two-agent multi-machine scheduling problems which incorporate either identical or different private objective functions. Agnetis, Mirchandani, Pacciarelli, and Pacifici (2004) and Agnetis, Pacciarelli, and Pacifici (2007) analyze the complexity of finding nondominated solutions for various problems from the multi-agent scheduling domain, whereas Cheng, Ng, and Yuan (2006) analyze the complexity of finding a feasible schedule given that agents are appointed with a limited total weighted number of tardy jobs and Cheng, Ng, and Yuan (2008) study the complexity of different multi-agent single machine scheduling problems with objectives in max-form. From a game-theoretic perspective, Agnetis, Pascale, and Pranzo (2009) show that finding a Nash bargaining solution for multi-agent scheduling is 
                        NP
                     -hard and present an algorithm for this problem. Finally, Huynh Tuong, Soukhal, and Billaut (2012) summarize, extend, and give an overview on the findings on multi-agent scheduling complexity.

Secondly, there is work studying centralized approaches for multi-agent problems disregarding strategic considerations. Balasubramanian, Fowler, Keha, and Pfund (2009) evaluate a genetic algorithm approach for finding nondominated solutions for parallel machine scheduling with two agents with different objectives (makespan and total flow time, respectively). Mor and Mosheiov (2010) introduce a polynomial-time algorithm for the minimization of the weighted earliness of an agent given that a counter agent’s maximum earliness does not exceed an upper bound. Similarly, Cheng, Chung, Liao, and Lee (2013) discuss a branch-and-bound algorithm and a simulated annealing approach for a single machine problem minimizing one agent’s total weighted flow time given that the maximum lateness of another agent is bounded. Ramacher and Mönch (2011) study an NSGA-II approach for finding nondominated solutions for two-agent single machine scheduling with mixed agent objective functions.

Machine scheduling is also an application domain of distributed artificial intelligence (DAI) research. DAI regards cooperative agents that voluntarily exchange information and pursue a joint goal (Durfee, 1999). In contrast, this study deals with autonomous agents that are liable to their very own interest and, hence, act non-cooperatively (Sandholm, 1999). With regard to DAI, Brauer and Weiss (1998) present a multi-agent learning approach, where every machine is regarded as an agent. Adacher, Agnetis, and Meloni (2000) consider agent-controlled manufacturing systems, where they simulated different manufacturing agent paradigms with respect to the number of late jobs in batch scheduling. Cowling, Ouelhadj, and Petrovic (2003) give an overview of multi-agent architectures for dynamic scheduling of machines incorporating real-time information. Macchiaroli and Riemma (2002) present an architecture, in which agents are endowed with a budget and find a schedule by using a counterproposal negotiation protocol. Mönch and Stehli (2005) introduce a multi-agent framework for production control taking interaction of different planning components into account. Wu and Weng (2005) propose an agent-based mechanism for flexible job shop scheduling. Polyakovskiy and M’Hallah (2014) make use of job agents to solve a weighted earliness and tardiness problem for multiple processing machines. Shen, Member, Wang, and Hao (2006b) and Shen, Hao, Yoon, and Norrie (2006a) provide an overview of agent-based systems for manufacturing scheduling.

Reflecting the present transformation of energy grids and its rising importance, the aspect of energy cost has been finding its way into scheduling research. Concerning this matter, Rager, Gahm, and Denz (2015) analyze energy cost minimizing parallel machine scheduling by means of a centralized evolutionary approach that levels resource utilization. Furthermore, Liu, Dong, Lohse, Petrovic, and Gindy (2014) applied a central NSGA-II for a job shop scheduling problem addressing the two objectives of total weighted tardiness and energy consumption. Similarly, Malakooti, Sheikh, Al-Najjar, and Kim (2013) used a centrally controlled heuristic that is inspired by bats’ hunting behavior for minimizing makespan, tardiness, and energy cost with multiple processors. Lastly, Le and Pang (2013) study reactive scheduling in flexible manufacturing systems with uncertain power consumption with regard to tardiness and energy cost. Furthermore, they illustrate and emphasize their model based on an industrial case study (stamping of metal).

With regard to negotiation protocols for complex contract spaces, several protocol designs are proposed in the literature: In the seminal work of Klein et al. (2003), an iterative protocol is developed that uses strong and weak answers as well as tokens for overcoming split decisions to prevent exaggeration. Extending this work, Fink (2004); 2006) designs an approach that uses accept/reject decisions instead of strong and weak votes and acceptance quotas over time instead of tokens. Also based on the work of Klein et al., Fujita, Ito, and Klein (2014) develop a protocol that is based on a decomposition of the contract space and issue grouping as well as a limit on strong votes to prevent exaggeration. Furthermore, Fujita, Ito, and Klein (2010b); 2012) propose a distributed mediator protocol, in which the agents reveal their private information to several mediators relying on their trustworthiness. Similarly, Fujita, Ito, and Klein (2010a) draw on distributed representative agents that obtain private information from the agents in the group they represent. Besides, there are some works that draw on auctions: Hattori, Klein, and Ito (2007) draw on iterative bidding in order to restrict the relevant search spaces. Lang and Fink (2012d) propose the usage of combinatorial auctions (bidding on sets of items) for selling the decision rights for contract issues. Ito, Klein, and Hattori (2008) develop an auction protocol, in which the agents explore their contract space by local search and, finally, bid for representative contracts. For more related work on multi-issue negotiations, we refer to Lai, Li, Sycara, and Giampapa (2004), who conduct a literature survey.

Preliminary versions of the later used negotiation protocol framework are presented in Lang and Fink (2012a, 2012b, 2012c, 2015). This study is different from previous ones insofar that we elaborate on a self-interested multi-agent paradigm for operational research, introduce and tackle a novel hard scheduling problem, and evaluate the negotiation protocol framework for a relevant decentralized optimization problem. The preceding study mostly considers theoretical aspects of automated negotiations as well as of the protocol and the preceding computational experiments mainly regard an artificial binary contract space (Lang & Fink, 2015).

Although there are a variety of protocol designs in the literature, we are not aware of any protocol that fulfills the following criteria (cf. Sandholm, 1999; Jennings et al., 2001; Lang & Fink, 2015): incentive compatibility, individual rationality, behavioral stability, guaranteed success, simplicity of optimal strategy, privacy, and scalability. The protocol of this study generally complies with those requirements (as discussed in Lang & Fink, 2015). There is no advantage from untruthful behavior, the agents can opt out of the procedure, the optimal strategy is easy to derive and stable, an active contract guarantees that there is no disagreement in the end, very little private information is revealed, the deduction of preferences is virtually impossible, and the protocol can be applied to a large number of agents and contract issues (Lang & Fink, 2015).

Finally, there are a few related studies that deal with negotiating schedules: Dudek and Stadtler (2005) consider specific negotiation approaches for the coordination within supply chain planning. Fink (2004; 2006) uses a negotiation protocol which draws on quotas for the problem of supply chain and project scheduling. Similarly, Lang and Fink (2012b, 2012c) present a quota-based protocol for minimizing the total weighted tardiness of several agents with single and parallel machines. Homberger (2012) describes an evolutionary (μ, λ)-negotiation mechanism for multi-project scheduling. Also considering multi-project scheduling, Confessore, Giordani, and Rismondo (2007) design a market-based coordination system drawing on combinatorial auctions. Fink and Homberger (2013) propose a negotiation protocol, which makes use of concepts from ant colonization optimization, for resource-constrained project scheduling. Liu, Keppens, and Luck (2012) consider negotiations of intercompany scheduling with shared resources.

To our best knowledge, the problem of finding procedures for multi-machine scheduling with autonomous agents is very little covered by the literature yet. Hence, this paper contributes to research by devising and analyzing a comprehensive framework of negotiation mechanisms with different optional building blocks which is applied for a challenging decentralized multi machine scheduling problem with nonlinear tardiness and machine operating cost functions. The proposed methodology particularly considers the restrictions due to the decentralized decision situation with multiple self-interested agents and information asymmetry.

In this section, we present a negotiation protocol which accounts for strategic issues and maintains privacy of the negotiation parties as far as possible. The protocol is improvement-based, i.e., it is designed to seek for joint gains (Raiffa, 1982; Vetschera, 2013). In contrast to related work, our procedure does not require much information revelation and maintains the privacy of the agents. Alongside the basic protocol, we describe optional policy building blocks which may be used to enhance the procedure. Its effects and the impact of the building blocks will be analyzed in the subsequent section by computational experiments.

The global elements of the negotiation protocol may be carried out by an artificial mediator software component which facilitates the interaction between the involved agents. This mediator component has no information about the private information of the different agents (in particular preferences). We do not require that the mediator is a trusted third party but the mediator simply carries out fully disclosed procedural elements of the negotiation protocol. The mediator may be implemented by an open source program (white box software component), which can be duplicated by the agents in parallel. This also allows the implementation of the overall negotiation system according to a peer-to-peer software architecture without any artificial centralized elements.

This protocol is partly based on concepts from the metaheuristic simulated annealing. Related ideas were initially proposed by Klein et al. (2003) and extended by Fink (2004; 2006) as well as Lang and Fink (2015). Simulated annealing involves that a provisional solution is successively adapted by introducing random changes which may be partly accepted even when they lead to deteriorations. In particular, deteriorating moves are accepted by means of a probabilistic criterion which ensures that smaller and in the search process earlier deteriorations are more likely to be accepted. The acceptance probability is controlled by a virtual temperature parameter according to the so-called Metropolis criterion (Cerný, 1985; Kirkpatrick, Gelatt, & Vecchi, 1983; Metropolis, Rosenbluth, Rosenbluth, Teller, & Teller, 1953).

For the considered decentralized scheduling problem with self-interested agents, the overall acceptance of a modified provisional solution (contract) within a negotiation procedure depends on a mutual agreement between the involved autonomous agents. If the agents act greedily by only accepting proposed contracts that seem beneficial for them (i.e., direct improvements), this generally leads to unsatisfactory outcomes as the negotiation usually gets quickly stuck in local optima (Fink, 2006; Lang & Fink, 2012a). Due to private preference information, agents cannot be forced to accept deteriorations by, e.g., using the Metropolis criterion. However, a negotiation protocol can include a rule that requires an agent to accept a certain number of proposals from a set. By introducing such acceptance quotas, agents may be forced to partly accept deteriorations as well and local optima can be overcome. Although there is no virtual temperature parameter, the behavior of simulated annealing processes can be mimicked by means of these quotas.


                           Algorithm 1
                            shows the pseudo code for the Mediated Negotiation Protocol Based on Simulated Annealing (MNP-SA). The protocol requires data about the initial acceptance quota (q; i.e., how many contracts have to be accepted in the first round), the number of negotiation rounds (R), the number of contract candidates per round (ρ), the agent objects/interfaces for each agent (Agents) as well as the building blocks configuration, which we will introduce in the next subsection.

At first, an initial contract draft is generated by some random procedure. The current contract draft ca
                            is called active contract and becomes the final contract when the negotiation stops. For the quota q, an annealing factor βq
                            is calculated which decreases the quota q in each round (see Line 21 of Algorithm 1) and is determined such that just one contract candidate has to be accepted at the end of the negotiation (
                              
                                 q
                                 =
                                 1
                              
                           ). When those initialization steps are done, the iterative part of the algorithm starts. In the beginning of each round, a set of contract candidates is generated (by either the mediator component or by the agents themselves); this results in the set Proposals which consists of the active contract and 
                              
                                 ρ
                                 −
                                 1
                              
                            contract proposals. Specifically, a proposal cc
                            shall be a mutation in the neighborhood of ca
                           . Besides the random generation of an initial contract draft, the mutation constitutes the only problem-specific element of the negotiation protocol. For the considered scheduling application we employ randomly shifting, swapping (see Geiger, 2010), and batch shifting (see Brandt & Bodenstein, 2012). Afterward, each agent 
                              
                                 i
                                 ∈
                                 I
                              
                            has to decide about which contracts he or she accepts and which not (binary vector 
                              
                                 
                                    Dec
                                    →
                                 
                                 i
                              
                           ). Of course, this decision is subject to the current acceptance quota q. By using the individual decision vectors 
                              
                                 
                                    
                                       Dec
                                       →
                                    
                                    i
                                 
                                 ,
                              
                            the overall accepted contracts are determined. A contract must be individually accepted by a certain number of agents (Threshold) for being accepted by the group as a whole (e.g., unanimity). Finally, one contract from the set of overall accepted contracts is randomly selected and becomes the new active contract draft (or the incumbent active contract is maintained in case that the set is empty). The negotiation starts over with new proposals and, eventually, after R negotiation rounds, the last active contract draft results in the final contract c.

The procedure that has been described in the previous subsection may be enhanced by four additional optional building blocks. (i) In the basic protocol, we assumed that the initial contract is determined at random. This may have the drawback that the starting point of the negotiation process may be rather bad and some particular agent(s) may by chance be in a distinctly better initial position than others. To alleviate this problem, the agents could determine their starting contract in a prenegotiation. We implemented this idea as follows: a number of random contracts are generated and the agents determine the actual starting contract by means of a pairwise elimination voting. (ii) The contract mutation (contract proposing) can be executed randomly or even partly by the agents. In case that the agents are allowed to propose contracts, their strategies must be considered once again. In our implementation of the agent proposal case, one agent controls half of the contract candidates in each round by selecting the individually best ones from a set of randomly mutated contracts that is generated by the mediator component. This may also be adapted by letting the agents completely determine contract proposals on their own with possible limits regarding the computation time and the distance to the active contract. The rest of the proposals is generated randomly by the mediator to prevent easy advantage seeking. The proposing agent changes every iteration in a round robin fashion. (iii) So far, we considered binary decisions only: accept or reject. This can be enhanced by introducing a third state: accept due to quota. This tertiary logic can express that no improvement is achieved. Thus, if all agents accept a candidate only because of the quota, the proposal would still be rejected by the negotiation protocol. On the one hand, this can prevent that all agents are worse off, but, on the other hand, it reveals more information which might be unwanted due to privacy considerations. (iv) Finally, the acceptance threshold has to be defined. Related work proposes unanimity (J) which we use as a default threshold (see Klein et al., 2003; Fink, 2006). As a building block, we also test simple majority as threshold (
                              
                                 ⌈
                                 (
                                 J
                                 +
                                 1
                                 )
                                 /
                                 2
                                 ⌉
                              
                           ).

In our simulations, we assume that the privacy of preferences should be maintained. Based on this supposition, the behavior of the agents regarding the acceptance of contract proposals is given as follows:

                           Proposition 2
                           
                              The best strategy for an agent unaware of other agents’ preferences is to accept his or her best contracts out of the proposal set.
                           

According to the expected utility theory (von Neumann & Morgenstern, 1944), an agent chooses the contracts with the highest risk-preference adjusted expected utility. Thus, the proposals are to be weighted with a vector 
                           
                              
                                 b
                                 i
                              
                              →
                           
                         depicting an agent’s belief that a contract is generally accepted and a utility function U(•) measuring the cost savings and risk preference: 
                           
                              
                                 
                                    arg
                                    max
                                 
                                 
                                    
                                       c
                                       c
                                    
                                    ∈
                                    Proposals
                                 
                              
                              
                                 
                                    b
                                    i
                                 
                                 →
                              
                              *
                              U
                              
                                 (
                                 
                                    C
                                    i
                                 
                                 
                                    (
                                    
                                       c
                                       c
                                    
                                    )
                                 
                                 )
                              
                           
                        . Since an agent has no information about private preferences of the other agents, the beliefs are not distinguishable and, thus, uniform 
                           
                              
                                 
                                    b
                                    i
                                 
                                 →
                              
                              ↦
                              
                                 b
                                 ¯
                              
                           
                        . The decision is now reduced to 
                           
                              
                                 
                                    arg
                                    max
                                 
                                 
                                    
                                       c
                                       c
                                    
                                    ∈
                                    Proposals
                                 
                              
                              
                                 b
                                 ¯
                              
                              *
                              U
                              
                                 (
                                 
                                    C
                                    i
                                 
                                 
                                    (
                                    
                                       c
                                       c
                                    
                                    )
                                 
                                 )
                              
                           
                         which is equivalent to choosing the best contract or contracts, respectively: 
                           
                              
                                 
                                    arg
                                    max
                                 
                                 
                                    
                                       c
                                       c
                                    
                                    ∈
                                    Proposals
                                 
                              
                              U
                              
                                 (
                                 
                                    C
                                    i
                                 
                                 
                                    (
                                    
                                       c
                                       c
                                    
                                    )
                                 
                                 )
                              
                           
                        . This corresponds to 
                           
                              
                                 
                                    arg
                                    min
                                 
                                 
                                    
                                       c
                                       c
                                    
                                    ∈
                                    Proposals
                                 
                              
                              
                                 C
                                 i
                              
                              
                                 (
                                 
                                    c
                                    c
                                 
                                 )
                              
                           
                        .□

Likewise, it can be shown that the agents also select and propose their best possible contracts in case that the agent proposal extension is used.

Firstly, we use as a benchmark negotiation protocol a more conventional approach that is also based on iterative proposals that mutate an active contract. However, in this benchmark negotiation protocol (BM), proposals are solely generated by the agents and we tried to incorporate a minimal set of rules. At first, an initial active contract is determined by a prenegotiation like the building block explained in Section 4.1.2. In each negotiation round, the agents propose mutations of the active contract where every agent proposes about the same number of proposals (possible remainders are distributed randomly). Furthermore, a proposal can become the active contract in case of a unanimous acceptance. Finally, the agents are not governed by further rules and can freely decide and act.

Secondly, we compare to results that are obtained by applying state-of-the-art multi-criteria metaheuristics for corresponding hypothetical centralized decision problems (see Section 5.1.2). We emphasize that centralized procedures neglect self-interested agents and information asymmetry.

In the following we present the evaluation of the proposed solution mechanisms. At first, we introduce the simulation setup and, afterward, the computational results. Finally, we discuss the findings.

For the simulation experiments, 90 problem instances have been created. At this, we draw on the scientific computing application (see Section 2.2) and consider a scenario where computing jobs have to be processed on computing machines.

Each problem instance involves 60 jobs per machine and there are between 5 and 20 machines. This results in 300–1200 jobs in total. A job j requires the resource with an amount of rj
                            ∈ {2, 4, 8, 12, 24} resembling processor cores. The number of cores is randomly chosen, but must not exceed the problem instance’s machine with the largest capacity (rj
                            ≤ max 
                              m
                           (cap
                              m
                           )). The standardized processing time of the job 
                              
                                 p
                                 j
                                 s
                              
                            is a uniformly distributed integer in the interval 
                              
                                 U
                                 [
                                 1
                                 ,
                                 10
                                 ]
                              
                            (standard processing speed is 2.00 gigahertz). In accordance with Akturk and Ozdemir (2000) and Mönch, Balasubramanian, Fowler, and Pfund (2005), the release times as well as the due dates are derived from the resource weighted sum of all processing times 
                              
                                 TP
                                 =
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       J
                                    
                                 
                                 
                                    p
                                    j
                                 
                                 *
                                 
                                    r
                                    j
                                 
                                 ,
                              
                            the total capacity 
                              
                                 CAP
                                 =
                                 
                                    ∑
                                    
                                       m
                                       ∈
                                       M
                                    
                                 
                                 
                                    cap
                                    m
                                 
                                 ,
                              
                            and two parameters (ϕ, φ). The release time is given by 
                              
                                 
                                    s
                                    j
                                 
                                 =
                                 ϕ
                                 *
                                 
                                    TP
                                    CAP
                                 
                                 *
                                 R
                                 ,
                              
                            where ϕ ∈ {0.5, 0.75} and 
                              R
                            is a random number with 
                              
                                 R
                                 ∼
                                 U
                                 [
                                 0
                                 ,
                                 1
                                 )
                              
                           . For the calculation of the due date, we introduce a slack time which is 
                              
                                 
                                    ψ
                                    j
                                 
                                 =
                                 φ
                                 *
                                 
                                    TP
                                    CAP
                                 
                                 *
                                 R
                                 .
                              
                            In the generated problem instances, the slack parameter φ can have the values φ ∈ {0.1, 0.2, 0.4}. The actual due date is then calculated by 
                              
                                 
                                    d
                                    j
                                 
                                 =
                                 
                                    s
                                    j
                                 
                                 +
                                 
                                    p
                                    j
                                 
                                 +
                                 
                                    ψ
                                    j
                                 
                                 .
                              
                            Both, sj
                            and dj
                           , are integers, which was generated by rounding. According to the usual practice, the tardiness weight function’s parameters (
                              
                                 
                                    α
                                    j
                                    w
                                 
                                 ,
                                 
                                    β
                                    j
                                    w
                                 
                                 ,
                                 
                                    γ
                                    j
                                    w
                                 
                              
                           ) are randomly generated (
                              
                                 
                                    α
                                    j
                                    w
                                 
                                 ,
                                 
                                    γ
                                    j
                                    w
                                 
                              
                            are integers, 
                              
                                 β
                                 j
                                 w
                              
                            is a decimal number): 
                              
                                 
                                    α
                                    j
                                    w
                                 
                                 ∼
                                 U
                                 
                                    [
                                    1
                                    ,
                                    5
                                    )
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    β
                                    j
                                    w
                                 
                                 ∼
                                 U
                                 
                                    [
                                    0.75
                                    ,
                                    1.25
                                    )
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    γ
                                    j
                                    w
                                 
                                 ∼
                                 U
                                 
                                    [
                                    0
                                    ,
                                    25
                                    )
                                 
                              
                           .

The relevant parameters of the machines are the energy consumption structure (
                              
                                 
                                    α
                                    m
                                    E
                                 
                                 ,
                                 
                                    β
                                    m
                                    E
                                 
                                 ,
                                 
                                    γ
                                    m
                                    E
                                 
                              
                           ), the machine resource capacity (rm
                           ), the operating speed os
                              m
                           , and the tariff (Γ). For the parameterization of the machines, we used empirical data of various real-world computing servers according to the SPEC (2008). The report provides performance-to-power-ratios for 182 common server systems, from which the allometric power functions were derived (Bodenstein et al., 2012). Subsequently, we randomly picked M ∈ {5, 10, 20} servers from different manufacturers, each containing between 2 and 48 cores.

Moreover, we include a three stage tariff as it is often used for industrial power contracts (Strbac, 2008). The tariff Γ(t) is equal to 
                              
                                 0.25
                                 
                                 ∀
                                 
                                 t
                                 ∈
                                 T
                                 |
                                 {
                                 t
                                 
                                 mod
                                 
                                 300
                                 <
                                 100
                                 }
                                 ,
                              
                           
                           
                              
                                 0.2
                                 
                                 ∀
                                 
                                 t
                                 ∈
                                 T
                                 |
                                 {
                                 100
                                 ≤
                                 t
                                 
                                 mod
                                 
                                 300
                                 <
                                 200
                                 }
                                 ,
                              
                           
                           
                              
                                 0.15
                                 
                                 ∀
                                 
                                 t
                                 ∈
                                 T
                                 |
                                 {
                                 200
                                 ≤
                                 t
                                 
                                 mod
                                 
                                 300
                                 <
                                 300
                                 }
                              
                           . The three energy price stages stand for peak and off-peak phases such as peak demand (e.g., noon with high prices), regular demand (e.g., afternoon with regular prices), and oversupply phases (e.g., at night with low prices) (Mohsenian-Rad et al., 2010). Such dynamic pricing schemes are becoming increasingly more important in the context of smart electrical grids (Davito, Tai, & Uhlaner, 2010).

For each job and machine parameterization, five problem instances were created resulting in 
                              
                                 5
                                 ×
                                 2
                                 [
                                 ϕ
                                 ]
                                 ×
                                 3
                                 [
                                 φ
                                 ]
                                 ×
                                 3
                                 [
                                 M
                                 ]
                                 =
                                 90
                              
                            problem instances in total.

We choose three agents as basic setup (except for Experiment 4), since, on the one hand, this allows testing the simple majority building block, and, on the other hand, the computational effort to approximately obtain a Pareto frontier (discrete Pareto set) is still feasible. The agents were assigned to the jobs in turn.

Besides the individual tardiness cost, the energy cost has to be allocated among the agents. We used an allocation scheme (except for Experiment 4) where the agents’ contribution depends on their relative resource needs, i.e., 
                              
                                 
                                    EC
                                    i
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             J
                                             :
                                             
                                                a
                                                j
                                             
                                             =
                                             i
                                          
                                       
                                       
                                          r
                                          j
                                       
                                       *
                                       
                                          p
                                          j
                                       
                                       
                                          (
                                          π
                                          )
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             J
                                          
                                       
                                       
                                          r
                                          j
                                       
                                       *
                                       
                                          p
                                          j
                                       
                                       
                                          (
                                          π
                                          )
                                       
                                    
                                 
                                 *
                                 EC
                              
                           .

For measuring the Pareto performance of a contract c, we normalized the results with the best solution 
                              
                                 C
                                 i
                                 best
                              
                            obtained for agent i and computed the Euclidean distance to the nearest point in the Pareto set (see Baarslag et al., 2013):

                              
                                 (7)
                                 
                                    
                                       Pareto
                                       
                                          (
                                          c
                                          )
                                       
                                       =
                                       
                                          min
                                          
                                             
                                                c
                                                ′
                                             
                                             ∈
                                             ParetoSet
                                          
                                       
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         
                                                            C
                                                            i
                                                         
                                                         
                                                            (
                                                            c
                                                            )
                                                         
                                                         −
                                                         
                                                            C
                                                            i
                                                         
                                                         
                                                            (
                                                            
                                                               c
                                                               ′
                                                            
                                                            )
                                                         
                                                      
                                                      
                                                         C
                                                         i
                                                         best
                                                      
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

To obtain a high-quality approximation of the Pareto set, we executed massive multi-objective criteria optimization runs using the Non-Dominated Sorting Genetic Algorithm-II (NSGA-II; see Deb, Pratap, Agarwal, and Meyarivan, 2002), a multi-objective Simulated Annealing approach (MOSA; cf. Ulungu, Teghem, Fortemps, and Tuyttens, 1999), a multi-objective evolutionary algorithm approach (MOEA; cf. Zitzler and Thiele, 1999) as well as multi-objective variants of Iterated Local Search (cf. Geiger, 2007) and Late-Acceptance Hill Climbing (cf. Burke & Bykov, 2012). The NSGA-II is a population-based evolutionary method that punishes proximity of solutions and, by doing so, it is able to find a broad Pareto frontier. Additionally, we applied another evolutionary approach (MOEA) by variable objective weighting. We aggregated the individual target functions by randomly assigning weights (0 ≤ ow
                              i
                            ≤ 1; 
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    ow
                                    i
                                 
                                 =
                                 1
                              
                           ) to the objective values in each run. By repeating this, we were able to explore different regions of the Pareto frontier, which augmented the set of solutions found by the NSGA-II. The variable objective weighting procedure was analogously applied with the Simulated Annealing metaheuristic (see Kirkpatrick et al., 1983), Iterated Local Search (see Lourenço, Martin, & Stützle, 2003) and Late-Acceptance Hill Climbing (see Burke & Bykov, 2012). The individual optimum of an agent i was determined by assigning a weight 
                              
                                 
                                    ow
                                    i
                                 
                                 =
                                 1
                              
                            and, respectively, 
                              
                                 
                                    ow
                                    
                                       −
                                       i
                                    
                                 
                                 =
                                 0
                                 
                                 
                                    (
                                    ∀
                                    
                                       −
                                       i
                                    
                                    ∈
                                    I
                                    
                                    |
                                    −
                                    i
                                    ≠
                                    i
                                    )
                                 
                              
                            to the objective functions, i.e., agent i’s target function served as the sole objective.

In the runs searching for Pareto-optimal solutions, we gathered a total of more than 2.4 million outcomes for 90 problem instances of which approximately 120,000 were eventually nondominated (i.e., on average more than 1300 nondominated solutions per problem instance). Furthermore, we included nondominated results of the negotiation simulations in the Pareto set. This means that we collected all data of the optimization runs and negotiation simulations before we conducted a domination reduction that identifies our Pareto frontier approximation.

To measure the social cost of a solution contract c, we computed the ratio of the resulting social cost and the best found solution:

                              
                                 (8)
                                 
                                    
                                       SC
                                       
                                          (
                                          c
                                          )
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                C
                                                i
                                             
                                             
                                                (
                                                c
                                                )
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                C
                                                i
                                             
                                             
                                                (
                                                
                                                   c
                                                   *
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           with 
                              
                                 
                                    
                                       c
                                       *
                                    
                                    =
                                    arg
                                    
                                       min
                                       c
                                    
                                 
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    C
                                    i
                                 
                                 
                                    (
                                    c
                                    )
                                 
                              
                           . This concept is also known as the price of anarchy that measures to what extent the self-interest of the agents deteriorates the solutions compared to the imaginary outcomes determined centrally by a benevolent dictator with full information (Roughgarden & Tardos, 2007). We approximated the social cost minimum (i.e., the social welfare maximum) using different metaheuristics—namely, Simulated Annealing (see Kirkpatrick et al., 1983), Iterated Local Search (see Lourenço et al., 2003), Late-Acceptance Hill Climbing (see Burke & Bykov, 2012), and a Memetic Algorithm (see Moscato, 1989)—as well as the results of the Pareto search and the negotiations themselves.

Using the Pareto distance and the social cost, we derived several figures for evaluation: (1) Avg—the mean figure for all problem instances, (2) CoV—coefficient of variation, i.e., standard deviation divided by the mean, (3) OnFR—on front ratio, i.e., the percentage number of nondominated solutions obtained by a protocol (used with Pareto distance only), (4) Best—the smallest social cost, (5)–(7) M = {5, 10, 20}—the respective Pareto and social cost results grouped by the number of machines M (and, thereby, number of jobs: 
                              
                                 J
                                 =
                                 M
                                 *
                                 60
                              
                           ).

We tested the results for statistical significance by the Wilcoxon–Mann–Whitney test (WMW-test; Mann and Whitney, 1947), using a single-sided hypothesis. That is, we tested whether the mean of one configuration is statistically significantly smaller than the mean of another configuration (significance level: p-value ≤ 5 percent).

@&#EXPERIMENTS@&#

In this section, we present the findings of our computational experiments. In total, we simulated more than 6500 negotiations grouped in four experiments. The protocol and its configuration is encoded by a character string: S—MNP-SA protocol, N—without quotas, Q—with quotas, P—with prenegotiation, A—proposals partly made by agents, 3—three-valued logic, and M—majority rule instead of unanimity. Finally, BM encodes the benchmark negotiation protocol.


                           
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                       
                                          
                                             Number of proposals (
                                                ρ
                                             )
                                          20
                                          
                                             Number of rounds (
                                                R
                                             )
                                          500k
                                       
                                       
                                          
                                             Number of agents (
                                                I
                                             )
                                          3
                                          
                                             Energy cost distribution
                                          
                                          consumption-based
                                       
                                    
                                 
                              
                           
                        

The first experiment’s purpose is to identify successful building blocks. We have tested several policies on their own as well as in combination.

As the computational results presented in Table 1
                            show, none of the configurations of the MNP-SA performs satisfactorily without the quota rule. The benchmark protocol achieves results similar to the basic MNP-SA without quotas (the two approaches are similarly structured). Furthermore, the majority extension leads to the worst outcomes and is clearly not suited in this setting. In contrast, the quota rule yields significantly better outcomes which are close to the Pareto frontier and the social cost minimum. Looking at the single building blocks, especially the three-valued logic extension leads to Pareto as well as social cost improvements. Furthermore, agent-based proposals can decrease the variation and yield more stable results. The use of prenegotiation seems to achieve slightly more stable results but, basically, it is comparable to the SQ configuration. From the WMW-test, we obtain a statistically significant superiority of SQ3 compared to SQ, SQA, and SQP in terms of Pareto performance and social cost. Furthermore, SQA statistically outperforms SQ in terms of social cost. Considering combinations of building blocks, SQA3 leads to even more stable results and SQPA3 reaches relatively good solutions but cannot outperform SQ3 with statistical significance.

Generally, the protocol can handle problems with 5–10 machines (300–600 jobs) relatively well. However, the large instances with 20 machines (1200 jobs) are harder to solve and show substantially worse results. Moreover, the procedures partly found outcomes that have a very small price of anarchy: the best found solutions are 1.0percent above the centrally approximated social cost optimum.

Exemplary negotiation histories for selected protocol configurations with two agents are illustrated in Fig. 1
                           . In this figure, one data point is plotted after every thousand rounds. The basic MNP-SA (SQ) shows a lot of deteriorations and moves in circles toward the Pareto frontier. The longer the negotiation continues the less deteriorations are accepted (due to the decreasing quota). Largely, the same holds true for the same protocol including agent-based proposals (SQA); however, the agent-based proposals lead to a more straightforward movement toward the frontier. The BM makes giant improving leaps at the beginning but achieves just very small gains after a few rounds—probably due to irresolvable conflicts of interest.

For the remainder of the paper, we focus on the following subset of configurations that consists of the basic protocols as well as successful strategy configurations: SQ, SQ3, SQA, and SQA3.


                           
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                       
                                          
                                             Number of proposals (
                                                ρ
                                             )
                                          10–40
                                          
                                             Number of rounds (
                                                R
                                             )
                                          250k–1M
                                       
                                       
                                          
                                             Number of agents (
                                                I
                                             )
                                          3
                                          
                                             Energy cost distribution
                                          
                                          Consumption-based
                                       
                                    
                                 
                              
                           
                        

The second experiment tests different parameterizations of the number of proposals and the number of rounds in comparison with the chosen parameters of Experiment 1. Here, we use 
                              
                                 ρ
                                 =
                                 10
                              
                            proposals and 
                              
                                 R
                                 =
                                 1
                              
                           M rounds as well as 
                              
                                 ρ
                                 =
                                 40
                              
                            proposals and 
                              
                                 R
                                 =
                                 250
                              
                           k rounds—both yield the very same number of total proposals like Experiment 1, i.e., 10M proposals throughout the negotiation.

The findings of Experiment 2 are shown in Table 2
                           . Having more proposals per negotiation round, but less rounds in total, is not advantageous for the MNP-SA nor the BM—the results become worse with this parameterization. In the case of having less proposals per rounds but more rounds in total, the outcomes become much better. We use the MNP-SA parameter values 
                              
                                 ρ
                                 =
                                 10
                              
                            and 
                              
                                 R
                                 =
                                 1
                                 ,
                                 000
                                 ,
                                 000
                              
                            for the remainder of this paper.


                           
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                       
                                          
                                             Number of proposals (
                                                ρ
                                             )
                                          10
                                          
                                             Number of rounds (
                                                R
                                             )
                                          10k–5M
                                       
                                       
                                          
                                             Number of agents (
                                                I
                                             )
                                          3–19
                                          
                                             Energy cost distribution
                                          
                                          Consumption-based
                                       
                                    
                                 
                              
                           
                        

In the third experiment, we analyze the scalability of the configurations regarding the number of agents and negotiation rounds. Fig. 2
                            shows the Pareto performance subject to the number of negotiation rounds. Since the findings are basically the same for the social cost performance, we omitted a separate presentation of those results.

If there are very few rounds only (10k), the basic protocol version (SQ) performs comparably to the benchmark procedure. Furthermore, SQ3 achieves similar outcomes as well, but is outperformed by the agent-based proposal configurations (SQA, SQA3) which also perform comparably among themselves. All configurations attain better results with more negotiation rounds; however, the marginal improvements seem to be decreasing. After 5M negotiation rounds, the advanced configurations mostly reached the Pareto frontier: SQ3, SQA, and SQA3 have a mean distance to the Pareto frontier between 0.6 percent and 0.4 percent and result in a nondominated contract in 85.6 percent–88.9 percent of the simulations (social cost: 102.0 percent–101.9 percent). The BM comes off far behind (Pareto: 13.5 percent; on front ratio: 4.4 percent; social cost: 108.4 percent).


                           Fig. 3
                            depicts the development of the social cost subject to the number of agents (for 
                              
                                 3
                                 ,
                                 5
                                 ,
                                 …
                                 
                                 ,
                                 19
                              
                            agents). Since the approximation of the Pareto frontier becomes very hard to calculate with more agents, we make use of the social cost performance here. Unsurprisingly, the social cost increases when there are more agents in place, although the total number of jobs to be scheduled stays the same. This results from the fact that more agents are more difficult to coordinate and there is a larger conflict of interests due to disparate preferences. However, the deterioration of the MNP-SA turns out to be relatively small, and the social cost appears to go up not as vigorously as with the BM. With 19 agents, each pursuing his or her own cost objective depending on his or her assigned jobs, SQA3 still attains a solution that on average just suffers from a mark-up of 12.8 percent on the social cost which is a relatively low price of anarchy. In the best case, we obtained a contract involving 19 parties with a social cost of 103.2 percent only.


                           
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                       
                                          
                                             Number of proposals (
                                                ρ
                                             )
                                          10
                                          
                                             Number of rounds (
                                                R
                                             )
                                          1M
                                       
                                       
                                          
                                             Number of agents (
                                                I
                                             )
                                          3
                                          
                                             Energy cost distribution
                                          
                                          Negotiated
                                       
                                    
                                 
                              
                           
                        

In the fourth and final experiment, we refrained from the scheme that the energy cost are distributed based on the respective jobs’ resource consumption. Instead of such a ratio, we integrated the energy cost allocation as a further negotiation issue. For this purpose, we have added a payment vector to the contract determining which shares of the cost have to be covered by which agents, which is mutated by redistributing a small percentage from one randomly chosen agent to another. Table 3
                            shows the results. BM does not yield any satisfying outcomes and suffers from a severe decline compared to the consumption-based allocation. In contrast, MNP-SA is able to obtain almost exclusively Pareto optimal outcomes. 95.6 percent of the negotiations reached a nondominated solution. Considering the 30 smaller problem instances with 5 machines and 300 jobs, SQA3 missed a nondominated solution just a single time. The Pareto performance was between 2.8 percent and 0.6 percent; on the other hand, the price of anarchy (social cost) is substantially higher compared to Experiment 2 with a very high significance.

Until now, being close at the Pareto frontier basically meant having a little social cost as well. To analyze this in more detail, Table 3 also compares the Gini coefficients (GC) for consumption-based energy cost allocation and negotiated energy cost allocation. The GC is a measurement of inequality, i.e., with a GC of 0, every agent has the very same cost and, with a GC of 1, a single agent covers the whole cost. As the data show, the consumption-based allocation leads to relatively homogeneous outcomes. The very low GC partly results from the fact that there is a base cost, i.e., a large part of the cost cannot be prevented. In the case of integrating the allocation in the negotiation, the BM still achieves comparable results. However, the MNP-SA, which also attains very good results, suffers from a huge disparity. Consequently, the improvements are prosperous for individual agents and are borne by others.

The findings show that the protocol is able to find high quality solutions although it does not make use of aggregated information and is subject to strategic behavior. In the experiments, the agents evaluate a tiny fraction of the contract space of this complex problem and provide specific acceptance and rejection signals only. Nevertheless, we found that the MNP-SA may deliver first-class solution quality. Beyond the introduction of quotas, we identified agent-based proposal and three-valued logic as successful policies for the MNP-SA. The majority acceptance extension deteriorates the results significantly, whereas the prenegotiation does not show a substantial impact. However, the latter might find fairer outcomes which we did not analyze in detail. As a small drawback, agent-based proposals require more communication as well as computation effort on the side of the agents.

Furthermore, the experiments indicate that the number of proposals and rounds can have a substantial impact on the eventual quality of the contracts. If there is sufficient computation time, the protocol often reaches the Pareto frontier, as shown for three agents. Moreover, a larger number of participating agents leads to an increased complexity of the problem and to a higher price of anarchy. As the last experiment shows, the integration of the energy cost allocation into the negotiation results in a very high ratio of nondominated outcomes.

Besides these beneficial findings, there are also some limitations of the computational study. First of all, a large part of the energy cost are unavoidable and there are also considerable tardiness costs. While this does not affect the assessment concerning achieving Pareto-efficiency or not, it scales the absolute figures of the outcomes and, hence, reduces the relative difference between the results (although we used the individual or global best outcomes for normalization). The second limitation addresses the results of Experiment 4, in which the protocol found a great number of nondominated contracts. Although we made huge efforts for determining the Pareto frontier (more than 2.4M solutions obtained with five different multi-criteria metaheuristics; see Section 5.1.2), Experiment 4 draws on slightly modified assumptions which can affect the results notably. The centralized procedures as well as the other negotiation simulations suppose consumption-based energy allocation in contrast to Experiment 4. This experiment can achieve every allocation of energy cost which is equivalent to allowing for side payments among the negotiation parties. By means of side payments, the agents can obtain solutions that are not feasible for the consumption-based energy allocation. That is why the comparability and, thus, the interpretation of the Pareto results of Experiment 4 have to be done with caution. Nonetheless, since we compare different protocols and configurations, the results still have external validity, because all procedures draw on the very same assumptions within this experiment. However, the dominance of the solutions from Experiment 4 can lead to greater gaps between the discrete Pareto points and result in worse distance figures for Experiments 1–3.

Finally, concerning the comparison of negotiation methods with multi-criteria procedures, a negotiation problem may be considered as a multi-criteria problem with additional fundamental difficulties. That is, negotiation scenarios suffer from strategic interactions of autonomous self-interested agents and lack of revealed truthful information. Thus, although there is a close relation between an agent and an objective, there is no way to centrally dictate the system. A central authority can just specify reasonable and verifiable rules of the negotiation protocol. This is why decentralized decision problems (such as the considered multi-agent multi-machine scheduling problem) are different from classical multi-criteria problems. Nonetheless, one may still compare the performance of negotiation protocols, with results that are biased by individual interests, with centralized multi-criteria procedures (see Section 5.1.2). We found that the obtained solutions of the negotiation procedures partly even dominate results from the centralized approaches. By using centralized approaches, we generated more than 2.4M solutions of which 119,087 were nondominated. In the negotiation simulations, we obtained 5040 results for the MNP-SA if we partly omit Experiments 3 and 4.
                           1
                        
                        
                           1
                           Experiment 3 partly studies more than three agents and Experiment 4 draws on different assumptions. In the latter, the MNP-SA dominates 11,229 solutions.
                         Despite the mentioned strategic and informational issues, the negotiation results dominate 4543 centralized results which were nondominated so far. This shows that negotiations with appropriate rules and mechanism design may keep up with centralized approaches despite self-interested agents and information asymmetry.

@&#CONCLUSIONS AND FUTURE WORK@&#

This paper studies the scheduling of competing jobs with due dates on multiple heterogeneous machines by multiple agents. As a feature, the model incorporates not only tardiness cost but also machine operating cost (or energy cost). The operating cost is subject to a time-dependent tariff and the machine’s utilization. Furthermore, we argue that tardiness as well as energy cost functions may be nonlinear. This already complex problem is exacerbated by selfish strategic considerations of the involved agents and their unwillingness to share relevant information. To overcome the latter, we present and evaluate a negotiation protocol framework that is partly inspired by metaheuristic concepts and is designed to achieve beneficial outcomes in terms of Pareto efficiency and social cost.

For evaluation purposes, we present a computational study with problems that include 300–1200 jobs, 5–20 machines, and 3–19 agents. The results of the computational experiments indicate that the proposed methods are capable to find (near) Pareto-efficient outcomes that also show a good performance in terms of social cost. Although the protocol is mainly generic, parameters such as the number of proposals or negotiation rounds have a significant impact on the eventual quality of the contracts. Even when there are a large number of agents, the measured price of anarchy is rather small and the outcomes are still relatively close to the best centrally determined solutions.

Summarizing, the paper contributes to research by the following: Firstly, we introduce a new challenging scheduling problem that incorporates nonlinear tardiness cost as well as machine operating cost functions for heterogeneous machines, which is substantiated by real-world data. Furthermore, the presented problem also considers the presence of different stakeholders (agents), which are self-interested and pursue their individual aims. Self-interested agents are unlikely to share private information with other agents or a central authority and act strategically as well as non-cooperatively. This reflects the reality of intercompany planning and scheduling. Besides the advancement of scheduling theory and applications, the paper enhances the knowledge on generic negotiation procedures. We introduce new policy building blocks and evaluate the negotiation protocol for multi-agent scheduling. As shown, despite having very limited information and suffering from self-interested agents, the protocol is able to obtain beneficial results similar to centralized approaches—even for this very hard scheduling problem.

Future work will be to further elaborate the protocol by developing and evaluating additional building blocks. For instance, the protocol could incorporate social choice mechanisms such as eliminating runoff votings in case of an equal amount of approvals. Moreover, the validity of the findings from this study should be assessed by considering other kinds of applications. Those applications might be within the scheduling domain, but the generic protocol might also be applied to other realms such as routing problems. Concerning the presented kind of scheduling problem, the performance will be analyzed subject to the parameters of the problem instances, i.e., we will evaluate the impact of the release time and due date tightness. Related to this, we will work out a decision support system for protocol selection. If protocol configurations perform differently subject to given problem instance characteristics, then the protocol can be chosen dynamically. This can be carried out by means of machine learning algorithms that are able to identify such performance-affecting problem properties. With regard to the underlying agent behavior, the agents could evaluate their improvements prospectively (e.g., by means of Markov chains), i.e., they value their potential improvement in future rounds rather than their current improvement. For the given scenario, such a prospective behavior requires, however, an immense computational effort due to the enormous combinatorial possibilities. Future work may also incorporate the empirical confirmation of the hypotheses of nonlinear cost functions. Another interesting aspect is the consideration of an unbalanced job allocation among the agents or mixed objective functions for the agents. Finally, beyond efficiency considerations, fairness among the agents (e.g., by means of the Gini coefficient) will be a criterion in future work.

@&#REFERENCES@&#

