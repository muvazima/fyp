@&#MAIN-TITLE@&#A memetic algorithm for the Multi Trip Vehicle Routing Problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A split procedure for the mutli trip vehicle routing problem is proposed.


                        
                        
                           
                           A new tailored local search operator is introduced.


                        
                        
                           
                           Results outperform previous works with respect to solution quality.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi Trip Vehicle Routing Problem

Memetic algorithm

City logistics

@&#ABSTRACT@&#


               
               
                  We consider the Multi Trip Vehicle Routing Problem, in which a set of geographically scattered customers have to be served by a fleet of vehicles. Each vehicle can perform several trips during the working day. The objective is to minimize the total travel time while respecting temporal and capacity constraints.
                  The problem is particularly interesting in the city logistics context, where customers are located in city centers. Road and law restrictions favor the use of small capacity vehicles to perform deliveries. This leads to trips much briefer than the working day. A vehicle can then go back to the depot and be re-loaded before starting another service trip.
                  We propose an hybrid genetic algorithm for the problem. Especially, we introduce a new local search operator based on the combination of standard VRP moves and swaps between trips. Our procedure is compared with those in the literature and it outperforms previous algorithms with respect to average solution quality. Moreover, a new feasible solution and many best known solutions are found.
               
            

@&#INTRODUCTION@&#

The well known Vehicle Routing Problem (VRP) is an 
                        
                           NP
                        
                     -hard combinatorial optimization problem where a set of geographically scattered customers has to be served by a fleet of vehicles. An implicit assumption of the VRP is that each vehicle can perform only one route in the planning horizon. This assumption is not realistic in several practical situations. For the distribution of goods in city centers, for example, small vehicles are generally preferred. Because of this capacity limitation, they daily perform several short tours. This problem is referred to as the Multi Trip VRP (also VRP with multiple use of vehicles, Taillard, Laporte, & Gendreau (1996), VRP with multiple trips, Petch & Salhi (2004) or VRP with multiple routes, Azi, Gendreau, & Potvin (2007)). In the rest of the paper it will be indicated as MTVRP.

The MTVRP is defined on an undirected graph G
                     =(V, E), where V
                     ={0,1,…,
                     n} is the set of vertices and E
                     ={(i, j) ∣i, j
                     ∈
                     V, i
                     <
                     j} is the set of edges. It is possible to travel from i to j, incurring in a travel time t
                     
                        ij
                     . Vertex 0 represents the depot where a fleet of m identical vehicles with limited capacity Q is based. Vertices 1,…,
                     n represent the customers to be served, each one having a demand q
                     
                        i
                     . A time horizon T
                     
                        H
                      exists, which establishes the duration of the working day. Overtime is not allowed. It is assumed that Q, q
                     
                        i
                      and T
                     
                        H
                      are nonnegative integers.

The MTVRP calls for the determination of a set of routes and an assignment of each route to a vehicle, such that the total travel time is minimized and the following conditions are satisfied:
                        
                           (a)
                           each route starts and ends at the depot,

each customer is visited by exactly one route,

the sum of the demands of the customers in any route does not exceed Q,

the total duration of the routes assigned to the same vehicle does not exceed T
                              
                                 H
                              .

It is also supposed that each customer i could be served by a return trip, i.e, t
                     0i
                     
                     +
                     t
                     
                        i0
                     ⩽
                     T
                     
                        H
                      and q
                     
                        i
                     
                     ⩽
                     Q.

Few papers in the literature address the MTVRP and no efficient population-based algorithm were proposed. Our goal is to fill this gap proposing a memetic algorithm able to compete with previous works. Our interest in the MTVRP raises from the MODUM project,
                        1
                        
                           http://www-lipn.univ-paris13.fr/modum.
                     
                     
                        1
                      where mutualized distribution in city centers is explored. The contribution of this paper is threefold:
                        
                           (1)
                           A high-performing memetic algorithm is proposed: the results found are the new state-of-the-art on classical instances for the MTVRP. Moreover, an instance has been solved for the first time, i.e., a feasible solution has been found.

An adaptation of the Split procedure (Prins, 2004) to segment a chromosome into a MTVRP solution is developed.

A new local search (LS) operator, that combines standard VRP moves and re-assignment of trips to vehicles is introduced.

This paper is organized as follows. In Section 2 the literature on the MTVRP is reviewed. Section 3 describes the proposed algorithm. Section 4 details the Combined LS. Results are reported in Section 5. Conclusions and perspectives are discussed in Section 6.

@&#LITERATURE REVIEW@&#

The well known VRP has been deeply studied in the last 50years and many exact and heuristic methods have been proposed in the literature (see Golden, Raghavan, & Wasil, 2008; Toth & Vigo, 2002). However, exact methods remain limited to problems with restricted size, i.e., less than 100 customers. Moreover, many different variants of the problem are introduced in order to face particular constraints that arise in everyday applications. Despite that, MTVRP has been investigated only in the last two decades and the literature is still scarce.


                     Fleischmann (1990) was the first to address the problem in his working paper in 1990. He proposes a modification of the savings algorithm and uses a bin packing (BP) problem heuristic to assign routes to the vehicles. In Taillard et al. (1996), VRP solutions are generated using a tabu search (TS) algorithm with adaptive memory (Taillard, 1993). The routes forming the VRP solutions are stored in a list. From that list a subset of routes is selected and a MTVRP solution is constructed using a BP heuristic. A benchmark of instances (constructed from VRP instances) is proposed. It will be used as efficiency comparison for all the authors that have developed a solution method for the MTVRP. Curiously, Taillard et al. (1996) provide values only when the algorithm fails in finding a feasible solution, introducing an arbitrary penalization factor θ
                     =2 for the overtime. Next papers follow the same scheme except Salhi and Petch (2007) (Olivera & Viera (2007) do not provide exact values, but just a GAP measure from a reference value as it will be explained in Section 5). Petch and Salhi (2004) propose a multi-phase algorithm with the minimization of the overtime as objective function. A pool of solutions is constructed by the parametrized Yellow’s savings algorithm Yellow (1970). For each solution in the pool, a MTVRP solution is constructed using a BP heuristic. The MTVRP solutions are improved using 2-opt, 3-opt moves, combining routes and reallocating customers. In Salhi and Petch (2007), as in Petch and Salhi (2004), the maximum overtime is minimized. A genetic algorithm is proposed. In this method the plane is divided in circular sectors. Each sector is defined by an angle measured with respect to the depot and the x axis. A chromosome is the sequence of such angles in non-decreasing order. Clusters are created by assigning each customer to the sector it occupies. In each cluster, the Clarke and Wright savings heuristic is used to solve a smaller VRP problem. The resulting routes are packed using a BP heuristic. Olivera and Viera (2007) use an adaptive memory approach to tackle the MTVRP. A memory M is constructed with different routes that form VRP solutions generated with the sweep algorithm. Each route is labeled with its overtime value and its cost and are sorted using a lexicographic order. New VRP solutions are generated by probabilistically selecting routes in M and improved by a TS algorithm. New VRP solutions are used to update M. From the best VRP solution a MTVRP solution is obtained using a BP heuristic. Recently, Mingozzi, Roberti, and Toth (2012) propose an exact method for the MTVRP based on two set partitioning-like formulations. 52 instances with up to 120 customers and with a known feasible solution (without overtime) are tackled and in 42 cases the optimal solution is found.


                     Alonso, Alvarez, and Beasley (2008) consider the site-dependent periodic MTVRP. Each customer has to be served up to t times in a planning horizon of t periods. Moreover, not every vehicle can serve all the customers. To each customer is assigned a delivery pattern and it is assigned to a vehicle using GENIUS heuristic (Gendreau, Hertz, & Laporte, 1992). If the insertion violates time or capacity constraints a new route is initialized. Two moves are used to improve the solution: customers are moved from a route to another and different patterns are assigned to a customer.

The MTVRP with time widows (MTVRPTW) is addressed as well. Several exact methods are proposed Azi et al., 2007; Hernandez, Feillet, Giroudeau, and Naudi, 2011. Instances with 100 customers and 1 vehicle (Azi et al., 2007) and with 50 customers and 4 vehicles (Hernandez et al., 2011) can be solved to optimality.

Different studies facing practical cases envisage to perform several trips during the working day. For example, Brandão and Mercer (1997) consider a MTVRPTW that raises from the biscuit distribution of a British company. Vehicles have different capacities, in case of need they can be hired from the company and the access to some customers is restricted to particular vehicles. Drivers’ schedule must respect the maximum legal driving time per day. Legal time breaks and unloading times are taken into account. Real instances including 45–70 customers and the use of 11 vans and 11 tractors are considered. In their subsequent work, Brandão and Mercer (1998) adapt the algorithm to compare the results with those obtained by Taillard et al. (1996). A two phases TS is performed. In the first phase, a solution is allowed to become infeasible regarding travel time constraints, but in the second phase, only feasible solutions are accepted. Insert and swap moves are considered. Battarra, Monaci, and Vigo (2009) consider the MTVRPTW and different commodities that cannot be transported together. The objective is to minimize the number of used vehicles. The problem is decomposed in simpler subproblems, one for each commodity. A set of routes is then generated for each commodity and packed by means of a BP heuristic in order to obtain a solution. Data comes from real-world instances where goods are delivered to supermarkets placed in a regional territory. The concept of multi-trips is also addressed by Cornillier, Laporte, Boctor, and Renaud (2009) and Gribkovskaia, Gullberg, Hovden, and Wallace (2006). The former paper concerns the petrol distribution to gas stations, while the latter proposes a model for the livestock collection.

The idea of multi-trip is found in the context of city logistics as well. For example, Taniguchi and Shimamoto (2004) propose a model to evaluate the impact of advanced information system in urban areas and they assume that vehicles are allowed to perform multiple trips per day. Browne, Allen, and Leonardi (2011) present the case of supplies company operating in the City of London. From a micro-consolidation urban center, electrically assisted cargo tricycles and electric vans perform deliveries. Due to the small size of tricycles and electric vans, they perform several trips during each day.

Genetic algorithms (GA) are adaptive methods inspired from the natural evolution of biological organisms. An initial population of individuals (chromosomes) evolves through generations until satisfactory criteria of quality, a maximum number of iterations or time limits are reached. New individuals (children) are generated from individuals forming the current generation (parents) by means of genetic operators (crossover and mutation). The principles of genetic procedure were firstly formalized by Holland (1975) and have been successfully used in different contexts (Neri & Cotta, 2012). The papers of Prins (2004) and Vidal, Crainic, Gendreau, and Rei (2012) are two examples of efficient GA (the former for the VRP and the latter for the multi-depot VRP and the periodic VRP) in the VRP field. In particular, GAs allow for a diversified exploration over the search space due to the management of several solutions at the same time. When Local Search (LS) algorithms are part of the procedure, the GA is commonly called memetic algorithm (MA). For an overview of GAs and MAs the reader is respectively referred to Reeves (2010, chap. 5) and Moscato and Cotta (2010, chap. 6).

In this section the proposed MA for the MTVRP is described. It makes use of an adaptation of the Split procedure (Prins, 2004) to obtain a MTVRP solution from giant tours (Section 3.2). The population diversity management is inspired by the work of Vidal et al. (2012): for survival, individuals are selected according to their quality and their contribution to the diversification of the population (Section 3.6). A sketch of the method is given in Algorithm 1.

A new advanced feature is embedded in the LS: when a pejorative move is detected, it is tested in combination with a re-assignment of trips. In case of improvement, both the move and the re-assignment are performed (Section 4).
                        Algorithm 1
                        Memetic Algorithm outline
                              
                                 
                                    
                                    
                                       
                                          
                                             1: Initialize population (Section 3.5)
                                       
                                       
                                          
                                             2: while Termination criteria is not met do
                                          
                                       
                                       
                                          
                                             3: Select parent chromosomes 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                              and 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                
                                              (Section 3.3)
                                       
                                       
                                          
                                             4: Generate a child S
                                             
                                                C
                                              (Section 3.3)
                                       
                                       
                                          
                                             5: Educate S
                                             
                                                C
                                              (Section 3.4)
                                       
                                       
                                          
                                             6: 
                                             if 
                                             S
                                             
                                                C
                                              is infeasible then
                                          
                                       
                                       
                                          
                                             7: Repair S
                                             
                                                C
                                              (Section 3.4)
                                       
                                       
                                          
                                             8: 
                                             end if
                                          
                                       
                                       
                                          
                                             9: Insert S
                                             
                                                C
                                              in the population
                                       
                                       
                                          10: 
                                             if Dimension of the population exceeds a given size then
                                          
                                       
                                       
                                          11: Select survivors (Section 3.6)
                                       
                                       
                                          12: 
                                             end if
                                          
                                       
                                       
                                          13: end while
                                          
                                       
                                    
                                 
                              
                           
                        

A chromosome is a sequence (permutation) S
                        =(S
                        1,…,
                        S
                        
                           n
                        ) of n client nodes, without trip delimiters. S can be viewed as a TSP solution that has to be turned in a feasible MTVRP solution by splitting the chromosome (inserting trip delimiters and assigning trips to vehicles). From that point of view, S is usually called a giant tour. From a giant tour S, different MTVRP solutions can be constructed depending on the way S is split.

During the search phase, overtime and overload are allowed and penalized in the fitness function with factors θ and λ respectively, even though a feasible solution is required.

A procedure AdSplit (explained in Section 3.2) is used to get a MTVRP solution ξ from S. The following notation is introduced: T
                        
                           v
                        (ξ) and O
                        
                           v
                        (ξ)=max{0, T
                        
                           v
                        (ξ)−
                        T
                        
                           H
                        } are respectively the travel time and the overtime of vehicle v in solution ξ. L
                        
                           r
                        (ξ) is the load of route r and r
                        ∈
                        v indicates that route r is assigned to vehicle v. The fitness F(S) of the chromosome S is the cost of the best solution ξ found by AdSplit and it is defined as
                           
                              (1)
                              
                                 F
                                 (
                                 S
                                 )
                                 =
                                 c
                                 (
                                 ξ
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          v
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                 
                                 
                                    
                                       T
                                    
                                    
                                       v
                                    
                                 
                                 (
                                 ξ
                                 )
                                 +
                                 θ
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          v
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                 
                                 
                                    
                                       O
                                    
                                    
                                       v
                                    
                                 
                                 (
                                 ξ
                                 )
                                 +
                                 λ
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          v
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          v
                                       
                                    
                                 
                                 
                                    max
                                 
                                 {
                                 0
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 ξ
                                 )
                                 -
                                 Q
                                 }
                              
                           
                        When confusion cannot arise, solution ξ will be omitted in the notation. The chromosome S is called feasible (infeasible) if AdSplit obtains, from S, a feasible (infeasible) solution ξ.

The splitting procedure proposed here, called AdSplit, is an adaptation of the procedure proposed by Prins (2004). It is used to turn a chromosome into MTVRP solutions. The cost of the solution obtained by AdSplit is associated with the chromosome itself as fitness value in order to evaluate its quality. The procedure is used each time a new individual is generated, either randomly (at the beginning for initialization purposes, Section 3.5), or after mating parents to generate children by means of crossover operators, Section 3.3.

The splitting procedure works on an auxiliary graph H
                           =(V′, A′). V′ contains n
                           +1 nodes indexed from 0 to n. Arc (i, j), i
                           <
                           j, represents a trip serving customers from S
                           
                              i+1 to S
                           
                              j
                            in the order they are in S. With each arc (i, j), is associated a cost c
                           
                              ij
                            defined as
                              
                                 (2)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ij
                                       
                                    
                                    =
                                    
                                       
                                          τ
                                       
                                       
                                          ij
                                       
                                    
                                    +
                                    θ
                                    
                                       max
                                    
                                    {
                                    0
                                    ,
                                    
                                       
                                          τ
                                       
                                       
                                          ij
                                       
                                    
                                    -
                                    
                                       
                                          T
                                       
                                       
                                          H
                                       
                                    
                                    }
                                    +
                                    λ
                                    
                                       max
                                    
                                    {
                                    0
                                    ,
                                    
                                       
                                          l
                                       
                                       
                                          ij
                                       
                                    
                                    -
                                    Q
                                    }
                                 
                              
                           where τ
                           
                              ij
                            and l
                           
                              ij
                            represent respectively the trip traveling time and the sum of customer’s requests served during the trip.

A simple example with five customers is given in Figs. 1 and 2
                           
                           . S
                           =(1, 2, 3, 4, 5), T
                           
                              H
                           
                           =45, Q
                           =50, θ
                           =
                           λ
                           =2 and the demand of each customer is given between brackets. For example, arc (1, 5) in Fig. 2 represents the trip serving customers from 2 to 5. τ
                           15
                           =116, l
                           15
                           =76. The arc cost is then c
                           15
                           =116+2·(116−45)+2·(76−50)=310.

Once H is computed, paths basically represent set of trips that can be assigned to vehicles. In the VRP context, an optimal splitting is equivalent to a shortest path (SP) in H each arc representing a route which is assigned to a vehicle. Since H is acyclic, Bellman’s algorithm can be used to find the SP in O(n
                           2). In the MTVRP context, more than one trip can be assigned to the same vehicle. The procedure proposed in Prins (2004) cannot be directly used and is modified as explained in Section 3.2.2.

The assignment procedure both selects and assigns trips to vehicles. It consists of two phases. In the first phase, the SP in H is computed. In the second phase, trips of the SP are assigned to vehicles by means of a labeling algorithm. The labeling algorithm works as follows.

Starting from node 0, labels are progressively extended along the graph defined by SP. Each label 
                              
                                 L
                              
                            has m
                           +3 fields: the first m fields store vehicle travel times in decreasing order (enhancing the strength of the dominance rule), the (m
                           +1)th field memorizes the total load infeasibility, the (m
                           +2)th the predecessor node, and the last field keeps the cost of the partial solution evaluated using Eq. (1) and equivalent to the cost 
                              
                                 c
                                 (
                                 L
                                 )
                              
                            of label 
                              
                                 L
                              
                           . When extending a label, m new labels are constructed, one for each possible allocation of the new trip to a vehicle. When node n is reached, the label 
                              
                                 L
                              
                            with minimum cost 
                              
                                 c
                                 (
                                 L
                                 )
                              
                            associated with node n is selected and the related solution is constructed.

Dominated labels, accordingly with the following dominance rule, are discarded: let 
                              
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                              
                            be two labels associated with the same node i. 
                              
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                              
                            dominates 
                              
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                              
                            if and only if
                              
                                 (3)
                                 
                                    c
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          1
                                       
                                    
                                    )
                                    +
                                    θ
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             m
                                          
                                       
                                    
                                    
                                       
                                          δ
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          L
                                       
                                       
                                          2
                                       
                                    
                                    )
                                    ⩽
                                    c
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                              
                           where 
                              
                                 c
                                 (
                                 L
                                 )
                              
                            is the cost associated with label 
                              
                                 L
                              
                           ,
                              
                                 
                                    
                                       
                                          δ
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          L
                                       
                                       
                                          2
                                       
                                    
                                    )
                                    =
                                    
                                       max
                                    
                                    {
                                    0
                                    ,
                                    
                                       min
                                    
                                    {
                                    
                                       
                                          T
                                       
                                       
                                          H
                                       
                                    
                                    ,
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          1
                                       
                                    
                                    )
                                    }
                                    -
                                    
                                       min
                                    
                                    {
                                    
                                       
                                          T
                                       
                                       
                                          H
                                       
                                    
                                    ,
                                    
                                       
                                          T
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          L
                                       
                                       
                                          2
                                       
                                    
                                    )
                                    }
                                    }
                                 
                              
                           and 
                              
                                 
                                    
                                       T
                                    
                                    
                                       j
                                    
                                 
                                 (
                                 L
                                 )
                              
                            is the (partial) travel time of vehicle j associated with label 
                              
                                 L
                              
                           . Roughly speaking, given two labels 
                              
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                              
                           , extending 
                              
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                              
                            is penalized as much as possible while it is not extending 
                              
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                              
                            in the same way. If inequality (3) holds, 
                              
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                              
                            cannot be extended in a better way than 
                              
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                              
                           , and it is eliminated.

The procedure is illustrated for the simple example in Fig. 1. First, SP is calculated on the corresponding auxiliary graph H. The solution is then constructed with the assignment procedure just explained. The SP and the solution obtained are depicted in Fig. 3
                           .

Label’s extension is reported in Table 1
                           . The first line reports the node. Due to space limitations, labels associated with nodes 0 and 3 are not reported: only the null label is associated with node 0, while node 3 is not connected. Moreover, predecessor of each label is straightforward and load infeasibility is zero for each label considered. Then, they are omitted. Column dom indicates whether the corresponding label is dominated by another label associated with the same node.

Note that this approach provides the optimal assignment of trips in SP, but is suboptimal with regard to the decomposition of S, as illustrated in Fig. 4
                           .

Applying the procedure on the complete graph H, the label that minimizes Eq. (1) at node n would correspond to the best decomposition of S in the MTVRP context. One could however expect that a huge number of labels would need to be treated, which do not appear to be viable in the MA context.

Arc (i, j) in the auxiliary graph H represents the trip serving customers (S
                           
                              i+1,
                           S
                           
                              i+2,…,
                           S
                           
                              j
                           ) in the order they appear in the giant tour S. Visiting customers in a different order can lead to a trip with a smaller cost. Let suppose the distance between customers 1 and 4 in the example shown in Fig. 1 is equal to 20. The trip (0, 2, 3, 4, 1, 0) would cost 207 that together with trip (0, 5, 0) leads to a solution of cost 241 (Fig. 5
                           ). As proposed by Prins, Labadi, and Reghioui (2009), each rotation (circular left shit) can be considered and evaluated in constant time. For example, a one-position rotation corresponds to the trip (0,
                           S
                           
                              i+2,…,
                           S
                           
                              j
                           ,
                           S
                           
                              i+1,0). Then, given an arc, all the possible rotations are considered looking for the best starting point of the trip without introducing any computational burden (see Prins et al. (2009) for a detailed explanation).

A pseudo-code sketch of the AdSplit procedure is proposed in Algorithm 2. Procedure SP_best_in() computes the shortest path on graph H, taking into consideration the best rotation for each arc. With each node i, it associates its successor succ
                           
                              i
                           , the traveling time and load of the trip represented by (i, succ
                           
                              i
                           ). These values are obtained when needed by procedures get_successor(i), get_best_in_time(i) and get_load(i). 
                              
                                 
                                    
                                       L
                                    
                                    
                                       k
                                    
                                 
                              
                            indicates the kth field of label 
                              
                                 L
                              
                           , while 
                              
                                 
                                    
                                       L
                                    
                                    
                                       lInf
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       L
                                    
                                    
                                       pred
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       L
                                    
                                    
                                       c
                                    
                                 
                              
                            refer respectively to the (m
                           +1)th, (m
                           +2)th and (m
                           +3)th label fields. 
                              
                                 sort
                                 (
                                 L
                                 )
                              
                            sorts the first m fields in decreasing order. If 
                              
                                 L
                              
                            is dominated by a label in 
                              
                                 
                                    
                                       ListLabel
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 is
                                 _
                                 dominated
                                 (
                                 
                                    
                                       ListLabel
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 L
                                 )
                              
                            returns true, otherwise it returns false. Labels in ListLabel
                           
                              i
                            dominated by the new inserted label 
                              
                                 L
                              
                            are eliminated from the list by 
                              
                                 eliminate
                                 _
                                 dominated
                                 _
                                 labels
                                 (
                                 
                                    
                                       ListLabel
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 L
                                 )
                              
                           .
                              Algorithm 2
                              
                                 AdSplit
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   1: SP_best_in()
                                             
                                             
                                                
                                                   2: for 
                                                   i
                                                   =0 to n 
                                                   do
                                                
                                             
                                             
                                                
                                                   3: 
                                                   LabelList
                                                   
                                                      i
                                                   
                                                   =∅
                                             
                                             
                                                
                                                   4: end for
                                                
                                             
                                             
                                                
                                                   5: 
                                                      
                                                         
                                                            
                                                               LabelList
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         ←
                                                         (
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        0
                                                                        ,
                                                                        …
                                                                        ,
                                                                        0
                                                                     
                                                                     
                                                                        ︷
                                                                     
                                                                  
                                                               
                                                               
                                                                  m
                                                               
                                                            
                                                         
                                                         ,
                                                         0
                                                         ,
                                                         0
                                                         ,
                                                         0
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   6: current
                                                   =0
                                             
                                             
                                                
                                                   7: while 
                                                   current
                                                   <
                                                   n 
                                                   do
                                                
                                             
                                             
                                                
                                                   8: 
                                                   succ
                                                   =
                                                   get_successor(current)
                                             
                                             
                                                
                                                   9: 
                                                   load
                                                   =
                                                   get_load(current);
                                             
                                             
                                                10: 
                                                   time
                                                   =
                                                   get_best_in_time(current)
                                             
                                             
                                                11: 
                                                   for all 
                                                   
                                                      
                                                         L
                                                         ∈
                                                         
                                                            
                                                               LabelList
                                                            
                                                            
                                                               current
                                                            
                                                         
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                12: 
                                                   for 
                                                   k
                                                   =1→
                                                   m 
                                                   do
                                                
                                             
                                             
                                                13: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         L
                                                      
                                                   
                                                
                                             
                                             
                                                14: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               k
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                         +
                                                         time
                                                      
                                                   
                                                
                                             
                                             
                                                15: 
                                                   
                                                   
                                                      
                                                         sort
                                                         (
                                                         L
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                16: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               lInf
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               lInf
                                                            
                                                         
                                                         +
                                                         λ
                                                         ·
                                                         max
                                                         {
                                                         load
                                                         -
                                                         Q
                                                         ,
                                                         0
                                                         }
                                                      
                                                   
                                                
                                             
                                             
                                                17: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               c
                                                            
                                                         
                                                         +
                                                         time
                                                         +
                                                         θ
                                                         ·
                                                         max
                                                         {
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               k
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               H
                                                            
                                                         
                                                         ,
                                                         0
                                                         }
                                                         -
                                                         θ
                                                         ·
                                                         max
                                                         {
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               H
                                                            
                                                         
                                                         ,
                                                         0
                                                         }
                                                         +
                                                         λ
                                                         ·
                                                         max
                                                         {
                                                         load
                                                         -
                                                         Q
                                                         ,
                                                         0
                                                         }
                                                      
                                                   
                                                
                                             
                                             
                                                18: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               pred
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         current
                                                      
                                                   
                                                
                                             
                                             
                                                19: 
                                                   
                                                   if not 
                                                   
                                                      
                                                         is
                                                         _
                                                         dominated
                                                         (
                                                         
                                                            
                                                               ListLabel
                                                            
                                                            
                                                               succ
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                20: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               ListLabel
                                                            
                                                            
                                                               succ
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                21: 
                                                   
                                                   
                                                      
                                                         eliminate
                                                         _
                                                         dominated
                                                         _
                                                         labels
                                                         (
                                                         
                                                            
                                                               ListLabel
                                                            
                                                            
                                                               succ
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                22: 
                                                   
                                                   end if
                                                
                                             
                                             
                                                23: 
                                                   end for
                                                
                                             
                                             
                                                24: 
                                                   end for
                                                
                                             
                                             
                                                25: 
                                                   current
                                                   =
                                                   succ
                                                
                                             
                                             
                                                26: end while
                                                
                                             
                                          
                                       
                                    
                                 
                              

The classic OX operator is used. Fig. 6
                         shows how the OX works. First, two cutting points have to be chosen in the parents 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        . In the example they are i
                        =4 and j
                        =7. Indicating with 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              =
                              OX
                              (
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              )
                           
                         the first child, 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              (
                              k
                              )
                              =
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              (
                              k
                              )
                           
                         for k
                        =
                        i,…,
                        j. Then, 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                         is circularly swept from 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              (
                              j
                              +
                              1
                              )
                           
                         onward inserting in 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         the missing nodes. By inverting the roles between 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        , we obtain the second child 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              =
                              OX
                              (
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              )
                           
                        .

Parents 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                         are selected with the classic binary tournament method: two chromosomes are randomly drawn from the population and the one with the lower fitness is selected. The procedure is repeated twice, once for the selection of each parent. The child that has to be inserted in the population is randomly selected between children 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              =
                              OX
                              (
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              )
                           
                         and 
                           
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              =
                              OX
                              (
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              )
                           
                        .

After crossover, the obtained child is evaluated by means of AdSplit procedure, and educated applying LS procedure with a probability p
                        
                           LS
                         trying to improve its quality. LS is usually used in literature as mutation operator in order to obtain a high-performance hybrid GA.

The operators listed in the following are used. Let u and z be two nodes and t and x be their respective successors (that could be the depot as well). R(u) indicates the route visiting customer u. The following simple types of moves are tested.
                           
                              M1
                              If u is a client node, remove u and insert it after z.

If u and t are clients, remove them and insert u and t after z.

If u and t are clients, remove them and insert t and u after z.

If u and z are clients, swap u and z.

If u, t and z are clients, swap u and t with z.

If u, t, z and x are clients, swap u and t with z and x.

If R(u)=
                                 R(z), replace (u, t) and (z, x) by (u, z) and (t, x).

If R(u)≠
                                 R(z), replace (u, t) and (z, x) by (u, z) and (t, x).

If R(u)≠
                                 R(z), replace (u, t) and (z, x) by (u, x) and (t, z).

If R(u)=
                                 R(z), create another route with all customers from u to z (or from z to u if z comes before u) and put it in a randomly drawn vehicle.

The nodes can belong to the same route or to different routes. Routes can either belong to the same vehicle or to different vehicles. Moves M1–M3 correspond to insertion moves, moves M4–M6 to swaps, move M7 is the well known 2-opt and moves M8, M9 are usually called 2-opt
                        ∗.

Moves M1–M9 are those used in Prins (2004). If u
                        =
                        z in M10, a new route with only customer u is created.

At the beginning of the LS with each type of move Mi, i
                        =1,…,10 is associated a weight w
                        
                           i
                        
                        =
                        w and the status active. At each iteration the LS procedure probabilistically selects a move among the active moves. The probability of move Mi to be chosen is w
                        
                           i
                        /W where 
                           
                              W
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    10
                                 
                              
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                           
                        . The selected move Mi is evaluated and the first improvement criteria is adopted. If the move fails, i.e., the current solution is a local optima in the neighborhood defined by Mi, Mi becomes inactive and cannot be selected anymore until another move succeeds. The LS terminates when all the moves are inactive, i.e., a local optima in the neighborhood defined by M1–M10 is reached.

After a fixed number of iterations ω (arbitrarily fixed to 100), the weights are updated accordingly to the number of successes. Precisely, 
                           
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    
                                       
                                          success
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          attempts
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                        , where success
                        
                           i
                         and attempts
                        
                           i
                         indicate respectively the times move Mi succeeded and was performed (attempts
                        
                           i
                         is usually not the same for all moves due to probabilistic selection). W is updated accordingly. Weights w
                        
                           i
                         can be viewed as a short-term memory, i.e., a move that historically successes more will have a higher probability to be chosen.

To speed up LS, granular search is implemented as proposed by Toth and Vigo (2003): a move is considered only when z is one of the n
                        closest closest customers of u (filtering rule).

Each time a solution ξ is obtained from chromosome S by means of AdSplit it is stored in four different n-size vectors that memorize in ith position the predecessor, the successor, the vehicle and the route of customer i. The travel time of each vehicle and the load of each route are stored as well. In this way, moves M1–M9 are evaluated in constant time, while M10 in O(n). Then, given a solution ξ and defining its neighborhood N(ξ) by the set of moves M1–M10, it can be completely explored in O(n
                        3) time (more precisely, in O(n
                        2
                        ·
                        n
                        
                           closest
                        ) with the usage of the filtering rule), although the neighborhood defined by M1–M9 requires O(n
                        2) operations to be explored.

After LS is applied, the educated chromosome can be either feasible or infeasible. In the latter case the repair procedure is applied with a probability p
                        
                           rep
                        . It consists in applying again LS with λ (load infeasibility penalization parameter) and/or θ temporarily multiplied by 10, regarding the nature of the infeasibility. If a feasible chromosome is obtained, it is inserted in the population, otherwise λ and/or θ are (temporarily) multiplied again by 10 and LS reapplied. The original chromosome is not discarded even if the repaired chromosome is feasible (Vidal et al., 2012). All the chromosomes obtained during LS and repair procedure are as well inserted in the population.

An ordered population Π of chromosomes is kept. A key value k
                        
                           S
                         is associated with each chromosome S and the population is sorted regarding the key value. k
                        
                           S
                         corresponds to the fitness F(S) of S multiplied by a penalization factor P. P
                        =1 if S is feasible, P
                        =1.5 if S is time-infeasible, P
                        =2 if S is load-infeasible, P
                        =3 if S is both load and time-infeasible. This is done in order to ensure the best feasible solution found so far corresponds to the chromosome in the first position of the population (infeasible individuals can cost less than the best feasible one) and in general to keep good quality individuals at the top of Π. Moreover, it allows to manage both feasible and infeasible chromosomes in the same population, differently from what is done, for example, in Vidal et al. (2012), where the population is divided in two subpopulations, one for feasible and the other for infeasible chromosomes.

The initial population is formed of π random generated chromosomes evaluated with the AdSplit procedure and improved applying LS.

The procedure terminates after a maximum number of iterations has been performed. An iteration consists of generating a child S
                        
                           C
                         crossing parents that undergoes evaluation (by means of AdSplit), education and eventually reparation procedures. S
                        
                           C
                         is then inserted in the population. It can be noticed that the number of iterations correspond to the number of crossovers performed.

When the population reaches a maximum dimension, i.e., π
                        +
                        μ, a survivor selection is performed as proposed by Vidal, Crainic, Gendreau, and Prins (2013) and Vidal et al. (2012). Survivor chromosomes are selected based on quality, i.e., on fitness F(S), and their diversity contribution f(S) defined as the average distance between S and its n
                        
                           c
                         closest neighbors in Π (forming set N
                        
                           c
                        ) as follows:
                           
                              (4)
                              
                                 f
                                 (
                                 S
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       
                                          
                                             n
                                          
                                          
                                             c
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                S
                                             
                                             
                                                1
                                             
                                          
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                c
                                             
                                          
                                       
                                    
                                 
                                 D
                                 (
                                 S
                                 ,
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 ,
                              
                           
                        where D(·, ·) is the broken pair distance that is the number of pairs of adjacent customers in S that are broken in S
                        1 
                        Prins (2009). D(·, ·) gives a measure on the amount of common arcs between S and S
                        1. A biased fitness bF(·) is calculated for each chromosome as follows:
                           
                              (5)
                              
                                 bF
                                 (
                                 S
                                 )
                                 =
                                 
                                    
                                       r
                                    
                                    
                                       F
                                    
                                 
                                 (
                                 S
                                 )
                                 +
                                 
                                    
                                       
                                          1
                                          -
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      e
                                                   
                                                
                                             
                                             
                                                |
                                                Π
                                                |
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       r
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 S
                                 )
                              
                           
                        where r
                        
                           F
                        (S) and r
                        
                           f
                        (S) are the ranks of chromosome S calculated based on fitness F and function f defined in Eq. (4) respectively, and n
                        
                           e
                         is a parameter that ensures elitism properties during selection (see Vidal et al. (2012) for a formal proof).

To optimize the packing of routes into vehicles, we introduce the possibility of a re-pack of trips along with a pejorative move M among M1–M10 introduced in Section 3.4. By pejorative move, we mean a move that does not decrease the solution cost. The swap between trips (Swp) in different vehicles is used as re-assignment procedure.

To understand the idea of the Combined LS (CLS) let focus on Figs. 7–9
                     
                     
                     . The example involves three vehicles with up to three routes each and T
                     
                        H
                     
                     =100 that is violated by the third vehicle (Fig. 7). Move M involves routes r
                     2 and r
                     3 of vehicles v
                     1 and v
                     2 respectively and it leads to the configuration shown in Fig. 8 with an increasing in the solution cost of 5 units (due to the increasing in routing cost). Since M is pejorative, it would be discarded by the LS procedure. However, with a different assignment of trips to vehicles, an improvement can be obtained. In the particular case, it consists of swapping r
                     2 in v
                     1 with r
                     2 in v
                     3 (Fig. 9).

The goal of the CLS is to detect when the combination of moves M1–M10 along with a swap of two trips leads to a better solution and, in that case, to perform both the move and the swap.

For the sake of computing time, the main issue here is to avoid evaluating every possible combination of moves with swaps (indicated with M
                     +
                     Swp). We propose to limit the evaluations of M
                     +
                     Swp according to the following rule 
                        
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                        
                     :
                        Rule 1
                        [
                              
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              
                           ] The evaluations of M
                           +
                           Swp is limited to those that would improve the solution even if the assignment of routes to vehicles is optimal before M
                           +
                           Swp is applied.

Using the subsequent propositions, it is then possible to limit heavily the size of the neighborhood explored with M
                     +
                     Swp.

In the following, we will note respectively ξ, ξ
                     
                        M
                     , ξ
                     
                        M+Swp
                      the current solution, the solution after applying move M and the solution after performing Swp as shown in Fig. 10
                     . A vehicle without (with) overtime will be called feasible (infeasible).

It is noteworthy that Swp can modify overtime, but does not affect the traveling time and the load infeasibility of the solution. We state two propositions in order to justify the restriction of pejorative moves that are tested along with swaps. The first proposition identifies which Swp can be worth to be tested once M has been performed. On the other hand, the second proposition states which moves M can lead to a global improvement when combined with a Swp. We start discussing the choice of swaps.
                        Proposition 1
                        
                           Under rule 
                           
                              
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              
                           
                           , we can restrict the choice of the Swp as follows:
                           
                              
                                 
                                    1.
                                 
                                 
                                    Swp involves (trips in) two different vehicles v
                                    
                                       1
                                     
                                    and v
                                    
                                       2
                                    
                                    ,
                                 


                                    exactly one vehicle between v
                                    
                                       1
                                     
                                    and v
                                    
                                       2
                                     
                                    is feasible,
                                 


                                    at least one vehicle between v
                                    
                                       1
                                     
                                    and v
                                    
                                       2
                                     
                                    has to have been involved in M.
                                 

The following notation is introduced. ΔO refers to a difference in the overtime of the solution induced by move M or Swp. In particular ΔO(ξ
                           
                              M
                           )=
                           O(ξ
                           
                              M
                           )−
                           O(ξ) and Δ O(ξ
                           
                              M+Swp
                           )=
                           O(ξ
                           
                              M+Swp
                           )−
                           O(ξ
                           
                              M
                           ).

We can notice that swapping trips belonging to the same vehicle v cannot lead to any improvement: T
                           
                              v
                            is not reduced, then O
                           
                              v
                            is not reduced neither (that proves 1). Let consider two trips belonging to two different vehicles v
                           1 and v
                           2. For ease of notation, we note r
                           
                              i
                            the trip that belongs to v
                           
                              i
                            (r
                           
                              i
                           
                           ∈
                           v
                           
                              i
                           ) and τ
                           
                              i
                           , instead of 
                              
                                 
                                    
                                       τ
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                           , the travel time of trip r
                           
                              i
                           . Let T
                           1 (resp., O
                           1) and T
                           2 (resp., O
                           2) be the respective travel times (resp., overtimes) of the two vehicles. If point 2 does not hold, we will prove that swapping r
                           1 with r
                           2 cannot improve the solution.

Let suppose both vehicles are feasible or both are infeasible, i.e., T
                           
                              i
                           (ξ
                           
                              M
                           )⩽
                           T
                           
                              H
                            or T
                           
                              i
                           (ξ
                           
                              M
                           )>
                           T
                           
                              H
                           , i
                           =1,2. We consider the two cases separately.
                              
                                 a.
                                 
                                    T
                                    1(ξ
                                    
                                       M
                                    )⩽
                                    T
                                    
                                       H
                                     and T
                                    2(ξ
                                    
                                       M
                                    )⩽
                                    T
                                    
                                       H
                                    . O
                                    1(ξ
                                    
                                       M
                                    )=
                                    O
                                    2(ξ
                                    
                                       M
                                    )=0. No improvement can be carried out with Swp.


                                    T
                                    1(ξ
                                    
                                       M
                                    )>
                                    T
                                    
                                       H
                                     and T
                                    2(ξ
                                    
                                       M
                                    )>
                                    T
                                    
                                       H
                                    . We consider without loss of generality τ
                                    2(ξ
                                    
                                       M
                                    )⩽
                                    τ
                                    1(ξ
                                    
                                       M
                                    ). With Swp, overtime of vehicle v
                                    1 decreases; ΔO
                                    1(ξ
                                    
                                       M+Swp
                                    )=max{τ
                                    2(ξ
                                    
                                       M
                                    )−
                                    τ
                                    1(ξ
                                    
                                       M
                                    ), T
                                    
                                       H
                                    
                                    −
                                    T
                                    1(ξ
                                    
                                       M
                                    )}. Overtime of vehicle v
                                    2 increases; ΔO
                                    2(ξ
                                    
                                       M+Swp
                                    )=
                                    τ
                                    1(ξ
                                    
                                       M
                                    )−
                                    τ
                                    2(ξ
                                    
                                       M
                                    ). Then ΔO(ξ
                                    
                                       M+Swp
                                    )=ΔO
                                    1(ξ
                                    
                                       M+Swp
                                    )+ΔO
                                    2(ξ
                                    
                                       M+Swp
                                    )⩾
                                    τ
                                    2(ξ
                                    
                                       M
                                    )−
                                    τ
                                    1(ξ
                                    
                                       M
                                    )+
                                    τ
                                    1(ξ
                                    
                                       M
                                    )−
                                    τ
                                    2(ξ
                                    
                                       M
                                    ), that is, ΔO(ξ
                                    
                                       M+Swp
                                    )⩾0.

This proves point 2. Point 3 directly follows from the rule 
                              
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              
                           . Let us suppose v
                           1 and v
                           2 are not involved in M. Then, τ
                           
                              k
                           (ξ)=
                           τ
                           
                              k
                           (ξ
                           
                              M
                           ) for all r
                           
                              k
                           
                           ∈
                           v
                           
                              i
                           , i
                           =1, 2. If an improvement is obtained by Swp, the same improvement could have been obtained applying Swp before M (that does not modify trips involved in Swp). This means that when the initial assignment of trips to vehicles is optimal, no improvement can be carried out.□

Let us now move the discussion to the choice of the move M to be tested along with a Swp. We introduce the following proposition.
                        Proposition 2
                        
                           Under 
                           Proposition 1 
                           we can restrict the choice of moves involved along with a swap to those such that
                           
                              
                                 
                                    
                                       
                                          τ
                                       
                                       
                                          r
                                       
                                    
                                    (
                                    
                                       
                                          ξ
                                       
                                       
                                          M
                                       
                                    
                                    )
                                    <
                                    
                                       
                                          τ
                                       
                                       
                                          r
                                       
                                    
                                    (
                                    ξ
                                    )
                                    
                                    for
                                    
                                    at
                                    
                                    least
                                    
                                    one
                                    
                                    route
                                    
                                    r
                                    
                                    involved
                                    
                                    in
                                    
                                    M
                                    .
                                    
                                    
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    )
                                 
                              
                           
                        

We suppose the assignment of trips to vehicles is optimal before M is applied. We will show that when 
                              
                                 
                                    
                                       C
                                    
                                    
                                       1
                                    
                                 
                              
                            does not hold, M
                           +
                           Swp cannot improve the solution cost. Applying 
                              
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              
                           , such moves can be discarded. We indicate respectively with R and R
                           
                              M
                            the set of trips that form ξ and ξ
                           
                              M
                           . Without loss of generality we can suppose ∣R∣;=∣R
                           
                              M
                           ∣ (if M creates a new route, an empty route could be added in R). Let us indicate with r a trip in R and with r
                           
                              M
                            the corresponding trip in R
                           
                              M
                            after M have been applied. The following considerations are valid.
                              
                                 ①
                                 The cost of the solution ξ
                                    
                                       M+Swp
                                     is greater than or equal to the cost of the solution obtained by optimally assigning trips in R
                                    
                                       M
                                     to vehicles. We indicate such solution with 
                                       
                                          
                                             
                                                ξ
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      M
                                                   
                                                
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                     and its cost with 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      M
                                                   
                                                
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    .

Let 
                                       
                                          
                                             
                                                ξ
                                             
                                             
                                                ̃
                                             
                                          
                                       
                                     be the solution constructed by assigning trips in R as follows: r is assigned to vehicle v if and only if the corresponding r
                                    
                                       M
                                     is assigned to vehicle v in 
                                       
                                          
                                             
                                                ξ
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      M
                                                   
                                                
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    . We note 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                ̃
                                             
                                          
                                       
                                     the cost of such solution. Since 
                                       
                                          
                                             
                                                τ
                                             
                                             
                                                
                                                   
                                                      r
                                                   
                                                   
                                                      M
                                                   
                                                
                                             
                                          
                                          ⩾
                                          
                                             
                                                τ
                                             
                                             
                                                r
                                             
                                          
                                       
                                     for all r
                                    ∈
                                    R (
                                       
                                          
                                             
                                                C
                                             
                                             
                                                1
                                             
                                          
                                       
                                     does not hold), 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      M
                                                   
                                                
                                             
                                             
                                                ∗
                                             
                                          
                                          ⩾
                                          
                                             
                                                c
                                             
                                             
                                                ̃
                                             
                                          
                                       
                                     is verified.

We note 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                R
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                     the cost of the solution obtained by optimally assigning trips in R to vehicles. Then, it holds 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                ̃
                                             
                                          
                                          ⩾
                                          
                                             
                                                c
                                             
                                             
                                                R
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    .

We have assumed the initial assignment of trips to vehicles to be optimal. Then, 
                                       
                                          
                                             
                                                c
                                             
                                             
                                                R
                                             
                                             
                                                ∗
                                             
                                          
                                          =
                                          c
                                          (
                                          ξ
                                          )
                                       
                                    .

Concluding, the following holds
                              
                                 
                                    c
                                    (
                                    
                                       
                                          ξ
                                       
                                       
                                          M
                                          +
                                          Swp
                                       
                                    
                                    )
                                    
                                       
                                          ⩾
                                       
                                       
                                          ①
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          
                                             
                                                R
                                             
                                             
                                                M
                                             
                                          
                                       
                                       
                                          ∗
                                       
                                    
                                    
                                       
                                          ⩾
                                       
                                       
                                          ②
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          ̃
                                       
                                    
                                    
                                       
                                          ⩾
                                       
                                       
                                          ③
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          R
                                       
                                       
                                          ∗
                                       
                                    
                                    
                                       
                                          =
                                       
                                       
                                          ④
                                       
                                    
                                    c
                                    (
                                    ξ
                                    )
                                    ,
                                 
                              
                           namely, M
                           +
                           Swp cannot improve the solution ξ.□

An algorithm sketch of the procedure is given in Algorithm 3.
                        Algorithm 3
                        Combined LS
                              
                                 
                                    
                                    
                                       
                                          
                                             1: evaluate move M
                                          
                                       
                                       
                                          
                                             2: if 
                                             M improves the solution
                                       
                                       
                                          
                                             3: accept M
                                          
                                       
                                       
                                          
                                             4: else
                                          
                                       
                                       
                                          
                                             5: 
                                             if 
                                             
                                                
                                                   
                                                      
                                                         C
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                              
                                             then
                                          
                                       
                                       
                                          
                                             6: 
                                             for all 
                                             v
                                             1 involved in M 
                                             do
                                          
                                       
                                       
                                          
                                             7: 
                                             
                                             for all 
                                             v
                                             2
                                             ≠
                                             v
                                             1 
                                             do
                                          
                                       
                                       
                                          
                                             8: 
                                             
                                             if (T
                                             1(ξ
                                             
                                                M
                                             )<
                                             T
                                             
                                                H
                                             
                                             ∧
                                             T
                                             2(ξ
                                             
                                                M
                                             )>
                                             T
                                             
                                                H
                                             )∨(T
                                             1(ξ
                                             
                                                M
                                             )>
                                             T
                                             
                                                H
                                             
                                             ∧
                                             T
                                             2(ξ
                                             
                                                M
                                             )<
                                             T
                                             
                                                H
                                             ) then
                                          
                                       
                                       
                                          
                                             9: 
                                             
                                             (r
                                             1, r
                                             2, tripDetected)=
                                             Detect_Trips_To_Swap(v
                                             1, v
                                             2)
                                       
                                       
                                          10: 
                                             
                                             
                                             if 
                                             tripDetected 
                                             then
                                          
                                       
                                       
                                          11: 
                                             
                                             
                                             perform(M)
                                       
                                       
                                          12: 
                                             
                                             
                                             swap(v
                                             1, v
                                             2, r
                                             1, r
                                             2)
                                       
                                       
                                          13: 
                                             
                                             
                                             end if
                                          
                                       
                                       
                                          14: 
                                             
                                             end if
                                          
                                       
                                       
                                          15: 
                                             
                                             end for
                                          
                                       
                                       
                                          16: 
                                             end for
                                          
                                       
                                       
                                          17: 
                                             end if
                                          
                                       
                                       
                                          18: end if
                                          
                                       
                                    
                                 
                              
                           
                        


                     Detect_Trips_To_Swap(v
                     1, v
                     2) is a function that tests swaps between trips in vehicles v
                     1 and v
                     2. If it finds a pair of trips r
                     1, r
                     2 that improves the solution if swapped, it returns them and sets tripDetected to TRUE. Otherwise tripDetected is set to FALSE. Function perform(M) performs move M while swap(v
                     1, v
                     2, r
                     1, r
                     2) swaps trips r
                     1, r
                     2.

This section reports the computational results obtained with the proposed method. The algorithm is coded in C++, compiled with Visual Studio 2008 and run on a Intel Xeon 2.80 Ghz processor. It is tested on classical instances in the MTVRP literature. These instances were introduced by Taillard et al. (1996) and are constructed from the instances 1–5 and 11–12 proposed in Christofides, Mingozzi, and Toth (1979) (that will be denoted CMT1–CMT5 and CMT11–CMT12 in the following) and instances 11–12 proposed in Fisher (1994) (F11–F12) for the VRP. For each VRP instance, instances for MTVRP are constructed with different values of m and two values of T
                     
                        H
                     , given by 
                        
                           
                              
                                 T
                              
                              
                                 H
                              
                              
                                 1
                              
                           
                           =
                           
                              
                                 
                                    
                                       
                                          1.05
                                          
                                             
                                                z
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                       
                                          m
                                       
                                    
                                 
                              
                           
                        
                      and 
                        
                           
                              
                                 T
                              
                              
                                 H
                              
                              
                                 2
                              
                           
                           =
                           
                              
                                 
                                    
                                       
                                          1.1
                                          
                                             
                                                z
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                       
                                          m
                                       
                                    
                                 
                              
                           
                        
                      where z
                     ∗ is the solution cost of the original CVRP instances found by Rochat and Taillard (1995) and [x] represents the closest integer to x (see Table 2
                     ). There are, in total, 104 different instances. For 42 of them, the optimal value is known and is provided by Mingozzi et al. (2012). We classify them in a first group denoted G1. For the remaining 62 instances, 56 have a known feasible solution (they will form a second group G2). The six remaining instances form the third group G3. These instances are not solved yet. These groups of the instances set will be used during the presentation of the computational results. When it is necessary to indicate a specific instance, the notation 
                        
                           N
                           _
                           
                              
                                 T
                              
                              
                                 H
                              
                              
                                 i
                              
                           
                           _
                           m
                        
                     , will be used, where N stands for the original VRP instance name and i
                     =1, 2 for the horizon length.

The overtime penalization parameter θ is set to 2 and it is kept fixed during all the search. That is done because the value θ
                           =2 is used in literature to penalize overtime when a feasible solution is not found.

The overload penalization parameter λ is set to 
                              
                                 
                                    
                                       d
                                    
                                    
                                       ¯
                                    
                                 
                                 /
                                 
                                    
                                       q
                                    
                                    
                                       ¯
                                    
                                 
                              
                           , where 
                              
                                 
                                    
                                       d
                                    
                                    
                                       ¯
                                    
                                 
                              
                            represents the average distance among customers and 
                              
                                 
                                    
                                       q
                                    
                                    
                                       ¯
                                    
                                 
                              
                            the average demand of customers. The value of λ is kept fixed during the search. Different dynamic adaptation schemes were tested, but no visible improvements were obtained.

The procedure requires the setting of a number n
                           
                              p
                            of parameters among values that have to be chosen in sensible ranges. To set the parameters involved in our algorithm, a tuning method is used. Roughly speaking, a tuning method is a procedure whose search space is 
                              
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 ×
                                 ⋯
                                 ×
                                 
                                    
                                       P
                                    
                                    
                                       
                                          
                                             n
                                          
                                          
                                             p
                                          
                                       
                                    
                                 
                              
                           , where P
                           
                              i
                            is the domain of parameter i and looks for the solution with the best utility, that is a measure of the algorithm’s efficiency on a given parameter vector Smit and Eiben (2009). In particular, the Evolutionary Strategy with Covariance Matrix Adaptation proposed by Hansen and Ostermeier (2001) is used. The tuning algorithm is run on a limited set of instances formed by 
                              
                                 CMT
                                 1
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       2
                                    
                                 
                                 _
                                 4
                              
                           , 
                              
                                 CMT
                                 2
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 6
                              
                           , 
                              
                                 CMT
                                 3
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 6
                              
                           , 
                              
                                 CMT
                                 4
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 8
                              
                           , 
                              
                                 CMT
                                 5
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 9
                              
                           , 
                              
                                 CMT
                                 11
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 4
                              
                            to determine the values of parameters listed in Table 3
                           . Instances with a large number of vehicles were selected since they are more difficult to solve. Other parameters are fixed a priori: the probability of educate a new chromosome is p
                           
                              LS
                           
                           =1 and the probability to repair an infeasible chromosome is p
                           
                              rep
                           
                           =0.5 as in Vidal et al. (2013). The adopted survivor strategy (Section 3.6) allows for the use of LS to educate each chromosome without premature convergence of the population. That is in particular due to the fact that survivor chromosomes are selected based on their contribution to the diversification of the population as well as their fitness value.

@&#DISCUSSION@&#

A fair and comprehensive comparison with previous works is quite difficult to carry out since (as already mentioned) complete and precise values are reported only by Salhi and Petch (2007).


                        Olivera and Viera (2007), report detailed results as well, but with some imprecision. Indeed, these authors provide gaps to values z
                        ∗ (see Table 2), which cannot be precisely converted into solution costs due to truncation.

Notation reported in Table 4
                         will be used in the following. In all tables, the first three columns indicate respectively the name, the number of vehicles and the time horizon of the instances.

All procedures stop once 2000 individuals have been generated. Preliminary computational experiments shown that it is a good compromise between solution quality and computational efficiency.

The results are reported as follows. In Section 5.2.1, the ability of the algorithm to find feasible solutions is tested. The algorithm terminates whenever a feasible solution is found, or after 2000 chromosome constructions. In Section 5.2.2 two variants of the algorithm, with or without CLS, are evaluated and complete and detailed results are reported. Both versions stop after a fixed number of iterations. Separate comparison with the results obtained by Olivera and Viera (2007) is discussed in Section 5.2.3. Finally, computational times comparison is discussed in Section 5.2.4.

The procedure is first run five times over all instances to measure its capability to obtain feasible solutions: it stops as soon as a feasible solution is found or after 2000 iterations. It is indicated as MA-F. The efficiency of the algorithm is measured on the time needed to find a feasible solution without considering its value, following the implicit idea of the paper by Taillard et al. (1996). Results are reported on Tables 5, 6
                           
                           .

The algorithm is able to find a feasible solution in at least one run on all instances from groups G1 and G2. Better, feasible solutions are always found on G1 and for 50 instances out of 56 on G2. In general, on all the 490 runs, feasible solutions are obtained 471 times, denoting high efficiency of the algorithm. Comparatively, only Olivera and Viera (2007) exhibit similar results. No feasible solutions are found on G3 instances.

The algorithm is run again five times over all the instances. Complete and detailed results are reported in Tables 7 and 8
                           
                           . Results from the MA without CLS are reported in columns indicated with MA while those from the MA with CLS are given in columns indicated with MA+CLS.


                           Table 7 reports results obtained on the 42 instances of G1. Optimal values are indicated in bold. MA and MA+CLS find optimal solutions on all the five runs in 23 cases, but the former finds the optimal value at least once in 32 cases while the latter in 37 cases. In general, MA+CLS is more efficient in finding optimal solutions: they are obtained 137 times over 210 runs while MA finds optimal solutions 129 times. Both procedures always find feasible solutions. Note that Salhi and Petch (2007) do not find any optimal solution and it is outperformed by both methods on all instances.

Results on instances of G2 are detailed in Table 8. Here, bold numbers are used to indicate best known values. MA finds a feasible solution at least once over all instances and the procedure finds a feasible solution on all the five runs in 50 cases (out of 56) for a total of 261 feasible solutions out of 280 runs. Introducing the CLS improves the results. Feasible solutions are always found in 52 cases and at least 2 feasible solutions are found over the five runs for a total of 271 feasible solutions. Again, solutions found by the procedures are always better than those reported in Salhi and Petch (2007).


                           Tables 9 and 10
                           
                            report results on instances of G3. Best known solution values are reported in bold. First of all, it can be noticed from Table 9 that MA+CLS finds a new feasible solution for instance CMT
                              
                                 4
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 7
                              
                            (details can be found in Appendix A). On the other five instances (Table 10), direct comparison with other methods on values of infeasible solutions found is possible. MA+CLS finds two new best known values for instances 
                              
                                 CMT
                                 2
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 7
                              
                            and 
                              
                                 F
                                 11
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 3
                              
                           . For the latter, the new best known value is as well reached by MA. On average, both methods outperform the others.

Averagely, MA+CLS performs better than MA as can be seen in the last columns of Tables 7 and 8. This, together with the new feasible solution found for instance 
                              
                                 CMT
                                 4
                                 _
                                 
                                    
                                       T
                                    
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 _
                                 7
                              
                            by MA+CLS, validates the usefulness and efficiency of the CLS.

A full comparison following the scheme proposed by Olivera and Viera (2007) is proposed in Tables 11 and 12
                           
                           . Given a solution ξ, the value GAP(ξ) is calculated as
                              
                                 (6)
                                 
                                    GAP
                                    (
                                    ξ
                                    )
                                    =
                                    100
                                    ·
                                    
                                       
                                          
                                             
                                                
                                                   c
                                                   (
                                                   ξ
                                                   )
                                                
                                                
                                                   
                                                      
                                                         z
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                             -
                                             1
                                          
                                       
                                    
                                    ,
                                 
                              
                           and results are reported accordingly. The number of runs ended with a feasible solution is reported for instances in G1 as in Olivera and Viera (2007). Focusing on the gap values, as it can be noticed, results obtained by MA+CLS outperform those by Olivera and Viera (2007). On the other side, the algorithm proposed by Olivera and Viera (2007) performs better than MA-F. A probable reason is that MA-F terminates the procedure as soon as a feasible solution is found, while Olivera and Viera (2007) check for feasibility each 100 iterations of their procedure. Regarding computing times (see Section 5.2.4), note however that Olivera and Viera (2007) and MA-F are much quicker than MA+CLS.

A fair computational time comparison could not be performed as the machine relative speeds were not found for all the computers used by previous papers. Machines used in previous works are listed in Table 13
                           . Original computational times, as well as those of our method, are reported in Table 14
                            (times are expressed in seconds). Furthermore, algorithm differences and inharmonious computational time reporting complicate comparison. In particular, Taillard et al. (1996) perform their algorithm five times on each instance. If no feasible solution is found, it is run another time. Average time on all runs is reported. Brandão and Mercer (1998) stop their procedure once a feasible solution is found and they report computational times over the runs where a feasible solution is found. Salhi and Petch (2007) and Alonso et al. (2008) stop their algorithm when a maximum number of iteration is reached, but while the former reports average computational time over five runs the latter runs the algorithm just once. Olivera and Viera (2007) check for feasibility each 100 iterations and terminate the computation in case of success. They report computational times only for the best run. We report the average computational time, on five runs, for each class of instances. Finally, our goal is to find high quality solution and not to just satisfy feasibility as it was done in previous works. Keeping that in mind, it can be noticed from Table 14 that MA-F is able to find feasible solutions very quickly (almost instantaneously for instances of families CMT3 and F12). We can also notice that the use of the CLS increases the time spent by the procedure. The time increase is, however, rewarded by more efficiency in finding optimal and feasible solutions as already outlined in Section 5.2.2.

In this paper we proposed a genetic algorithm for the Multi Trip Vehicle Routing Problem. It is the first evolutionary procedure that efficiently faces the benchmark of instances proposed in the literature.

We use an adaptation of the Split procedure proposed by Prins (2004) to evaluate the chromosomes.

We introduce a new LS operator that performs pejorative moves along with re-assignment of trips to vehicles and is called Combined LS (CLS). The efficiency of the CLS is validated by the quality of the results obtained. This opens a new promising research direction related to the management of moves combined with re-packing procedures.

We report detailed results over all instances (and not only for unsolved instances) and we give precise values of the found solutions (differently than what is done in Olivera & Viera (2007)).

The method finds a feasible solution over 99 instances, one more than all the previous works (that have failed in finding a feasible solution for instance 
                        
                           CMT
                           4
                           _
                           
                              
                                 T
                              
                              
                                 H
                              
                              
                                 1
                              
                           
                           _
                           7
                        
                     ). Solutions found are always better than those reported by Salhi and Petch (2007) (the only paper which gives detailed results). GAP values are averagely better than those reported by Olivera and Viera (2007).

The proposed algorithm could be extended to the MTVRP with time windows introducing slight modifications into the AdSplit procedure explained in Section 3.2, in moves M1–M10 and in the CLS. This will be the subject of future research.

@&#ACKNOWLEDGEMENT@&#

This work is supported by the French National Research Agency (ANR-Agence Nationale de la Recherche) and is part of project MODUM-Mutualisation et Optimisation de la distribution Urbaine de Marchandises.

The procedure found a new feasible solution for problem 
                        
                           CMT
                           4
                           _
                           
                              
                                 T
                              
                              
                                 H
                              
                              
                                 1
                              
                           
                           _
                           7
                        
                      that is detailed in Table A15
                      where v, r, τ
                     
                        r
                      and l
                     
                        r
                      indicate the vehicle, the route, its traveling time and its load.

@&#REFERENCES@&#

