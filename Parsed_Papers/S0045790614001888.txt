@&#MAIN-TITLE@&#Energy-aware routing algorithm for wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new energy aware routing algorithm has been proposed for cluster based wireless sensor networks.


                        
                        
                           
                           It achieves O(1) message complexity per sensor node and O(n) time complexity for a WSN having n sensor nodes.


                        
                        
                           
                           It efficiently forms the directed virtual backbone of cluster heads to facilitate data routing to the sink.


                        
                        
                           
                           It is successful in balancing the relaying load among the sensor nodes with respect to their residual energy.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Clustering

Routing

Energy efficient

Network lifetime

Energy consumption

@&#ABSTRACT@&#


               
               
                  The main constraint of wireless sensor networks (WSNs) is the limited and generally irreplaceable power source of the sensor nodes. Therefore, designing energy saving routing algorithm is one of the most focused research issues. In this paper, we propose an energy aware routing algorithm for cluster based WSNs. The algorithm is based on a clever strategy of cluster head (CH) selection, residual energy of the CHs and the intra-cluster distance for cluster formation. To facilitate data routing, a directed virtual backbone of CHs is constructed which is rooted at the sink. The proposed algorithm is also shown to balance energy consumption of the CHs during data routing process. We prove that the algorithm achieves constant message and linear time complexity. We test the proposed algorithm extensively. The experimental results show that the algorithm outperforms other existing algorithms in terms of network lifetime, energy consumption and other parameters.
               
            

@&#INTRODUCTION@&#

Wireless sensor networks (WSNs) have gained enormous attention for their usage in monitoring environment, security surveillance, heath and underground mines [1]. However, the main limitation of WSNs is that the sensor nodes are operated on limited power sources. Moreover, in several applications such as in battlefields, dense forest etc. sensor nodes are not easily accessible due to hostile nature of such environment and therefore they cannot be recharged. Thus energy conservation of the sensor nodes to maximize the network lifetime is one of the most challenging issues in WSNs. Therefore, a lot of research has been carried out for energy saving of the sensor nodes for the long run operation of the WSNs.

One of the techniques to save the energy consumption is clustering sensor nodes [2–14]. In clustering process, sensors nodes are organized into distinct groups, called clusters and each cluster has a coordinator referred as cluster head (CH) and remaining nodes within a cluster act as cluster members (CMs). Each sensor node must belong to one and only one cluster. Sensor nodes send their sensed data to their corresponding CHs. CHs then aggregate them and send it to a remote base station called sink using single hop or multi-hop communication. Many cluster-based multi-hop routing algorithms have been developed in the literature which can be found in [15–22]. In most of these techniques, periodic re-clustering is performed to balance the energy consumption of the CHs. However, in such routing techniques, all neighbor CHs may route their data packets to a single CH which may deplete its energy quickly. As a result, the whole network may get partitioned in the very early stage. In addition to this, clustering algorithm also influences the performance of the routing algorithm owing to inefficient CH selection, uneven CH distribution and ineffective cluster formation. A sensor node cannot sustain as a CH if its residual energy is very low since the CHs are burdened with extra work as compared to their member sensor nodes. If the selected CHs are not well distributed in the network, then the distance between the CHs and their member sensor nodes is not minimal. This consumes more energy for intra-cluster communication. Furthermore, inappropriate selection by a sensor node to join a CH also leads to improper energy utilization.

In this paper, we propose a new energy-aware routing algorithm, called ERA for a cluster based wireless sensor network that addresses the above mentioned issues. In our approach, all the sensor nodes are organized into distinct clusters. To select CHs, each node starts the campaign to become a CH by initiating a time delay which depends on its residual energy. To form clusters, nodes join CHs by considering their residual energy and distance. Then, a directed virtual backbone (DVB) of CHs rooted at the sink is constructed using all the CHs to facilitate the routing of the data. In data routing, each CH forwards the data packets to next hop CHs in such way that their energy consumption can be balanced. Experiments are performed on the proposed algorithm, ERA. The results are compared with existing routing algorithms such as EEPA (energy-efficient and power-aware) [18] and EADC (energy-aware distributed clustering) [23] and also with our previous works such as BDCP (backoff-based distributed clustering protocol) [14] and EMRA (energy-aware multi-level routing algorithm) [25]. The results demonstrate the effectiveness of the proposed algorithm in terms of network life time, energy consumption, power imbalance factor, and data aggregation.

The remainder of the paper is organized as follows. We review some related works in Section 2.The system models for the proposed algorithm are presented in Section 3. The proposed algorithm is described in Section 4. We present experimental results and their comparison with other existing algorithms in Section 5 followed by the conclusion in Section 6.

@&#RELATED WORKS@&#

Many clustering algorithms have been developed for WSNs. LEACH (low energy adaptive clustering hierarchary) [3] is a well known distributed clustering algorithm in which CHs are selected with some probability and remaining nodes join the nearest CH without considering its residual energy. Although the role of CH is rotated among the nodes, the overall energy consumption of nodes is neither balanced nor minimized. Moreover, this approach does not ensure even distribution of the CHs across the whole network. HEED (a hybrid energy-efficient distributed clustering) [4] is another popular distributed clustering algorithm that selects CHs by considering residual energy of the sensor nodes and intra-cluster distance as the primary and secondary criteria respectively. It achieves well distribution of CHs and minimizes intra-cluster communication cost. However, HEED introduces extra communication overhead to compute the communication cost with its neighbors by exchanging large number of messages. Many other clustering algorithms have been proposed in the literature [5–14]. All these algorithms introduce high message complexity in selecting CHs and forming the clusters, almost similar to HEED.

Multi-hop based data transmission has been considered as an efficient technique to conserve the energy of the sensor nodes. Some of the proposed techniques can be found in [15–22]. In CPEQ (cluster-based, periodic, event driven, and query processing) [15], a CH sends its data to the sink via minimum number of intermediate sensor nodes. To find the minimum hops, the sink starts the restricted flooding mechanism to configure all the nodes into number of hops away from the sink. Then a CH forwards the data to the next hop CH which is closest to the sink. In EEPA [18], a CH floods the route request packet to the sink. Upon receiving multiple copies of the packet via different paths, the sink computes the total cost of the each path, a cost is embeds by each node along the path. The cost depends on the residual energy of the CHs along the routing path and communication energy consumed by these nodes. Then, the sink sends back the route reply message in the same reverse paths. The message contains the total cost of the path. Upon receiving the multiple copies of the route reply message, the CH chooses one of the paths with minimum cost and confirms the route. However, this technique constructs efficient route at the cost of huge control messages and multiple paths are constructed without use of most of them. Other approaches as reported in [19–22] try to build routing tree for data transmission and switch to different tree structures to alleviate the imbalance energy consumption of the sensor nodes along the routing path. Recently, an energy-aware routing algorithm called EADC has been proposed in [23]. In this algorithm, a CH is selected on the basis of the ratio between its residual energy to the average residual energy of its neighbors. To form clusters, each node chooses the nearest CH without considering its residual energy. To route the data to the sink, a CH chooses the next hop CH by considering its residual energy and load i.e., number of CMs. However, one common problem in all these techniques is that they do not assure that the relaying load of the CHs is balanced with respect to their residual energy. In other words, all the CHs are not participating in relaying the data of other CHs resulting imbalance of energy consumption of the CHs. Hence, it limits the network lifetime. The authors of this paper proposed an energy aware multilevel routing algorithm for cluster based WSNs, called EMRA [25]. However, the algorithm suffers from high message complexity. We also presented a clustering algorithm called BDCP [14]; but this was without any routing algorithm. However, the algorithm was experimented by assuming single hop communication between the CHs and the sink similar to LEACH [3]. In the present version, we extend the work of BDCP by developing a new multi-hop routing algorithm. We also incorporate a cluster formation technique which is different and more efficient than the BDCP. The advantages of the proposed algorithm are summarized as follows:
                        
                           (1)
                           Each sensor node independently decides its candidature for CH selection. Therefore, this technique does not require exchange of any control messages.

For efficient formation of clusters, each node decides itself to join a CH by considering both the residual energy of the CHs and the distance. This results in energy saving of the WSNs.

To balance the forwarding load of the CHs, we devise a simple and elegant method by which each CH distributes and transmits the data packets to a next hop CH for equalizing their energy consumption.

Here we present some assumptions for the network model used in the proposed algorithm followed by the energy model of the sensor nodes.

We assume that a homogenous set of sensor nodes are deployed in the target area. All the sensor nodes become static once they are deployed and the target area is completely covered by them. The sink is also static and located outside the target area. We assume that all the sensor nodes are initially provisioned with equal amount of energy. Each sensor node has given a unique identification number, sensing range, denoted by r, and communication range R where R
                        =2r, as shown in Fig. 1
                        . We also assume that the inter-cluster transmission range between the CHs can be adjusted to kR (k
                        =2, 3 …). The maximum value of k is derived in the next section. The sensor nodes are aware of their locations through some localization techniques such as proposed in [24].

The energy model of the WSN is adopted from [3] in which both the free space and multi-path fading channels are used depending on the distance between the transmitter and receiver node. If the distance is less than a threshold value d
                        0, then the free space (fs) model is used, otherwise, the multipath (mp) model is considered. Let εfs
                         and εmp
                         be the energy required by amplifier in free space and multipath respectively. Let αtx
                         and αrx
                         be the energy dissipated in transmitting and receiving one bit respectively. Then the energy consumed by node i to transmit β-bit data packet to node j is given as follows
                           
                              (3.1)
                              
                                 
                                    
                                       E
                                    
                                    
                                       tx
                                    
                                 
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         tx
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         ε
                                                      
                                                      
                                                         fs
                                                      
                                                   
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   )
                                                   β
                                                   ,
                                                   
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   <
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         tx
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         ε
                                                      
                                                      
                                                         mp
                                                      
                                                   
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                      
                                                         4
                                                      
                                                   
                                                   )
                                                   β
                                                   ,
                                                   
                                                   
                                                      
                                                         D
                                                      
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                   
                                                   ⩾
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where D
                        (
                        
                           i, j
                        
                        ) is the distance between the node i and j.

Also the energy consumed in receiving the β-bit data by node j is given by
                           
                              (3.2)
                              
                                 
                                    
                                       E
                                    
                                    
                                       rx
                                    
                                 
                                 (
                                 j
                                 )
                                 =
                                 
                                    
                                       α
                                    
                                    
                                       rx
                                    
                                 
                                 β
                              
                           
                        
                     

The algorithm consists of two phases, namely clustering and routing. They are subsequently described in the following sections.

Here, sensor nodes are grouped into clusters as follows. Each sensor node sets its own timer independently before it starts the campaign for CH selection. Let t(i) be the timer of sensor node i which is derived as follows
                           
                              (4.1)
                              
                                 t
                                 (
                                 i
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       i
                                       )
                                       -
                                       
                                          
                                             E
                                          
                                          
                                             r
                                          
                                       
                                       (
                                       i
                                       )
                                    
                                    
                                       
                                          
                                             E
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       i
                                       )
                                    
                                 
                                 ×
                                 
                                    
                                       T
                                    
                                    
                                       CH
                                    
                                 
                              
                           
                        where TCH
                         is the maximum allotted time for CH selection, Em
                        (i) and Er
                        (i) are the initial maximum energy and residual energy of the sensor node i respectively. According to Eq. (4.1), a sensor node with higher residual energy will be selected as CH since it has shorter time. Once the timer expires then the node i selects itself as a CH and broadcasts a CH announcement message in the communication range R. The announcement message includes its identification number (ID), residual energy Er
                        (i) and location information. If a node j receives the message then it withdraws its candidature for CH selection by cancelling its timer and becomes a non-CH node for the upcoming communication round. Node j also starts keeping track of the sensor nodes from which it receives CH announcement messages by maintaining a neighbor CH set denoted by NCH
                        (i). Node j decides its cluster membership in the later stage by using NCH
                        (i).

To form the clusters, each non-CH node decides its cluster membership as follows. Node j needs to join one of the CHs belonging to the set NCH
                        (j). Let v
                        1, v
                        2, v
                        3, …, vm
                         be the set of CHs belonging to the set NCH
                        (j). Then, the node j computes the average residual energy of the CHs, denoted by μ(j) which is calculated as follows
                           
                              (4.2)
                              
                                 μ
                                 (
                                 j
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             m
                                          
                                       
                                       
                                          
                                             E
                                          
                                          
                                             r
                                          
                                       
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       m
                                    
                                 
                              
                           
                        
                     

Node j joins the nearest CH whose residual energy is greater than or equal to μ by broadcasting a cluster join message in the communication range R. Note that the approach of CH selection distributes the CHs across the whole network evenly, i.e., no two CHs are neighbor to each other. The pseudo code of the algorithm is shown in Fig. 2
                        .
                           Lemma 1
                           
                              Message and time complexity of the proposed clustering method is O(1) per sensor node and O(n) for n sensor nodes in the network.
                           

For clustering, a sensor node either broadcasts a CH announcement message or cluster join message only. Therefore, the message complexity of the proposed clustering method is O(1). Each node decides independently to become a CH or not. This can be done in constant time. To form clusters, each sensor node need to process n−1 CHs in worst case to join a cluster. Therefore, the time complexity of the proposed clustering method is O(n).□


                              The maximum inter-cluster communication range to ensure connectivity between the CHs is 3R given that the sensor nodes sufficiently cover the entire target area, where R is the communication range of the sensor nodes.
                           

We prove the lemma by using the following two cases:


                              
                                 
                                    (1)
                                    
                                       Case (i): Let u be the non-CH node and it receives the CH announcement message from the CHs v and w (see Fig. 3
                                       (a)). It means that the maximum possible distance between u and v and also between u and w is less than or equal to R. Therefore, the maximum possible distance between u and w is 2R.


                                       Case (ii): Let u and v be two non-CH nodes and the distance between them is less than or equal to R. They receive the CH announcement message from the CHs w and x respectively, as shown in Fig. 3(b). It is obvious to note that the maximum distance between u and x is less than or equal to 3R.□

To route the data to the sink, a directed virtual backbone (DVB) of the CHs rooted at the sink is constructed as follows. Initially, the sink sends a route request message RREQ to the CHs in the range 2R. The message contains its ID, level (L) and location information. The level of the sink is assumed to be at zero, i.e., L(sink)=0. When a CH u receives the message then the node increments its level to one higher than the sink, i.e., L(u)=
                        L(sink)+1 and sets the sink as its parent node (PN), i.e., PN(u)=sink. In other words, all the CHs within the range 3R to the sink are designated as level one. Recursively, node u broadcasts a modified RREQ message to the CHs in the range 3R. The message consists of its ID, L(u), Er
                        (u) and location information. If a CH v receives the message and if its level is equal or less than the level of the node u, then it simply discards the message. Otherwise, it updates its level to one more than the level of node u and sets it as one of the PNs, i.e., PN(v)=
                        u. Recursively, all the CHs broadcasts the RREQ to complete the process of forming DVB.

In DVB, a CH may have multiple PNs and hence multiple paths to the sink. Let v
                        1, v
                        2, v
                        3, …, vp
                         are the set of CHs belonging to set PN(u), as shown in Fig. 4
                        .

Prior sending the data packets, node u calculates the average residual energy of the CHs referred as η(u), using the formula
                           
                              (4.3)
                              
                                 η
                                 (
                                 u
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             p
                                          
                                       
                                       
                                          
                                             E
                                          
                                          
                                             r
                                          
                                       
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       p
                                    
                                 
                              
                           
                        
                     

Let W
                        ={w
                        1, w
                        2, w
                        3, …, wm
                        } be such CHs whose residual energy is greater than or equal to η(u). Then, node u distributes all incoming data packets including its own into the following ratios
                           
                              (4.4)
                              
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       3
                                    
                                 
                                 )
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       4
                                    
                                 
                                 )
                                 :
                                 
                                 ⋯
                                 
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       m
                                    
                                 
                                 )
                              
                           
                        and sends them to the corresponding CHs. The schedule for data sending and receiving is shown in Fig. 5
                        . The pseudo code of the routing algorithm is shown in Fig. 6
                        .
                           Remark 1
                           Note that according to Eq. (4.3), each CH eliminates those next hop CHs which have relatively less residual energy than others. Each CH distributes the data packets among the next hop CHs whose residual energy is greater than or equal to η. As a result, residual energy of the forwarding CHs is balanced.


                              The time complexity of the proposed algorithm is O(n) for n sensor nodes in the network.
                           

It can be note from Lemma 1 that the time complexity of the clustering algorithm is O(n). During data routing phase, each CH needs to calculate the average residual energy of the next hop CHs (using Eq. (4.3)) for which it requires to check residual energy of n−1 CHs in worst case. Therefore, the time complexity of the proposed algorithm (clustering and routing) is O(n).□

In this section, we present the experimental results of the proposed algorithm ERA and their comparisons with the existing algorithms, EEPA [18], EADC [23]. The results are also compared with EMRA [25] and our previous version BDCP [14]. Simulation program was written in Dev C++ and Matlab. The parameters and their values used in the simulation are given in Table 1
                     .

In our experiments, we choose two types of node deployments; random and grid. In random deployment, sensor nodes are randomly deployed in the target area of the size 100×100 meter square. In case the grid deployment, nodes are deployed on the grid lines of the target area 100×100 meter square. We assumed that the location of the sink was set (50,0) in the 100m×100m plane. Examples of these two deployments scenarios are shown in Fig. 7
                     .

To evaluate the performance of ERA, we use several performance metrics described as follows.
                        
                           1.
                           
                              Network lifetime (NL-FND): The network lifetime (NL) of the WSN is defined as the number of rounds until the first node dies (FND). For the sake of completeness, we also show the number of alive sensor nodes per round.


                              Power imbalance factor (PIF): We define this metric to evaluate the energy balance characteristics of the proposed algorithm. This is expressed as the standard deviation of energy consumption of the sensor nodes and given by 
                                 
                                    (5.1)
                                    
                                       PIF
                                       =
                                       
                                          
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         E
                                                      
                                                      
                                                         avg
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         E
                                                      
                                                      
                                                         con
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                               where n is the number of alive sensor nodes, Eavg
                               is the average residual energy consumption of the sensor nodes, and Econ
                              (i) is the energy consumed by the node i in the current round. In addition to this, we also show the average energy consumption of the sensor nodes.


                              Data aggregation (Dagg
                              ): We quantify the NL-FND with different level of data aggregation as follows. Let u be the CH and m be the number of CMs of u. we assume that, in a round, a CM sends a single data packet to its CH. Therefore, the number of data packets received by CH u is equivalent to m. Then, CH u adopts data aggregation strategy as given by the following equation 
                                 
                                    (5.2)
                                    
                                       
                                          
                                             D
                                          
                                          
                                             agg
                                          
                                       
                                       =
                                       k
                                       ×
                                       m
                                    
                                 
                               where, k is the constant coefficient lies in the interval [0,1]. Here, k
                              =0means that the CH u aggregates all of its data packets into one packet irrespective of the CMs. In case of k
                              =1, CH u does not perform aggregation of data packets. If k
                              =0.5, then the node u aggregates m packets into m/2 number of data packets.

We ran the algorithms with 200 sensor nodes using random and grid deployment. The results are shown in Fig. 8
                        (a) and (b) respectively. We observe that the proposed algorithm ERA outperforms the algorithms EADC, EEPA, EMRA and BDCP.

In order to evaluate the performance of the proposed routing algorithm for various density of the sensor nodes, we also tested the algorithms by varying the number of sensor nodes from 200 to 600 in the same target area. Fig. 9
                        (a) and (b) show the NL-FND of the algorithms. Note that ERA achieves 15–30% improvement on network lifetime over the EMRA in both the random and grid deployment, 30–150% over EADC and EEPA and 150–175% over BDCP. We also observe that as the number of sensor nodes increases the performance of the proposed ERA also increases relatively. The performance of BDCP is very poor since it adopts single hop communication between the CHs and the sink for data sending and this consumes high energy. Comparatively EMRA performs better but inferior to ERA as it bears high message complexity for building backbone network of CHs.

Next we ran the algorithms to evaluate energy consumption. The results are shown in Fig. 10
                        (a) and (b) in terms of average energy consumption of the sensor nodes for random and grid deployment respectively. These figures show that the proposed algorithm achieves less energy consumption as compared to existing algorithms.

We also evaluate the PIF. Fig. 11
                        (a) and (b) show the PIF of the sensor nodes for the random and grid deployment respectively. It is easy to observe that the energy consumption of the proposed ERA is more balanced than the existing algorithms including EMRA and BDCP.

Here, we evaluate the performance of the algorithm by varying the k value (refer Eq. (5.2)). Fig. 12
                        (a) and (b) show the NL-FND for different values of k. We observe that the performance of the proposed ERA is best among all the algorithms including EMRA and BDCP. Note that it relatively increases as the load on each CH increases for both the deployment scenarios.

The reasons for the superior performance of the proposed ERA are justified and summarized as follows:
                           
                              (1)
                              In ERA and EADC, selection of CHs depends on its residual energy whereas CHs are selected with some probability in EEPA. Sensor nodes with higher residual energy can sustain as CHs for longer period of time as the CHs are burdened with extra load as compared to CMs.

While forming the clusters, non-CH nodes in both EADC and EEPA join the nearest CH without considering their residual energy. In ERA, non-CH nodes consider both the residual energy as well as the distance to join a CH.

In ERA, each CH distributes data packets proportional to the residual energy of the next hop CHs. This balances the relaying load of the CHs and therefore balances the energy consumption. On the other hand, a CH route all of its data packets to a single CH in EADC and EEPA. As a result only a few CHs are heavily burdened with relaying traffic load and others are ideal. This leads to early death of the CHs and thus limits the network lifetime.

In EMRA, the message complexity for backbone formation of the CHs is very high as compared to the proposed algorithm. In addition to this, a CH selects very few CHs as next hop CHs amongst available to forward its data results in imbalance energy consumption due to uneven data forwarding load.

In BDCP, a CH sends the data packets to the sink directly which consumes very high energy. As a result, BDCP reports early death of the sensor nodes and hence the network lifetime in BDCP is very less.

@&#CONCLUSION@&#

Conservation of energy is the main challenge in the development of wireless sensor networks. We have presented in this paper, a new energy efficient routing algorithm for wireless sensor networks called ERA. The algorithm consists of clustering and routing phases. We have shown that there is no requirement of any exchange of control message for cluster head selection. We have developed an efficient strategy to organize all the CHs into various levels for constructing a directed virtual backbone to facilitate data routing toward the sink. We have also devised a simple but elegant method to ensure that all the CHs should take part in data routing process and at the same time their relaying load is balanced with respect their residual energy. It has ben shown that the proposed algorithm has O(1) message complexity per sensor node and O(n) time complexity for a WSN with n sensor nodes. The algorithm has been simulated extensively. For the sake of comparison, simulations have been made by considering two scenarios of node deployment, random and grid. Simulation results have been compared with four existing algorithms. The proposed algorithm has been shown to outperform all these algorithms in terms of various performance metrics including network lifetime, energy consumption, power imbalance factor, and data aggregation in both the scenarios of sensor node deployment. However, we have not considered the dynamic scenario and fault tolerant aspects of the sensor network in the proposed work. Our attempt will be made to address these issues in our future research.

@&#ACKNOWLEDGEMENT@&#

The first version of the paper was appeared in the Proceedings of the International Conference ICACCI 2013, 22–25 August, 2013 (IEEE Explorer, pp. 1012–1016, 2013), Mysore, India. The authors are thankful to the anonymous reviewers for their valuable comments and suggestions.

@&#REFERENCES@&#

