@&#MAIN-TITLE@&#Multi-objectivization Via Decomposition: An analysis of helper-objectives and complete decomposition

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           First known analytic comparison of Pareto frontiers generated by different algorithms.


                        
                        
                           
                           Analytic and empirical study between complete decomposition vs. helper objectives.


                        
                        
                           
                           First study of heuristic strength and decomposition size for multi-objectivization (supplemental material).


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi-objectivization

Multi-Objectivization via Segmentation (MOS)

Helper-objectives

Complete decomposition

Job shop scheduling problem (JSSP)

@&#ABSTRACT@&#


               
               
                  Multi-objectivization has been used to solve several single objective problems with improved results over traditional genetically inspired optimization methods. Multi-objectivization reformulates the single objective problem into a multiple objective problem. The reformulated problem is then solved with a multiple objective method to obtain a resulting solution to the original problem. Multi-objectivization Via Decomposition (MVD) and the addition of novel objectives are the two major approaches used in multi-objectivization. This paper focuses on analysis of two major MVD methods: helper-objectives and complete decomposition. Helper-objectives decomposition methods identify one or more decomposed objectives that are used simultaneously with the main objective to focus attention on components of the decomposed objectives. Complete decomposition, unlike helper-objectives does not explicitly use the main objective and instead uses decomposed objectives that exhaustively cover all portions of the main objective. This work examines the relationship between helper-objective decompositions and complete decomposition using both an analytic and experimental methodology. Pareto dominance relationships are examined analytically to clarify the relationship between dominant solutions in both types of decompositions. These results more clearly characterize how solutions from the two approaches rank in Pareto-frontier based fitness algorithms such as NSGA-II. An empirical study on job shop scheduling problems shows how fitness signal and fitness noise are affected by the balance of decomposition size. Additionally we provide evidence that, for the settings and instances studied, complete decompositions have a better on-average performance when compared to analogous helper-objective decompositions. Lastly we examine the underlying forces that determine effective decomposition size. We argue that it is advantageous to use less balanced decompositions as within-decomposition conflict increases and as heuristic strength increases.
               
            

@&#INTRODUCTION@&#

Genetic Algorithms (GAs) are a machine intelligence technique that is inspired by the process of modeling survival-of-the-fittest on a group of solutions. GA terminology has been inspired by similar biological phenomena. An individual, contains decision variables, genes, required to constitute a solution. The GA manages a group of individuals called a population. Populations change over time through several processes. Solution generation occurs through the recombination of individuals. Recombination conveys traits from a set of two or more parents, selected through parent selection, to new child solutions. Children can also be generated through mutation. Mutation is a process that randomly changes genetic material in a solution. Children and parents compete for a spot in the successor population, generation, through a process called survival selection. Both parent and survival selection must create some pressure toward surviving fitter individuals. However, it is also important that a GA maintains diversity in the population so that the global search method does not converge too quickly. Since GAs manage a group of solutions, it is possible to have the algorithm find multiple solutions to a problem simultaneously. The reader is referred to De Jong (2006) for more details on GAs.

Evolutionary Multi-objective Optimization (EMO) techniques are genetically inspired techniques that attempt to solve multi-objective problems. Ideally these methods create a variety of solutions along a Pareto efficient frontier so that the decision maker can pick from several alternatives that are Pareto incomparable. These methods must balance two forces that control selection pressure: the dominance relationship between solutions and the diversity of Pareto incomparable solutions. Descriptions for many of the Multi-Objective Evolutionary Algorithms (MOEAs) used in EMO are provided in Coello Coello, Lamont, and Van Veldhuisen (2007).

An optimization technique called multi-objectivization has been used to solve several single objective problems with improved results over traditional genetically inspired optimization methods. Multi-objectivization, a term and technique introduced in Knowles, Watson, and Corne (2001), reformulates the single objective problem into a multiple objective problem. The problem is then solved using a multi-objective method such as those used in EMO. These reformulations come in two basic types, the addition of novel objectives, and the decomposition of existing objectives (Handl, Lovell, and Knowles, 2008a). The use of existing components of the objective function as the building blocks for decompositions is termed Multi-objectivization Via Decomposition (MVD) in this paper. MVD has been applied to problems with sum-of-parts objective functions. The Traveling Salesman Problem (TSP) and the Job Shop Scheduling Problem (JSSP) for flowtime are the two most studied problems using MVD to date. The TSP has been studied in Knowles et al. (2001), Jensen (2004), Jahne, Li, and Branke (2008), and Lochtefeld and Ciarallo (2014) and the JSSP has been studied in Jensen (2004) and Lochtefeld and Ciarallo (2011). These problems have a permutation string based representation where the order of the elements in the solution is significant.

The two major methods used in MVD to date are helper-objectives (Jensen, 2004) and complete decomposition (Jahne et al., 2008). The only empirical evidence directly comparing these methods to date was accomplished on the TSP in Jahne et al. (2008). We explore more deeply the relationship between helper-objectives and complete decomposition methods. We explore analytically how Pareto efficient frontiers interrelate between the two methods for additive fitness functions. An empirical study on the JSSP is also used to explore the relationship between complete decomposition and helper methods.

Multi-objectivization is theorized to improve performance over single-objective methods in two ways. The signal-to-noise principle (Lochtefeld and Ciarallo, 2012) theorizes that some fitness improvements in an objective (signal) are not always recognized and rewarded if they happen to be expressed in a solution at the same time that an offsetting fitness decrement (noise) is generated in another part of the objective. The ratio of the frequency and magnitude of fitness improvements to the frequency and magnitude of fitness decrements determines a Signal-to-Noise Ratio (SNR). SNRs in multi-objectivization are discussed in the context of both SNRs within an objective and SNRs between objectives. Multi-objectivization can be thought of as a method that improves the recognition of fitness improvements between objectives and thus this work discusses signal-to-noise in the context of between objective signal and noise. Based on the signal-to-noise principle, Lochtefeld and Ciarallo (2012) studied the TSP and generated decompositions with improved performance over previous decompositions. The second major way multi-objectivization improves performance is the concept that local optima can be overcome because they may not be present in one or more of the new objectives. Another title for this way of improving performance is the “breakage of epistasis”. Epistasis, the nonlinear interactions in a problem (Reeves and Wright, 1995) can be partially circumvented through the use of multi-objectivization although it is possible to also make a problem harder through the decomposition of objectives (Brockhoff, Friedrich, Hebbinghaus, Klein, Neumann, and Zitzler, 2007).

In addition to these principles, several key theoretic results have been proven. Firstly in Knowles et al. (2001), multiobjectivization methods are shown to preserve the global optimal solution as Pareto efficient if either the reformulated problem contains the original objective or the original problem can be decomposed into a sum of several objectives. Secondly, in Handl, Lovell, and Knowles (2008b) multiobjectivization of scalar cost functions are analyzed and it is noted that multi-objectivization of these functions can result in the introduction of additional plateaus in the reformulated problem landscape which may make the problem more difficult for some hill climbing algorithms. Lastly, Brockhoff et al. (2007), working with a well known plateau function, demonstrate that multi-objectivization can both make a problem harder or easier dependent upon the structure of the problem. The work shows that multi-objectivization appears to work best when moderate sized areas of neutral fitness (plateaus in the fitness landscape) must be overcome.

In MVD, there are many possible decompositions but only one subset of decompositions is used at a given point in time as the algorithm proceeds. Because there has not existed a good understanding about which decompositions are best, most MVD methods to date switch decompositions after a period of time so that a single decomposition does not overly bias the search (Jahne et al., 2008; Jensen, 2004; Lochtefeld and Ciarallo, 2014). Lochtefeld and Ciarallo (2014) introduced the term degrees of decomposition which indicates the number of objectives in a given decomposition. We use the term decomposed objective to refer to the subset of objective parts that have been assigned to an objective in the multi-objective search procedure. Individual objective parts associated with a decomposed objective are components of the decomposed objective.

Helper-objectives were proposed by Jensen (2004). Helper-objectives are additional objectives that are used simultaneously with the main objective because the “additional objectives [can guide] the search” (Jensen, 2004). In the work, both the TSP and the JSSP were studied. Jensen used objectives that were decomposed parts of the main objective as the helper-objectives thus Jensen studied helper-objectives using MVD. The work demonstrated that dynamic switching of various helper-objectives often obtained better results than using a single decomposition throughout the run. Helper-objectives are referred to as helpers subsequently in this document.

Prior to Lochtefeld and Ciarallo (2011), previous helper related research on the JSSP studied randomly sequenced helpers chosen from all possible jobs (Jensen, 2004). Lochtefeld and Ciarallo (2011) compared randomly sequenced helpers to a deterministic order of helpers. Improved results were obtained using the Shortest Job First (SJF) rule for sequencing. In the SJF rule, the sequence that jobs are used as helpers is such that shorter jobs are used before longer jobs. The premise of the SJF rule is based upon the well known heuristic in the literature on the management of operations that when optimizing for flowtime it is better to delay a long job by a short job’s time rather than vice-versa (Pinedo, 2009).

Subsequent to helper objectives, Jahne et al. (2008) proposed Multi-Objectivization via Segmentation (MOS). Unlike helper methods which use the main objective simultaneously with decomposed objectives that contain a subset of the main objective’s components, MOS assigns all component parts of the main objective into two or more decomposed objectives. MOS does not explicitly use the main objective. Each decomposed objective in MOS was termed a segment. Instead of segmentation, we term this type of MVD complete decomposition. As the name implies, complete decomposition takes all component parts of the main objective and divides them into a number of new decomposed objectives such that each component of the main objective is represented an equal number of times and all decomposed parts are assigned to a decomposed objective. Equal representation of the objective components preserves the original problem as it is decomposed. Unlike previous approaches, several of the decompositions in MOS were adaptive; the decompositions were based on properties of solutions in the current population. The complete decompositions used in MOS generally outperformed the helper methods on the TSP instances studied. Lochtefeld and Ciarallo (2014) studied MOS and proposed a more general version of MOS called Multi-objectivization via Progressive Segmentation (MOPS). When progressive segmentation is not enabled in MOPS, MOPS is identical to MOS. Progressive segmentation increases the degree of decomposition over time as the evidence provided indicated that using more aggressive multi-objectivization later in the run works best.

One popular MOEA used in multi-objectivization is the Non-dominated Sorting Genetic Algorithm version II (NSGA-II) which is described in Deb, Pratap, Agarwal, and Meyarivan (2002). NSGA-II uses Pareto dominance relationships between solutions to determine the first order of magnitude of fitness for the solution. Then, between solutions that are within the same front, NSGA-II uses a hyper-boxed based penalty function to reward solutions that are far apart so that solutions, hopefully, do not cluster in the same area on the Pareto front. Recent work on MOEA includes Elaoud, Louckil, and Teghem (2007), Beume, Naujoks, and Emmerich (2007), Chen and Lu (2008) and Gong and Cai (2009).

The dominance relationship in NSGA-II is determined as follows. All solutions in the population are searched to find those solutions that are non-dominated, that is, those solutions that are not weakly dominated by any other solution in the population. These non-dominated solutions are all labeled with the front number 1 and are removed from further consideration. Then the remaining population is again searched for non-dominated solutions. These solutions are labeled with the front number 2 and are removed from further consideration. This process proceeds until all individuals in the population have been assigned a front number. In NSGA-II, any individual with a lower front number is considered a more-fit individual than an individual with a higher front number.

In practice, helpers in Jensen (2004) and Lochtefeld and Ciarallo (2011) and complete decomposition in Jahne et al. (2008) and Lochtefeld and Ciarallo (2014) seem to share more similarities than differences. The two methods use the same strategy for mitigating a poor decomposition by using new decompositions over time. The methods both swap in new decompositions using the same logic. Also, both methods are MVD methods, dividing the main objective into component parts. The only major difference between the methods is in the definition of the decomposition itself. In helpers the main objective is used in place of the final decomposed objective that would have been used in complete decomposition. Thus in helpers the main objective is explicitly an objective while in complete decomposition the main objective is implicit. A complete decomposition can be created from a helper by paring down the main objective to only those objective components that are not in the helpers. With this in mind, we embarked on a careful direct comparison of complete decompositions versus helpers. For simplicity in the analysis below we assume a minimization problem of an additive and decomposable objective function. Similar analysis holds for maximization of an additive and decomposable objective function.

The analysis below explores general relationships that hold between solutions that are compared in the Pareto sense both in helper decompositions and complete decompositions. The definitions for complete decomposition and helper-objectives below relate to all previous works where decomposition was used to generate the objective functions. Complete decompositions were used in a consistent manner to the definitions here in Knowles et al. (2001), Jahne et al. (2008), Neumann and Wegener (2007), Handl et al. (2008a); 2008b), Garza-Fabre, Rodriguez-Tello, and Toscano-Pulido (2012) and Lochtefeld and Ciarallo (2014). Helper-objectives were used in a similar manner to the definitions presented here in Jensen (2004), Jahne et al. (2008), Lochtefeld and Ciarallo (2011, 2012), and Brockhoff et al. (2007). Inconsistent to the definition with helper objectives here are those methods that used novel helper-objectives such as Burke and Landa Silva (2006), Greiner, Emperador, Winter, and Galván (2007), Mouret (2011), and Watanabe and Sakakibara (2007). No complete decomposition methods were found in the literature that were inconsistent with the analysis herein. Building on these fundamentals we develop a mapping of Pareto efficient solutions in helpers to corresponding Pareto efficient solutions in complete decompositions. This leads to the conclusion that solutions in the ith Pareto frontier in helpers appear on the ith or lower frontiers in complete decomposition.

We use several definitions of Pareto comparison operators in the work below based upon weak dominance. Weak dominance can be used to identify the subset of solutions in a population that compose a Pareto efficient set. Solution x weakly dominates solution y is represented by the notation x≽y. Solutions x and y are Pareto identical is represented by x ≈ y. Solutions x and y are Pareto incomparable is represented by x≺≻y. Solution y is not weakly dominated by x is represented by 
                        
                           x
                           
                           ¬
                           ⪰
                           
                           y
                        
                     . Deb and Saha (2010) provide a comprehensive set of dominance definitions including the difference between strong and weak Pareto dominance and the strong and weak Pareto optimal set. The analysis of helpers and complete decomposition methods can lead to multiple Pareto comparisons because the decompositions have different objectives, so when needed for clarity in the following development the Pareto operators are augmented with H and C respectively. For example 
                        
                           x
                           
                           
                              ⪰
                              H
                           
                           
                           y
                        
                      denotes that solution x weakly dominates solution y based on a helper-objective structure.

We use the following notation to represent how solutions are evaluated with the objectives under helper and complete decompositions when minimizing a sum-of-parts objective function (such as for the TSP or JSSP). This definition only applies when valid solutions are generated such as when a repair mechanism is employed. Let xk
                      denote the kth objective value associated with solution x. In our work, both helpers and complete decomposition methods contain exactly m simultaneous objectives to be minimized. Thus, in a comparison of two objective values, the lower value is considered desirable. Symmetric definitions exist for a sum-of-parts maximization problem where higher values are desirable. For both methods m indicates the degree of decomposition. For a generic decomposition k ∈ K, where K is a set of objective indices. For complete decomposition k ∈ KC
                      ≡ {1, 2, …, m}. For helpers k ∈ KH
                      ≡ {1, 2, …, m − 1, M} where M is the main objective and m − 1 is the number of helpers. Note that the set operator symbols for intersection and union used below are ∩ and ∪, respectively.

                        Definition
                        The main objective M is the sum of all decomposed objectives.

                              
                                 (1)
                                 
                                    
                                       
                                          x
                                          M
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             
                                                =
                                                1
                                             
                                          
                                          m
                                       
                                       
                                          x
                                          k
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2)
                                 
                                    
                                       
                                          y
                                          M
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             
                                                =
                                                1
                                             
                                          
                                          m
                                       
                                       
                                          y
                                          k
                                       
                                    
                                 
                              
                           
                        

Solution x weakly dominates solution y, denoted x ≽y, if and only if x is better than y in at least one objective and x is no worse than y in all other objectives (Deb et al., 2002).

                              
                                 (3)
                                 
                                    
                                       x
                                       
                                       ⪰
                                       
                                       y
                                       
                                       
                                       iff
                                       
                                       
                                       
                                          [
                                          
                                             ∃
                                             k
                                             ∈
                                             K
                                             :
                                             
                                                x
                                                k
                                             
                                             <
                                             
                                             
                                                y
                                                k
                                             
                                          
                                          ]
                                       
                                       
                                       and
                                       
                                       
                                          [
                                          
                                             ∀
                                             k
                                             ∈
                                             K
                                             :
                                             
                                                x
                                                k
                                             
                                             ≤
                                             
                                             
                                                y
                                                k
                                             
                                          
                                          ]
                                       
                                    
                                 
                              
                           
                           
                              
                                 x
                                 
                                 
                                    ⪰
                                    C
                                 
                                 
                                 y
                              
                            indicates weak dominance in complete decomposition where K = KC
                           . 
                              
                                 x
                                 
                                 
                                    ⪰
                                    H
                                 
                                 
                                 y
                              
                            indicates weak dominance in helpers where K = KH
                           .

Solution x is incomparable to solution y, denoted x≺≻y, if and only if x is better than y in at least one objective and x is worse than y in at least one objective.

                              
                                 (4)
                                 
                                    
                                       x
                                       ≺
                                       ≻
                                       y
                                       
                                       
                                       iff
                                       
                                       
                                       
                                          [
                                          ∃
                                          k
                                          ∈
                                          K
                                          :
                                          
                                             
                                                x
                                                k
                                             
                                             <
                                             
                                             
                                                y
                                                k
                                             
                                          
                                          ]
                                       
                                       
                                       and
                                       
                                       
                                          [
                                          ∃
                                          k
                                          ∈
                                          K
                                          :
                                          
                                             
                                                y
                                                k
                                             
                                             <
                                             
                                             
                                                x
                                                k
                                             
                                          
                                          ]
                                       
                                    
                                 
                              
                           
                           
                              
                                 x
                                 
                                 
                                    
                                       ≺
                                       ≻
                                    
                                    C
                                 
                                 y
                              
                            indicates incomparable solutions in complete decomposition where K = KC
                           . 
                              
                                 x
                                 
                                 
                                    
                                       ≺
                                       ≻
                                    
                                    H
                                 
                                 
                                 y
                              
                            indicates incomparable solutions in helpers where K = KH
                           .

Solutions x and y are Pareto identical, denoted x ≈ y, if and only if each of the corresponding objective values in x and y are identical.

                              
                                 (5)
                                 
                                    
                                       x
                                       ≈
                                       y
                                       
                                       
                                       iff
                                       
                                       
                                       [
                                       ∀
                                       k
                                       ∈
                                       K
                                       :
                                       
                                          
                                             x
                                             k
                                          
                                          =
                                          
                                             y
                                             k
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                           
                              
                                 x
                                 
                                    ≈
                                    C
                                 
                                 y
                              
                            indicates Pareto identical in complete decomposition where K = KC
                           . 
                              
                                 x
                                 
                                 
                                    ≈
                                    H
                                 
                                 y
                              
                            indicates Pareto identical in helpers where K = KH
                           .


                           For two solutions x and y, if y is not weakly dominated by x, denoted
                           
                              
                                 x
                                 
                                 ¬
                                 ⪰
                                 
                                 y
                                 ,
                              
                            
                           it is straightforward to show that either y weakly dominates x, y is Pareto incomparable to x, or y is Pareto identical to x.

                              
                                 (6)
                                 
                                    
                                       If
                                       
                                       x
                                       
                                       ¬
                                       ⪰
                                       
                                       y
                                       
                                       
                                       then
                                       
                                       
                                       [
                                       
                                       y
                                       
                                       ⪰
                                       
                                       x
                                       
                                       
                                       ]
                                       
                                       
                                       or
                                       
                                       
                                       [
                                       
                                       y
                                       ≺
                                       ≻
                                       x
                                       
                                       ]
                                       
                                       
                                       or
                                       
                                       
                                       [
                                       
                                       y
                                       
                                       ≈
                                       
                                       x
                                       
                                       ]
                                    
                                 
                              
                           
                           In complete decomposition, if
                           
                              
                                 x
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    C
                                 
                                 y
                              
                            
                           then Property 
                           
                              1
                            
                           holds for K = KC. In helpers, if
                           
                              
                                 x
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    H
                                 
                                 y
                              
                            
                           then Property 
                           
                              1
                            
                           holds for K = KH
                           .

All solutions that are not weakly dominated by any solution are defined to be strongly Pareto efficient. Together these solutions make up a set of solutions called the Pareto efficient frontier (Belton and Stewart, 2002; Kirkwood, 1997). We define the sets C
                     1 and H
                     1 to contain the Pareto efficient solutions in a given population for complete decomposition and helper decomposition, respectively.

                        Definition 4
                        
                           
                              
                                 (7)
                                 
                                    
                                       y
                                       ∈
                                       
                                          C
                                          1
                                       
                                       
                                       iff
                                       
                                       
                                       ∀
                                       x
                                       
                                          
                                          :
                                          
                                          
                                       
                                       x
                                       
                                       
                                          
                                             
                                                
                                                   ¬
                                                   ⪰
                                                
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                       y
                                    
                                 
                              
                           
                           
                              
                                 (8)
                                 
                                    
                                       y
                                       ∈
                                       
                                          H
                                          1
                                       
                                       
                                       iff
                                       
                                       
                                       ∀
                                       x
                                       
                                          
                                          :
                                          
                                          
                                       
                                       x
                                       
                                       
                                          
                                             
                                                
                                                   ¬
                                                   ⪰
                                                
                                             
                                          
                                          
                                             
                                                H
                                             
                                          
                                       
                                       
                                       y
                                    
                                 
                              
                           NSGA-II categorizes solutions in the population based on Pareto fronts allowing the algorithm to quickly determine which of the dominated solutions have better fitness. Subsequent fronts are defined by eliminating the solutions in the population in previous fronts from consideration and then, in the remaining solutions, finding the solutions that are not weakly dominated to define a new front. We define the sets Ci
                            and Hi
                            to contain all solutions on the ith Pareto frontier for complete decomposition and helpers respectively, for i ∈ {1, …, ∞}, with C
                           0 ≡ ∅ and H
                           0 ≡ ∅. Further define the sets 
                              
                                 C
                                 i
                                 +
                              
                            and 
                              
                                 H
                                 i
                                 +
                              
                            to contain all solutions in ith Pareto frontier as well as those in the previous frontiers building up to the ith frontier for the associated decomposition method.


                           
                              
                                 (9)
                                 
                                    
                                       
                                          H
                                          i
                                          +
                                       
                                       =
                                       
                                          ⋃
                                          
                                             k
                                             
                                                =
                                                1
                                             
                                          
                                          i
                                       
                                       
                                          H
                                          k
                                       
                                    
                                 
                              
                           
                           
                              
                                 (10)
                                 
                                    
                                       
                                          C
                                          i
                                          +
                                       
                                       =
                                       
                                          ⋃
                                          
                                             k
                                             
                                                =
                                                1
                                             
                                          
                                          i
                                       
                                       
                                          C
                                          k
                                       
                                    
                                 
                              
                           
                        


                           If a solution is contained in the
                           
                              
                                 i
                                 
                                    t
                                    h
                                 
                              
                            
                           frontier, then it is straightforward to show that it is not contained in any of frontiers 1 through i − 1.

                              
                                 (11)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                ∀
                                                i
                                                ∈
                                                
                                                   {
                                                   
                                                      1
                                                      ,
                                                   
                                                   …
                                                   ,
                                                   ∞
                                                   }
                                                
                                                
                                                   ,
                                                   
                                                   
                                                
                                                if
                                                
                                                x
                                                ∈
                                                
                                                   C
                                                   i
                                                
                                                
                                                
                                                then
                                                
                                                
                                                x
                                                ∉
                                                
                                                   C
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                   +
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (12)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                ∀
                                                i
                                                ∈
                                                
                                                   {
                                                   
                                                      1
                                                      ,
                                                   
                                                   …
                                                   ,
                                                   ∞
                                                   }
                                                
                                                
                                                   ,
                                                   
                                                   
                                                
                                                if
                                                
                                                x
                                                ∈
                                                
                                                   H
                                                   i
                                                
                                                
                                                
                                                then
                                                
                                                
                                                x
                                                ∉
                                                
                                                   H
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                   +
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

These definitions and properties lead to the following results clarifying the relationship between dominant solutions under complete decompositions versus helper decompositions in multi-objectivization:

                        Proposition 1
                        
                           A solution y that is weakly Pareto dominated by another solution x in complete decomposition is also weakly dominated by that solution in helpers:
                           
                              
                                 
                                    
                                       If
                                       
                                       
                                       x
                                       
                                       
                                          
                                             
                                                ⪰
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                       y
                                       
                                       
                                       then
                                       
                                       
                                       x
                                       
                                       
                                          
                                             
                                                ⪰
                                             
                                          
                                          
                                             
                                                H
                                             
                                          
                                       
                                       
                                       y
                                       .
                                    
                                 
                              
                           
                        

Assume 
                              
                                 x
                                 
                                 
                                    ⪰
                                    C
                                 
                                 
                                 y
                              
                           . By (1)–(3), and the property of addition xM
                            < yM
                           . In going from the complete decomposition evaluation of solutions x and y to the helper decomposition evaluation, we remove exactly one objective and replace it with the main objective, M. Thus the conditions in (3) will continue to hold because xM
                            < yM
                           .□


                           Any two solutions that are Pareto incomparable in helpers are also Pareto incomparable in complete decomposition.
                           
                              
                                 
                                    
                                       If
                                       
                                       
                                       x
                                       
                                       
                                          
                                             
                                                
                                                   ≺
                                                   ≻
                                                
                                             
                                          
                                          
                                             
                                                H
                                             
                                          
                                       
                                       
                                       y
                                       
                                       
                                       then
                                       
                                       
                                       x
                                       
                                       
                                          
                                             
                                                
                                                   ≺
                                                   ≻
                                                
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                       y
                                    
                                 
                              
                           
                        

Assume 
                              
                                 x
                                 
                                 
                                    
                                       ≺
                                       ≻
                                    
                                    H
                                 
                                 
                                 y
                              
                           . We decompose the situation into two mutually exclusive and complete cases: The solutions are either Pareto incomparable in helpers because of two or more conflicting values in the first m − 1 objectives (Case 1) or the solutions are Pareto incomparable in helpers because of the main objective and one or more conflicting values in the other m − 1 objectives (Case 2).

                              Case 1
                              We examine the solutions that are Pareto incomparable in helpers because of two or more conflicting values in the first m − 1 objectives:

                                    
                                       (13)
                                       
                                          
                                             
                                                [
                                                ∃
                                                k
                                                ∈
                                                
                                                   {
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   m
                                                   −
                                                   1
                                                   }
                                                
                                                :
                                                
                                                   
                                                      y
                                                      k
                                                   
                                                   <
                                                   
                                                      x
                                                      k
                                                   
                                                
                                                ]
                                             
                                             
                                             
                                             and
                                             
                                             
                                             
                                                [
                                                ∃
                                                k
                                                ∈
                                                
                                                   {
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   m
                                                   −
                                                   1
                                                   }
                                                
                                                :
                                                
                                                   
                                                      x
                                                      k
                                                   
                                                   <
                                                   
                                                      y
                                                      k
                                                   
                                                
                                                ]
                                             
                                          
                                       
                                    
                                 
                              

If in each solution x and y at least one of the m − 1 helper objective values is superior, the solutions are Pareto incomparable in both helpers and complete decomposition since these objectives are common in both decompositions.

We examine the solutions that are Pareto incomparable in helpers because of the value of the main objective for solutions x and y, and one or more conflicting values in the other m − 1 objectives. Thus

                                    
                                       (14)
                                       
                                          
                                             Either
                                             
                                             
                                                [
                                                ∃
                                                k
                                                ∈
                                                
                                                   {
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   m
                                                   −
                                                   1
                                                   }
                                                
                                                :
                                                
                                                   
                                                      y
                                                      k
                                                   
                                                   <
                                                   
                                                      x
                                                      k
                                                   
                                                
                                                ]
                                             
                                             
                                             
                                             and
                                             
                                             
                                             
                                                (
                                                
                                                   x
                                                   M
                                                
                                                <
                                                
                                                   y
                                                   M
                                                
                                                )
                                             
                                          
                                       
                                    
                                 or

                                    
                                       (15)
                                       
                                          
                                             
                                                [
                                                ∃
                                                k
                                                ∈
                                                
                                                   {
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   m
                                                   −
                                                   1
                                                   }
                                                
                                                :
                                                
                                                   
                                                      x
                                                      k
                                                   
                                                   <
                                                   
                                                      y
                                                      k
                                                   
                                                
                                                ]
                                             
                                             
                                             
                                             and
                                             
                                             
                                             
                                                (
                                                
                                                   y
                                                   M
                                                
                                                <
                                                
                                                   x
                                                   M
                                                
                                                )
                                             
                                          
                                       
                                    
                                 Since the statements in (14) and (15) are symmetric (through interchange of x and y), only the analysis for (14) is shown here.

From (14) we know that 
                                    
                                       
                                          y
                                          
                                             k
                                             *
                                          
                                       
                                       <
                                       
                                          x
                                          
                                             k
                                             *
                                          
                                       
                                    
                                  for some k* ∈ {1, …, m − 1} and that xM
                                  < yM
                                 .

                                    
                                       1.
                                       If xm
                                           < ym
                                          , together with 
                                             
                                                
                                                   y
                                                   
                                                      k
                                                      *
                                                   
                                                
                                                <
                                                
                                                   x
                                                   
                                                      k
                                                      *
                                                   
                                                
                                             
                                           for some k* ∈ {1, …, m − 1}, then the condition for 
                                             
                                                x
                                                
                                                
                                                   
                                                      ≺
                                                      ≻
                                                   
                                                   C
                                                
                                                
                                                y
                                             
                                           in Definition 2 is satisfied.

If xm
                                           ≥ ym
                                          , assume that yk
                                           ≤ xk
                                           for all k ≠ k* and k ∈ {1, …, m − 1}. Under this assumption
                                             
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   m
                                                
                                                
                                                   
                                                      x
                                                      k
                                                   
                                                   >
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      m
                                                   
                                                   
                                                      y
                                                      k
                                                   
                                                
                                                ,
                                             
                                           indicating xM
                                           > yM
                                          , which is a contradiction. Thus yk
                                           > xk
                                           for at least one k ≠ k* and k ∈ {1, …, m − 1}. Together with 
                                             
                                                
                                                   y
                                                   
                                                      k
                                                      *
                                                   
                                                
                                                <
                                                
                                                   x
                                                   
                                                      k
                                                      *
                                                   
                                                
                                             
                                           for some k* ∈ {1, …, m − 1} the condition for 
                                             
                                                x
                                                
                                                
                                                   
                                                      ≺
                                                      ≻
                                                   
                                                   C
                                                
                                                
                                                y
                                             
                                           in Definition 2 is satisfied.


                           □


                           Solutions x and y are Pareto identical in helpers if and only if they are Pareto identical in complete decomposition.
                           
                              
                                 
                                    
                                       
                                          (
                                          x
                                          
                                          
                                             
                                                
                                                   ≈
                                                
                                             
                                             
                                                
                                                   H
                                                
                                             
                                          
                                          
                                          y
                                          )
                                       
                                       
                                       
                                       iff
                                       
                                       
                                       
                                          (
                                          x
                                          
                                          
                                             
                                                
                                                   ≈
                                                
                                             
                                             
                                                
                                                   C
                                                
                                             
                                          
                                          
                                          y
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        


                           
                              Case 1
                              Assume 
                                    
                                       x
                                       
                                       
                                          ≈
                                          C
                                       
                                       
                                       y
                                       ,
                                    
                                  show 
                                    
                                       x
                                       
                                       
                                          ≈
                                          H
                                       
                                       
                                       y
                                    
                                 . By Definition 3: ∀k ∈ {1, …, m} : xk
                                  = yk
                                 . Using (1) and (2) (xM
                                  = yM
                                 ) which implies 
                                    
                                       x
                                       
                                       
                                          ≈
                                          H
                                       
                                       
                                       y
                                    
                                 .

Assume 
                                    
                                       x
                                       
                                       
                                          ≈
                                          H
                                       
                                       
                                       y
                                       ,
                                    
                                  show 
                                    
                                       x
                                       
                                       
                                          ≈
                                          C
                                       
                                       
                                       y
                                    
                                 . By Definition 3:  ∀k ∈ {1, …, m − 1} : xk
                                  = yk
                                  and xM
                                  = yM
                                 . Using (1) and (2) 
                                 xm
                                  = ym
                                  which implies 
                                    
                                       x
                                       
                                       
                                          ≈
                                          C
                                       
                                       
                                       y
                                    
                                 .


                           □

The results in Propositions 1–3 are important for reasoning about the dominated solutions under helper and complete decompositions. The following major results demonstrate important characteristics of the relationship between the frontiers of non-dominated solutions in a population under helper and complete decompositions as used in NSGA-II.

                        Theorem A
                        All solutions in the Pareto efficient frontier (the first Pareto frontier) in helper objectives are also in the Pareto efficient frontier in complete decomposition:

                              
                                 
                                    
                                       If
                                       
                                       
                                          (
                                          x
                                          
                                          
                                             
                                                
                                                   
                                                      ¬
                                                      ⪰
                                                   
                                                
                                             
                                             
                                                
                                                   H
                                                
                                             
                                          
                                          
                                          y
                                          )
                                       
                                       
                                       then
                                       
                                       
                                          (
                                          x
                                          
                                          
                                             
                                                
                                                   
                                                      ¬
                                                      ⪰
                                                   
                                                
                                             
                                             
                                                
                                                   C
                                                
                                             
                                          
                                          
                                          y
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                        

Assume 
                              
                                 x
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    H
                                 
                                 
                                 y
                                 ,
                              
                            show: 
                              
                                 x
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    C
                                 
                                 
                                 y
                              
                           . If 
                              
                                 x
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    H
                                 
                                 
                                 y
                              
                            then one of three cases must hold:

                              
                                 
                                    Case 1:
                                 
                                 At least one of the m − 1 helper values in y is better than the corresponding helper value in x so that ∃k ∈ {1, …, m − 1}: xk
                                     > yk
                                    . Since these m − 1 objective values are common to the corresponding complete decomposition, x does not weakly dominate y in complete decomposition.

The first m − 1 objective values in x and y are identical in helpers and the main objective in y is better than the main objective in x so that ∀k ∈ {1, …, m − 1}: xk
                                     = yk
                                    , andxM
                                     > yM
                                    . Through use of substitution and the property of addition in (1) and (2),  xm
                                    > ym
                                    . Thus x does not weakly dominate y in complete decomposition.

When x and y are Pareto identical in helpers, the first m − 1 objective values in x and y are equal, and the main objectives in x and y are equal so that ∀k ∈ {1, …, m − 1} : xk
                                     = yk
                                     and xM
                                     = yM
                                    . By substitution and subtraction in (1) and (2), xm
                                    = ym
                                    . Thus x does not weakly dominate y in complete decomposition.


                           □


                           All solutions in the i
                              
                                 t
                                 h
                              
                            
                           or lower frontier in helpers are in the i
                              
                                 t
                                 h
                              
                            
                           or lower frontier in complete decomposition:
                           
                              
                                 
                                    H
                                    i
                                    +
                                 
                                 ⊆
                                 
                                    C
                                    i
                                    +
                                 
                              
                           .

By definition Pareto fronts are mutually exclusive: ∀i, j, (i ≠ j): Hi
                           ∩Hj
                            = ∅ and ∀i, j, (i ≠ j): Ci
                           ∩Cj
                            = ∅.

For the case where i = 1, Theorem A shows the desired result. For the inductive step, assume

                              
                                 (16)
                                 
                                    
                                       
                                          H
                                          i
                                          +
                                       
                                       ⊆
                                       
                                          C
                                          i
                                          +
                                       
                                    
                                 
                              
                           In order to show that

                              
                                 (17)
                                 
                                    
                                       
                                          H
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                          +
                                       
                                       ⊆
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                          +
                                       
                                    
                                 
                              
                           
                        

The proof of the inductive step will proceed by assuming that (16) does hold and that simultaneously (17) does not hold. Assuming these facts simultaneously leads to a logical contradiction. To achieve this, suppose there exists a point x that is in H
                           
                              i + 1 but is not in 
                              
                                 C
                                 
                                    i
                                    +
                                    1
                                 
                                 +
                              
                           . We will reason about x relative to a point y that is in C
                           
                              i + 1. Suppose

                              
                                 (18)
                                 
                                    
                                       ∃
                                       
                                       x
                                       
                                          ,
                                          
                                       
                                       y
                                       
                                          
                                          :
                                          
                                       
                                       x
                                       ∈
                                       
                                          H
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          ,
                                          
                                       
                                       x
                                       
                                       ∉
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                          +
                                       
                                       ;
                                       
                                       y
                                       
                                       ∈
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                       
                                       ;
                                       
                                       y
                                       
                                       
                                          
                                             
                                                ⪰
                                             
                                          
                                          
                                             
                                                C
                                             
                                          
                                       
                                       
                                       x
                                    
                                 
                              
                           
                        

Note the assumption 
                              
                                 y
                                 
                                 
                                    ⪰
                                    C
                                 
                                 
                                 x
                              
                            is consistent with the assumptions y ∈ C
                           
                              i+ 1 and 
                              
                                 x
                                 
                                 ∉
                                 
                                    C
                                    
                                       i
                                       
                                          +
                                          1
                                       
                                    
                                    +
                                 
                              
                            because there must be a y in an earlier front than x in complete decomposition where 
                              
                                 y
                                 
                                 
                                    ⪰
                                    C
                                 
                                 
                                 x
                              
                           . Because of mutual exclusivity of the Pareto fronts

                              
                                 (19)
                                 
                                    
                                       
                                          C
                                          i
                                          +
                                       
                                       ∩
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          =
                                          
                                       
                                       ∅
                                    
                                 
                              
                           By (16), (18), and (19),

                              
                                 (20)
                                 
                                    
                                       y
                                       ∉
                                       
                                       
                                       
                                          H
                                          i
                                          +
                                       
                                    
                                 
                              
                           By the assumption and Proposition 1, 
                              
                                 y
                                 
                                 
                                    ⪰
                                    H
                                 
                                 
                                 x
                              
                           .

However, this is a contradiction since x ∈ H
                           
                              i + 1 by assumption, and only solutions in 
                              
                                 H
                                 i
                                 +
                              
                            can weakly dominate x in helpers. Thus x cannot simultaneously be in H
                           
                              i + 1 and in 
                              
                                 C
                                 
                                    i
                                    +
                                    1
                                 
                                 +
                              
                           . By (20) and the definition of the Pareto fronts, 
                              
                                 y
                                 
                                 
                                    
                                       ¬
                                       ⪰
                                    
                                    H
                                 
                                 
                                 x
                              
                           .

                              
                                 (21)
                                 
                                    
                                       
                                       ∄
                                       
                                       x
                                       
                                       ∈
                                       
                                          H
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          ,
                                          
                                       
                                       x
                                       
                                       ∉
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                          +
                                       
                                    
                                 
                              
                           
                           
                              
                                 (22)
                                 
                                    
                                       and
                                       
                                       finally
                                       
                                       
                                       
                                          H
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                       
                                       ⊆
                                       
                                       
                                       
                                          C
                                          
                                             i
                                             
                                                +
                                                1
                                             
                                          
                                          +
                                       
                                    
                                 
                              
                           Since 
                              
                                 
                                    
                                       H
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                    +
                                 
                                 =
                                 
                                    H
                                    i
                                    +
                                 
                                 ∪
                                 
                                    H
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 ,
                              
                            and by (16), 
                              
                                 
                                    H
                                    
                                       i
                                       +
                                       1
                                    
                                    +
                                 
                                 ⊆
                                 
                                    C
                                    
                                       i
                                       +
                                       1
                                    
                                    +
                                 
                              
                           .□

The JSSP is a well studied problem in optimization where a number of jobs must be processed through a job shop. Each of the n jobs has a number of operations that must be processed on the machines in the job shop. The operations associated with jobs must be processed through the machines in a specified order. This order is referred to as the set of technological constraints. Each operation has an associated machine and processing time. There are ω machines in a given job shop and each machine is assumed to service a given job no more than once. Assuming all machines service all jobs, the maximum size of a problem is nω operations. The size of problem instances herein is denoted based upon the notation (n × ω). For instance a 10 job problem with 5 machines is denoted as a (10 × 5) problem. In the JSSP there is no preemption—once an operation starts on a machine it cannot be interrupted. For the problems studied there is also no recirculation—each machine is never required more than once by a job. The goal of the JSSP is to minimize some measure of cost such as makespan (the completion time of the final job) or total flowtime (the sum of the times to complete each job).

The JSSP formally defined here is adapted from Vaessens, Aarts, and Lenstra (1996) for optimizing flowtime. Four sets are defined: set
                        
                           
                           M
                        
                      with ω machines, set 
                        J
                      with n jobs, set O with l operations, and A, a set of binary relations. For each operation o ∈ O there is a unique machine 
                        
                           M
                           
                              (
                              o
                              )
                           
                           ∈
                           M
                        
                      on which the operation must be processed, a unique job 
                        
                           J
                           
                              (
                              o
                              )
                           
                           ∈
                           J
                        
                      to which the operation belongs, and a processing time 
                        
                           p
                           
                              (
                              o
                              )
                           
                           ∈
                           N
                           .
                        
                      Precedence relationships are contained in the set A; if (o, v) ∈ A, then v must be performed after o. Given in set A are the technological constraints. The optimization adds relationships in A representing machine links. If (o, v) ∈ A and there is no u ∈ O with (o, u) ∈ A and (u, v) ∈ A, then M(o) ≠ M(v). The objective is to minimize total flowtime: 
                        
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              n
                           
                           
                              max
                              
                                 (
                                 ∀
                                 v
                                 ∈
                                 
                                    J
                                    i
                                 
                                 :
                                 S
                                 
                                    (
                                    v
                                    )
                                 
                                 +
                                 p
                                 
                                    (
                                    v
                                    )
                                 
                                 )
                              
                           
                        
                     . A schedule is a function 
                        
                           S
                           
                           :
                           O
                           
                           →
                           N
                           ∪
                           
                              {
                              0
                              }
                           
                        
                      that for each o defines a start time S(o). S is feasible if:

                        
                           •
                           ∀o ∈ O: S(o) ≥ 0,

∀o, v ∈ O, (o, v) ∈ A: S(o) + p(o) ≤ S(v), and

∀o, v ∈ O, o ≠ v, M(o) = M(v): S(o) + p(o) ≤ S(v) or  S(v) + p(v) ≤ S(o).

A common way to represent schedules using a directed graph is presented in Fig. 1
                      which shows a sample schedule for a notional three job and four machine JSSP instance. Operations are indicated as the circles in the figure. The process time associated with an operation is displayed in the circle. The black solid arrows between the jobs, the conjunctive arcs, indicate the technological constraints which are fixed for the optimization. The dashed arrows, a subset of all possible disjunctive arcs, indicate the machine sequences that were picked by the optimization for each job. A given operation cannot start until all incoming links have finished. Fig. 2
                     a shows a Gantt chart representation of the same schedule in Fig. 1. To calculate total flowtime we add the time that the final operation is completed for each job. In this example the total flowtime for the schedule is 84 minutes. Fig. 2a shows a Gantt chart representation of the schedule from a machine perspective. From this perspective, the idle times of machines are easier to identify.

Many of the evolutionary algorithms that attempt to solve the JSSP use a permutation based representation. These types of representations assess and rank the priority of scheduling an operation. Such methods require an interpreter to build a schedule from the priority list. The well established Giffler–Thompson (GT) schedule builder (Giffler and Thompson, 1960) is one such interpreter. The GT schedule builder has been proven to always build locally optimal, active, schedules. The GT schedule builder uses the priority list to pack the schedule one operation at a time so that the operation occurs as early as possible given the constraints and the priorities. The builder is primarily deterministic but does use random draws to resolve tie-breaker situations when they occur.

Simple heuristics used to solve the job-shop scheduling problem can be roughly divided into one of two major categories. Job-based heuristics such as Shortest Processing Time (SPT) or Earliest Due Date (EDD) first, base their decisions on properties related to the jobs (Pinedo, 2009). Often these heuristics are static—the decisions of the method do not change as portions of a schedule are created. Machine-based heuristics such as the shifting-bottleneck procedure focus the construction of schedules on machines that will likely impede the progress of the schedule (Adams, Balas, and Zawack, 1988). Unlike the static job-based heuristics, the shifting-bottleneck heuristic is dynamic (Pinedo, 2009). This method iteratively solves single machine problems in order to build a schedule. The reader is referred to Vaessens et al. (1996) for additional details and references on heuristics used in the JSSP.

@&#EXPERIMENTS@&#

@&#MOTIVATION@&#

When the main objective is represented explicitly, such as in helpers, the best known solution during a run of the GA is never weakly dominated by other solutions—the best solution is always Pareto efficient. Based on Theorem B, the same solution is also Pareto efficient in complete decomposition. With this knowledge, we hypothesize that complete decomposition may lead to better on average performance compared to helpers for many problem instances due to a signal-to-noise argument. In helpers, when a new best fitness within a given helper is found (signal), the algorithm rewards that solution regardless of what other simultaneous negative fitness decrements (noise) have occurred in other parts of the objective values. However, if a new best fitness occurs in a solution in a component of the objective that is not represented by a current helper and that fitness improvement occurs simultaneously with larger offsetting fitness decrements in one or more helpers, the solution may go unrewarded by the helper algorithm. Since complete decomposition covers all components of the objective but does not contain overlap of any objective components, it may benefit from being able to identify and reward these fitness improvements. However, in complete decomposition there is less explicit emphasis on the main objective which could hamper performance. Experiment 1 explores which of these two forces, signal-to-noise improvements and emphasis on the main objective, are most important in the JSSP instances studied.

Making wise choices regarding multi-objectivization can be difficult as there are more than a few things to balance in the process. Experiment 2 studies the factors involved in determining good decomposition sizes. To accomplish this task, new JSSP instances are generated and tested using a variety of decomposition heuristics and decomposition balances. In both Experiments 1 and 2, there were common design decisions to provide sharper comparisons of the features in our hypotheses.

Solution representation was permutation based and built using a priority list of operations associated with jobs as in Bierwirth (1995). Each job number appears in the solution string once for each operation associated with the job. The first appearance of a job number thus implies the priority for the first operation for the job. Unlike a representation that assigns unique identifiers to each operation, this representation never allows operations later in a job to have a higher priority over operations earlier in the job. Thus the technological constraints are implicitly maintained in such a representation. ‘0, 0, 1, 1, 1, 2, 1, 0, 2, 2, 0, 2’ is a sample string of this permutation based representation with three jobs and four machines. The first 0 in the string indicates that the highest priority operation to schedule is the first operation in job 0. The 0 in the second position in the string indicates that the second operation associated with job 0 is next most important, and so on.

To provide consistency with previous works on the JSSP using multi-objectivization, in most cases we directly followed experimental design choices made in Jensen (2004) and Lochtefeld and Ciarallo (2011). As in the preceding works, we formulate the optimization problem to minimize total flowtime. The instances studied here were obtained or derived from instances in Beasley’s OR Library (Beasley, 1990). The original descriptions for these instances can be found in Giffler and Thompson (1960) for the ft instances, in Lawrence (1984) for the la instances, and Storer, Wu, and Vaccari (1992) for the swv instances. In all experiments NSGA-II was used to perform the multi-objective search procedures. It is possible that other MOEAs could obtain better results than NSGA-II, but a relative comparison of performance of different MOEAs on multi-objectivization was not the focus of the experiments here. Common parameter settings and operators were set as follows. A population size of 100 was used and 100 new candidate solutions were created in each generation. The number of decompositions per run was always set to the number of jobs, n. The number of fitness evaluations was set to 200nω. A minimum number of fitness evaluations was set to 20,000. Binary tournament selection was used to select parent solutions from the population. Generalized Order Crossover (GOX) was used to generate new candidate solutions. GOX takes a substring from one parent and inserts it into another parent (Bierwirth, 1995). As its name implies, the order in which operations appears is used to determine how the spliced solution is repaired to feasibility. Position Based Mutation (PBM) was applied to all new solutions after they were generated using crossover but before fitness evaluation. PBM removes a random operation from one location in the solution string and inserts the operation at another location in the solution string (Bierwirth, 1995). Both GOX and PBM generate solution strings that have a valid priority list so no additional repair operator was required. The GT schedule builder (Giffler and Thompson, 1960) was used to build active schedules. Only one schedule was built for each solution even though the GT builder can create more than one active schedule for some priority strings. The main objective value and all decomposed objective values were calculated from the solution’s built schedule.

Previous objective decompositions on the JSSP were accomplished by dividing jobs into various new objectives (Jensen, 2004; Lochtefeld and Ciarallo, 2011). The total flowtime of a job was the fitness contribution of the job on its associated decomposed objectives. Job flowtimes are the sum of all delays and process times associated with each operation. As a result, we examine decompositions here based on operations rather than jobs. We define a given operation’s contribution to fitness as the operation’s process time plus the immediately preceding delay between the start of the operation and the end of the previous operation in the job.

The performance of complete decomposition was compared with the performance of helpers in order to determine which method works best for the JSSP instances studied. The same set of problem instances as those studied in Lochtefeld and Ciarallo (2011) were examined for this experiment. As much as possible, all settings were consistent with those in Lochtefeld and Ciarallo (2011) to provide a direct comparison for the SJF methods. As in the prior study, the number of decompositions used was set to the number of jobs, n. Each decomposition was used exactly once for a consecutive number of generations. Each decomposition was used for 2ω generations where ω is the number of machines in the instance. In all cases, the degrees of decomposition K was set to 2 as this value has generally given the best overall performance for these studied instances of the JSSP (Jensen, 2004; Lochtefeld and Ciarallo, 2014). In half of the cases studied, we used the SJF heuristic to sequence the appearance of objectives. In the other cases, operations were assigned randomly to decompositions and then sequenced randomly.

In the SJF cases, all operations associated with a particular job i* are assigned to one objective. For SJF helpers, the remaining objective is assigned all fitness components (for all jobs i) of the original problem’s objective. For SJF complete, the remaining objective is assigned only operations (for jobs i ≠ i*) that were not assigned to the first objective. As the sequencing of helpers has been shown to be important (Lochtefeld and Ciarallo, 2014), the SJF methods assign decompositions such that the decomposition associated with the shortest job is used first, the decomposition associated with the next shortest job is the second decomposition to be used, and so forth.

For the random operation cases a random set of operations equal in number to the size of a job was assigned to the first objective. The first objective is further described as the focus objective because it generally has fewer objective components assigned to it than the other concurrently used objective. For complete decomposition, the remaining operations were assigned to the second objective while in the case of helpers all operations were assigned to the second objective. Studying random operation assignment allows us to compare decomposition methods that exploit problem information to decomposition methods that do not exploit any problem structure. For each run, the number of decompositions used was equal to the number of jobs, similar to the SJF cases. Also similar to the SJF cases, once a random operation was assigned to the focus objective, it was no longer used in the focus objective. That is, the random assignment of operations to the focus objective was accomplished without replacement across all of the possible decompositions.

@&#EXPERIMENTAL RESULTS@&#


                           Table 1
                            displays the results of Experiment 1. The first column indicates the problem instance studied along with its problem size. The best known solution column indicates the best known total flowtime value for the problem instance. Previous best values were reported in Lochtefeld and Ciarallo (2011). The best total flowtime values for the la01 and la02 instances have been proven optimal through a branch-and-bound method described in Sierra and Varela (2010). Values in bold in the best known column indicate a new best known value was found during the course of this experiment. Values in the final four columns indicate the average percentage above the best known flowtime for that instance. Each method-instance combination was run for 200 replications. Percentages formatted in bold are the best value for all four cases—the combination of the two types and decomposition methods. Percentage values that are underlined in the SJF columns indicate the best value compared within those SJF cases. Similarly underlined values in the random operation columns indicate the best comparative performance on those two setting combinations. Values marked with a ‘*’ indicate that the underlined result is statistically better (with average results closer to the best known solution) than its associated counterpart (helpers vs. complete decomposition). Statistical tests were performed for each problem instance with the Student’s t-test using an α = 0.05 level of confidence for each individual comparison. Because of the large number of paired comparisons the overall rate of error in identifying significant differences across all problem instances simultaneously is higher than 5 percent (Law, 2007).

To verify correct implementation of the methods, we compared the results in Table 1 from the SJF helper cases to the corresponding data reported in Lochtefeld and Ciarallo (2011). The values here were nearly identical to those reported previously, often having variation only after the second or third significant digit, which may be accounted for by the random variation inherent in the implemented methods. As established in a similar experiment where random sequencing of jobs in the successive decompositions during a run was compared with SJF sequencing in Lochtefeld and Ciarallo (2011), multi-objectivization using the SJF sequenced decompositions outperforms multi-objectivization using decompositions sequenced with random operations in the helper objective.

The SJF helper performance was never statistically better on any problem instance when compared to SJF complete. In contrast to this, there were 3 problem instances out of 24 on which SJF complete was statistically better than SJF helpers. In the random operation decompositions, multi-objectivization using complete decomposition outperformed its helper complement in 7 of these 24 instances with statistically lower average percentage differences from the best known solution. In comparison, across the same cases, there was only one instance where multi-objectivization using random operation helpers had a statistically lower percentage from the best known solution. The results of these pairwise Student’s t-tests show that, for the JSSP instances studied, complete decomposition may be a slightly better a priori choice for multi-objectivization.

Performance, as a function of time and algorithm type, was plotted for each of the problem instances. Two such examples are shown in Fig. 3
                           . Similar to these two examples, many of the instances neared convergence regardless of method, implying that the computational budget was sufficiently long to capture the performance of the algorithms. Through visual inspection of these graphs, it can be observed that complete decomposition generally had an advantage earlier in the run which was rarely overcome by helper objectives to a significant extent. In SJF the differences between complete decomposition and helpers was relatively marginal with the greatest differences earlier in the run. In random operation decompositions, complete methods were better than, or at least as good as, helpers throughout the run.

These informal observations can also be observed more formally in aggregate across all the problems studied. A comparison of performance was made at the end of each of the quartiles of the computational budget. We selected a 0.005 percent absolute difference between the methods as a tie based upon visual significance. These differences are reported in Table 2
                           . Each instance is reported once for each quartile and multi-objectivization method. Across the board, helpers obtained zero wins. The helper method is clearly dominated by complete decomposition when ties are considered. The strong heuristic of SJF creates only a few cases where complete decomposition outperforms helpers, but for random operations, the separation between the methods is quite apparent. It can be seen in Table 2 that complete decompositions generally gain an early advantage versus helpers and that lead is diminished later in the run. This is apparent by the declining number of wins that complete decomposition has in the later quartiles.

This investigation of the performance over time demonstrates two things. Firstly, complete decomposition generally outperforms helpers in the instances and decomposition strategies studied regardless of the computational budget. Secondly, when a strong heuristic like SJF is present, the difference between complete decomposition and helpers is marginal at best.

The theory behind complete decompositions is that isolation of local fitness improvements can best be accomplished by providing complete and exhaustive coverage of the objective function’s contributing components in a way that divides those components in relatively equal size decompositions (Lochtefeld and Ciarallo, 2012). Prior research on complete decompositions has studied balanced decompositions (decompositions that assign a roughly equal number of operations to the different objectives) with the theory that balanced decompositions isolate noise from signal better than imbalanced decompositions. However, based upon the results in this experiment we observe that the SJF heuristic gives better results implying that all fitness improvements are not equally favored. We theorize there may be an interaction between the decomposition assignment and sequencing strategy, the decomposition balance (size), and problem asymmetries.

Based on our analytical results from Section 3, we expect that complete decompositions are at least as effective as helper decompositions, all other factors being equal. Additionally, we hypothesize that in the absence of significant insight into the problem instance, between-objective SNRs will be best improved when working with balanced decompositions, as improvements in one segment of a decomposition would more often be found with a paired fitness decrement in the remaining part of the solution in other segments. Finally, we know that effective sequencing of objectives can improve performance when appropriate insight is available. This led to our design for Experiment 2.

The signal-to-noise principle indicates that it is best to isolate fitness decrements (noise) from fitness improvements (signal) (Lochtefeld and Ciarallo, 2012). Given no knowledge of the problem structure, balanced divisions of the objective space do the best job of exploiting this principle, since it requires deep knowledge of a problem to determine which components have an intrinsic need for fitness improvements. A heuristic such as SJF, which represents a richer understanding of problem structure, may be more effective when combined with an unequal division of the objective as this unequal division places focus on the most important signal. SJF should be effective in determining which signal is more important and thus isolation of local fitness improvements can be accomplished in an imbalanced way. This experiment investigates how the strength of a heuristic and the size of the decomposition relate to algorithm performance. To accomplish this task, two decompositions are tested on a range of problems with varying amounts of structure to be exploited.

Asymmetries in a problem, either in terms of problem structure or instance data, are often the reason that heuristics are effective. For example, a greedy method of constructing a solution will typically be no better than a pure random method if all the selection choices are identical. Various levels of asymmetries in a problem are examined in this experiment in order to determine the effectiveness of balanced and imbalanced sized decompositions as they relate to decomposition strength based on problem knowledge. We examine two decomposition types. Randomly assigning operations to segments in a decomposition exploits no knowledge of the problem structure. Alternately, segments in a decomposition built by assigning operations in the same job to a given segment uses information pertaining to the structure of the problem.

The classical ft10 and ft20 problems and other problems based on these with similar dimensions are examined: 10 × 10—la16, la17, la18, la19, and la20; 20 × 5—la11, la12, la13, la14, and la15. Since 10 × 10 problems contain exactly 10 jobs and 10 machines, we consider these problems to be neutral in terms of the importance of machines and the importance of jobs. In the 10 × 10 problems, every job may be processing an operation simultaneously in a feasible schedule. The 20 × 5 problems contain 5 machines and as a result no more than 5 jobs can be processed simultaneously in a feasible schedule even though there are 20 jobs to process. When optimizing for flowtime in the 20 × 5 problems, it is very likely that finishing some jobs early in the schedule achieves the goal of minimizing flowtime. Because jobs are in high competition for the same machines, there is a flowtime advantage for having some jobs finish before others. In the 10 × 10 problems, there is less, but still significant, competition for machines. This equal ratio of jobs and machines makes it less advantageous to have some jobs finish early in the schedule as parallel processing of jobs throughout the schedule can lead to overall low flowtimes.

We conjecture that the first level of asymmetry that a job-based decomposition can focus on effectively is the balance of number of machines and jobs. When there are more jobs than machines, placing emphasis on certain jobs likely produces improved results over random decompositions by operation. The second level of asymmetry that may be important is variation in the total of the process times of all operations associated with a given job—the total job process time. If there is large variation in the total job process time, then the order in which jobs finish is important since it is well known that total flowtime is reduced if a long job is delayed by a short job rather than vice-versa.

The detailed empirical analysis of these experiments including: how various problem instances are created, the characteristics of those instances, and the analysis of the interactions, is lengthy and has been included in the online supplemental material for this paper. Using an Analysis of Variance (ANOVA) approach, we attempt to isolate and explain key drivers that are associated with the interactions between decomposition size, heuristic strength, and inter-decomposition conflict. Effects driven by decomposition size were identified and an additional three principles governing the choice of decompositions and their sequences were supported. Appropriate decomposition size is based on: an effective minimal decomposition size (Lochtefeld and Ciarallo, 2012), heuristic strength, and conflict levels within a decomposition. Good decomposition heuristics should maintain a minimum effective size while attempting to both minimize within-decomposition conflict and exploit known problem asymmetries. The three principles governing decomposition choice are: focus through balance, focus by order of appearance, and adequate coverage. There is value in creating appropriate focus on an objective based on its value through selection of decompositions that are balanced or imbalanced. Imbalanced decompositions place emphasis on the smaller segments in a decomposition and should be used when it is known which components of the decompositions are more important in the optimization. There is also value in picking appropriate sequences of decompositions such that more productive focus is placed earlier in the search. Lastly there is value in adequate coverage: most or all portions of the main objective should be given focus at some point in the search process by being assigned to smaller decomposed objectives. The principles identified in this experiment only contain a moderate amount of evidence derived from the JSSP. The general validity of these principles warrants further investigation using other types of problems.

This paper investigated differences between complete decomposition and helper-based decompositions. Specifically, we examined Pareto dominance relationships for closely related solutions in both methods. Our formal analysis indicates that a given Pareto efficient frontier in complete decomposition always contains all of the Pareto efficient solutions in a similar helper decomposition. This result is extended to draw conclusions about additional fronts beyond the initial Pareto efficient frontier. An empirical study of complete decomposition and associated helper methods shows that, on average, complete decomposition is slightly better for the instances studied. These two facts, the analytical and empirical evidence here, and previous evidence provided on the TSP (Jahne et al., 2008), leads us to the tentative conclusion that the use of complete decompositions is generally better than the use of helpers in most problems with a permutation-based formulation. This conclusion is dependent on the cases, problems, and methods studied so further investigation into the relative performance is warranted. Performance is obviously related to more than just the multi-objectivization method—it is also related to selection and variation operators, among other things. However, for methods which provide emphasis on selecting Pareto efficient solutions, the conclusion that complete decomposition works best likely holds. While helper-decompositions provide explicit emphasis on the main objective, they may not identify some possibly good fitness improvements and are possibly less effective than complete decomposition.

Supplementary data associated with this article can be found, in the online version, at 10.1016/j.ejor.2014.11.041.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

