@&#MAIN-TITLE@&#An experimental investigation of metaheuristics for the multi-mode resource-constrained project scheduling problem on new dataset instances

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper evaluates meta-heuristic procedures for the multi-mode RCPSP.


                        
                        
                           
                           New benchmark instances for the multi-mode RCPSP have been proposed.


                        
                        
                           
                           A fair comparison between the procedures has been described.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Project scheduling

Multi-mode

Metaheuristics

@&#ABSTRACT@&#


               
               
                  In this paper, an overview is presented of the existing metaheuristic solution procedures to solve the multi-mode resource-constrained-project scheduling problem, in which multiple execution modes are available for each of the activities of the project. A fair comparison is made between the different metaheuristic algorithms on the existing benchmark datasets and on a newly generated dataset. Computational results are provided and recommendations for future research are formulated.
               
            

@&#INTRODUCTION@&#

Resource-constrained project scheduling has been a well-known and extensively studied research topic for the past decades. The optimization problem minimizes the makespan of the project, subject to precedence relations between the activities and resource constraints. When introducing different modes to each activity, with for every mode a different duration and different resource requirements, the problem is generalized to the Multi-Mode Resource-Constrained Project Scheduling Problem (MRCPSP).

In the MRCPSP, three different categories of resources can be distinguished (Slowinski, 1981): renewable resources, which are limited per time-unit (e.g. manpower, machines), nonrenewable resources, which are limited for the entire project (e.g. budget) and doubly constrained resources, which are limited both per time-unit and for the total project duration (e.g. cash-flow per time-unit). Since doubly constrained resources can be considered as a combination of renewable and nonrenewable resources, we do not consider them explicitly and do not take them into account in this study. In the remainder of this paper, we will refer to the MRCPSP/R if only renewable resources are considered while the general term MRCPSP is used for the multi-mode scheduling problem with both renewable and nonrenewable resources. Moreover, in this paper only discrete resources are considered. These resources can be allocated in discrete amounts to activities from a given finite set of possible allocations (Weglarz, Jozefowska, Mika, & Waligora, 2011).

As the MRCPSP is a generalization of the RCPSP, the MRCPSP is known to be NP-hard (Blazewicz, Lenstra, & Rinnooy Kan, 1983). Moreover, if there is more than one nonrenewable resource, the problem of finding a feasible solution for the MRCPSP is NP-complete (Kolisch, 1995). The problem is denoted as m, 1T∣cpm,
                     disk,
                     mu∣C
                     
                        max
                      using the classification scheme of Demeulemeester and Herroelen (2002) and is denoted as MPS∣prec∣C
                     
                        max
                      by Brucker, Drexl, Möhring, Neumann, and Pesch (1999).

In the MRCPSP, a set A of pairs of activities between which a precedence relationship exists, and a set N of n activities, where each activity i
                     ∈
                     N
                     ={1,…,
                     n}, can be performed in different execution modes, is given. The set M
                     
                        i
                     
                     ={1,…,∣M
                     
                        i
                     ∣} determines the possible execution modes for activity i, while m
                     
                        i
                      indicates the chosen mode for activity i. The duration of activity i, when executed in mode m
                     
                        i
                     , is 
                        
                           
                              
                                 d
                              
                              
                                 
                                    
                                       im
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     . Each mode m
                     
                        i
                      also requires 
                        
                           
                              
                                 r
                              
                              
                                 
                                    
                                       im
                                    
                                    
                                       i
                                    
                                 
                                 k
                              
                              
                                 ρ
                              
                           
                        
                      units for each resource in the set R
                     
                        ρ
                      of renewable resource types. For each renewable resource k
                     ∈
                     R
                     
                        ρ
                     
                     ={1,…,∣R
                     
                        ρ
                     ∣}, the availability a
                     
                        k
                      is constant throughout the project horizon. Activity i, executed in mode m
                     
                        i
                     , will also use 
                        
                           
                              
                                 r
                              
                              
                                 
                                    
                                       im
                                    
                                    
                                       i
                                    
                                    
                                       ν
                                    
                                 
                                 l
                              
                           
                        
                      nonrenewable resource units of the total available nonrenewable resource 
                        
                           
                              
                                 a
                              
                              
                                 l
                              
                              
                                 ν
                              
                           
                        
                     , with l
                     ∈
                     R
                     
                        ν
                      and R
                     
                        ν
                      the set of nonrenewable resources. The aim of the MRCPSP is to select exactly one mode for each activity in order to schedule the project with a minimal makespan, subject to the resource and precedence constraints.


                     Talbot (1982) presented the mathematical programming formulation of this problem, while the MRCPSP can be formulated conceptually as follows:
                        
                           (1)
                           
                              minimize
                              
                              
                                 
                                    f
                                 
                                 
                                    n
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              subject
                              
                              to
                              
                              
                                 
                                    f
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    d
                                 
                                 
                                    
                                       
                                          jm
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                              ⩽
                              
                                 
                                    f
                                 
                                 
                                    j
                                 
                              
                              
                              ∀
                              (
                              i
                              ,
                              j
                              )
                              ∈
                              A
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ∈
                                       S
                                       (
                                       t
                                       )
                                    
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    
                                       
                                          im
                                       
                                       
                                          i
                                       
                                    
                                    k
                                 
                                 
                                    ρ
                                 
                              
                              ⩽
                              
                                 
                                    a
                                 
                                 
                                    k
                                 
                                 
                                    ρ
                                 
                              
                              
                              ∀
                              k
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    ρ
                                 
                              
                              ,
                              
                              ∀
                              t
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                              
                              
                                 
                                    r
                                 
                                 
                                    
                                       
                                          im
                                       
                                       
                                          i
                                       
                                    
                                    l
                                 
                                 
                                    ν
                                 
                              
                              ⩽
                              
                                 
                                    a
                                 
                                 
                                    l
                                 
                                 
                                    ν
                                 
                              
                              
                              ∀
                              l
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    ν
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    M
                                 
                                 
                                    i
                                 
                              
                              
                              ∀
                              i
                              ∈
                              N
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    f
                                 
                                 
                                    0
                                 
                              
                              =
                              0
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    f
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    int
                                 
                                 
                                    +
                                 
                              
                              
                              ∀
                              i
                              ∈
                              N
                           
                        
                     where S(t) denotes the set of activities in progress in period ]t
                     −1,
                     t] and f
                     
                        i
                      the finish time of the ith activity. The objective of the MRCPSP is to find a mode and a start time for each activity such that the makespan is minimized and the schedule is feasible with respect to the precedence constraints and the renewable and nonrenewable resource constraints. If the schedule is not feasible with respect to one of the precedence or resource constraints, the solution is called infeasible.

Several exact, heuristic and metaheuristic solution methods for the MRCPSP have been proposed in the literature in recent years. Exact solution procedures have been proposed by Slowinski (1980), Talbot (1982), Patterson, Slowinski, Talbot, and Weglarz (1989), Speranza and Vercellis (1993), Sprecher (1994), Sprecher, Hartmann, and Drexl (1997), Sprecher and Drexl (1998), Hartmann and Drexl (1998) and Zhu, Bard, and Tu (2006). Except from the last, all procedures are applications of branch-and-bound algorithms, for which an overview is made by Hartmann and Drexl (1998). However, none of these exact procedures can be used for solving large-sized realistic projects, since they are unable to find an optimal solution in a reasonable computation time. Therefore, different single-pass heuristic and metaheuristic procedures were presented.

For the MRCPSP/R (with renewable resource only), heuristic procedures were proposed by Elmaghraby (1977); Boctor (1993, 1996a); Knotts, Dror, and Hartman (2000); Artigues and Roubellat (2000) and Lova, Tormos, and Barber (2006). Heuristic solution procedures for the general MRCPSP (with renewable and nonrenewable resources) were presented by Talbot (1982); Drexl and Grünewald (1993); Özdamar and Ulusoy (1994) and Kolisch and Drexl (1997).

The increasing interest in operations research for metaheuristics during the recent years has also resulted in the development of several metaheuristic solution procedures for the MRCPSP. A wide variety of metaheuristic strategies, solution representations and schedule generation schemes were used to develop the most efficient algorithms. Since the methods are tested on different benchmark datasets using different stop criteria, a fair comparison between each of these procedures is difficult. Moreover, the current benchmark datasets show several shortcomings, which could lead to biased results. For an extensive overview of the available exact, heuristic and metaheuristic approaches to the MRCPSP, the reader is referred to the overview paper of Weglarz et al. (2011).

The objective of this paper is threefold: first, an overview of the available metaheuristics is given and a classification is made based on the characteristics of each method. Second, a new dataset will be proposed in order to deal with the shortcomings of the current benchmark datasets. Finally, an extended computational comparison is performed to compare the metaheuristics and to evaluate the impact of the network and resource parameters of the project on the efficiency of the procedures.

The remainder of this paper is organized as follows: in Section 2, an overview is given of all the metaheuristics solution procedures for the MRCPSP. In Section 3, the shortcomings of the current benchmark datasets are mentioned and a new benchmark dataset is proposed. In Section 4, the computational experiments are reported as well as the results of the different metaheuristics on the current and new benchmark datasets. In the last section, overall conclusions and suggestions for future research are presented.

This section gives an overview of the current available metaheuristics from literature. In Section 2.1, we briefly explain the preprocessing process as proposed by Sprecher et al. (1997). In Section 2.2, an overview of the different classification criteria, as mentioned in Kolisch and Hartmann (1999), is given and the available algorithms are classified according to these criteria. Finally, in Section 2.3, an overview is given of the methodology used to code each of the metaheuristics in order to make a fair comparison for these procedures.


                        Sprecher et al. (1997) developed a preprocessing procedure, which can be applied before the solution procedure is started, to reduce the search space in which the solution procedure will operate. This reduction procedure excludes those modes which are inefficient or non-executable and those resources which are redundant. As defined by Sprecher et al. (1997), a mode is called inefficient if there is another mode of the same activity with the same or smaller duration and no more requirements for all resources. A mode is called non-executable if its execution would violate the renewable or nonrenewable resource constraints in any schedule. A nonrenewable resource is called redundant if the sum of the maximal requests for that nonrenewable resource does not exceed its availability. Excluding these modes or nonrenewable resources does not affect the set of feasible or optimal schedules and reduces the search space of the problem.

In order to make a classification of the available metaheuristics, the procedures are categorized based on four classification criteria: the metaheuristic strategy, the schedule representation, the mode representation and the schedule generation scheme. In what follows, each of these criteria is briefly discussed.
                           
                              
                                 Metaheuristic strategy. Several metaheuristic strategies to solve a scheduling problem are available. For an overview of these metaheuristic strategies we refer to Glover and Kochenberger (2003) and Talbi (2009). For the MRCPSP the following eight strategies were used in literature: genetic algorithm (GA), scatter search (SS), simulated annealing (SA), particle swarm optimization (PSO), ant colony optimization (ACO), differential evolution algorithm (DEA), the multi-agent learning algorithm (MAL) and the estimation of distribution algorithm (EOD).


                                 Schedule representation. Kolisch and Hartmann (1999) distinguished five different schedule representations in the RCPSP literature, from which the activity-list (AL) representation and the random key (RK) representation are the most widespread. In both representations, a priority structure between the activities is embedded. In the AL representation, the position of an activity in the AL determines the relative priority of that activity versus the other activities, while in the RK representation the sequence in which the activities are scheduled is based on the priority value attributed to each activity.


                                 Mode representation. Two mode representations can be distinguished in the literature: the mode list (ML) representation and the mode vector (MV) representation. In the mode list representation, the list represents the execution modes of the activities in ascending order, i.e. the first number in the list indicates the mode in which the first activity will be executed, the second number the execution mode of the second activity, etc. In the mode vector representation, the mode indicated in the ith position of the mode vector represents the execution mode of the activity placed in the ith position of the activity list. A mode vector is therefore always represented in combination with an activity list.


                                 Schedule generation scheme. A schedule generation scheme (SGS) translates the schedule representation into a schedule. Two commonly used types of SGSs are the serial SGS (Kelley, 1963) and the parallel SGS (Bedworth & Bailey, 1982). Kolisch and Sprecher (1996) have shown that it is sometimes impossible to reach an optimal solution with the parallel SGS. Nevertheless, both schemes are used in the solution procedures currently available in the literature.


                                 Local search procedures. Several local search (LS) procedures have been proposed in literature and used in the different algorithms. These procedures can be classified into several categories:
                                    
                                       1.
                                       
                                          Improving quality of initial population: These procedures are focussing on the feasibility and quality of the initial population elements and try to improve the overall quality of the initial population elements. Therefore, simple (as the procedure of Hartmann (2001)) or more advanced (as the Minimum Normalized Resources procedure of Lova, Tormos, Cervantes, & Barber (2009)) procedures are developed.


                                          Improving feasibility: These procedures are focussing on the improvement of the feasibility of a population element. Examples are the massive mutation procedure of Lova et al. (2009) and the mode shift procedure of Józefowska, Mika, Rózycki, Waligóra, and Weglarz (2001).


                                          Improving makespan: These procedures are focussing on the improvement of the makespan of a population element. Examples are the single-pass improvement of Hartmann (2001) or the critical path improvement method of Van Peteghem and Vanhoucke (2011).


                                          Forward–backward: Some algorithms are also using the forward–backward improvement method (Tormos & Lova, 2001) or an extended or modified version. This specific local search tries to improve the makespan by transforming left-justified schedules (where all activities are scheduled as soon as possible) into right-justified schedules (where all activities are scheduled as late as possible) and vice versa until no further improvements can be found.

In Table 1
                        , an overview of the different metaheuristic algorithms is given in chronological order. This overview paper contains all metaheuristic solution procedures published in international peer reviewed journals before January 1, 2013. For each solution procedure, the name of the author(s) and the abbreviation which will be used in the remainder of the paper to refer to the procedure is given. The indication R or RNR in the third column indicates if the procedure is applicable on datasets with only renewable resources (R) or with both renewable and nonrenewable (RNR) resources. The information in the fourth, fifth, sixth and seventh column indicates the metaheuristic strategy (MS), the schedule representation (SR), the mode representation (MR), the schedule generation scheme (SGS) and the type of local search (LS) used to solve the problem instances, respectively. The algorithmic details of each of the procedures can be found in the respective papers. However, on the website http://www.projectmanagement.UGent.be an extensive summary of the details of each of these algorithms can be found.

@&#METHODOLOGY@&#

In order to compare each of the procedures presented in Table 1 on the same computer and within the same stop criteria, each algorithm described above has been coded. In this section, we will explain the methodology that has been followed in order to obtain a fair and realistic reproduction of the original codes.

Each paper is studied by three undergraduate students and one PhD student. For each procedure, three independently coded programs were available, each reviewed by a PhD student to look whether the structure of the program corresponded to the steps presented in the original paper. In case the content of the paper was insufficient to interpret the algorithm, other papers and solution procedures of the author were analyzed. If necessary, the following two adaptations were made. First, since not all algorithms included the preprocessing method of Sprecher et al. (1997), the preprocessing procedure was added to each solution procedure in order to make a fair comparison based on the same solution space. Second, procedures which are only applicable to datasets with renewable resources (more in particular the algorithms BOCT96 and MORI97), were transferred to a version in which nonrenewable resources are incorporated. In order to deal with possible infeasible solutions, the penalty function as introduced by Alcaraz, Maroto, and Ruiz (2003) was used in the code.

From the three independently coded programs, the program that obtained the results that were the closed to the results presented in the original paper (taken into account the stopping criteria) was selected and submitted to a second control phase, in which the code was reviewed again in detail. An overview of all coded solution procedures and the obtained results is given in Table 2
                        . For every procedure, the different datasets for which results are presented in the original papers and the stop criterium which is applied are mentioned. All results were obtained on the same computer and indicate the average percentage deviation from the optimal solution, unless otherwise indicated.

The table shows that all procedures, except the procedures HART01 and ZHAN06, obtain results which are equivalent or slightly better than the results obtained in the original papers. This can be due to randomness, the incorporation of the preprocessing process or the competitive nature of the coding process. For the procedures VANP10, WAUT11, VANP11 and COEL11, the results were obtained from the authors.

The different procedures were used to test the performance of each algorithm. These computational tests were performed on both the available dataset PSPLIB and on a new dataset, which is described in detail in the next section. For each subset and each algorithm, a full factor design was set up in order to obtain the best results for each individual solution procedure.

Most of the metaheuristics mentioned in Table 1 were tested on two well-known benchmark datasets, the PSPLIB dataset (Kolisch, Sprecher, & Drexl, 1995) and the Boctor dataset (Boctor, 1993). However, the two datasets show some important shortcomings given the recent evolution in the development of metaheuristic search procedures. Therefore, we propose a new benchmark dataset which overcomes the disadvantages of the current datasets and which can be used as a benchmark dataset for further research. In Section 3.1, we make an analysis of the current benchmark datasets and explain their shortcomings, while in Section 3.2 the indicators of the newly developed and generated benchmark dataset are proposed.

In this section, we make an analysis of the two current benchmark datasets, the PSPLIB dataset and the Boctor dataset. In Table 3
                        , an overview of the input parameters of both datasets is given.
                           
                              
                                 PSPLIB. The PSPLIB dataset is generated with the project generator ProGen (Kolisch et al., 1995) and is available in the project scheduling problem library PSPLIB from the ftp server of the Technische Universität München (http://129.187.106.231/psplib/). The dataset contains 7 subsets: the datasets J10, J12, J14, J16, J18, J20 and J30, containing 640 project instances with 10, 12, 14, 16, 18, 20 and 30 activities, respectively. Not for all instances, however, a feasible solution can be found. The projects in the dataset use 2 renewable and 2 nonrenewable resources and have 3 execution modes for each activity.


                                 Boctor. This dataset, proposed by Boctor (1993), contains 2 subsets of 120 instances. There is one set of 50 activities (Boctor50) and one set of 100 activities (Boctor100). For each project, one, two or four renewable resource types are used and one, two or four execution modes per activity are determined. The Boctor dataset can also be downloaded from the PSPLIB server.

Several project parameters have been introduced in the literature for describing the characteristics of a project network and the resource scarceness. The coefficient of network complexity (CNC, Pascoe, 1966), the order strength (OS, Mastor, 1970) and the I2 indicator (Vanhoucke, Coelho, Debels, Maenhout, & Tavares, 2008) are examples of network topology measures. The resource factor (RF, Pascoe, 1966) and resource strength (RS,Kolisch et al., 1995) are examples of resource scarceness measures.

An overview of the values of these instance characteristics for the J30 and Boctor100 dataset is given in Table 4
                        . In this table, the average value, the minimum value and the maximum value for the different project characteristics (OS, CNC and I2) and the different resource characteristics (RS and RF) are presented. In Fig. 1
                        , a frequency graph is given for the values of both the order strength and resource strength. As can be seen, the range for the values of the order strength (for J30 and Boctor100) and the resource strength (for Boctor100) is rather limited.

Despite the diverse range of the resource parameters (the RS varies between 0.25 and 1) and the incorporation of both renewable and nonrenewable resources in the J30 dataset, we believe that the instances of the PSPLIB dataset have four major shortcomings to stimulate further research for the MRCPSP. A first shortcoming lies in the inability to report feasible solutions for all problem instances. As an example, only 552 instances from the 640 generated instances have a possible feasible solution. A similar shortcoming holds for the J10 to J20 datasets. This results in an average of 549 feasible instances over all PSPLIB subsets. (see Alcaraz et al., 2003; Van Peteghem & Vanhoucke, 2010). A second drawback is the small range of OS values (between 0.35 and 0.60) which implies a low diversity in the complexity of the project topology networks. A third shortcoming lies in the observation that most solution procedures are able to solve the project instances to near optimality, which leaves little room to reach major improvements with newly developed solution procedures. Future instances should contain projects with more activities (>30), more mode combinations per activity (>3) or more renewable or nonrenewable resources. Finally, the generation of activity modes should be done differently, in order to guarantee that all modes are efficient. In the J30 dataset, three modes have been generated per activity. However, a number of these modes can be deleted by the preprocessing procedure of Sprecher et al. (1997), leading to only 2.88 modes per activity on average (see Van Peteghem & Vanhoucke, 2010). Moreover, the deletion of inefficient modes leads to a change of the resource parameters of the project instance, which could possibly lead to biased results.

The main advantage of the Boctor100 dataset is the large number of activities per project instance. However, three major concerns about this dataset can be specified. First, only renewable resources are taken into account and nonrenewable resources are neglected. Second, the average resource strength per project is not larger than 0.25, which means that the renewable resources are almost not restricted. Finally, the order strength of the projects varies between 0.8 and 0.95, which means that the projects are mainly serial.

In the next section, the new MMLIB dataset for the MRCPSP will be presented. This dataset will cover most of the shortcomings mentioned in this section.

In order to overcome the shortcomings of the PSPLIB and Boctor datasets, the following conditions were taken into account while generating the dataset:
                              
                                 1.
                                 The generated instances are diverse with respect to the project (OS) and resource characteristics (RS and RF).

Every instance has at least one feasible solution.

No modes can be excluded.

Both renewable and nonrenewable resources are taken into account.

For the generation of the instances, we have used the RanGen project scheduling instances generator developed by Vanhoucke et al. (2008) and extended to projects with multiple modes. However, in a limited number of cases it is not possible to fullfill the conditions mentioned in the previous section. In order to meet these conditions, two repair functions are used under specific project settings.

During the generation of the instances, it was noted that for projects with low values for the nonrenewable resource strength (RS
                              
                                 ν
                              
                              =0.25) and resource factor (RF
                              
                                 ν
                              
                              =0.50), many infeasible projects were generated. This problem was also cited by Demeulemeester, Vanhoucke, and Herroelen (2003) who stated that the feasibility of the problem cannot be assured for low values of the resource strength and will lead to many infeasible modes, that is, modes for which the resource demand exceeds the availability a
                              
                                 ν
                              . Since the generation of the resource demands per activity occurs randomly, only in a limited number of cases a feasible project is generated. Moreover, this number decreases for an increasing number of activities per project. In order to avoid this specific generation problem, a repair function is applied on the generated instances in order to obtain projects with a RS
                              
                                 ν
                               equal to 0.25 and RF
                              
                                 ν
                               equal to 0.50. In the first phase, instances are generated using the RanGen instance generator and extended to projects with multiple modes, as is also done for the instances with other project characteristics. However, in the second phase, the nonrenewable resource demand information was deleted and replaced by new data, obtained according to the following steps:
                                 
                                    •
                                    Firstly, a large set of small (sub)projects with 10 activities and a RS
                                       
                                          ν
                                       
                                       =0.25 and a RF
                                       
                                          ν
                                       
                                       =0.50 is generated until in total 1000 subprojects (with 10 activities) are obtained for which at least 1 feasible solution (w.r.t. the nonrenewable resource demand) is found.

Secondly, for each generated project with 50 or 100 activities, respectively 5 or 10 subprojects are randomly selected from the set of feasible subprojects.

Thirdly, from each activity of these subprojects the nonrenewable resource demand information is then randomly assigned to one of the activities of the new project. For example, the nonrenewable data information of activity 4 of subproject 2 is then randomly assigned to activity 43 of the new project. This is done till all activities of the new project have obtained nonrenewable resource demand information from one of the subprojects. Only the nonrenewable resource demand information is used, other project data of the subprojects is not considered. The total nonrenewable resource availability is obtained by taking the sum of all nonrenewable resource availabilities of the selected 5 (10) subprojects.

This repair function is based on the mathematical formulation of the nonrenewable resource strength, which states that RS
                              
                                 ν
                               is equal to
                                 
                                    (8)
                                    
                                       
                                          
                                             RS
                                          
                                          
                                             ν
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   ν
                                                
                                             
                                             -
                                             
                                                
                                                   r
                                                
                                                
                                                   min
                                                
                                                
                                                   ν
                                                
                                             
                                          
                                          
                                             
                                                
                                                   r
                                                
                                                
                                                   max
                                                
                                                
                                                   ν
                                                
                                             
                                             -
                                             
                                                
                                                   r
                                                
                                                
                                                   min
                                                
                                                
                                                   ν
                                                
                                             
                                          
                                       
                                    
                                 
                              with 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          min
                                       
                                       
                                          ν
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          max
                                       
                                       
                                          ν
                                       
                                    
                                 
                               the minimum and maximum nonrenewable resource consumption which can be obtained by cumulating the consumptions obtained when performing each activity in the mode having minimum and maximum consumptions.

The idea of this repair function can be explained using the following example. Two projects A and B are randomly generated, each with 5 activities per project and 2 modes per activity. For these two projects, the information about the two nonrenewable resources is given in Table 5
                              . It can easily be calculated that the RF
                              
                                 ν
                               for both projects is 0.5 and that the RS
                              
                                 ν
                               is equal to 0.25. By choosing for each activity the first mode, a feasible mode assignment can be found.

In order to generate a new project C with 10 activities, the nonrenewable resource data from each activity of project A and B is now randomly assigned to one of the activities of project C. In Table 5, the activity in project C to which each activity of project A and B is assigned is given between brackets in the first column. The nonrenewable resource availability of project C is equal to 9 and 12, which is the sum of the nonrenewable resource availabilities of A and B. It can be calculated that the RF
                              
                                 ν
                               of project C remains 0.5 and that the RS
                              
                                 ν
                               is still equal to 0.25.

Many inefficient modes were generated during the data generation process. Modes are labelled as inefficient if its duration is not shorter and the resource demand for each resource is not less than that of another mode of the same activity. Since all projects are generated randomly, it is straightforward that inefficient modes are generated. Therefore, a repair function is used in order to deal with the problem of inefficient modes. If an inefficient mode is detected, the resource requirement for one of the nonrenewable resources is set to a value lower than the original nonrenewable resource demand. This is only possible if the nonrenewable resource demand is not zero or if the nonrenewable resource demand is larger than the minimal resource demand for that activity, otherwise the nonrenewable resource strength will be affected (as can be derived from Eq. (8)). In case no changes can be performed, a new project is generated.

By applying these 2 repair functions, we were able to generate a set of project instances which fulfills all conditions set in Section 3.2.1.

The dataset generation resulted in the design of a new dataset MMLIB with three subsets: the MMLIB50 and MMLIB100 sets, which have project characteristics similar to the PSPLIB set and take the shortcomings mentioned in the previous section into account, and the MMLIB+dataset, which also takes more resources and more modes into account. The motivation to generate the new dataset comes from the idea that the complexity of the current benchmark datasets should be increased. The MMLIB50 and MMLIB100 are generated in order to increase the complexity of the scheduling problem (i.e. more activities), the MMLIB+dataset is generated to increase the complexity of both the scheduling problem (i.e. more activities) and the mode assignment problem (i.e. more possible nonrenewable mode combinations).
                              
                                 
                                    MMLIB50 and MMLIB100. The MMLIB50 and MMLIB100 dataset contains 50 and 100 activities, respectively. Each project activity has 2 renewable and 2 nonrenewable resources and for each activity, 3 modes were defined. The order strength is set at 0.25, 0.50 or 0.75. The resource strength of both the renewable and nonrenewable resource strength is set at 0.25, 0.50 or 0.75 and the resource factor is set at 0.50 or 1 for both renewable and nonrenewable resources. Using 5 instances for each problem class, each dataset contains 540 instances. The MMLIB50 and MMLIB100 datasets can be considered as similar to the PSPLIB datasets, since most parameters in both datasets are equal. However, some important differences should be noticed: firstly, the order strength of the projects in the MMLIB50 and MMLIB100 dataset is more diverse than the order strength of the projects in the PSPLIB dataset. Secondly, the MMLIB50 and MMLIB100 datasets do not contain projects with a resource strength equal to 1. Thirdly, all the instances have a feasible solution and finally, no modes can be deleted during the preprocessing procedure.


                                    MMLIB+. The MMLIB+dataset contains projects with 50 and 100 activities. Each project activity has 2 or 4 renewable and nonrenewable resources. For each activity, 3, 6 or 9 modes are defined. The order strength is set at 0.25, 0.50 or 0.75. The resource strength of both the renewable and nonrenewable resource strength is set at 0.25, 0.50 or 0.75. In order to keep the number of instances to a reasonable level, the renewable and nonrenewable resource factor is set at 1. Using 5 instances for each problem class, the MMLIB+dataset contains 3240 instances.

The MMLIB dataset and the best known solutions for each problem instance are available online. They can be downloaded from the website http://www.projectmanagement.UGent.be. This website will be updated regularly, and we call upon researchers to report the solutions of their procedures when this leads to an improvement.

In this section, a computational comparison is made between the different metaheuristic solution procedures. In Section 4.1, the design of the tests is explained, while in Section 4.2, the results of the tests on the PSPLIB and Boctor dataset (Section 4.2.1) and MMLIB dataset (Section 4.2.2) are presented.

The tests which are performed in this computational comparison are executed on the following two sets of problem instances.
                              
                                 1.
                                 First, the metaheuristic solution procedures are executed on the instances of the J10, J20, J30, Boct50 and Boct100 dataset.

Secondly, the procedures are also tested on the instances of the MMLIB dataset, namely the MMLIB50, MMLIB100 and MMLIB+.

In order to keep the number of tests under control, the instances of the J12, J14, J16 and J18 subsets of the PSPLIB dataset are not included in the comparison.

In order to make a fair comparison between the different solution procedures, the evaluation is stopped after a predefined number of generated schedules. According to Kolisch and Hartmann (2006), the advantage of the number of schedules as stop criterion is twofold: first, it is platform independent and second, future studies can easily make use of the benchmark results by applying the same stop criterion. However, the stop criterion also has a few shortcomings: first, it cannot be applied to all different heuristic strategies. Second, the required time to compute one schedule might differ between metaheuristics. Nevertheless, Kolisch and Hartmann (2006) conclude that limiting the number of schedules is the best criterion available for a broad comparison, which motivated us to use this stop criterion in all computational experiments.

In order to measure the number of generated schedules, the definition of one schedule should be defined. In their RCPSP review paper, Kolisch and Hartmann (2006) state that one schedule corresponds to (at most) one start time assignment per activity, as done by a SGS. However, measuring the number of schedules according to this rule means that for every mode change in a local search procedure a new schedule should be counted. Therefore, Lova et al. (2009) define the number of generated schedules as the sum of times each activity of the project has obtained a feasible start time divided by the number of activities of the project. This means that each change of the schedule, i.e. by changing either the start time or the finish time of one activity, is counted as 1/∣N∣ schedules. Assume a project with eight activities, each with three modes. Suppose that the SGS generates a schedule based on an activity and mode list (8 start times are assigned) and that a local search procedure has also analyzed the two other (feasible) modes for three of the activities (without affecting the start times of the other activities). This means that the procedure has generated and analyzed (8+2×3)/8=1, 75 schedules.

In the remainder of this paper, the definition of Lova et al. (2009) is used to define the number of schedules.

@&#EXPERIMENTAL RESULTS@&#

The results for the first set of instances obtained after 5000 schedules can be found in Table 6
                           . In the first column, the reference to the authors is given, while in the second column the metaheuristic strategy (MS) is indicated. In the following columns, the results for the J10, J20, J30, Boctor50 and Boctor100 sets are given. For the J10 and J20 set, the average deviation from the optimal solution is given. For the J30 and Boctor dataset, the deviation from the minimal critical path-based lower bound is reported. If a solution procedure was not able to obtain a feasible solution for all project instances, the percentage of instances for which a feasible solution was found is indicated between brackets. As can be seen in the table, not all heuristics were able to obtain a feasible solution for all project instances. The metaheuristics are sorted with respect to decreasing average deviations for the Boctor100 dataset, except for schedules which were not able to obtain feasible results for all datasets.

The best results for a specific dataset are displayed in bold. In order to determine the best heuristic, the concept of dominance as defined in Kolisch and Hartmann (2006) is used: a heuristic a is dominated by a heuristic b if a has for at least one subset a higher average deviation than b without having for any of the other subsets a lower average deviation. Table 6 reveals that the procedures of Lova et al. (2009); Van Peteghem and Vanhoucke (2010) and Van Peteghem and Vanhoucke (2011) are not dominated by other heuristics. For the PSPLIB dataset, the procedure of Van Peteghem and Vanhoucke (2011) dominates all other metaheuristics.

The results of the computational tests on the MMLIB50, MMLIB100 and MMLIB+ are given in the Tables 7–9
                           
                           
                           . In these tables, performance measures for the three stop criterion (1000, 5000 and 50,000 schedules, respectively) are shown. For every stop criterion, the average deviation from the minimal critical path is indicated. However, when the algorithm was not able to obtain a feasible solution for all project instances in the set, the percentage of instances for which a feasible solution is found, is shown. This percentage is indicated between brackets.

As can be seen in Table 7, the solution procedures of Slowinski, Soniewicki, and Weglarz (1994), Boctor (1996b), Bouleimen and Lecocq (2003), Özdamar (1999) and Coelho and Vanhoucke (2011) do not succeed in obtaining a feasible schedule for all project instances of the MMLIB50 dataset after 50,000 schedules. This is mainly due to the fact that these metaheuristics have not included a search procedure to enhance the feasibility of an infeasible solution vector or to the increased complexity of the projects. The procedure of Boctor (1996b) was designed to solve the MRCPSP/R, while the procedure of Bouleimen and Lecocq (2003) was originally designed to solve the RCPSP. The procedure of Coelho and Vanhoucke (2011) produces infeasible solutions due to the limitations in the SAT-solver. The number of procedures which are not able to generate feasible solutions for all instances further increases for MMLIB100 (Table 8) and MMLIB+ (Table 9), mainly due to the increased complexity of the instances (more activities and more modes per activity). As can be seen in Table 9, the feasibility rate of some procedures significantly increases for an increasing number of schedules evaluated (Boctor, 1996b; Mori & Tseng, 1997), while other metaheuristic solution procedures do not succeed in increasing this rate (Slowinski et al., 1994; Özdamar, 1999; Bouleimen & Lecocq, 2003; Ranjbar, De Reyck, & Kianfar, 2009; Coelho & Vanhoucke, 2011).

Based on the results, it can be stated that the procedure of Van Peteghem and Vanhoucke (2011) dominates all other metaheuristics for the MMLIB-datasets.

A closer look on the results shows that the main difference in the performance of the different algorithms is mainly due to the characteristics of the local search procedures used in the algorithm. Algorithms that make use of more advanced initial population procedures (LS1) perform better, just as the algorithms that make use of the feasibility improvement (LS2) and the makespan improvement local search (LS3). The use of the forward–backward local search procedure does not distinguish between a good or bad performing metaheuristic, as opposed to what can be found in literature (Kolisch & Hartmann, 2006).

This general analysis can be proven by the multivariate regression analysis that is performed. In Table 10
                        , the results are shown for a regression analysis with the different algorithmic components (local search procedures) as independent variables and the deviation of the result from the best known solution as the dependent variable (R
                        2
                        =.342). All independent variables are dummy variables. The values for the different local searches indicate if the specific local search is used (value=1) or not (value=0). It should be noted that for the initial population local search, only the more advanced local search procedures, such as the minimum normalized resources procedure of Lova et al. (2009) and the controlled mode assignment procedure of Van Peteghem and Vanhoucke (2011), are taken into account (see Section 2.2).

As can be seen in the table, all parameters are significant (p
                        <0.001).The influence of the first three local searches is straightforward: the initial population local search (LS1), the improving feasibility local search (LS2) and the improving makespan local search (LS3) all have a negative coefficient and thus, a positive and significant impact on the results. The result for the forward–backward local search (LS4) is opposite as expected (Kolisch & Hartmann, 2006). As shown in the analysis, the positive coefficient indicates that worse results will be obtained if this local search is used. However, this is not in line with previous research, where this local search procedure has already proven being successful (see Valls, Ballestin, & Quintanilla, 2005). A closer look to the literature also shows that the introduction of the forward–backward procedure results in a better performance of the individual algorithm. However, since not all of the algorithms are using this method and some of them not using it are also obtaining good results, the forward–backward procedure is no conditione sine qua non for obtaining good results.

A specific remark is dedicated to the DEA-procedure, as proposed by Damak, Jarboui, Siarry, and Loukil (2009). This algorithm does not use any specific local search procedure, but is performing quite good: 3rd position for MMLIB50, 4th for MMLIB100 and 4th for MMLIB+ (after 50,000 schedules). This indicates that this search strategy is very promising for the problem under study and probably will also perform well for other (project) scheduling problems. The choice for a specific metaheuristic search strategy does not consistently lead to better results. This can be seen by the results of the different genetic algorithms (the search strategy that is used the most to solve the MRCPSP): while the genetic algorithms of Lova et al. (2009) and Van Peteghem and Vanhoucke (2010) perform very well on both the PSPLIB and MMLIB dataset, the genetic algorithms of Mori and Tseng (1997) and Özdamar (1999) generate solutions of low quality. The same remark can be made for other search strategies, such as the simulated annealing and scatter search.

Based on these results, it can be stated that the use of specific heuristic components have a positive and significant influence on the results obtained by a specific heuristic.

In this section, the influence of the different project parameters is studied and evaluated. First, a multivariate linear regression analysis assesses the influence of the renewable and nonrenewable resource strength (RS
                        
                           ρ
                         and RS
                        
                           ν
                        ), the order strength (OS), the number of modes (∣M∣) and the number of renewable (∣R
                        
                           ρ
                        ∣) and nonrenewable (∣R
                        
                           ν
                        ∣) resources (the independent variables) on the deviation from the best known solution after 50,000 schedules (the dependent variable). The analysis is performed on the MMLIB+dataset truncated after 5000 schedules and is performed on each algorithm that obtains feasible solutions for all project instances. The results of this analysis are provided in Table 11
                        . For each method, the resulting R
                        2-value, the constant (Const), and the coefficient for each problem parameter are provided. An asterisk (*) indicates that the coefficient is significant at the 1% level of confidence. If no value is indicated, the coefficient is not significant at the 5% level of confidence.

The resulting R
                        2-values range between .185 and .597, which means that the 6 problem parameters are not able to predict the performance of a heuristic on a specific project instance. As can be seen, the resource strength (both renewable and nonrenewable) and the number of modes are the only parameters for which all values are significant at the 5% level. For the number of modes, the coefficients are all highly significant and positive, which means that an increase in the number of modes results in a higher deviation from the best known solution, mainly due to the increased number of feasible mode combinations.

For the renewable resource strength RS
                        
                           ρ
                        , the coefficients are mainly negative which indicates that for an increasing renewable resource strength, the deviation with the best known solution becomes smaller. The higher the value of the coefficient, the more sensitive the heuristic is in terms of the resource scarceness of the project instance. The most sensitive heuristic is the one of Lova et al. (2009) (see also below), while the most insensitive heuristic is the one of Van Peteghem and Vanhoucke (2011). Most heuristics also have a positive coefficient for the nonrenewable resource strength RS
                        
                           ν
                        , which is opposite to the renewable resource strength. It means that the higher the nonrenewable resource strength becomes (thus the easier it becomes to find a feasible solution), the larger the deviation with the best known solution will be. This seems counter-intuitive, but can be explained by the increased search space that comes with an increased number of feasible mode combinations: since more mode combinations will lead to a feasible solution, the risk of selecting a mode combination which leads to a poor schedule becomes higher.

The same conclusion can be made for the OS coefficient. All significant OS coefficients are negative, indicating that with an increasing value of the order strength, the average performance of the heuristics increases. This in line with the findings of Hartmann and Kolisch (2000), who stated that more precedence relations between activities lower the number of possible activity sequences and thus the size of the solution space. The high value of the OS-coefficient for the heuristic of Józefowska et al. (2001) indicates the this procedure becomes more performant if the complexity of the project network increases.

The influence of the number of nonrenewable resources is rather low, ranging from -.020 to 0.004, while the influence of the number of renewable resources on the solution quality is negligible (only in 3 cases the coefficient is significant). Finally, the constant-values are significant at the 1% level for all heuristics and give an indication of the heuristic performance: the lower the value of constant, the better – on average – the performance. It can be noticed that the procedure of Lova et al. (2009) has a better (negative) value for the constant coefficient than the procedure of Van Peteghem and Vanhoucke (2011), although the latter has an overall better performance.

In the remainder of this section, the focus is on the effects of the renewable and nonrenewable resource strength. In Table 12
                        , the average deviations from the best known solutions after 5000 iterations for each parameter setting of the MMLIB+dataset, respectively, is given. The number between brackets (if indicated) indicates the relative position of the procedure under the defined parameter setting. The table only indicates a result if all solutions found are feasible.

For the renewable resource strength, the results are in line with the results obtained from the multivariate regression analysis: the procedure of Van Peteghem and Vanhoucke (2011) performs the best under all parameter settings (indicated in bold). It can also be noticed that the algorithm of Lova et al. (2006) performs very well for low values of RS
                        
                           ρ
                        , while its performance diminishes for higher values. This is in line with the rather high coefficient values found for RS
                        
                           ρ
                         in the multivariate regression analysis. The inverse is true for the procedures of Józefowska et al. (2001) and Damak et al., 2009 which perform very well for high values of RS
                        
                           ρ
                        .

For the nonrenewable resource strength RS
                        
                           ν
                        , the number of procedures able to find 100% feasible solutions increases for an increasing RS
                        
                           ν
                        , i.e. for a declining resource availability: the number increases from 11 (RS
                        
                           ν
                        
                        =.25) to 16 (RS
                        
                           ν
                        
                        =.75). This is obviously a consequence of the increased availability of nonrenewable resources and the decreased complexity to find a feasible solution.

@&#DISCUSSION AND CONCLUSIONS@&#

This research has given an overview of the metaheuristic solution procedures available in the literature to solve the multi-mode resource-constrained project scheduling problem and has made a fair comparison between these procedures. Moreover, a new benchmark dataset is proposed. Researchers are encouraged to use this dataset to compare the results of their solution procedures with other procedures.

Based on the results, the following three conclusions can be made. First, the MRCPSP can be divided into two subproblems: the mode assignment problem, whose aim is to generate a feasible mode assignment list, and a scheduling problem, whose aim is to minimize the makespan of the problem. Some procedures mainly focused on the scheduling problem, by which these procedures were not able to generate feasible solutions for all project instances. Moreover, procedures using a thought-out mode assignment procedure to generate the initial population, such as the minimum normalized resources procedure of Lova et al. (2009) or the controlled mode assignment procedure of Van Peteghem and Vanhoucke (2011), have an advantage compared to other methods. Future research will have to focus on this mode assignment problem, since for an increasing number of activities and an increasing number of modes the complexity of this problem also increases.

Second, the good performance of some procedures is mainly due to the applied MRCPSP-specific local search procedures rather than to the followed metaheuristic search strategy. This conclusion is supported by computational tests executed by several authors comparing the effectiveness of both their algorithm and a similar solution procedure without the proposed local search method. Lova et al. (2009) proved that their hybrid genetic algorithm with an efficient improvement method clearly outperforms a simple genetic algorithm. Similar results are found by Hartmann (2001), who showed that the use of the single-pass improvement method clearly improves the performance of the proposed genetic algorithm. Moreover, the use of problem specific information in the local search process increases the efficiency of the procedure significantly.

A final contribution is made by making a fair comparison between the different available metaheuristic solution procedures. We believe that the introduction of the new MMLIB dataset opens the possibility to compare new solution procedures with the currently available methods. We hope that the introduction of this new dataset will also stimulate the development of new ideas and techniques to solve the MRCPSP.

@&#ACKNOWLEDGMENTS@&#

The computational resources and services used in this work were provided by Ghent University, the Hercules Foundation and the Flemish Government.

@&#REFERENCES@&#

