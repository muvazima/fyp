@&#MAIN-TITLE@&#Single row layout models

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We systematically review 82 publications covering the period from 2000 to 2014.


                        
                        
                           
                           Classified by, e.g., model formulation, input data, objective, solution method.


                        
                        
                           
                           We provide several tables clustering different aspects of our research.


                        
                        
                           
                           This includes a general overview, model extensions, exact methods, meta-heuristics.


                        
                        
                           
                           We pay particular attention to recent developments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Facilities planning and design

Single row layout

Literature review

@&#ABSTRACT@&#


               
               
                  The single row layout problem (SRLP) consists of finding the most efficient arrangement of a given number of facilities or machines along one side of the material handling path, a topic that has enjoyed lasting interest for the past 45 years. As well as for use in manufacturing environments, the SRLP can serve to arrange rooms along a corridor in, e.g., hospitals and supermarkets. Besides its practical relevance, the problem is also interesting from a formal point of view due to its 
                        NP
                     -hardness and therefore attracts the attention of many researchers. Beginning with the year 2000, this paper systematically reviews 82 articles focusing on single row layout problems. After featuring the relevance and timeliness, the SRLP is first positioned within the superordinate facility layout problem (FLP). Thereafter, the articles are classified according to topic of the paper, model formulation and representation, type of input data, objective function, and solution methods. We pay particular attention to recent developments in model formulation and solution methods to elaborate some possible directions and opportunities for further research.
               
            

@&#INTRODUCTION@&#

To stay competitive, modern manufacturing companies have to face steadily changing technology and a market environment characterised by, e.g., growing and more customised product diversification, fluctuating and unpredictable demand quantities, and shorter product life-cycles that require an increased machine flexibility, high productivity, and cost efficiency of manufacturing (cf. Benjaafar & Sheikhzadeh, 2000). It is known that these factors are impacted positively by a beneficial machine layout (cf. Drira, Pierreval, & Hajri-Gabouj, 2007). Understandably, a vast amount of research literature has been published in past decades addressing different topics of layout problems. One problem frequently regarded is the efficient arrangement of machines along the material transportation track, which is known as the single row layout problem (SRLP; also referred to as the one-dimensional space allocation problem, see, e.g., Picard & Queyranne, 1981; Romero & Sánchez-Flores, 1990; Simmons, 1969). In this paper, we intend to provide an overview of articles published since 2000 that consider single row layout models, a research area that has attracted an increasing interest in the recent literature. To the best of our knowledge, we are aware of only four publications that review SRLP. However, they focus on the general facility layout problem (FLP) and solely broach the SRLP (see Drira et al., 2007), reflect only a subset of single row layout literature (see Kothari & Ghosh, 2012c), or concentrate on very specific issues such as linear programming- and semidefinite programming-based methods for SRLP (see Anjos & Liers, 2012) or different modelling approaches (see Hungerländer & Rendl, 2013a).

To determine the relevant operational research literature dealing with SRLP, several databases such as Business Source Complete, Academic Source Complete, ScienceDirect, Web of Knowledge, and Google Scholar were searched for the keywords single row layout, linear layout, and one-dimensional space allocation, as well as their variations with the term facility and machine. Supplementarily, we used appropriate bibliographic references of articles thus obtained to complete our literature collection.

During our research we found 148 publications related to SRLP, whereof 82 articles published in the last 14 years emphasised the still increasing interest in this field of research, as shown in Fig. 1. Measured by the number of publications, Fig. 2 indicates that European Journal of Operational Research is especially one of the most important journals for researchers in SRLP.

Our review comprises 82 scientific articles, conference papers, book chapters, and working papers on SRLP in (cellular) manufacturing covering the period from 2000 to 2014. We also contain the latest papers missing in the previous surveys.
                     
                  

The paper is organised as follows. The position of SRLP within facility layout problems is presented in Section 2. In Section 3 the layout research literature of the past 14 years is examined and classified, highlighting actual trends in the research. A more detailed analysis of different model formulations is the topic of Section 4. Before drawing the conclusions and showing some further research opportunities, different methods used for solving the SRLP are presented in Section 5.

The SRLP consists of finding the most efficient arrangement of n facilities or machines along one side of the material handling path. More precisely, given the connectivity cij
                      between two machines i and j and their known lengths li
                     , …, ln
                     , a feasible layout π is sought so as to optimise the weighted sum of the distances between all pairs of machines (i, j). Let Π denotes the set of all permutations π of N = {1, 2, …, n}, then the minimisation problem can be formally stated as:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                π
                                                ∈
                                                Π
                                             
                                          
                                          
                                             ∑
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ⊂
                                                N
                                             
                                          
                                          
                                             c
                                             
                                                i
                                                j
                                             
                                          
                                          
                                             d
                                             
                                                i
                                                j
                                             
                                             π
                                          
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           d
                           
                              i
                              j
                           
                           π
                        
                      is the distance calculated between the centroids of two machines i and j with respect to a particular layout permutation π. Due to the vast literature concerning the arrangement of machines along a line, different terms such as single row, linear flowline, linear machine sequence, or line layout are used to define this problem (cf. Chen, Wang, & Chen, 2001).


                     Meller and Gau (1996) categorise the SRLP as a specially structured case of the more general FLP, which many researchers regard as a two stage design problem consisting of the block layout and the subordinated machine layout problem. Here, the block layout has to be detailed in the following or subsequent stage where machine layout problems are considered. This perception can be found in the layout literature concerning flexible manufacturing environments (see, e.g., Meller & Gau, 1996; Singh & Sharma, 2006), as well as in cellular manufacturing where the block layout and the machine layout correspond to the inter-cell and intra-cell layout, respectively (cf. Braglia, 1997; Jajodia, Minis, Harhalakis, & Proth, 1992; Morad, 2000). However, in (flexible) manufacturing environments, FLP is often called the machine layout problem (MLP) and both terms are used synonymously. Mostly in this context, the term facility is limited to equipment needed for manufacturing, such as machines, machine tools, workstations, etc. Studies referring to this understanding are, e.g., Balamurugan (2012), El-Baz (2004), and Kouvelis, Chiang, and Kiran (1992).

Indeed, as depicted in Fig. 3
                     , we follow the common differentiation in block and machine layout where the FLP comprises both problems hierarchically. Nevertheless, we use both terms, facility and machine, to define the same.

Regardless of considered perception of FLP and MLP, different existing (or assumed) manufacturing characteristics clearly impact and therefore require different layout patterns; in particular: the number of machines needed for production, available space, allowed flow movement of parts, similarities in operations sequences, input and output locations, and type of material handling devices chosen (cf. Drira et al., 2007; Hassan, 1994; Heragu & Kusiak, 1988).

The selection of layout configuration and material handling system have an especially strong relationship, since both problems are mutually dependent, as pointed out by Hassan (1994). Usually, it is assumed that the material handling system has been selected before the layout is optimised. In some situations though, e.g., handling hazardous materials, a particular material handling system is necessary to execute the production operations, regardless of the best layout for this purpose. Solving both problems simultaneously may be desirable, but it is impracticable due to complexity of each separate problem (see, e.g., Heragu, 1992).

However, based on the type of material handling system in use, layout arrangements are classified as row layout, loop layout, and cluster/open-field layout. Furthermore, row layout problems can be divided into single row, double row, and multi row problems, as shown in Fig. 4 (see, e.g., Drira et al., 2007; Jain, Khare, & Mishra, 2013). Single row layouts are popular in practice due to their simple and efficient flow structure, which causes low operational complexity with a manageable flow control, although modern and flexible material handling systems are suited for more complex layouts (cf. Ho & Moodie, 1998; Kumar, Asokan, & Kumanan, 2010; Ponnambalam & Ramkumar, 2001).

Typically, the layout configuration of single rows can be designed as a straight line (linear), semicircular, serpentine, or U-shaped line, as depicted in Fig. 5
                     
                      (see, e.g., Hassan, 1994; Ho & Moodie, 1998). Additionally, some researchers treat the loop layout pattern as another possible configuration of single row layout, since all machines are organised on a line as well (see, e.g., Djellab & Gourgand, 2001; Ho & Moodie, 1998; Lin, 2009; Mohagheghi, Georgoulas, Stylios, & Groumpos, 2009; Papadimitriou, Georgoulas, Stylios, & Groumpos, 2006; Ponnambalam & Ramkumar, 2001; Solimanpur, Vrat, & Shankar, 2005). Nevertheless, in this paper, we join the majority of researchers and consider the loop layout as a separate layout pattern with its own characteristics and special requirements in model formulation and solution methodologies (cf. Drira et al., 2007). Hence, a huge amount of research literature is dedicated to this particular type of layout where Asef-Vaziri and Laporte (2005) and Saravanan and Ganesh Kumar (2013) provide good overviews. Consequently, we exclude the loop layout in our review.

Beside the distinctive linear configuration, the material handling track in a single row layout is characterised by the material flow movement, which may be uni- or bidirectional (cf. Ho & Moodie, 1998; Heragu, 2008). In a unidirectional flow path, parts move in only one direction. A bidirectional system allows forward and backward movements along the material handling system, which is the most common assumption in the literature reviewed. However, a modern single row manufacturing system processes plenty of parts with different operation sequences so that the machines are strongly connected with each other and no unidirectional flow movement may be possible (cf. Hassan, 1994; Kouvelis & Chiang, 1992).

Commonly, flow movements are distinguished in in-sequence, repeat, bypass, and backtrack (see Fig. 6
                     ) (cf. Ponnambalam & Ramkumar, 2001). Both in-sequence and bypass flow in a forward direction. While the former is favoured because of its consecutive order, the latter skips one or more machines in the sequence. A repeat movement occurs if a part is rehandled on the same machine. In a unidirectional system, backtracking is defined as the movement against the main material flow that disturbs and complicates the material handling (see, e.g., Aneke & Carrie, 1986; Kouvelis & Chiang, 1992).

According to the single row layout structure and possible material movements, specific material handling devices are preferable. Straight single row layouts are efficiently served uni- or bidirectionally by an automated guided vehicle (see, e.g., Heragu & Kusiak, 1988). However, handling robots are appropriate for semicircular layouts (cf. Kouvelis et al., 1992). Conveyors can be used for all configurations of unidirectional single row layouts.
                  

Along with the application in manufacturing and cellular environments, as exemplarily depicted in Table 1, SRLP is utilised for numerous practical situations as identified by Picard and Queyranne (1981) and Suryanarayanan, Golden, and Wang (1991). For example, the optimal arrangement of rooms along a corridor in hospitals and supermarkets, the design of warehouse layouts, or the assignment of airplanes to gates in an airport terminal are mentioned.

In this section, we discuss general characteristics of SRLP and how we classify the literature surveyed. Following Drira et al. (2007), layout problems and therefore the SRLP can be categorised according to their model formulation, representation, type of input data, objective function, and solution methods. We add two criteria: the general topic of paper and clearances, which are regarded as an interesting model extension and ripe for future research. Summarising these essential features, Table 2
                      gives an overview of all publications of SRLP considered in this review.

The publications are roughly divided into their general topic, whether new models (M) or solution approaches (S) are presented, a structural analysis (A) of SRLP is discussed or the literature of SRLP is summarised in a review (R). Most researchers focus on developing more efficient or new kinds of solution approaches, e.g., by adopting biological concepts (see Kumar et al., 2010; Ulutas, 2013). However, new model formulations and analytical discussions have not attained similar interest with respect to the number of articles published. Nevertheless, in the last few years, Amaral (2006), Anjos, Kennings, and Vannelli (2005), and Hungerländer and Rendl (2013a) furthered new directions in formulating the SRLP by introducing novel mixed integer programming models and semidefinite programming (SDP) approaches. Although only a limited number of articles are hitherto observed, more and more authors concentrate on analysing the structure of SRLP or identifying special properties. These results are the source of developing new and improved existing solution methods as well as finding alternative problem formulations that can be solved exactly and/or in less time. For example, both Sanjeevi and Kianfar (2010) and Amaral and Letchford (2013) perform an intensive polyhedral study of the SRLP. The former analyse the polyhedral structure of the linear programming (LP) model introduced by Amaral (2009). They are able to prove the facet-defining property of several valid inequalities. Thus, the solution of LP over these valid inequalities gives the optimal solution for all instances studied by Amaral (2009). The latter derive classes of valid and facet-inducing inequalities and propose a branch-and-cut algorithm for the SRLP based on them.

A systematical investigation of semidefinite programming relaxations to ordering problems, e.g., SRLP, is conducted by Hungerländer and Rendl (2013b). They conclude that the resulting bounds for linear ordering problems are superior to those obtained by LP-based relaxations. Diponegoro and Sarker (2003b) analyses the unique characteristics of the distance matrix with assumed asymmetric and unequally-spaced machine locations in order to accelerate their solution algorithm. This attempt is related to the former detection of the so-called amoebic properties for equally-spaced locations along a track by Sarker, Wilhelm, Hogg, and Han (1995).

Aside from that, we recognised four articles that present an overview of different research aspects in SRLP. In their paper, Anjos and Liers (2012) describe recently published LP- and SDP-based approaches for SRLP. Drira et al. (2007) review literature concerning the facility layout problem in general and partly focus on SRLP. They propose a possible classification scheme of facility layout problems wherein the single row layout is a special layout configuration affected by the material handling system. A survey on methods for SRLP is done by Hungerländer and Rendl (2013a), in which they compare different modelling approaches. Kothari and Ghosh (2012c) present a state-of-the-art overview of different formulations for SRLP as well as a description of selected solution approaches.

In the literature, several model formulations for SRLP are available that belong to linear or nonlinear programming models, LP or NLP, respectively. Restricting the domain of variables, they may also be differentiated into mixed integer (MIP) or pure integer (IP) models where only some or all of the variables must be integer values. By combining the different classifications with each other, the single row layout models can be categorised into: LP and (M)ILP as well as NLP and (M)IP. The most commonly encountered formulations are nonlinear, such as the traditional quadratic assignment formulation (QAP) or the ABSMODEL (ABS) introduced by Heragu and Kusiak (1991) (see, e.g., Palubeckis, 2012 and Solimanpur, Vrat, & Shankar, 2004, as well as Samarghandi & Eshghi, 2010 and Gomes de Alvarenga, Negreiros-Gomes, & Mestria, 2000, respectively). Please note, some authors use dij
                         instead of absolute values |xi
                         − xj
                        | to formulate the ABSMODEL (see, e.g., Kunlei, Chaoyong, Liang, & Xinyu (2011)). Another large group of publications propose nonlinear (mixed) integer programming problems, such as Kumar, Asokan, Kumanan, and Varma (2008), Lee (2001) and Teo and Ponnambalam (2008). In general, it is difficult to find an optimum for nonlinear programming formulations so that a variety of literature considers (mixed) (integer) linear model formulations such as Amaral (2006), Braglia, Zanoni, and Zavanella (2003), Brusco (2004), and Chaieb and Korbaa (2003). Semidefinite programming approaches are discussed as well (see Anjos & Vannelli, 2008). Since Anjos et al. (2005) transferred SDP to SRLP for the first time, several papers have been published showing that SDP is still one of the most promising procedures (see, e.g., Anjos & Yen, 2009; Anjos & Liers, 2012; Engau, Anjos, & Vannelli, 2012; Hungerländer & Rendl, 2013a; Hungerländer, 2014). There are a large number of publications that address analysis or solution approaches for which it is adequate to use only an objective function or objective criteria. Therefore, these articles are not classified.

Depending on the problem representation, SRLP can be divided into two broad areas: SRLP with discrete representation or SRLP with continuous representation (see, e.g., Drira et al., 2007; Heragu, 2008; Liu & Meller, 2007). Most of the researchers in SRLP (56 papers) prefer the latter, which is discussed in detail in Section 4.2. Discrete formulations require that all potential locations for each machine are known a priori in order to find an optimal assignment from facilities to locations under a given objective. Here, the distances between locations and, therefore, between machines are predefined according to the predefined locations. These approaches implicate equal-sized machines and similar shapes so as to be suitable for the predefined locations. Otherwise, unequal machine sizes cause different location dimensions that change depending on the machine sequence and are thus unknown in advance. Consequently, ignoring area requirements, the orientation of machines are neglected, just as necessary clearances between machines and location of input/output points (see, e.g., Drira et al., 2007; Moslemipour, Lee, & Rilling, 2012; Solimanpur et al., 2005).

These limitations can be overcome by continuous problem formulations, which the majority of authors preferred in the last few years, as depicted in Table 2. A continuous framework allows the placement of machines anywhere along the single row provided that the machines do not overlap. This is more accurate and realistic than the simplified discrete formulation that eliminates solutions from consideration. However, the continuous representation increases the solution space and therefore the complexity of SRLP (see, e.g., Liu & Meller, 2007). Here, an optimal machine sequence or ordering of machines, rather than a sole assignment of machines to locations, is intended (cf. Brunese & Tanchocoa, 2013; Simmons, 1969).

The majority of researcher suppose complete knowledge of all data necessary for modelling the SRLP. These deterministic SRLP are not suitable for many practical situations where, e.g., the material flow cannot be estimated with certainty and therefore is subject to changes because of demand fluctuations. In the literature reviewed, only 10 papers consider such an uncertain environment which can be modelled with stochastic approaches (6 papers) or fuzzy logic (4 papers). While most studies regard material flow as the only uncertain parameter, Nematian (2014) additionally includes length of departments and clearances between machines as fuzzy numbers into the model.

To determine the optimal or near-optimal layout in a given problem situation, an appropriate evaluation criterion must be defined. In most of the literature reviewed an objective related to the distance covered by the material handling system is chosen. Prevalently, this concerns the intent to minimise the total material handling costs (see, e.g., Djellab & Gourgand, 2001; Nematian, 2014; Ramkumar & Ponnambalam, 2004), minimise the total flow distance (see, e.g., Clauss, Bernt, & Middendorf, 2013; Datta, Amaral, & Figueira, 2011; Ozcelik, 2012; Solimanpur et al., 2005,) or simply minimise the distance between all pairs of machines (i, j) (see, e.g., Diponegoro & Sarker, 2003b; Lin, 2009). A generalisation of these is the minimisation of weighted distances between all machines, where the weight may represent costs or material flow as well as their combination (see, e.g., Amaral, 2006; Anjos et al., 2005; Engau et al., 2012; Hungerländer & Rendl, 2013a; Kothari & Ghosh, 2014a). In fact, these optimisation criterion are not necessarily convenient for all SRLP. Moreover, works considering discrete problem representation often pursue the reduction of backtracking (see, e.g., Chrysostomos & Vlachos, 2005; Mohagheghi et al., 2009; Papadimitriou et al., 2006). Backtracking operations have to be performed against the main material flow in unidirectional systems, (cf. Section 2) which complicate the workflow and affect productivity and costs (cf. Hassan, 1994; Morad, 2000). While on that account this flow movement is the least desirable, movements corresponding to the main or feasible flow should be increased. Following this, Ponnambalam and Ramkumar (2001) and Chen et al. (2001) maximise the number of in-sequence movements.

Apart from the majority of publications with distance-based optimisation parameters, we observed very few works proposing other objectives. Predominantly, these are publications with multi-criteria considerations in order to achieve more realistic layout solutions. Azadeh et al. (2011, 2014) address the special problems in a refrigerator manufacturing company where reducing the waiting time in queues or queue lengths, machine utilisation and time-in-system is targeted. However, a simultaneous approach that minimises the total investment costs, total number of machines, and total flow distance of the products is presented by Lenin et al. (2013); Lenin et al. (2014) additionally include the total material handling costs. Balamurugan (2012) considers operational performance such as work-in-process, cycle time, resource utilisation, etc. in the model. In the research of Na, Kelin, and Wei (2010) logistic costs, processing times and area occupancy rates are taken into account. To the best of our knowledge, Ou-Yang and Utamima (2013) are the only authors who integrate safety constraints and fixed costs in the objective function to form an enhanced SRLP. An objective that has been neglected so far is the minimisation of bypass movements, which is similar to how backtracking negatively impacts the workflow, productivity, and throughput (cf. Hollier, 1963; Hassan, 1994).

The various types of SRLP formulated in the literature require different approaches to obtain a good solution that satisfies certain constraints and/or achieves a global or local optimum. Therefore, a common differentiation criterion of facility layout problems is the solution method in use, which will be discussed in more detail in Section 5. In Table 2 we distinguish between the four types of methods: exact approaches, heuristics, meta-heuristics, and solution methods that cannot be included in the former approaches and are summarised as others. Since the SRLP is a 
                           NP
                        -hard combinatorial optimisation problem, only small instances of the problem—up to 40 machines—can be solved by exact algorithms. Predominantly, the algorithms use relaxation techniques in order to reduce the optimisation problem and diminish the computational complexity (see, e.g., Amaral, 2009; Anjos et al., 2005; Anjos & Yen, 2009; Engau et al., 2012; Hungerländer, 2014; Lee & Park, 2010). Although exact algorithm generate globally optima and therefore are favoured by many researchers, approximate solution approaches have gained much more attention during the last few years, 19 compared to 57 publications. Meta-heuristics are extensively discussed by almost half of the authors, while the number of papers addressing heuristic methods decreases, in contrast to the years before 2000. Nevertheless, Djellab and Gourgand (2001), Diponegoro and Sarker (2003a), Kothari and Ghosh (2013a), and Yu and Sarker (2003) propose new heuristics for the SRLP, in particular for problems with special characteristics. Aside from that, new kinds of solution approaches are necessary to cope with complex and uncertain manufacturing systems. In this area, simulation techniques as well as knowledge-based expert-systems have recently been picked up by Azadeh, Moghaddam, Asadzadeh, and Negahban (2011), Azadeh, Roozbahani, and Moghaddam (2013), Azadeh et al. (2014), Balamurugan (2012), Chan and Malmborg (2010a), Chan and Malmborg (2010b), Chan and Malmborg (2013), Suo and Chi (2013), and Khan, Hussain, and Noor (2011), respectively.

In order to fulfil indispensable requirements of real-life manufacturing, in recently published articles more and more authors include clearances in their model and solution method (see, e.g., Amaral, 2009; Djellab & Gourgand, 2001; Ozcelik, 2012). Clearances are the necessary space between machines so that regular machine operations can be performed. According to the assumption of predefined locations, clearances are not essential in the discrete representation and therefore are limited to researches considering continuous formulations. A deeper discussion of this topic takes place in Section 4.3.2.

In order to design an efficient single row layout, a convenient mathematical description of the underlying problem is essential. As shown in Table 2, the variety of objectives and constraints leads to diverse single row layout formulations. In this section, we selectively describe some models that are differentiated between discrete and continuous, as the mathematical formulation relies on the problem representation. Prior to this, the assumptions are presented and afterward we discuss some model extension found in the SRLP literature.

The major assumption made in the discrete problem formulation is that machines can only be assigned to locations that are known in advance (cf. Solimanpur et al., 2004). Here, the number of machines equals the number of locations (cf. Palubeckis, 2012), so each machine is assigned to exactly one location and vice versa (cf. Sarker et al., 1995). Formally, the binary variable xih
                         takes value 1 if machine i is assigned to location h, and 0 otherwise. By assuming known locations, the distances dhk
                         between the centroids of two locations, h and k, in the row are predefined as well and do not change according to different machine assignments. This implicitly follows that the machines are assumed to be identical in size and shape, usually rectangular or square. Therefore, it is not necessary to consider the orientation of machines that do not influence the assignment or distance calculation.

To conform all of these assumptions, the discrete SRLP can be mathematically formulated as the well-known quadratic assignment problem (QAP) with the following objective function:

                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   h
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                             
                                                f
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                             
                                                d
                                                
                                                   h
                                                   k
                                                
                                             
                                             
                                             
                                                x
                                                
                                                   i
                                                   h
                                                
                                             
                                             
                                             
                                                x
                                                
                                                   j
                                                   k
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

where fij
                         denotes the material flow from machine i to j and dhk
                         the distance

                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             d
                                             
                                                h
                                                k
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                |
                                                h
                                                −
                                                k
                                                |
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

with the hth and kth location where machines i and j are assigned, respectively.

Considering the minimisation of backtracking movements or distances, the objective of the QAP changes to (cf. Mohagheghi et al., 2009):

                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   h
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                             
                                                r
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                             
                                                b
                                                
                                                   h
                                                   k
                                                
                                             
                                             
                                             
                                                x
                                                
                                                   i
                                                   h
                                                
                                             
                                             
                                             
                                                x
                                                
                                                   j
                                                   k
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

where bhk
                         denotes the necessary number of backtracking steps (distance) to transport the material flow rij
                         from machine i located at h to machine j assigned to location k. The backtracking distance bhk
                         is defined as

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                b
                                                
                                                   h
                                                   k
                                                
                                             
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            h
                                                            −
                                                            k
                                                         
                                                      
                                                      
                                                         
                                                            if
                                                            
                                                            
                                                               x
                                                               k
                                                            
                                                            >
                                                            
                                                               x
                                                               h
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         
                                                            otherwise
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In the interest of brevity, we have decided to exclude the large amount of literature discussing QAP-based models and solution approaches on the premise that no application to single row layout is explicitly stated. However, in general, QAP-models can be applied to the discrete SRLP adjusting distances between locations appropriately. For a general discussion of QAP researches, we refer the reader to Loiola, de Abreu, Boaventura-Netto, Hahn, and Querido (2007).

The continuous SRLP tries to overcome the aforementioned drawbacks of discrete model representations.

By analysing the articles published since 2000, we state that regardless of the underlying model formulation, several basic assumptions are valid for continuous SRLP. Similar to the discrete case, all machines have to be arranged in one row, e.g., along the material handling path. The machines are geometrically represented by rectangles or squares of fixed, but unequal heights and widths so that their shapes and dimensions are known a priori, but vary. Although different machines dimensions are considered, the orientations are predetermined, i.e., it is given which machine’s side or length is directed toward the transport path connecting the machines and thus influences the distance (cf., e.g., Anjos et al., 2005; Amaral, 2006; Balamurugan, 2012; Brunese & Tanchocoa, 2013; Ficko, Brezocnik, & Balic, 2004; Gomes de Alvarenga et al., 2000; Kumar et al., 2008). Additionally, in most of the publications, the floor area on which the machines are arranged is unrestricted. This assumption may be removed.


                           Solimanpur et al. (2005) presented a nonlinear integer formulation of SRLP based on binary variables xih
                            representing the assignment of machine i to the hth position in the machine sequence.

                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   ∑
                                                   
                                                      h
                                                      =
                                                      1
                                                   
                                                   
                                                      N
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      h
                                                      +
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   (
                                                   
                                                      f
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   +
                                                   
                                                      f
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                
                                                
                                                   d
                                                   
                                                      h
                                                      k
                                                   
                                                
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      h
                                                   
                                                
                                                
                                                
                                                   x
                                                   
                                                      j
                                                      k
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           s.t.

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   d
                                                   
                                                      h
                                                      k
                                                   
                                                
                                                =
                                             
                                          
                                          
                                             
                                                
                                                   1
                                                   2
                                                
                                                
                                                   ∑
                                                   
                                                      r
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   l
                                                   r
                                                
                                                
                                                
                                                   x
                                                   
                                                      r
                                                      h
                                                   
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      r
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   ∑
                                                   
                                                      s
                                                      =
                                                      h
                                                      +
                                                      1
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   l
                                                   r
                                                
                                                
                                                
                                                   x
                                                   
                                                      r
                                                      s
                                                   
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      r
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   ∑
                                                   
                                                      s
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   ∑
                                                   
                                                      t
                                                      =
                                                      h
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   e
                                                   
                                                      r
                                                      s
                                                   
                                                
                                                
                                                
                                                   x
                                                   
                                                      r
                                                      t
                                                   
                                                
                                                
                                                
                                                   x
                                                   
                                                      s
                                                      ,
                                                      t
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                +
                                                
                                                   1
                                                   2
                                                
                                                
                                                   ∑
                                                   
                                                      r
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   l
                                                   r
                                                
                                                
                                                
                                                   x
                                                   
                                                      r
                                                      k
                                                   
                                                
                                                
                                                1
                                                ≤
                                                h
                                                <
                                                k
                                                ≤
                                                N
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (8)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      h
                                                   
                                                
                                                =
                                                1
                                                
                                                ∀
                                                h
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      h
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      h
                                                   
                                                
                                                =
                                                1
                                                
                                                ∀
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (10)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   
                                                      i
                                                      h
                                                   
                                                
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   1
                                                   }
                                                
                                                ,
                                                
                                                
                                                   d
                                                   
                                                      h
                                                      k
                                                   
                                                
                                                ∈
                                                R
                                                
                                                ∀
                                                i
                                                ,
                                                h
                                                ,
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

As in most papers, the objective function minimise the centre-to-centre distances of all machine pairs (i, j), which the material flow fij
                            has to overcome. The distance dhk
                            between two machine positions includes the lengths of machines placed between position h and k and clearances eij
                            depending on the sequence of machines in the single row; thus, dhk
                            is sequence dependent as well. Although there are similarities to the QAP according to the quadratic objective function and the constraints, they address the continuous model representation. Nevertheless, an exact solution is only attainable for small problem instances.


                           Amaral (2009) suggested a 0-1 integer programming model using ‘betweenness’ variables that indicate the relative position of one machine to two other machines in the single row. More precisely, the binary variables ζijk
                            (i, j, k ∈ N, i < j, i ≠ k ≠ j) are defined as

                              
                                 (11)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ζ
                                                   
                                                      i
                                                      j
                                                      k
                                                   
                                                
                                                =
                                                
                                                   {
                                                   
                                                      
                                                         
                                                            1
                                                         
                                                         
                                                            
                                                               if
                                                               
                                                               machine
                                                               
                                                               k
                                                               
                                                               lies
                                                               
                                                               between
                                                               
                                                               machines
                                                               
                                                               i
                                                               
                                                               and
                                                               
                                                               j
                                                               ,
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            0
                                                         
                                                         
                                                            
                                                               otherwise
                                                               .
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

All ζijk
                            form the corresponding vector ζ ∈ {0, 1}
                              n(n − 1)(n − 2) which represents a permutation of n machines. The author defined a betweenness polytope

                              
                                 (12)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   P
                                                   n
                                                
                                                =
                                                conv
                                                
                                                   {
                                                   ζ
                                                   
                                                   :
                                                   
                                                   ζ
                                                   
                                                   represents
                                                   
                                                   an
                                                   
                                                   ordering
                                                   
                                                   of
                                                   
                                                   the
                                                   
                                                   elements
                                                   
                                                   of
                                                   
                                                   N
                                                   }
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           which is the convex hull including all feasible permutations. Therefore, the SRLP can be formulated in terms of ζ using 
                              
                                 P
                                 n
                              
                            (cf. Hungerländer & Rendl, 2013a)

                              
                                 (13)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   min
                                                   
                                                      ζ
                                                      ∈
                                                      
                                                         P
                                                         n
                                                      
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      i
                                                      <
                                                      j
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      <
                                                      j
                                                   
                                                   n
                                                
                                                
                                                   (
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   −
                                                   
                                                      c
                                                      
                                                         i
                                                         k
                                                      
                                                   
                                                   
                                                      l
                                                      j
                                                   
                                                   )
                                                
                                                
                                                   ζ
                                                   
                                                      i
                                                      j
                                                      k
                                                   
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      i
                                                      <
                                                      j
                                                   
                                                
                                                
                                                   (
                                                   
                                                      1
                                                      2
                                                   
                                                   
                                                      (
                                                      
                                                         l
                                                         i
                                                      
                                                      +
                                                      
                                                         l
                                                         j
                                                      
                                                      )
                                                   
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         k
                                                         >
                                                         j
                                                      
                                                      n
                                                   
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           with the following valid equations for 
                              
                                 P
                                 n
                              
                           
                           
                              
                                 (14)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ζ
                                                   
                                                      i
                                                      j
                                                      k
                                                   
                                                
                                                +
                                                
                                                   ζ
                                                   
                                                      i
                                                      k
                                                      j
                                                   
                                                
                                                +
                                                
                                                   ζ
                                                   
                                                      j
                                                      k
                                                      i
                                                   
                                                
                                                =
                                                1
                                                
                                                i
                                                ,
                                                j
                                                ,
                                                k
                                                ∈
                                                N
                                                ,
                                                i
                                                <
                                                j
                                                <
                                                k
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           This constraint ensure if machine i is arranged before machine j in the permutation, then a third machine k can only be assigned either before machine i, or between machine i and j, or after machine j.


                           Amaral (2009) states that using the model and a suggested LP-based cutting plane algorithm, problem instances of up to 35 machines were optimally solvable.

The first single row layout model based on semidefinite programming was proposed by Anjos et al. (2005). They use a similar principle to the preceding integer programming model. A variable Rij
                            is defined for each machine pair (i, j) with i < j
                           
                              
                                 (15)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                =
                                                
                                                   {
                                                   
                                                      
                                                         
                                                            1
                                                         
                                                         
                                                            
                                                               
                                                               if
                                                               
                                                               machine
                                                               
                                                               i
                                                               
                                                               is
                                                               
                                                               to
                                                               
                                                               the
                                                               
                                                               right
                                                               
                                                               of
                                                               
                                                               machine
                                                               
                                                               j
                                                               ,
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               −
                                                               1
                                                            
                                                         
                                                         
                                                            
                                                               
                                                               if
                                                               
                                                               machine
                                                               
                                                               i
                                                               
                                                               is
                                                               
                                                               to
                                                               
                                                               the
                                                               
                                                               left
                                                               
                                                               of
                                                               
                                                               machine
                                                               
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           Including a third machine k, the ordering of all three machines in a feasible arrangement can be described as follows, if machine i is left(right) to machine j and machine j is left(right) to machine k, Rij
                            = Rjk
                           , then it is necessary that i is also left(right) to machine k, Rik
                            = Rij
                            and therefore Rik
                            = Rjk
                           . Thus, this consideration is expressed by

                              
                                 (16)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   R
                                                   
                                                      j
                                                      k
                                                   
                                                
                                                −
                                                
                                                   R
                                                   
                                                      i
                                                      k
                                                   
                                                
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                −
                                                
                                                   R
                                                   
                                                      i
                                                      k
                                                   
                                                
                                                
                                                   R
                                                   
                                                      j
                                                      k
                                                   
                                                
                                                =
                                                −
                                                1
                                                
                                                for
                                                
                                                all
                                                
                                                triples
                                                
                                                i
                                                <
                                                j
                                                <
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           This leads to the following SRLP formulation:

                              
                                 (17)
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                K
                                                −
                                                
                                                   ∑
                                                   
                                                      i
                                                      <
                                                      j
                                                   
                                                
                                                
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   2
                                                
                                                
                                                   (
                                                   
                                                      ∑
                                                      
                                                         k
                                                         <
                                                         i
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      R
                                                      
                                                         k
                                                         i
                                                      
                                                   
                                                   
                                                      R
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   −
                                                   
                                                      ∑
                                                      
                                                         i
                                                         <
                                                         k
                                                         <
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      R
                                                      
                                                         i
                                                         k
                                                      
                                                   
                                                   
                                                      R
                                                      
                                                         k
                                                         j
                                                      
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         k
                                                         >
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      R
                                                      
                                                         i
                                                         k
                                                      
                                                   
                                                   
                                                      R
                                                      
                                                         j
                                                         k
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           s.t.

                              
                                 (18)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   R
                                                   
                                                      j
                                                      k
                                                   
                                                
                                                −
                                                
                                                   R
                                                   
                                                      i
                                                      k
                                                   
                                                
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                −
                                                
                                                   R
                                                   
                                                      i
                                                      k
                                                   
                                                
                                                
                                                   R
                                                   
                                                      j
                                                      k
                                                   
                                                
                                                =
                                                −
                                                1
                                                
                                                for
                                                
                                                all
                                                
                                                triples
                                                
                                                i
                                                <
                                                j
                                                <
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (19)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   R
                                                   
                                                      i
                                                      j
                                                   
                                                   2
                                                
                                                =
                                                1
                                                
                                                for
                                                
                                                all
                                                
                                                i
                                                <
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 K
                                 =
                                 
                                    ∑
                                    
                                       i
                                       <
                                       j
                                    
                                 
                                 
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    2
                                 
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    l
                                    k
                                 
                              
                            is a constant. The objective is to minimise the weighted centre-to-centre distances. Here, the ordering of subscripts of Rij
                            is important with i < j.

To obtain the matrix-based formulation, the vector

                              
                                 (20)
                                 
                                    
                                       
                                          
                                             
                                                v
                                                =
                                                
                                                   
                                                      (
                                                      
                                                         R
                                                         
                                                            p
                                                            1
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         R
                                                         
                                                            p
                                                            
                                                               (
                                                               
                                                                  n
                                                                  2
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                      )
                                                   
                                                   T
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           is introduced which collects the variables Rij
                            by fixing an ordering of all feasible machine pairs ij. pk
                            denotes the kth pair ij in the ordering. Herefrom, the matrix X = vvT
                            is constructed whose main diagonal elements correspond to 
                              
                                 R
                                 
                                    i
                                    j
                                 
                                 2
                              
                            and hence diag(X) = e is gained. Using X instead of the ordering variables Rij
                           , the SRLP model is reformulated as follows:

                              
                                 (21)
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                K
                                                −
                                                
                                                   ∑
                                                   
                                                      i
                                                      <
                                                      j
                                                   
                                                
                                                
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   2
                                                
                                                
                                                   (
                                                   
                                                      ∑
                                                      
                                                         k
                                                         <
                                                         i
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      X
                                                      
                                                         k
                                                         i
                                                         ,
                                                         k
                                                         j
                                                      
                                                   
                                                   −
                                                   
                                                      ∑
                                                      
                                                         i
                                                         <
                                                         k
                                                         <
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      X
                                                      
                                                         i
                                                         k
                                                         ,
                                                         k
                                                         j
                                                      
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         k
                                                         >
                                                         j
                                                      
                                                   
                                                   
                                                      l
                                                      k
                                                   
                                                   
                                                      X
                                                      
                                                         i
                                                         k
                                                         ,
                                                         j
                                                         k
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           s.t.

                              
                                 (22)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   X
                                                   
                                                      i
                                                      j
                                                      ,
                                                      j
                                                      k
                                                   
                                                
                                                −
                                                
                                                   X
                                                   
                                                      i
                                                      j
                                                      ,
                                                      i
                                                      k
                                                   
                                                
                                                −
                                                
                                                   X
                                                   
                                                      i
                                                      k
                                                      ,
                                                      j
                                                      k
                                                   
                                                
                                                =
                                                −
                                                1
                                                
                                                for
                                                
                                                all
                                                
                                                triples
                                                
                                                i
                                                <
                                                j
                                                <
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (23)
                                 
                                    
                                       
                                          
                                          
                                             
                                                diag
                                                (
                                                X
                                                )
                                                =
                                                e
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (24)
                                 
                                    
                                       
                                          
                                          
                                             
                                                rank
                                                (
                                                X
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (25)
                                 
                                    
                                       
                                          
                                          
                                             
                                                X
                                                ⪰
                                                0
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

where vector diag(X) contains all diagonal elements of matrix X and e denotes the vector of all ones. The last constraint ensures that X is a symmetric positive semidefinite matrix. A detailed description can be found in Anjos et al. (2005), Anjos and Vannelli (2008), and Hungerländer and Rendl (2013a).
                        


                           Anjos and Yen (2009) reduce the number of linear constraints from 
                              
                                 O
                                 (
                                 
                                    n
                                    3
                                 
                                 )
                              
                            to 
                              
                                 O
                                 (
                                 
                                    n
                                    2
                                 
                                 )
                              
                            and formulate an alternative formulation where only the first constraint is changed

                              
                                 (26)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  k
                                                                  ≠
                                                                  i
                                                                  ,
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  k
                                                                  =
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   n
                                                
                                                
                                                   X
                                                   
                                                      i
                                                      j
                                                      ,
                                                      j
                                                      k
                                                   
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  k
                                                                  ≠
                                                                  i
                                                                  ,
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  k
                                                                  =
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   n
                                                
                                                
                                                   X
                                                   
                                                      i
                                                      j
                                                      ,
                                                      i
                                                      k
                                                   
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  k
                                                                  ≠
                                                                  i
                                                                  ,
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  k
                                                                  =
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   n
                                                
                                                
                                                   X
                                                   
                                                      i
                                                      k
                                                      ,
                                                      j
                                                      k
                                                   
                                                
                                                =
                                                −
                                                
                                                   (
                                                   n
                                                   −
                                                   2
                                                   )
                                                
                                             
                                          
                                          
                                          
                                             
                                                for
                                                
                                                all
                                                
                                                pairs
                                                
                                                i
                                                <
                                                j
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Both models can be solved by using semidefinite relaxation. Due to the large amount of linear constraints in the first model, the authors stated they were only capable of solving single row layouts with up to 30 machines to optimality.

In the SRLP literature reviewed, we recognised various modifications and extensions to the basic problem formulations of Sections 4.1 and 4.2 by adding constraints or incorporating special properties in order to fulfil more real-life requirements or to suit specific manufacturing environments. These variations are compiled in Tables 3 and 4.
                     

To manufacture a specific product, it has to pass several machines in a predefined operation sequence. In the presence of multiple products, their operation sequence might not be uniform. Considering a unidirectional single row layout, either backtracking is necessary or multiple machines with identical performances need to be employed, if backward movements are not allowed. Very few authors discuss this special case of SRLP with sets of identical or duplicate machines (see, e.g., Chaieb & Korbaa, 2003; Chen et al., 2001; Diponegoro & Sarker, 2003a; Kumar, Islamb, Lenin, Kumar, & Ravindran, 2011; Lenin et al., 2013, 2014). In all papers, the number of identical machines is limited and it is known which machine is available as a multiple resource.

As described in the preceding sections, an optimal or efficient single row layout is usually characterised by an arrangement in which machines are positioned as close as possible to each other in compliance with the objective and constraints considered. In practical manufacturing situations, this can only be carried out if a minimum space between machines (clearance eij
                           ) is taken into account according to safety issues and operative considerations. Different production rates cause the need to store products or components temporarily in order to be processed on the machine or to be handled by the material transport system (cf. Solimanpur et al., 2005). Similarly, loading and unloading machines require enough space to ensure safe operations and sufficient space for workers to move (see, e.g., Ozcelik, 2012). Kaku and Rachamadugu (1992) and Brunese and Tanchocoa (2013) refer to the case of maintenance when machine failures occur and components must be exchanged or repaired. Undesired interactions of adjacent machines due to the emission of oscillations or other interference elements, such as the aforementioned occasions, necessitate clearances of different sizes between machines (cf. Chaieb & Korbaa, 2003). Solimanpur et al. (2005) state that the required size of clearance spaces is affected by several factors: (a) the routing and production volumes of components, (b) the processing times of operations on machines, (c) the shape and size of components, (d) the type of transport device(s), and (e) the type and size of the pallets used by material handling devices.

In contrast to the practical needs, in the respective literature, the importance of clearances are either insignificantly incorporated or ignored altogether. In fact, only 28 works address clearances in some manner. Table 4 summarises these articles and shows that different strategies has been developed to deal with the subject.

One strategy is based upon equal clearances for all machine pairs (i, j) so as to integrate it into the machine dimensions by adjusting the length appropriately (see, e.g., Amaral, 2009; Anjos & Vannelli, 2008; Brunese & Tanchocoa, 2013). Hence, the model is simplified and can be treated as a problem without clearances. Most authors, however, follow Heragu and Kusiak (1988) and assume variable clearances depending on the machine sequence in the single row layout (cf. column 4). Here, the necessary clearance space is influenced by the machines arranged adjacent to each other. For example, a milling machine can be arranged closer to a lathe than to a drilling machine (cf. Ozcelik, 2012). But even though model or solution approaches include this case, for comparable results, the clearances are often set to zero or an constant value during performance tests (see, e.g., Balamurugan, 2012; Gomes de Alvarenga et al., 2000; Hungerländer & Rendl, 2013a; Nematian, 2014). Here, new test instances will be advantageous.

Due to the symmetric arrangements of the single row layout, Simmons (1969) and Anjos et al. (2005) observe that the left and right ends of the layout can be exchanged without increasing the distance and therefore the objective value. This leads to the simplification of the problem with i < j where machine i is positioned left of machine j in the ordering and consequently imply symmetric clearances, eij
                            = eji
                           . But the observation does not hold in the case of asymmetric, sequence dependent clearances with eij
                            ≠ eji
                            resulting in different distances between machine i and j, dij
                            ≠ dji
                           . For example, this may occur in manufacturing environments with machines emitting oscillations only on one side.

To the best of our knowledge, solely the model of Solimanpur et al. (2005) is capable to handle asymmetric, sequence dependent clearances, although it is not explicitly mentioned. None of the other publications in SRLP regard or discuss this special case. Nevertheless, the models and solution approaches of Chung and Suh (2014), Ficko et al. (2004). Na et al. (2010), and Ozcelik (2012) could be enhanced to cover asymmetric cases. This is clearly an interesting topic for further research.

When designing an efficient layout, authors usually consider machines as an infinite production resource. In practice, infinite production is not possible, but rather is limited to the maximum capacity of each machine. To handle a manufacturing environment where the demand is uncertain and represented by fuzzy numbers, and thereby the material flow as well, Aiello and Enea (2001) take into account limited production capacities. The limitation restricts the maximum possible material flow between machines.

Some articles assume symmetric material flows between machine pairs (i, j) (see, e.g., Amaral, 2009; Sanjeevi & Kianfar, 2010). When attempting to minimise the total flow distance, whether machine i is arranged before machine j in the layout or vice versa does not change the objective value. In both cases, the total flow distance is the same. However, especially, if the pursued objective is the minimisation of backtracking or maximisation of in-sequence, asymmetric flows will influence the objective value and the layout arrangement due to the determination of which flow movement, from i to j or from j to i, needs to be backtracked or moved forward. Wang and Sarker (2002) and Yu and Sarker (2003, 2006) all consider the concept of asymmetric flow matrices. In contrast, Samarghandi and Eshghi (2010) address the special case of identical flow movements between each machine pair (i, j) with cij
                               = c so the objective function is only composed of the machine distances. This case is used for generating initial feasible solutions.

As discussed in Section 3, in the discrete representation, it is assumed that all machines are equidistant, with the exception of the articles published by Yu and Sarker (2006) and Diponegoro and Sarker (2003b). They consider fixed, but unequal distances between locations and pick up a special case of discrete SRLP. Additionally, the latter allows asymmetric distances between locations. Since Heragu and Kusiak (1991) published their ABSMODEL, several authors have adopted it for modelling the continuous SRLP. Here, the distance between machines i and j is measured from a vertical reference line to the centroids of the machines (see, e.g., Balamurugan, 2012; Gomes de Alvarenga et al., 2000). Whereas most SRLP formulations are based on centre-to-centre distances where the centroid of the machine defines the input and output point (see, e.g., Amaral, 2008; Anjos & Vannelli, 2008; Hungerländer, 2014).

In some cases, the operational sequence of production necessitates that a machine needs to be located before another one in the single row. Djellab and Gourgand (2001) and Lin (2009) consider these precedence constraint, where the former add priority constraints in the construction heuristic in order to rank the machines. It is worth mentioning that precedence requirements can be enforced by adjusting the position variables, such as ζijk
                               in the MIP-model (formula (11)) by Amaral (2009) or Rij
                               in the SDP-model (formula (15)) by Anjos et al. (2005).

In the SRLP, one of the objectives consists of minimising the total material handling cost. In most cases, the costs of handling material from one machine to another are linearly proportional to the covered distance. We are aware of only three papers lifting this cost assumption by piecewise linear (see Chan & Malmborg, 2010a) and accordingly nonlinear transportation costs (see Chan & Malmborg, 2010b; Chan & Malmborg, 2013). However, Braglia et al. (2003) add assignment costs that are characteristic of the dynamic layout model formulations so far. Furthermore, aside from assignment cost, Ou-Yang and Utamima (2013) use a penalty term to make sure that safety constraints are maintained.

In the literature considered, we found different solution methods suggested to address the variety of SRLP formulations as stated in Section 3. Itemised by discrete and continuous problem representation, Fig. 7
                      shows the absolute division of the literature between 2000 and 2014 into exact, heuristic, meta-heuristic and other solution methods. By far, substantial interest is attracted in using meta-heuristics, followed by exact and heuristic approaches. Somewhat different methods, e.g. simulation and expert-systems, are almost neglected so far, notwithstanding in recent years a growing number of publications is observed.

The mathematical formulations mentioned in the previous sections can be solved to optimality, at least theoretically. The most obvious exact approach is the complete enumeration of all feasible solutions and choosing the one with the best objective value. In the context of SRLP, this would mean to evaluate n! solutions. For this reason, exact methods are computationally expensive and require high computational effort (cf. Kothari & Ghosh, 2012c). As a consequence, to date, exact approaches are only capable of arranging optimal single rows with up to 40 machines.

Supplementary to the classification of SRLP in Section 3, Hungerländer (2014) divides exact solution approaches by the type of variables used to formulate the problem. The author suggests four different types: Either (integer) distance variables modelling the distances between all pairs of machines or binary position variables describing the positions of machines. Furthermore, ordering variables or betweenness variables modelling the relative order between all pairs or triples of machines are used. In the context of SRLP, all publications reviewed tackling exact approaches are summarised and depicted in Table 5
                         by the type of variables, type of relaxation and the size of SRLP, which can either be solved to optimality or determine a lower bound.

Most of the authors simplify optimisation models by removing specific constraints so that the resulting relaxed problem can be solved optimally (see, e.g., Amaral & Letchford, 2013; Anjos et al., 2005; Anjos & Vannelli, 2008; Engau et al., 2012; Lee & Park, 2010). Usually one distinguishes between LP-based and SDP-based relaxations whereof linear programming models and matrix-based models are relaxed, respectively. Here, the feasible solution space increases. The optimal value of the relaxed problem is concurrent with an optimum of the original problem if it satisfies the relaxed constraint. Usually no satisfaction is obtained and therefore, in general, relaxations provide only a lower bound on the optimum of the original problem, cf. Anjos et al. (2005). Lately, research in the area of SDP-based single row layout models focuses on strengthening the relaxations, e.g. by adding valid inequalities, which seem to be very promising (see, e.g., Anjos & Yen, 2009; Hungerländer & Rendl, 2013a). A good coverage of SDP theory and algorithms as well as further applications is given in the handbook of Anjos and Lasserre (2012).

Other authors use Branch-and-Bound (see, e.g., Brusco, 2004; Nematian, 2014; Palubeckis, 2012) or mathematical programming (Brunese & Tanchocoa, 2013; Chaieb & Korbaa, 2003; Chung & Suh, 2014) as in traditional machine layout problems.

The most successful exact approaches are those of Amaral (2009) based on LP-relaxation and Hungerländer and Rendl (2013a) based on SDP-relaxation according to Amaral and Letchford (2013) and Anjos and Liers (2012).

The computational complexity of solving even small instances of SRLP exactly leads to the extensive research of heuristics and meta-heuristics although they do not guarantee an optimal solution (cf. Sönmez & Baray, 2013) or provide any estimation of the gap to optimality (see Hungerländer & Rendl, 2013a). But these procedures often provide a sufficiently good solution within acceptable computational time.

Heuristics are problem-oriented procedures that determine or improve solutions according to certain rules by exploiting the specific structure of the underlying problem. Typically, they are easier to implement than exact approaches (cf. Ozcelik, 2012).


                        Djellab and Gourgand (2001) proposed a very efficient two-stage heuristic. In contrast with previous published procedures, the heuristic exploits the current solution at each iteration. Its solutions either match the best-known solutions or surpass most of the other methods mentioned in SRLP literature. Single row layouts involving sets of identical machines are optimised by Kumar et al. (2011) and Diponegoro and Sarker (2003a). The latter introduce a two-stage heuristic in which the problem is first decomposed into several unique machine problems and afterward the corresponding flow assignment is obtained. Diponegoro and Sarker (2003b) use specific machine distance properties in their heuristic to find an efficient solution. Furthermore, Yu and Sarker (2003, 2006) address both the assignment of machine-cells on the floor area that is synonymous with the SRLP, since cells can be seen as machines. Regarding cellular manufacturing as well, Wang and Sarker (2002) determine an initial solution through a three-pair comparison heuristic where the Bubble Search technique improve the initial solution. For the first time, Kothari and Ghosh (2013a) introduced a Lin–Kernighan heuristic based on an insertion neigbourhood search. The variant of Kothari and Ghosh (2013a) is capable of improving best-known solutions of some problem instances. They state that it is suitable for large-size instances of the SRLP up to 110 machines.

In the following, we summarise meta-heuristics suggested in the SRLP literature, as shown in Table 6
                        . In contrast to heuristics, which are problem-dependent, meta-heuristics are generic procedures applicable to a broad range of optimisation problems. Generally, given at least one initial feasible layout, they iteratively achieve an improved solution based upon the efficient exploration of a predefined search space. While single solution based meta-heuristics such as simulated annealing (SA) and tabu search (TS) modify and improve only a single solution at a particular time, population-based approaches consider multiple solutions (population) combined to induce new solutions (cf. Kothari & Ghosh, 2014a). The last type includes genetic algorithm (GA), scatter search (SS), particle swarm (PSO) and ant (colony) optimisation (ACO), as well as new meta-heuristics such as estimation of distribution algorithm, clonal selection and bacterial foraging algorithm.

As depicted in Table 6, most researchers prefer genetic algorithms or hybridised variations to obtain near-optimal solution for SRLP irrespective of whether discrete or continuous representation is considered. In fact, 17 articles use this approach on which a wide range of publications state that genetic algorithms are used to find the near-optimal layouts consisting of a relatively small number of machines (see, e.g., El-Baz, 2004; Ficko & Balic, 2008; Lenin, Siva Kumar, Islam, & Ravindran, 2013; Lin, 2009; Ramkumar & Ponnambalam, 2004). Both Azadeh et al. (2013) and Balamurugan (2012) apply GA in conjunction with simulation to an uncertain environment, one by using fuzzy logic, and the other by stochastic approaches. Likewise, both cases only consider a small problem size of eight machines. Furthermore, GA are adopted for minimising backtracking (see Morad, 2000; Mohagheghi et al., 2009) or maximising in-sequence (see Ponnambalam & Ramkumar, 2001) who hybridise the used meta-heuristic with flow line analysis methods. For large scale problems of 80 and 110 machines, Datta et al. (2011), Kothari and Ghosh (2014a), and Ozcelik (2012) propose powerful algorithms, of which the last two have several features in common. While Datta et al. (2011) use four different methods to obtain an initial population and a self-designed crossover operator, the other two randomly generate initial solutions and apply different operators specially developed for permutation problems. Additionally, Ozcelik (2012) and Kothari and Ghosh (2014a) include local search operators in their heuristic to improve the fitness function.

Among the most frequently used meta-heuristics, tabu search is discussed by Gomes de Alvarenga et al. (2000), who introduced the first tabu search approach, by Palubeckis (2012), who connects it with a branch-and-bound algorithm, as well as Ou-Yang and Utamima (2013) using TS as a local search and Kothari and Ghosh (2012a) who integrated TS into a path-relinked heuristic. Although tabu search belongs to single solution-based meta-heuristics, Samarghandi and Eshghi (2010) developed a population-based variant where a set of initial solutions are not generated randomly, but by using the optimal solution of the specific SRLP with identical flow between all machine pairs (i, j), thereby, reducing the computational efforts. Kothari and Ghosh (2012a, 2013b) and Samarghandi and Eshghi (2010) were able to implement tabu search for large-scale SRLP, obtaining optimal and near-optimal layouts with 80 and 110 machines or improving the objective value for problems without known optima (cf. Samarghandi & Eshghi, 2010; Kothari & Ghosh, 2013b). Considering the special case of a limited number of duplicate machines, Lenin et al. (2014) describe a tabu search implementation for the multi-objective SRLP.

In the time period reviewed, we determine a decreasing interest in solving the SRLP by simulated annealing as only Gomes de Alvarenga et al. (2000), Chen et al. (2001), Ramkumar and Ponnambalam (2004), and Hosseini-Nasab and Emami (2012) treat this kind of meta-heuristic. This may be due to the fact that the performance of the algorithm, and thus the solution quality, is sensitive to the characteristic SA parameters, which must be chosen properly by the user (cf. Braglia, 1996). Nevertheless, the SA proposed by Gomes de Alvarenga et al. (2000) and the recently introduced SA connected with a clonal selection algorithm by Hosseini-Nasab and Emami (2012) both obtain the proven optimal solutions of well-known test problems and improve some of the best-known solutions so far.

Simulating the behaviour of organisms living in a swarm, the particle swarm optimisation algorithm has been adopted to a multitude of optimisation problems as the machine layout problem. In the context of single row layout design, different PSO algorithms were presented, e.g. by Samarghandi, Taabayan, and Jahantigh (2010) and Mohagheghi et al. (2009), some of them partially hybridised with other meta-heuristics (cf. Ou-Yang & Utamima, 2013; Teo & Ponnambalam, 2008). The algorithms are able to handle small and medium-sized problem instances with up to 9 or 30 machines.

Like PSO, ant colony optimisation uses the natural behaviour of living entities, in this case, ants foraging for food. Solimanpur et al. (2004, 2005) apply it to a linear machine arrangement formulated as a QAP in cellular manufacturing and the continuous SRLP. While in the conference proceedings of Chrysostomos and Vlachos (2005), Papadimitriou et al. (2006), and Mohagheghi et al. (2009) the ACO is introduced for minimising the backtracking distance in a discrete SRLP, Clauss et al. (2013) discuss a modified variant in order to arrange machines with minimal distances in a continuous floor area.

Another population-based meta-heuristic is scatter search, which was introduced by Glover (1977) for obtaining near-optimal solutions to integer programming problems. Recently, Kumar et al. (2008) picked it up and applied SS to SRLP for the first time. However, the major drawback of their algorithm is its limited capability of solving problem instances only up to 30 machines in the single row layout. We encounter only one further group of authors dealing with scatter search, for large size instances of 110 machines. Kothari and Ghosh (2014b) propose four different SS algorithms that outperform all other algorithms available in the single row layout literature and is recommended by the researchers for large scale SRLP. In the working paper Kothari and Ghosh (2012a), scatter search is hybridised with a path-relinked heuristic. The authors conclude that path relinking does not efficiently improve the solutions obtained using scatter search, see Kothari and Ghosh (2012a). This is the only publication addressing path-relinked heuristics, which may be an interesting future research area.

Analysing the SRLP literature, we found an increasing number of articles in the last years applying nontraditional optimisation approaches to SRLP. Inspired by nature, these rather new meta-heuristics imitate and transfer biological concepts such as the artificial immune system (AIS) (see Kumar et al., 2010), bacterial foraging (BFA) (see Ulutas, 2013), clonal selection (CSA) (see Hosseini-Nasab & Emami, 2012; Ulutas, 2013) and the behaviour of fireflies (see Sönmez & Baray, 2013) to the layout planning. Other novel directions include the imitation of imperialistic competition (ICA) (see Kunlei et al., 2011) or the use of estimated distribution algorithms (EDA) (see Ou-Yang & Utamima, 2013), which is a generalisation of genetic algorithms. Apart from the firefly algorithm, the performance of all other algorithms was tested using benchmark problems of different sizes. The respective authors declare that their approaches could obtain the proven optimal solutions or produce new better results to those with unknown optima. ICA, (hybrid) CSA and BFA seem to be suitable for large size SRLP with 80 machines (see Hosseini-Nasab & Emami, 2012; Kunlei et al., 2011; Ulutas, 2013).

As mentioned in Section 3, some authors apply simulation and knowledge-based expert-systems to SRLP alternatively to exact approaches and (meta-)heuristics (see, e.g., Azadeh et al. 2011, 2013, 2014; Balamurugan, 2012; Suo & Chi, 2013). Especially to deal with uncertain or rapidly changing manufacturing environments, as well as multi-criteria decisions, these kinds of methods seem to be established. Chan and Malmborg (2010a,b, 2013) propose Monte Carlo simulation methods for stochastic line layout problems that can be seen as SRLP. Their application empirically searches for (robust) layout solutions considering different input parameters like nonlinear movement cost, stochastic demand scenarios or uncertain work centre space requirements. Regarded as a computer program, expert-systems use the knowledge of human experts to solve the SRLP. Basically, input data from the user is analysed by different rules and finally an appropriate layout in conjunction with a transport system is suggested. In the last decade, Khan et al. (2011) is the only author who propose such a knowledge-based expert-system which assist in designing and selecting an appropriate layout and material handling system as well as analysing costs for a flexible manufacturing system. However, more and particularly user-optimised expert-systems are necessary to cope with the complexity of arranging machines and the interrelation to other problems affecting the system performance, e.g. the choice of a proper material handling system.

In this paper, we give a comprehensive overview of SRLP literature published in the last 14 years. Since the first paper by Simmons (1969), a steadily growing number of researchers address the single row layout problem. Indeed, more than half of the papers have been published since 2000.

After a brief introduction to the SRLP, we classified the rich variety of past literature and discussed general characteristics. Here, it is shown that many authors consider deterministic input parameters, though in practice demand values are typically predicted, e.g. based on experience, and thereby not fully known. A few authors consider fuzzy theory or stochastic approaches to include uncertainties faced by practitioners, and we believe that future research should clearly pursue and extend this stream of SRLP. As uncertainty is common in other facility layout problems, the used models and solution approaches may be adopted to the case of single row layouts. Another possible stream of future studies is the application of robust optimisation to SRLP. A robust layout may not be optimal for any particular scenario of uncertainty, but near-optimal for a wide range of scenarios (cf. Kouvelis, Chiang, & YU, 1995; Moslemipour et al., 2012; Yang & Peters, 1998).

In the same way, to the best of our knowledge, dynamic considerations are almost entirely neglected in the single row layout literature of the past 14 years, and therefore no categorisation related to this is conducted in Table 2. Merely, Braglia et al. (2003) include dynamic environments where a strategy has to be identified whether an agile or robust layout should be preferred. Chan and Malmborg (2010a,b) incorporate dynamic aspect by using the Monte Carlo simulation. Due to the lack of literature concerning dynamic single row layouts, this could be another future task.

In the next section of our review, we described selected model formulations for both discrete and continuous representation. Here, mixed-integer programming and semidefinite programming models are very promising. This section ends with a detailed summary of extensions of the basic single row layout models where clearances are of major interest, although in many articles, the importance of clearances is not incorporated sufficiently. On this account, the more practical consideration of asymmetric, machine sequence dependent clearances is apparently an interesting topic of further research.

As shown in the previous sections, only one paper address this specific case. It is worthy to examine whether the known solution methods such as meta-heuristics and exact approaches are applicable. Especially if the promising exact solution methods can be applied according to the assumed layout symmetry in the underlying single row layout models, which are no longer valid for this kind of clearance. Additionally, further benchmark instances including clearances, particularly asymmetric clearances, may be useful, as many researchers assume constant clearances during performance tests although their objective regards sequence dependent clearances. A brief overview of current results to benchmark instances is given in Kothari and Ghosh (2012c).

The last subject of our review comprised methods to solve the SRLP exactly or near-optimal where meta-heuristics are the most preferred approaches. In recent years, more and more new meta-heuristics like the imperialist competitive algorithm, firefly algorithm or clonal selection algorithms are applied to single row layouts. An extensive performance comparison between them and well-established meta-heuristics may be carried out, particularly using benchmark instances. As many publications has been revealed, future studies should continue to hybridise two or more meta-heuristics in order to achieve their benefits and to overcome their individual drawbacks. Considering exact approaches for SRLP, we expect that mainly tightening or generating novel LP- and SDP-relaxations will be of further research relevance. In general, it will be interesting to determine how an optimal solution can be obtained for larger problem sizes.

Additionally, to model the SRLP, almost all of the papers reviewed assume that the required material handling system has already been selected. However, in practice, the layout problem influences other design problems like material handling system, type of manufacturing, determination of resource capacities, etc. (cf. Drira et al., 2007; Hassan, 1994) and should therefore be considered jointly. Due to the complexity of a simultaneous solution, no approach has been proposed so far. Even though, Khan et al. (2011) suggest an expert-system that provides a solution to both layout arrangement and selection of material handling system, it is solved sequentially. Future studies may broaden their search for a simultaneous approach to other operational research areas such as game theory, as introduced by Navidi, Bashiri, and Messi Bidgoli (2012) for the general facility layout problem.

Lastly, it would be useful to determine further requirements from day-to-day practice in order to include them in SRLP on the premise that model solvability is still ensured.

In summary, with these future directions, the single row layout problem is still an interesting and worthwhile source for further researches.

@&#REFERENCES@&#

