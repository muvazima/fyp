@&#MAIN-TITLE@&#A resource-efficient multimedia encryption scheme for embedded video sensing system based on unmanned aircraft

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           By studying the resources constraints with their development trends in video sensing system, an information-utility-value-oriented multimedia encryption optimization model under resources constraints is given.


                        
                        
                           
                           A video-compression-independent speed-adjustable lightweight encryption scheme with its improved version based on the previously proposed model is given.


                        
                        
                           
                           A DSP and ARM based embedded secure video sensing system is designed, and the proposed encryption scheme has been implemented in it.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Video sensing

Multimedia big data

Video encryption

Generalized information security

Embedded system

@&#ABSTRACT@&#


               
               
                  Battery-powered unmanned aerial vehicle based video sensing system is more cost-saving and energy-saving than traditional aircraft based systems. However, high-volume real-time sensing data is more vulnerable in unmanned system than that in manned system. Meanwhile, the computation and energy resources in such system are very limited, which restricts the use of complex encryption process on video data. Therefore, how to achieve confidentiality of video data under limited resources efficiently needs to be addressed. Firstly, resources constraints with their development trends in video sensing system are studied. Secondly, an information-utility-value-oriented resource-efficient encryption optimization model under resources constraints is given. Thirdly, based on this model, a video-compression-independent speed-adjustable lightweight encryption scheme with its improved version is proposed. Fourthly, a DSP and ARM based embedded secure video sensing system is designed, and the proposed encryption scheme has been implemented in it. In addition, theoretical analyses based on information theory and experimental analyses on throughputs show that the proposed encryption schemes can meet the real-time requirements of system under the tight resources constraints.
               
            

@&#INTRODUCTION@&#

@&#BACKGROUND@&#

In recent years, applications of Internet of Things (IoT) have drawn wide attention from both academia and industry. Multimedia sensing is one of the important IoT applications (Atzori et al., 2010). Unmanned Aerial Vehicle (UAV) based video sensing system is a new class of multimedia sensing. The battery-powered unmanned system can largely reduce the operational risks and be more energy-saving than video sensing system based on traditional aircraft.

Nevertheless, the information technology has always been haunted by information security problem. And this problem is more serious in network times. Consequently, the IoT applications, which are based on network communication technology, inherit the security problem naturally. So the security issue becomes a central concern which may hamper the development of IOT technology and has attracted widespread attentions (Granjal et al., 2015; Almalkawi et al., 2010). As for UAV-based video sensing, since there is no pilot in the aerial vehicle, the aircraft is easily captured by attackers, which makes the airborne data more vulnerable. However, protecting real-time big multimedia sensing data needs complex encryption operation. For battery-powered sensor devices, when compared with general non-battery-powered IoT equipments, the limited computation and energy resources further restrict the protection of data security. Then these limitation make the security issue of multimedia data with resources constraints more troublesome (Ning and Liu, 2012; Chen et al., 2009; Min, 2014).

To solve the problem of high-volume multimedia data protection, optimized encryption schemes for audio/video data have been researched (Lian et al., 2009; Singh and Manimegalai, 2012). As to our application scenario, that is considering different steps of video compression where encryption process is introduced, those schemes could be generally divided into the following two classes.

The first class can be called partial encryption or selective encryption in general. The main idea of this class is taking advantage of the characters of compressed video, and using the traditional encryption algorithm to encrypt a selected crucial subset of the video data after or in a certain step of the video compression. Although the left data, except the selected crucial subset, is transmitted in plaintext and could be wiretapped by attackers, the missing selected subset makes attackers hard to rebuild a discernible video.

The first class can then be divided into two subclasses. In the first subclass, some typical algorithms only encrypt the I-frames of video (Maples and Spanos, 1995). In these algorithms about one third of the total data needs to be encrypted (Agi and Gong, 1996). Despite the P-frames and B-frames are transmitted in clear, and could be eavesdropped by attackers, it is very hard to rebuild a clear A/V without the I-frames.

Another subclass is designed based on the first subclass. This subclass is generally called joint compression encryption scheme (Singh and Manimegalai, 2012; Mallika and Sivakumar. 2014; Nidhi et al., 2014). Compared with the first one, the main idea of this subclass is applying the encryption in a certain processing step of the video compression algorithms, while dividing the encrypted subsets into smaller segments. For example, those schemes always encrypt DCT (Discrete Cosine Transform) coefficients, MV(Motion Vector) and other parameters in video encoding.

As to the first subclass, the experimental analysis given in (Agi and Gong, 1996) shows that without the crucial subset, using the scheme (Maples and Spanos, 1995) where only I-frames are encrypted as an example, attackers may also get a video with a decreased quality. That is because the unencrypted I-blocks in P-frames and B-frames can be decoded fully. Albeit these data lose commercial values after encrypted by such schemes, part of the video can be rebuilt and understood. So those schemes are not secure enough for some confidential applications. An improved scheme is proposed by Meyer and Gadegast (1995), where 4 levels of security are implemented. One important level is to encrypt all the I-frames and I-blocks in both P and B frames. Such scheme increases the security of the encrypted data, but lowers the encryption speed and information leakage still cannot be totally avoid (Agi and Gong, 1996).

Compared to the first subclass of schemes, the second subclass schemes are faster. However, since the encryption rate is relatively small, their security is comparatively low (Lian et al., 2009; L. Qiao and Nahrstedt, 1998, 1997). To be specific, as to the security requirement of application discussed in this paper, just by lowering the qualities of the videos to protect the commercial value of data is not secure enough. Because the information such as contours and movements of the main objects of the videos are all needed to be protected. Under this circumstance, the first class is hard to be qualified. In addition, since those schemes need to combine with video compression processes, as to modularized video capture devices whose video compressions have already been implemented in hardwares, joint compression schemes are hard to integrate with such devices.

Although the joint compression encryption schemes have some security problems, as they have a high encryption speed, they are convenient to be used in commercial or recreational applications to protect the data by reducing the qualities of videos.

The second class is developed from traditional full encryptions, which is commonly called improved full encryption. The scheme presented by Qiao and Nahrstedt (1997) is a representative one. It is a simplified full encryption which is similar to each iterative operation of DES encryption algorithm. In one iterative step of DES algorithm, 64bit input plaintext is divided into two parts: 32bit L
                        
                           i−1 and 32bit R
                        
                           i−1, and let output L
                        
                           i
                        =R
                        
                           i−1 and R
                        
                           i
                        =L
                        
                           i−1⊕F(R
                        
                           i−1, K
                        
                           i
                        ), where F is a permutation function, and K
                        
                           i
                         is a key.


                        Qiao and Nahrstedt (1997) firstly analyzed the statistical character of compressed video data. The analysis results show that the data have high randomness at the byte level because of the use of variable-length Huffman codes and other processes in the video compression. Based on this statistical character of compressed video, Video Encryption Algorithm (VEA) is proposed. The main idea of VEA scheme is as follows: (1) divides the plaintext block into 2 subblocks: Even and Odd parts, (2) encrypts the Odd part with a standard encryption algorithm E to get a half of the ciphertext E(Odd), (3) exclusive-OR-eds (⊕ or Xor) Even and Odd parts to get another half C, where C=Odd ⊕Even. Therefore, the final ciphertext is the integration of C and E(Odd). This mechanism can reduce the encryption complexity to 53% of that of the used standard full encryption algorithm E, and achieve a sufficient security level. Tosun and Feng (2000) further extended this scheme. They bisected the odd parts, and only encrypt one fourth of the plaintext. This scheme reduced the encryption complexity to about one fourth of standard full encryption algorithm E.

Compared with the first class, such schemes can encrypt all kinds of compressed data. However, since its encryption rate is fixed, the improvements of encryption speeds of these schemes are limited.

The two previous classes of optimized encryption schemes always focus on the real-time character rather than the optimization of the use of limited resources (Lian et al., 2009; Liu and Koenig, 2014; Liu and Koenig, 2010). Besides, Massoudi et al. (2008) points out that those schemes use static encryption parameters and rates of encrypted parts. Such designs make the throughputs of those schemes could not adjust dynamically to meet the fluctuated throughputs of media data in real-time systems.

In addition, few schemes are video-compression-independent, and each of those schemes focuses on one or a few specific video compression standards. Above reasons limit their use in video sensing systems with resources constraints, in which bandwidth of video data fluctuates dramatically (Liu and Koenig, 2014; Heer et al., 2011; Hu and Chen, 2012). A resource-efficient, video-compression-independent, throughput-adjustable encryption scheme which can achieve an acceptable video security under tight resources constraints is sorely expected.

Then we analyze the security of multimedia encryption schemes based on Shannon information theory (Shannon and Weaver, 1949; Weaver, 1949; Guiasu, 1977). The variables we used are shown as following: (1) a random multimedia object is denoted as M; (2) traditional Shannon entropy is denoted as H(M); (3) conditional entropy, which is the uncertainty of M under the condition of known Z, is denoted as H(M|Z); (4) mutual information, which is the amount of information about information source X after Y is known, is denoted as I(X;Y). As to generalized information, (5) generalized information entropy of multimedia event M is denoted as H
                        ⁎(M); (6) generalized information conditional entropy is denoted as H
                        ⁎(M|Z); (7) generalized mutual information is denoted as I
                        ⁎(X;Y). Let FE
                        
                           i
                        (M) be the encryption output after M is encrypted by full encryption algorithm FE
                        
                           i
                        . According to classical information theory, we can get H(M|FE
                        
                           i
                        (M))=H(M), and then I(X;Y)=H(M)–H(M|FE
                        
                           i
                        (M))=0.

Very few researches discuss the theoretical security of multimedia encryptions. As far as we know only (Gibson et al., 2004) analyses the security of its selective encryption of scalable speech coding based on Shannon theory. They use X
                        ^ to indicate core layer information, and use X
                        ^
                        2 to indicate enhancement layer information. Then the uncertainty of X^ given X^
                        2 can be denoted as H(X
                        ^|X
                        ^
                        2). They draw the conclusion that H(X
                        ^|X
                        ^
                        2)=H(X
                        ^), or equivalently, mutual information I(X
                        ^:X
                        ^
                        2)=H(X
                        ^|X
                        ^
                        2)–H(X
                        ^)=0. Thus they hold that even though the enhancement layer is sent in-the-clear, the eavesdropper gains no advantages.

The problem of the analysis is that whether the plaintext subset X
                        ^
                        2 contains no information about X
                        ^ that would be encrypted, namely whether I(X
                        ^: X
                        ^
                        2)=0, is not important. Nonetheless, the most important issue is whether unencrypted X
                        ^
                        2 contains information of the video which needs protection, i.e. whether I
                        ⁎(M; X
                        ^
                        2)=H(M)–H(M|X
                        ^
                        2) equals to 0 is very important. For example, as to the typical selective encryption scheme, I-frames in the video are encrypted, but P-frames and B-frames are not encrypted. Even P and B-frames (considered as X
                        ^
                        2) do not contain the information of I-frames (considered as X
                        ^), i.e. I(X
                        ^: X
                        ^
                        2)=0, P and B-frames do have a large amount of information of video. (Agi and Gong, 1996) analyzed and attacked the videos encrypted by scheme (Maples and Spanos, 1995), and gave images of some decompressed frames. As shown in the images of their paper, contours of the main objects of videos could be rebuilt and be understood by attackers. As to confidential applications rather than commercial ones, contours and movements of the main objects actually have a higher value to attackers.

In selective or partial encryption, the most ideal solution is to find an independent data subset (X
                        ^
                        2) that contains few information of the video (i.e. I
                        ⁎(M; X
                        ^
                        2) would be close to 0,) and can be transmitted in plaintext. But it is almost impossible for most multimedia compression standards to get the ideal solution. However, even such subset X
                        ^
                        2 can be found, if the data volume is not big enough, i.e. the encrypted part M-X
                        ^
                        2 is not small enough, the improvement of the encryption speed is limited. On the other side, if we wish that M-X
                        ^
                        2 is small enough, encryption must be engaged during compression process to encrypt some subsets of data, which will lead to non-universality of encryption schemes. So there will be a tradeoff between high speed and video-compression-independent.

Compared with the first class of schemes, the improved full encryption does not have data which is sent in clear. Our proposed scheme also belongs to this class. Its security will be discussed in Section 4.4.

In this paper, we firstly analyze the application scenario and the variation trends of encryption resources constraints, then put forward a encryption optimization model, based on which we also proposed an encryption scheme aiming at the application mentioned before. Moreover, the efficiency of the proposed scheme is analyzed in the embedded prototype system we constructed.

Application scenario considered in this paper is a video sensing system based on a battery-powered multi-rotor Unmanned Aerial Vehicle (UAV) we designed, which is shown in 
                        Fig. 1 Since there are security requirements in this video system, the sensing data should be stored confidentially to avoid being wiretapped. In addition, an extended function in this system is sending snapshots of video to remote controller in wireless channel. This snapshot data should also be sent confidentially.

Protecting the security of aforementioned data involves complicated data encryption operations. To analyze the throughput of traditional encryption schemes, 3DES algorithm programed in C++ is tested in the embedded prototype system implemented in Section 5. Without any other heavy-load processes, its throughput is about 8Mbps, which could not undertake the real-time task that encrypting only one stream of higher-quality video data (e.g. 1080p video with a code rate of 10Mbps).

As to battery-powered equipments, the resources constraints which limit the data protection include not only computation but also energy resources. However, the growth of data volume overwhelms the growth of encryption resources, and this problem is non-convergent. That is because, firstly, the growth of encryption throughput is highly correlated with the growth of the CPU speed. Even if Moore׳s Law is not failed, the performance of chips continually doubles every 18 months, or grows about 60 percent per year. Comparatively, the disk density doubles every year (Gray and Patterson, 2003), which overwhelms the increase of computer performance. Secondly, the data volume of multimedia data, the image process ability and the bandwidth of core network grow even faster than disk densities. In addition, the computation and encryption capabilities of battery-powered equipments are also constrained by battery capacity. And the battery capacity grows more slowly. A conclusion could be drawn that the resources constraints will continue to affect the data security of multimedia sensing systems adversely, and this problem will not converge. Therefore, a resource-efficient model for data encryption optimization is very necessary.

Optimization of resources distribution should take video data characters into consideration. When the data encryption process has no time limitation and the encryption resource is adequate enough, like protecting text data in usual systems, traditional full encryption schemes are appropriate. In this case, the full encryption allocated the sufficient encryption resource into all symbols in the plaintext averagely, where distribution of information value is relatively even, and can provide unconditional security (Norman and Landgrave, 1997). However, the distribution of information value in compressed multimedia data is not evenly distributed. In addition, the same video in different application scenarios has different values. Moreover, as to video sensing, encryption resources are insufficient in long terms, as discussed in Section 2. Hence, unconditional security is impossible, and the traditional full encryption schemes are unsuitable and wasteful.

However, previous studies on multimedia encryption schemes always focused on the real-time issue, and the encryption cost of energy and other resources are relatively disregarded. In addition, few studies offer a formalized encryption optimization model under a consideration of resource efficiency.

In this section, firstly, a formalized model for analyzing the security of generalized information for multimedia data is constructed; secondly, the impacts of encryption optimization on attacker׳s behavior are discussed; thirdly, an information-utility-value-oriented encryption optimization model for multimedia data is proposed.

We firstly analyze the security of multimedia data based on generalized information. Due to the characteristic of multimedia compression coding, the length of compressed data is positively correlated to the complexity of original multimedia information. There could be some valuable information beyond all the bits of the original information. For example, in some sensitive applications, the complexity of original multimedia data reflected by the length of compressed data can also expose some multimedia pragmatic information to attackers. However, there is no such problem for original uncompressed video. That is because the original video data with same time lengths have same volumes

As to generalized information of video mentioned above, their security sometimes could not be protected by traditional encryption schemes. According to the concept of generalized information given in Section 1, there could be generalized mutual information beyond all the bits of the original information, the generalized mutual information of FE
                        
                           i
                        (M) and M, denoted as I
                        ⁎(M;FE
                        
                           i
                        (M)) is greater than 0. Therefore, using traditional encryption schemes is not a sufficient condition for generalized information security of multimedia data. As to the example given above, some tail filling schemes could be used to protect the information of the complexity of the videos, which can be gotten from the length of the compressed video.

Meanwhile, previous studies on multimedia encryption (Liu and Koenig, 2014; Lian et al., 2009) point out that some encryption schemes could achieve an acceptable security level by encrypting some selected crucial subsets of the video data.

Let MES
                        
                           i
                         denote a selected multimedia encryption scheme, then MES
                        
                           i
                        (M) is the ciphertext, or in other words, encryption output of multimedia data M encrypted by MES
                        
                           i
                        .


                        Let us assume that MES
                        
                           i
                         has a constant encryption ratio Rate (MES
                        
                           i
                        ), where function Rate() represents the ratio between the encryption resources cost of MES
                        
                           i
                         and full encryption. Thus, we can get the following expression:
                           
                              (1)
                              
                                 ∃
                                 M
                                 E
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       I
                                    
                                    ⁎
                                 
                                 (
                                 M
                                 ;
                                 M
                                 E
                                 S
                                 i
                                 
                                    (
                                    M
                                    )
                                 
                                 )
                                 /
                                 
                                    
                                       H
                                    
                                    ⁎
                                 
                                 
                                    (
                                    M
                                    )
                                 
                                 <
                                 1
                                 −
                                 R
                                 a
                                 t
                                 e
                                 
                                    (
                                    
                                       M
                                       E
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 )
                                 .
                              
                           
                        
                     

Therefore, full encryption is neither a necessary nor a sufficient condition for generalized information security of multimedia data. It is necessary to build a formalized model to discuss the costs and benefits of multimedia encryption processes.


                        Guiasu (1977) is an earlier literature putting forward the concept of utility value of information. Zhong (1998) suggests that utility value and pragmatic of information have a similar implication. Furthermore, we believe the utility value of data is related with application scenarios. We use v(M, Scenario) to show the utility value of multimedia data M in a specific application scenario which is denoted as Scenario.

We use valueLeak (M, MES
                        
                           i
                        , Scenario, Cost) to denote the maximum utility value of information that could be stolen from MES
                        
                           i
                        (M) by an attacker with total resources cost Cost. Here MES
                        
                           i
                        (M) is the ciphertext of M encrypted by MES
                        
                           i
                        . The costs spent by attacker include the time, money, computational resources, electric energy of unplugged equipments and other limited resources. According to the definition of generalized mutual information, we have valueLeak (M,MES
                        
                           i
                        , Scenario, Cost)<=I
                        ⁎(M;MES
                        
                           i
                        (M)).

As for those legitimate users who have the key of MES
                        
                           i
                        , they need just the normal decryption cost DecryptionCost to get the original multimedia data M. At this time, valueLeak (M, MES
                        
                           i
                        , “UserHaveKey”, DecryptionCost)=v(M, Scenario). As for those attackers who have unlimited resources, valueLeak (M, MES
                        
                           i
                        , Attacker,∞)=v(I
                        
                           ⁎
                        (M; MES
                        
                           i
                         (M)), Scenario).

If we focus on the relationship of function value valueLeak() and costs of attackers Cost in a given condition where the type of multimedia data M, multimedia encryption scheme MES
                        
                           i
                        , and Scenario are fixed, we can regard the leaked value as a unary function of Cost: valueLeak
                        
                           ⁎
                        
                        
                           MESi
                        (Cost), where valueLeak
                        
                           ⁎
                        
                        
                           MESi
                        (Cost)=valueLeak (M,MES
                        
                           i
                        , Scenarios, Cost). And the function satisfies following properties:
                           
                              (2)
                              
                                 0
                                 ≤
                                 v
                                 a
                                 l
                                 u
                                 e
                                 L
                                 e
                                 a
                                 
                                    
                                       
                                          k
                                       
                                       ⁎
                                    
                                    
                                       M
                                       E
                                       S
                                       i
                                    
                                 
                                 
                                    (
                                    
                                       C
                                       o
                                       s
                                       t
                                    
                                    )
                                 
                                 ≤
                                 v
                                 
                                    (
                                    
                                       M
                                       ,
                                       S
                                       c
                                       e
                                       n
                                       a
                                       r
                                       i
                                       o
                                       s
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

And first derivative of function should satisfy the following expression:
                           
                              (3)
                              
                                 v
                                 a
                                 l
                                 u
                                 e
                                 L
                                 e
                                 a
                                 
                                    
                                       
                                          k
                                       
                                       ⁎
                                    
                                    
                                       M
                                       E
                                       S
                                       i
                                       ′
                                    
                                 
                                 
                                    (
                                    
                                       C
                                       o
                                       s
                                       t
                                    
                                    )
                                 
                                 ≥
                                 0
                                 .
                              
                           
                        
                     

Since the costs that attackers are willing to spend in different application scenarios are dramatically different, in the following analysis, behaviors of attackers are discussed under two application scenarios: (1) commercial or entertainment applications and (2) confidential applications.

In commercial application, requirement for data security is always Conditional Computational Security (CCS) (Norman and Landgrave, 1997). CCS requires that the costs of attackers should be greater than the value of information they can steal.

On the contrary, as for attackers, they wish the value of information they stole to be larger than their costs. In general, if a commercial system satisfies CCS, the higher costs may prevent attackers׳ attacks. So the constrain expression of the attackers could be expressed as follows:
                              
                                 (4)
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   V
                                                   =
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   L
                                                   e
                                                   a
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         ⁎
                                                      
                                                      
                                                         M
                                                         E
                                                         S
                                                         i
                                                      
                                                   
                                                   
                                                      (
                                                      
                                                         C
                                                         o
                                                         s
                                                         t
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   V
                                                   ≥
                                                   C
                                                   o
                                                   s
                                                   t
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

As is shown in 
                           Fig. 2(a), the vertical axis represents the utility value of multimedia information, the horizontal axis represents the resources cost of attackers. The red straight line represents the V=Cost, and the area of region shaded with red vertical lines on the upper left indicates the feasible region where the constraint of V≥Cost is satisfied.

Let us assume that the blue curve represents the function of valueLeak
                           
                              ⁎
                           
                           
                              MESi
                           (Cost), and the region shaded with horizontal lines on the lower right part denotes the probable profits could be obtained by attackers. Hence, in Fig. 2(a), only the overlap region colored with green satisfies the constraint in expression Eq. (4). Point e is the intersection point of straight line and curve mentioned above. Ordinate of e is the maximum utility value could be obtained by attackers.

According to the application scenarios and resources constraints, multimedia system designers should improve the encryption scheme to minimize the utility value of information gained by attackers.

As is shown in Fig. 2(b), with the improvement of encryption scheme, the blue curve will move closer to horizontal axis. Then the intersection point of the blue curve and the red straight line will move from e
                           1 to e
                           2, then e
                           3, and attackers will get less information, which may make the attackers give up attacking. For example, when intersection point e
                           3 overlaps with the origin point, attackers will not get utility value of multimedia data larger than their costs.

Compared with it of commercial applications, value of multimedia information in confidential applications might be higher. Consequently, attackers may even put forth their best effort to attack without considering resource costs. In this occasion, we wish a higher security level Computational Security (CS) (Norman and Landgrave, 1997) could be satisfied. Compared with CCS, CS requires that the system could not be broken by attackers in an acceptable time with all best resources available. However, since resources in battery-powered embedded systems are limited, CS is too expensive to be achieved. A compromised scheme is to minimize the utility value of information which could be stolen by attackers.

We can treat CS as CCS with unlimited value of data. In this case, attackers will cost maximum probable resources, denoted as Cost
                           
                              ⁎
                           , to attack the system. And the new constrain expression of the attackers could be expressed as follows:
                              
                                 (5)
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   V
                                                   =
                                                   v
                                                   a
                                                   l
                                                   u
                                                   e
                                                   L
                                                   e
                                                   a
                                                   k
                                                   
                                                      (
                                                      
                                                         M
                                                         ,
                                                         M
                                                         E
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ,
                                                         S
                                                         c
                                                         e
                                                         n
                                                         a
                                                         r
                                                         i
                                                         o
                                                         s
                                                         ,
                                                         C
                                                         o
                                                         s
                                                         t
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   C
                                                   o
                                                   s
                                                   t
                                                   ≤
                                                   C
                                                   o
                                                   s
                                                   
                                                      
                                                         t
                                                      
                                                      ⁎
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

As is shown in Fig. 2(c), the region shaded with red vertical lines on the left indicates the feasible region where the constraint that Cost≤Cost
                           
                              ⁎
                            is satisfied. And the region shaded with blue horizontal lines on the lower right part denotes the feasible profits which could be obtained by attackers. The overlap region colored with green satisfies the constraint in expression Eq. (5). Ordinate of intersection point e is the maximum utility value could be obtained by attackers.

Like that in Fig. 2(b), with the improvement of encryption scheme, the blue curve in Fig. 2(c) will also move closer to horizontal axis. Then the intersection point will move from e
                           1 to e
                           2, then e
                           3, and attackers will get less information. In the most optimistic case, the blue curve could overlap with the horizontal axis, and attackers will not get any utility value.

It can be seen that improvements of the encryption schemes can prevent attackers׳ attacks. But improvements are always achieved at the cost of computation and energy resources. So a resources-effective encryption optimization model is very necessary.

In this subsection, an Information-utility-value-oriented Encryption Optimization (IEO) model is proposed. The optimization principle of this model is to select appropriate subset of data and encryption schemes to minimize the utility value which could be stolen by attackers, under both the real-time constraint and limited resources constraints of application. We use the following optimization expression to construct the optimization model:
                           
                              (6)
                              
                                 {
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                .
                                                v
                                                a
                                                l
                                                u
                                                e
                                                L
                                                e
                                                a
                                                k
                                                (
                                                M
                                                ,
                                                M
                                                E
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                S
                                                c
                                                e
                                                n
                                                a
                                                r
                                                i
                                                o
                                                ,
                                                C
                                                a
                                                s
                                                
                                                   
                                                      t
                                                   
                                                   ⁎
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                s
                                                .
                                                t
                                                .
                                                
                                                   (
                                                   1
                                                   )
                                                
                                                real
                                                −
                                                time
                                                
                                                constraint
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   (
                                                   2
                                                   )
                                                
                                                limited
                                                
                                                resources
                                                
                                                constraints
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The decision variable of the above optimization model is MES
                        
                           i
                        . In this model, M could be a set of target multimedia data, and MES
                        
                           i
                         could be a set of corresponding multimedia encryption schemes. When M is a single stream of data, MES
                        
                           i
                         means a specific multimedia encryption scheme. Comparatively, when M includes several streams of data, MES
                        
                           i
                         means a whole optimization plan including the selection of encryption algorithms and selection of streams to be encrypted.

It should determine the optimum encryption algorithm for each stream in the system, and let the used encryption resources be concentrated on the streams with higher security weightiness. In addition, application scenario Scenario also needs to be considered in the optimization.

According to the IEO model given in Section 3, optimization of encryption scheme should firstly take application scenario into consideration. In addition, information utility value got by attackers should be minimized under the resources constraints.

Therefore, under the application environment of our research, the following requirements should be taken into full account in the encryption scheme we study.
                           
                              1)
                              Although the camera used in the prototype system only has a resolution of 1280⁎720. With the increasingly extensive usage of 4K (4096⁎2160) pixels camera and multi-camera, the volume of big video sensing data grows very fast. At the meantime, because the embedded video system and the aerial vehicle share the limited battery, the discrepancy between the massive video data and the limited resources is very serious, and the encryption scheme should be designed as light as possible.

When sensing system is applied in some sensitive scenario, there might be some puissant attackers who will make analytical attacks on the data. Simple partial encryption algorithms would probably make part of the video information leaked (Agi and Gong, 1996). Then attackers might get important information from the unencrypted part and rebuild a discernible video with decreased quality. In this time, valueLeak (M, MES
                                 
                                    i
                                 , Scene, Cast⁎
                                 ) is significant. Then the security requirements of the sensitive system could not be met. Therefore, the encryption scheme should have the ability to defense some analytical attacks.

The throughput of existing encryption schemes cannot adjust dynamically (Massoudi et al., 2008). As to video sensing system, the bandwidth fluctuation of real-time video is significant. Hence, the throughputs of the encryption scheme need to be adjustable.

The existing encryption schemes are always connected with specific video encoding algorithm, and are lack of universality. As to our embedded system, video encoding module and video encryption module work independently. Thus, universal video encryption scheme will enhance the scalability of system.

Since that in multimedia compression and coding, the variable-length Huffman coding and other coding processes remove the redundant information from the original datagram, statistical character of compressed multimedia data is dramatically different from that of text data. Statistical analysis shows that coded data has high randomness at the byte level (Qiao and Nahrstedt, 1997). Based on this statistical character of media data, we use traditional block cipher to encrypt a block of data, and use its plaintext as stream cipher key to encrypt the following l blocks. By changing the parameter l, the speed of the encryption scheme can be adjusted. The statistical property of encoded multimedia data makes analytical attacks difficult to be effective. Therefore, if the attackers cannot break the full encryption algorithm FE that used in this scheme, they are unable to get any information from the video. This method utilizes small resources and acquires a higher security assurance.

The encryption scheme is shown in Procedure 1. In the scheme, firstly, plaintext is divided into blocks with a same length BlcLength. Secondly, we use a traditional block cipher, full encryption FE, to encrypt one block. Thirdly, as to the next l blocks, we use the plaintext of the previous block as its stream cipher key.
                           
                              
                                 
                                 
                                    
                                       
                                          Procedure 2 
                                          
                                             Package-oriented SAFE scheme
                                          
                                       
                                    
                                    
                                       Procedure SAFE
                                    
                                    
                                       
                                          1. Divide plaintext into blocks with a length of BlcLength
                                       
                                    
                                    
                                       Repeat
                                    
                                    
                                       
                                          2. Use FE to encrypt the first block in the buffer.
                                    
                                    
                                       
                                          3. For i:=1 to l do
                                    
                                    
                                       
                                          
                                          Let next l block׳s ciphertext CipherBlc
                                          
                                             j
                                          =Blc
                                          
                                             j−1⊕Blc
                                          
                                             j
                                          .
                                    
                                    
                                       
                                          Until get the last block.
                                    
                                    
                                       
                                          4. For the last block, encrypt it using FE.
                                    
                                 
                              
                           
                        
                     

This algorithm is designed for file data. To avoid the attackers from guessing the file header, the first n blocks could be full encrypted, where n could be calculated from the session key. In addition, although the probability of a block guessed by attackers is very low, permutation could be used before the division in step 1. Parameter l in step 3 is the speed control parameter. By controlling the parameter l, the encryption throughput could be adjusted. And the parameter l can be determined dynamically according to current data volume in the buffer.

For file encryption, parameter l should be properly saved either by saving in a separate file or saving as an encryption flag EF, which records whether it have been full encrypted, in the header of each block. The decryption process can determine the decryption way according to this flag. If EF is true, the plaintext equals to FE
                        −1(CipherBlc
                        j), else equals to. PlainText
                        
                           j-1⊕Cipher
                        
                           j
                        .

In the prototype system, we can estimate data volume based on the video resolution and the target bit rate, and then choose parameter l. Meanwhile, when the fullness degree of the buffer is higher than a certain threshold value, encrypted parameter l could be doubled transiently.

The former encryption scheme is designed for encrypting continuous data and is suitable for multimedia file encryption. However, as for wireless transmission module, this scheme cannot solve the problems of bit error and packet loss. Moreover, data is packed according to the RTP protocol. Therefore, a packet-based algorithm can achieve higher efficiency. A package-oriented scheme (POSAFE) is shown in Procedure 2.
                           
                              
                                 
                                 
                                    
                                       
                                          Procedure 1 
                                          
                                             Basic SAFE scheme
                                          
                                       
                                    
                                    
                                       Procedure SAFE
                                    
                                    
                                       
                                          1. Divide plaintext into blocks with a length of BlcLength
                                       
                                    
                                    
                                       
                                          Repeat
                                    
                                    
                                       
                                          
                                          2. Use FE to encrypt the first block in the buffer.
                                    
                                    
                                       
                                          
                                          3. For i:=1 to l do
                                    
                                    
                                       
                                          
                                          Let next l block׳s ciphertext CipherBlc
                                          
                                             j
                                          =Blc
                                          
                                             j−1⊕Blc
                                          
                                             j
                                          .
                                    
                                    
                                       
                                          Until getting the last block.
                                    
                                    
                                       
                                          4. For the last block, encrypt it using FE.
                                    
                                 
                              
                           
                        
                     

Because adjacent packets could have different lengths, the XOR operator in Step 2 is implemented as expression Eq. (7), where PlainByte
                        
                           i
                        
                        
                           k
                         is byte k of packet i, CipherByte
                        
                           i
                        
                        
                           k
                         is its ciphertext, and PL
                        
                           i
                         is the length of packet i. In other word, the former packet will be duplicated at the rear of itself if it is shorter than the current packet. In addition, the encryption flag of each RTP payload could be saved in the RTP header.
                           
                              (7)
                              
                                 C
                                 i
                                 p
                                 h
                                 e
                                 r
                                 B
                                 y
                                 t
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   P
                                                   l
                                                   a
                                                   i
                                                   n
                                                   B
                                                   y
                                                   t
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   ⊕
                                                   P
                                                   l
                                                   a
                                                   i
                                                   n
                                                   B
                                                   y
                                                   t
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                      
                                                         k
                                                         
                                                         Mod
                                                         
                                                         P
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               i
                                                               −
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   P
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   >
                                                   P
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   P
                                                   l
                                                   a
                                                   i
                                                   n
                                                   B
                                                   y
                                                   t
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         i
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   ⊕
                                                   P
                                                   l
                                                   a
                                                   i
                                                   n
                                                   B
                                                   y
                                                   t
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   P
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ≤
                                                   P
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         i
                                                         −
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In order to analyze the throughputs of SAFE with different values of parameter l, simulation program is designed in C++. The test platform is Intel Core i7 2.1GHz quad-cores. The full encryption algorithm FE in the test is DES algorithm with EBC mode.

Experimental results shown in 
                        Table 1. are the throughputs of SAFE when the CPU has difficult loads. The throughput is measured in MBps. Row 1 (load 1) gives the result of SAFE without any other heavy load competitor processes. Row 2 (load 2) gives the results, where a process with 75MBps on average disk transmission is added based on load 1. In row 3 (load 3), another process which has heavy load is added based on load 1. Besides, l=0 SAFE algorithm is equal to full encryption, and l=1 SAFE is equal to VEA (Qiao and Nahrstedt, 1997).


                        
                        Figure 3 shows the increasing trends of the throughput of encryption scheme SAFE with different loads. When parameter l is small, the speed of SAFE almost grows linearly. But when l is very large, limited by the speed of XOR operation, the throughputs of SAFE converge to 11GBps and 5.9GBps respectively.

By comparing the three different load series, we have known that other computation intensive process in system will compete computation resources with SAFE and impact the throughput of SAFE a lot. Contrarily, the I/O intensive process would not impact the SAFE a lot. Because the main tasks of control module of our embedded system are data encryption and storing, and the load factor may not be essential.

We also test the proposed schemes in the embedded prototype system implemented in Section 5. The result shows that the throughput of SAFE in that system could achieve approximately 15% of that mentioned in Table 1. If further optimizations on the software and hardware are accomplished, a better efficiency shall be achieved.

To analyze the theoretical security of SAFE, we considering the blocks from Blc
                        
                           i
                         to Blc
                        
                           i+l
                         in SAFE, based on Shannon theory, the attack difficulty of ciphertext-only attack is H(KP|C), where K is the key of encryption algorithm F, C is the ciphertext of plaintext P, Cphr
                        
                           i
                         is the corresponding ciphertext of Blc
                        
                           i
                        , and H is the conditional entropy function. We get
                           
                              (8)
                              
                                 H
                                 
                                    (
                                    
                                       K
                                       P
                                       |
                                       C
                                    
                                    )
                                 
                                 =
                                 H
                                 
                                    (
                                    
                                       K
                                       B
                                       l
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                       B
                                       l
                                       
                                          
                                             c
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       …
                                       B
                                       l
                                       
                                          
                                             c
                                          
                                          
                                             i
                                             +
                                             l
                                          
                                       
                                       |
                                       C
                                       p
                                       h
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                       C
                                       p
                                       h
                                       
                                          
                                             r
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       …
                                       C
                                       p
                                       h
                                       
                                          
                                             r
                                          
                                          
                                             i
                                             +
                                             l
                                          
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

Since the previous block is used as the stream cipher key of the current block, the security of the current block depends on the previous one. Finally, security of blocks from Blc
                        
                           i+1 to Blc
                        
                           i+l
                         depends directly or indirectly on Blc
                        
                           i
                        , whose security depends on the theoretical secrecy of algorithm F. Thus, the ciphertext-only attack of SAFE has an attack difficulty of
                           
                              (9)
                              
                                 H
                                 
                                    (
                                    
                                       K
                                       P
                                       |
                                       C
                                    
                                    )
                                 
                                 <
                                 =
                                 H
                                 
                                    (
                                    
                                       K
                                       B
                                       l
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       C
                                       p
                                       h
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

Only when adjacent blocks are unrelated with each other, do we have
                           
                              (10)
                              
                                 H
                                 
                                    (
                                    
                                       K
                                       P
                                       |
                                       C
                                    
                                    )
                                 
                                 =
                                 H
                                 
                                    (
                                    
                                       K
                                       B
                                       l
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       C
                                       p
                                       h
                                       
                                          
                                             r
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

Statistical analysis of compressed video stream shows that the video data has high randomness at the byte level. Thus, the security of SAFE may be equivalent to the security of the full encryption FE, which is used to encrypt the Blc
                        
                           i
                        .

An embedded video processing system based on DSP and ARM9 is designed, and the encryption scheme proposed in Section 4 is implemented. The hardware platform can be divided into three modules, and the system structure is shown in 
                        Fig. 4. It includes video sensing module, data processing module and control module.

The video sensing module consists of capture module, A/D, FPGA and FIFO. When control commands are given by CPLD at runtime, FPGA will parse the command words and process the captured data according to the user request patterns. Then FPGA can capture video signals and store them into FIFO in a given format, and inform data processing module by an interrupt signal. Then the DSP with EDMA transmit the data periodically into the buffer in DRAM.

The data processing module consists of DSP, DRAM and FLASH memory. TMS320C6455 DSP is used to perform data processing. It has a frequency of 1GHz, 2MB RAM and 8 parallel processing units. All the intermediate data of reference frames and reconstructed frames are put into the outer temporary buffer in a 64MByte DRAM. An 8MB flash memory is used to save the bootloader program. In this module, H.264/AVC compression standard is adopted. At runtime, data processing module can read video data from the capture module, process them with specified H.264/AVC encoder and then transmit them to the control module. Moreover, the implementation of the encoder is optimized to achieve real-time processing.

The control module is designed based on S3C2410 processor with the kernel of ARM920T and embedded Linux. In this module, DRAM and Flash memory are used as the memory, while the CPLD is used to provide external chip select, and the dual RAM is used to engage the data transmission between the DSP and ARM, and JTAG port is used for debugging and testing.

In the control module, H.264 encoded stream is encrypted by the encryption scheme proposed in Section 4 while the parameter l used in the prototype system is 64. Then the encrypted video stream is stored in flash disk. In consideration of the low resolution of sensing video in prototype system, a fixed parameter l can meet the requirements of real-time application easily. If multi-camera with 4K (4096⁎2160) high resolution is adopted in the practical system, a large parameter l could be selected and be adjusted by the method mentioned before. In the functions of wireless transmission, the control module sends the snapshot video produced by the data processing module to remote control unit through wireless channel. Snapshot data is packaged using RTP protocol. And the RTP payload is encrypted using POSAFE proposed in Section 4.3.

The typical resolution ratio we implemented in the prototype system is 1280⁎720@25fps while the target bit rate is 5Mbps. According to the results in Section 4.4, if the parameter l in SAFE is set to 64, the throughput of the scheme would be greater than 200Mbps. And the computation resources occupation rate of the encryption process is about 2%, which would not be a significant overhead for the control module.

Thereby, even several 4K high-definition sensing equipments are introduced, the problem of real-time encryption also can be solved by adjusting the parameter l of SAFE.

@&#CONCLUSIONS@&#

Real-time video data in embedded video sensing system has a high bandwidth. However, as to battery- powered system, limited computation and energy resources restrict the usage of full encryption process on video data. Firstly, this research analyses the discrepancy between encryption resources and volume of real-time data, and then draws a conclusion that the discrepancy would not converge because the increase of encryption ability is difficult to catch up with the increase of data volume. Secondly, to get a better optimization for encryption scheme, impacts of encryption optimization on attacker׳s behavior are discussed. And then, information-utility-value-oriented encryption optimization model for multimedia data under resources constraints is proposed. Such model can optimize the distribution of limited resources, then minimize the probable information utility value which could be stolen by attacker. Thirdly, based on aforementioned model a video-compression-independent speed-adjustable fast encryption scheme and a packet-oriented improved version are proposed. Fourthly, an embedded video sensing system has been designed, and the proposed encryption schemes have been implemented in data storing and transmission module respectively. Theoretical analyses based on information theory and experimental analyses indicate that the performance of the proposed scheme is effective enough to support the encryption of real-time data in embedded video sensing systems.

@&#ACKNOWLEDGMENTS@&#

This work was partially supported by the National Natural Science Foundation of China (Grant no. 61300182 and 61370197), and the Fundamental Research Funds for the Central Universities(Grant no. BUPT2012RC0209).

@&#REFERENCES@&#

