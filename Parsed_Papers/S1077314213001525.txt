@&#MAIN-TITLE@&#Manifold surface reconstruction of an environment from sparse Structure-from-Motion data

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The surface is directly estimated from the sparse Structure-from-Motion data.


                        
                        
                           
                           Both visibility and manifold constraints are enforced.


                        
                        
                           
                           We experiment with hand-held and helmet-held low cost omnidirectional cameras.


                        
                        
                           
                           Compact models of complete environments are obtained with low time complexity.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

2-Manifold reconstruction

3D Delaunay triangulation

Steiner vertices

Complexity analysis

Sparse point cloud

Structure-from-Motion

@&#ABSTRACT@&#


               
               
                  The majority of methods for the automatic surface reconstruction of an environment from an image sequence have two steps: Structure-from-Motion and dense stereo. From the computational standpoint, it would be interesting to avoid dense stereo and to generate a surface directly from the sparse cloud of 3D points and their visibility information provided by Structure-from-Motion. The previous attempts to solve this problem are currently very limited: the surface is non-manifold or has zero genus, the experiments are done on small scenes or objects using a few dozens of images. Our solution does not have these limitations. Furthermore, we experiment with hand-held or helmet-held catadioptric cameras moving in a city and generate 3D models such that the camera trajectory can be longer than one kilometer.
               
            

@&#INTRODUCTION@&#

The topic of the paper is the reconstruction of a manifold surface using a sparse method. The definition and the importance of the manifold property are detailed in Section 1.1. Section 1.2 explains the motivations for a sparse method, i.e. a method which reconstructs a surface directly from the sparse point cloud estimated by Structure-from-Motion (SfM). Section 1.3 compares our work to the previous sparse methods and Section 1.4 summarizes our contributions.

Remember that SfM is a necessary and preliminary step which estimates the successive poses and (sometimes) intrinsic parameters of the camera from an image sequence. The sparsity comes from the fact that the SfM calculations are done for interest points, which have uneven distributions and low densities in the images (about 1 pixel over 200–300 is reconstructed in our experiments using Harris points [15]).

The sparse methods contrast with the predominant dense methods. There are two main cases of dense methods which estimate a manifold:
                        
                           1.
                           A surface evolves in 3D such that it minimizes a photo-consistency cost function for all image pixels [11,17,18,31].

A surface reconstruction method [41,6,21] is applied on a dense point cloud obtained by a dense stereo method [12,22].

Combinations of both cases are possible (e.g. 
                     [23]) and an exhaustive list of references for dense methods is outside the paper scope. By contrast to the dense methods, the sparse methods are less popular and are a minority [10,19,27,29,32,36,38] in the bibliography.

In a 2-manifold, i.e. a 2D topological manifold surface, every point of the surface has a surface neighborhood which is homeomorphic to a disk [5]. In short, a 2-manifold is parametrized by two real parameters. In the discrete case, a 2-manifold is usually defined by a list of triangles such that every triangle is exactly connected by its three edges to three other triangles.

The manifold property is required to enforce smoothness constraints on the computed surface. Indeed, the continuous differential operators of normal and curvature are extended to the discrete case thanks to this property [28,5], and then we can use them to enforce smoothness constraints on the triangle list as in dense stereo [17]. More generally, a lot of Computer Graphic algorithms are not applicable if the triangle list is not a 2-manifold [5]. In our work, the manifold property is used to constrain a surface interpolating the sparse SfM point cloud and to improve surface denoising.

There are several reasons to estimate a surface directly from the sparse SfM cloud. First, it would be ideal for both time and space complexities. This is interesting for obtaining compact models of large and complete environments like cities or for an implementation in a small embedded hardware. Second, it could be used for navigation pre-visualization [8], for initialization of dense stereo methods (e.g. 
                        [17,18]), or for autonomous navigation [7]. Last, the accuracy of a point in SfM cloud is expected to be better than that of a point in a dense stereo cloud, thanks to the SfM machinery [16] involving interest point detection and bundle adjustment.

Methods [10,19,27,29,32,36,38] using our input (sparse SfM data) start by establishing potential adjacency relationships between the input points, which are selected latter to build a surface. These methods can be classified by examining the data structures encoding the potential adjacencies: [10,32,27,38] use one 3D Delaunay triangulation (Section 1.3.2) and [29,36,19] use 2D Delaunay triangulations (Section 1.3.3). The SfM data also includes visibility constraints, i.e. line segments (rays) which should not intersect the target surface, except at a segment end. A ray links a point to one of the view points used by SfM to reconstruct the point.

The sculpting method in [4] is closely related to our method, although it does not use rays. It partitions 
                              
                                 
                                    
                                       R
                                    
                                    
                                       3
                                    
                                 
                              
                            into tetrahedra of the 3D Delaunay triangulation of the input points. The tetrahedra are labeled as inside or outside, and the surface is the list of triangles which bound the inside region (according to [2] and Fig. 1
                           , a “good” surface can be obtained by such a segmentation). Every tetrahedron is initialized inside; the remainder of 
                              
                                 
                                    
                                       R
                                    
                                    
                                       3
                                    
                                 
                              
                            is outside. Then an inside tetrahedron is selected by a geometric criterion and becomes outside while the resulting surface is manifold and every Delaunay vertex is in an inside tetrahedron. This method requires that the input point cloud is denser that ours and does not contain bad points.

Methods [10,22,32,27,38,39] use rays to label the tetrahedra of the 3D Delaunay triangulation: a tetrahedron is freespace if it is intersected by ray(s), otherwise it is matter.

In contrast to our method, [22,32] do not enforce manifold constraint and [27] directly consider the surface as the list of triangles separating the freespace and matter tetrahedra. Then, the resulting surface can be non-manifold. For example, the surface has a singularity at vertex v if all tetrahedra which have vertex v are matter, except two freespace tetrahedra Δ1 and Δ2 such that the intersection of Δ1 and Δ2 is exactly v (left of Fig. 2
                           ). Another singularity example is obtained if we replace “vertex v” by “edge e” in the previous example (right of Fig. 2). A post-processing [13] can be applied to obtain a 2-manifold by removing the singularities, but such an approach does not enforce the manifold constraint during the surface calculation and generates new vertices for every singular vertex.

Only [10] and our previous work [38,39] provide a 2-manifold. In [10], a region growing procedure in the matter tetrahedra removes all surface singularities and reconstructs very simple scenes. In [38,39], the region growing is in the freespace tetrahedra and deals with more complex topologies than those in [10,4]: the estimated surface can be a torus with several handles. Our region growing is essentially a best first approach based on the number of ray intersections per tetrahedron ([10] does not use this information). In [39], artifacts called “spurious handles” and generated by [38] are removed while maintaining the manifold property. Here the largest handles are removed thanks to the tetrahedron labels (e.g. freespace). The previous removal methods [37,42] remove the smallest handles without these labels.

Methods [29,36,19] use 2D Delaunay triangulations in images. In [19], the surface is not 2-manifold and the approach is applied to a small sequence of real images. In [29], the surface is a 2-manifold limited to a simple topology (sphere or plane). In [36], reconstructed edges are inserted in the constrained 2D triangulations, then the back-projected 2.5d triangulations are merged by computing the union of the freespace defined by the 2.5d triangulations. The resulting implicit surface is converted to manifold mesh by the marching cube method [26], which requires a thin-scale regular subdivision of space. However, an irregular space subdivision is better for large scale scene [22]. Compared to these methods, ours estimates a 2-manifold without topology limitation and without thin-scale regular space subdivision.

According to Sections 1.3.2 and 1.3.3, our contributions over the other sparse methods are the following: we combine both 2-manifold and visibility constraints without limitation on the surface genus (i.e. the number of handles of the surface), and the experiments are done on larger image sequences of complete environments (hundreds/thousands of images in a few seconds/minutes). Furthermore, this paper is an extended version of our previous work [38,39]. New material includes: highlight of our method with visibility optimization (Section 2), efficient tetrahedron-based manifold test (Section 2), discussion on bad SfM points (Section 3.6), complexity analysis (Sections 5 and 6). Section 3 describes the overall method, then artifacts called “spurious handles” are removed by the methods in Section 4. Also there are new experiments in Section 7 about manifold constraint, varying densities of reconstructed and Steiner points, comparison with the Poisson surface reconstruction [21], larger still and video sequences. Note that we do not focus on the incremental surface reconstruction [40].

Our algorithm needs prerequisites on 2-manifolds embedded in a 3D Delaunay triangulation. Here we introduce notations (Section 2.1), our optimization problem (Section 2.2), and the 2-manifold tests (Section 2.3).

Let P be a set of reconstructed points. The 3D Delaunay triangulation of P is a list T of tetrahedra which meets the following conditions: the tetrahedra partition the convex hull of P, their vertex set is P, and the circumscribing sphere of every tetrahedron does not contain a vertex in its interior. A vertex/edge/triangle is a face of a tetrahedron in T. Assuming L
                        ⊆
                        T, border δL is the list of triangles which are included in exactly one tetrahedron of L. Let F
                        ⊆
                        T be the list of freespace tetrahedra, i.e. the tetrahedra intersected by ray(s). The tetrahedra which are not freespace are matter. According to Section 1.3.2, δF can be non-manifold. Here we introduce O
                        ⊆
                        F, the list of outside tetrahedra, such that δO is manifold. The tetrahedra which are not outside are inside.

We also consider T as a graph: a graph vertex is a tetrahedron, a graph edge is a triangle between two tetrahedra. A standard practice is to introduce infinite vertex v
                        ∞ such that we define a virtual tetrahedron connecting δT triangle and v
                        ∞ 
                        [1]. The virtual tetrahedra do not exist in 3D, but they are vertices of the graph. They make easier both implementation and paper clarity since every tetrahedron has exactly four neighbors in the graph.

Since P is reconstructed in all directions around the view points to model complete environments, all rays are included in the convex hull of P. Then the virtual tetrahedra are labeled matter. Every matter tetrahedron is inside.

Note that δF and δO are closed surfaces; δF cuts 
                           
                              
                                 
                                    R
                                 
                                 
                                    3
                                 
                              
                           
                         into free-space (F) and matter, δO cuts 
                           
                              
                                 
                                    R
                                 
                                 
                                    3
                                 
                              
                           
                         into outside (O) and inside. Furthermore, O
                        ⊆
                        F.

In short, the target surface δO is a 2-manifold which should separate the matter and free-space tetrahedra “as much as possible”. Let 
                           
                              r
                              :
                              F
                              →
                              
                                 
                                    R
                                 
                                 
                                    +
                                    ∗
                                 
                              
                           
                         a scalar and positive function. We extend r to O
                        ⊆
                        F by 
                           
                              r
                              (
                              O
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    Δ
                                    ∈
                                    O
                                 
                              
                              r
                              (
                              Δ
                              )
                           
                        . We would like to estimate O included in F and maximizing r(O) subject to the constraint that δO is a 2-manifold. Intuitively (if r
                        =1), a large O in F with a 2-manifold border δO is a good solution. Now we give two remarks.

First, this optimization problem is difficult due to the manifold constraint. Then we solve it using a greedy algorithm: we add progressively free-space tetrahedra in O as long as δO remains a 2-manifold, then r(O) increases and the final δO is an approximation of the exact solution of our problem.

Second, several definitions of r are possible. Here we optimize visibility by defining r(Δ) as the number of rays which intersect tetrahedron Δ. Since our paper focuses on manifold extraction and related complexity, we do not investigate on more sophisticated definitions of r inspired by [27,32,22,20].

Here we explain how to check that a surface S (a list of triangles of T) is a 2-manifold. This topic is somewhat technical but very important in practice for the computation time of our method.

Let v be a point in S. We say that v is regular if it has a neighborhood in S which is topologically a disk. Otherwise v is singular. By definition (Section 1.1), S is 2-manifold if all its points are regular. In our context where S is a list of triangles of T, we only need to check that every vertex v of S is regular using the following neighborhood of v: the list of the S triangles which have vertex v 
                        [4]. Now we describe three 2-manifold tests.

Vertex v is regular if and only if [4] the edges opposite to v in the triangles of S having v as vertex form a simple polygon (Fig. 3
                           ). A simple polygon is topologically a circle, i.e. a list of segments which forms a closed path without self-intersection. This test was used in our previous work [38,39].

The test in Section 2.3.1 is adequate if the surface S is implemented as an adjacency graph of triangles. This is not the case here since S is embedded in a Delaunay T implemented as an adjacency graph of tetrahedra.

So we introduce a faster test to check that v is regular. Let g
                           
                              v
                            be the graph of the tetrahedra incident to v (g
                           
                              v
                            is a sub-graph of T). Section A shows that the v-opposite edges above form a simple polygon if and only if the inside tetrahedra of g
                           
                              v
                            are connected and the outside tetrahedra of g
                           
                              v
                            are connected (Fig. 4
                           ). Thus we check that v is regular thanks to a simple traversal of graph g
                           
                              v
                            where the edges between inside and outside are removed.

Now we explain how to use the 2-manifold tests in Sections 2.3.1 and 2.3.2. In our context, S
                           =
                           δO is estimated by a greedy method (Section 2.2). Assume that δO is a 2-manifold. We add A
                           ⊆
                           F into O. Then we should check that (the new) δO is still a 2-manifold. We collect in list W all vertices of the tetrahedra in A which are in δO. The new δO is a 2-manifold if every vertex in W is regular. Otherwise, it is not and A is removed from O. The vertices of δO which are not in W do not need to be checked since the labels outside-inside of their incident tetrahedra do not change by adding A.

In the special case where list A contains a single tetrahedron Δ, there is a test based on [4], which is faster than those in Section 2.3.3. In this case, we first check a condition on O and then add Δ to O (if the condition is meet). This condition is detailed in Section B. It only requires to read once the lists of tetrahedra incident to the four Δ-vertices.

Every sub-section describes a step of our method, except the last one which discusses bad (false positive) SfM points.

Assume that SfM estimates the geometry of the whole image sequence. The geometry includes the sparse cloud of points {p
                        
                           i
                        }, camera locations {
                           c
                        
                        
                           j
                        } and rays defined by visibility lists {V
                        
                           i
                        }. List V
                        
                           i
                         is the list of indices of images which reconstruct the 3D point p
                        
                           i
                        , and a ray is a line segment linking p
                        
                           i
                         to 
                           c
                        
                        
                           j
                         if j
                        ∈
                        V
                        
                           i
                        . The size of V
                        
                           i
                         is greater than 2 (2 is the theoretical minimum but it is insufficient for robustness).

Point p
                        
                           i
                         has poor accuracy if it is reconstructed in degenerate configuration [16]: if p
                        
                           i
                         and all c
                        
                           j
                        , j
                        ∈
                        V
                        
                           i
                         are nearly collinear. This case occurs in part of the camera trajectory which is a straight line and if points reconstructed from this part are close to the straight line. Thus, the point cloud is filtered as in [9]: p
                        
                           i
                         is added in T if and only if there is {j, k}⊆
                        V
                        
                           i
                         such that angle 
                           
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                           
                         meets 
                           
                              ∊
                              ⩽
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                              ⩽
                              π
                              -
                              ∊
                           
                         using threshold ∊
                        >0.

We set r
                        =0 and apply ray tracing to all rays. Since T is a graph (Section 2.1), tracing a ray c
                        
                           j
                        
                        p
                        
                           i
                         is a walk in the graph, starting from a tetrahedron incident to p
                        
                           i
                        , moving to another tetrahedron through the triangle intersected by the line segment c
                        
                           j
                        
                        p
                        
                           i
                        , and stopping to the tetrahedron which contains c
                        
                           j
                         (the inverse walk is also possible). Ray c
                        
                           j
                        
                        p
                        
                           i
                         is traced if and only if p
                        
                           i
                         is a vertex of T. For every tetrahedron Δ intersected by a ray, r(Δ) is increased by 1. We obtain function r and list F of the free-space tetrahedra.

According to Section 2.2, we use a greedy algorithm to approximate the list O which maximizes r(O) such that δO is a 2-manifold and O
                        ⊆
                        F: O grows from ∅ by adding free-space tetrahedra such that δO remains 2-manifold. The result of this step is the final δO. We use r to define a priority for the free-space tetrahedra: the Δs with the largest r(Δ) are added in O before others. Due to the manifold constraint, we also require that the selected Δ has (at least) one face in δO to avoid that the greedy algorithm gets stuck too easily in a bad solution.

The tetrahedra in the neighborhood of O are stored in a heap (priority queue) for fast selection of the tetrahedron with the greatest r. Thus O usually grows from the most confident free-space tetrahedra (with large r) to the less confident ones (with small r).


                        Algorithm 1 presents our growing method in C style. The inputs are the initial O, list F, list Q
                        0 of tetrahedra which includes the initial value of the heap, and function r. Here we use O
                        =∅ and Q
                        0
                        =∅. The output is O.
                           Algorithm 1
                           Outside Growing 
                                 
                                    
                                       
                                       
                                          
                                             01: Q
                                                =∅; // ∗∗∗ initialization of priority queue Q ∗∗∗
                                          
                                          
                                             02: if (O==∅) { // Section 3.3
                                             
                                          
                                          
                                             03: let Δ∈
                                                F be such that r(Δ) is maximum;
                                          
                                          
                                             04: 
                                                Q
                                                ←
                                                Q
                                                ∪{Δ};
                                          
                                          
                                             05: } else for each Δ∈
                                                Q
                                                0
                                                ∩
                                                F // Section 3.4
                                             
                                          
                                          
                                             06: 
                                                if (Δ∉
                                                O and Δ has a 4-neighbor in O)
                                          
                                          
                                             07: 
                                                Q
                                                ←
                                                Q
                                                ∪{Δ};
                                          
                                          
                                             08: while (Q!=∅) { // ∗∗∗ region growing of O ∗∗∗
                                          
                                          
                                             09: pick from Q the Δ which has the largest r(Δ);
                                          
                                          
                                             10: 
                                                if (Δ∈
                                                O) continue;
                                          
                                          
                                             11: 
                                                O
                                                ←
                                                O
                                                ∪{Δ};
                                          
                                          
                                             12: 
                                                if (all vertices of Δ are regular) {
                                          
                                          
                                             13: 
                                                for each 4-neighbor tetrahedron Δ′ of Δ
                                          
                                          
                                             14: 
                                                
                                                if (Δ′∈
                                                F and Δ′∉
                                                O)
                                          
                                          
                                             15: 
                                                
                                                Q
                                                ←
                                                Q
                                                ∪{Δ′};
                                          
                                          
                                             16:
                                                } else 
                                                O
                                                ←
                                                O⧹{Δ};
                                          
                                          
                                             17: }
                                          
                                       
                                    
                                 
                              
                           

The outside region O computed in Section 3.3 has the ball topology since we add tetrahedra one-by-one [4]. This is problematic if the true outside does not have the ball topology, e.g. if the camera trajectory contains closed loop(s) around building(s). In the simplest case of one loop, the true outside has the toroid topology and the computed outside O cannot close the loop (as shown by Fig. 5
                        ).

This problem is corrected as follows. Firstly, we find a vertex in δO such that all inside tetrahedra incident to this vertex are free-space. Secondly, these tetrahedra are collected in list A. Thirdly, we try to add A into O using a 2-manifold test in Section 2.3. At last, if the test is successful, we use the region growing in Section 3.3 where Q
                        0 is the list of tetrahedra neighbors of A. In practice, we go through the list of δO vertices several times to do this process.

Although the surface S provided by the previous steps is a 2-manifold (S
                        =
                        δO), it has several weaknesses which are easily noticed during visualization. Now we examine these weaknesses and explain how to remove or reduce them using prior knowledge of the scene.

A peak is a vertex p
                           
                              i
                            on S such that the ring of its incident triangles in S defines a solid angle w which is too small to be physically plausible, i.e. w
                           <
                           w
                           0 where w
                           0 is a threshold. Let L be the list of the tetrahedra in the acute side of the peak ring. L is outside or inside. Now we reverse the L label: inside becomes outside, and vice versa. The removal of peak p
                           
                              i
                            from S is successful if all vertices of the L tetrahedra remain regular. Otherwise, the label of L is restored to its original value and we try to remove another peak. In practice, we go through the list of S vertices several times to detect and remove peaks. Note that this step ignores the free-space/matter labeling.

The S reconstruction noise is reduced thanks to a smoothing filter p′=
                           p
                           +Δp where p is a vertex of S and Δp is a discrete Laplacian defined on S vertices [35]. The smoothed p′ is stored in a distinct array of p. We do not apply p
                           ←
                           p′ to avoid the computation overhead due to vertex update in T.

Up to now, S is closed and contains triangles which correspond to the sky (assuming outdoor image sequence). These triangles should be removed since they do not approximate a real surface. They also complicate the visualization of the 3D model from a bird’s-eye view. Firstly, the upward vertical direction u is robustly estimated assuming that the camera motion is (roughly) on a horizontal plane. Secondly, we consider open rectangles defined by the finite edge c
                           
                              i
                           
                           c
                           
                              i+1 and the two infinite edges (half lines) starting from c
                           
                              i
                            (or c
                           
                              i+1) with direction u. A triangle of S which is intersected by an open rectangle is a sky triangle and is removed from S. Now S has hole in the sky. Lastly, the hole is increased by propagating its border from triangle to triangle while the angle between triangle normal (oriented from outside to inside) and u is less than threshold β.

SfM can reconstruct bad point p due to repetitive texture or image noise. Now we discuss the consequences and give solutions for this problem. If p is in the true matter of the scene, there are tetrahedra that should be matter which are labeled free-space due to bad ray of p. If these tetrahedra are in O, δO can be corrupted, e.g. a wall with a spurious concavity. In practice, the risk of bad p is low thanks to the SfM machinery (bundle adjustment, RANSAC, robust matching, interest point detectors).

Nevertheless, our method reduces this risk and can remove spurious concavities. First, the risk is reduced thanks to the choice of ∊ in the point selection step (Section 3.1): the larger ∊, the more accurate points and their rays used by ray tracing (Section 3.2), the lower risk of spurious concavity. Second, the spurious concavities created by the manifold constraint in the growing steps (Sections 3.3 and 3.4) cannot be worse (larger) than those of the free-space in the matter. Indeed, a concavity is a list of outside tetrahedra which are included in free-space. Third, Section C explains how Peak Removal (Section 3.5.1) can remove spurious concavities.

Section 4.1 introduces spurious handles. Then two removal methods are presented in Sections 4.2 and 4.3, which complete our methods in Section 3 (the removal methods are not presented in Section 3 for the paper clarity).

Topology Extension (Section 3.4) calculates a 2-manifold without genus constraint and improves our solution of the optimization problem (Section 2.2), but it has one drawback: it can generate spurious handles. Fig. 6
                         shows an example in a real case: the oblique handle on the left connects a small wall to the ground. This handle is spurious: it does not exist on the true scene surface and it should be removed while maintaining the manifold property.

In the paper, we remove the handles which are both “visually critical” and due to “incomplete” outside growing in the free-space. “Visually critical” means that we ignore the handles that are too small to be easily noticeable by viewers (virtual pedestrians) located at all view points c
                        
                           j
                         reconstructed by SfM. “Incomplete” means that the handles only contains free-space tetrahedra that are inside and which should be forced to outside. We use these conditions to localize the spurious handles and to obtain a final 2-manifold which meets the visibility constraints provided by the rays. For the remainder of the paper, a “spurious handle that is visually critical and due to incomplete growing” is shortened to “spurious handle”.

Our spurious handle removal methods use Steiner vertices, i.e. extra points in T which are not in the original (SfM) input. The Steiner vertices do not have rays.

In [38], a simple method is used to reduce the risk of spurious handles. In the 3D Delaunay step (Section 3.1), Steiner points are added in T such that the long tetrahedra potentially involved in spurious handles are split in smaller tetrahedra. The Steiner points are added in the critical region for visualization: the immediate neighborhood of the camera trajectory. We randomly add a fixed and small number of Steiner vertices at the neighborhood of every camera location c
                        
                           j
                        . A neighborhood is a ball centered at c
                        
                           j
                         with radius defined as a multiple (e.g. 10) of mean
                           j
                        ∥c
                        
                           j+1
                        −
                        c
                        
                           j
                        ∥.

Another removal method [39] is applied after “Topology Extension” and before “Post-Processing”. Every sub-section describes a step of the method.

Let e be an edge with finite vertices a
                           
                              e
                            and b
                           
                              e
                           . Let α
                           >0 be a threshold. Edge e is “visually critical” if
                              
                                 1.
                                 every tetrahedron including e is free-space and

at least one inside tetrahedron includes e and

there is a view point c
                                    
                                       j
                                     such that angle 
                                       
                                          
                                             
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      e
                                                   
                                                
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      j
                                                   
                                                
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      e
                                                   
                                                
                                             
                                             
                                                ^
                                             
                                          
                                       
                                     is greater than α.

The first step is the calculation of all visually critical edges in list L
                           
                              α
                           . A spurious handle has critical edges both on its border and its interior (Fig. 7
                           ).

The larger α, the smaller size of L
                           
                              α
                            and also the greater lengths of the edges in L
                           
                              α
                           . We use this to select a moderated number of handles and apply on every selected handle a processing, whose time computation per tetrahedron/vertex is greater than those in Sections 3.3 and 3.4.

This step needs a mesh operator called “Edge Splitting”. It splits an edge of T by adding a Steiner vertex on the edge, and every tetrahedron including the edge is also split in two tetrahedra whose labels (free-space, matter, inside, outside) are the same as the original tetrahedra. Thus, the resulting triangulation T is not 100% Delaunay after this step, but our surface δO which separates outside and inside tetrahedra is still a 2-manifold (the set of surface points is unchanged).

Now we split every L
                           
                              α
                            edge by a Steiner vertex on its middle (one example in Fig. 7). This changes the graph of tetrahedra and provides new tetrahedra for the next step, which is a local region growing of O in F. For each vertex v
                           
                              i
                            on (split) critical edges, we define the list of tetrahedra L
                           
                              i
                            incident to v
                           
                              i
                            which are free-space and inside. Then a first round of (Force,Repair) is applied to the list L
                           
                              i
                           . Function “Force” adds tetrahedra in O without checking that δO is a 2-manifold, and function “Repair” (Section 4.3.3) tries to grow O such that δO becomes a 2-manifold. If it fails, another round of (Force,Repair) is tried for every tetrahedron of L
                           
                              i
                           . Algorithm 2 presents our method in C style.
                              Algorithm 2
                              Force Tetrahedra Outside 
                                    
                                       
                                          
                                          
                                             
                                                01: for each vertex v
                                                   
                                                      i
                                                    of the (split) edges of every e
                                                   ∈
                                                   L
                                                   
                                                      α
                                                    {
                                             
                                             
                                                02: let L
                                                   
                                                      i
                                                    be the list of tetrahedra incident to v
                                                   
                                                      i
                                                   ;
                                             
                                             
                                                03: 
                                                   G
                                                   =(L
                                                   
                                                      i
                                                   
                                                   ∩
                                                   F)⧹O;
                                             
                                             
                                                04: 
                                                   O
                                                   ←
                                                   O
                                                   ∪
                                                   G; // Force
                                             
                                             
                                                05: 
                                                   if (!Repair)
                                             
                                             
                                                06: 
                                                   for each tetrahedron Δ∈
                                                   L
                                                   
                                                      i
                                                   
                                                
                                             
                                             
                                                07: 
                                                   
                                                   if (Δ∈
                                                   F and Δ∉
                                                   O) {
                                             
                                             
                                                08: 
                                                   
                                                   G
                                                   ={Δ};
                                             
                                             
                                                09: 
                                                   
                                                   O
                                                   ←
                                                   O
                                                   ∪
                                                   G; // Force
                                             
                                             
                                                10: 
                                                   Repair;
                                             
                                             
                                                11:
                                                   }
                                             
                                             
                                                12: }
                                             
                                          
                                       
                                    
                                 
                              

The repair step is a local growing of O in F such that the number n of singular vertices of surface δO decreases and every regular vertex is maintained regular. At the beginning, n
                           >0 is due to the addition of G in O (Force). Then a free-space and inside tetrahedron Δ is chosen in the neighborhood of G, and it is added to O. If n increases, we remove Δ from O and try another tetrahedron. We continue until every Δ candidate increases n. If the final n is 0, the local region growing succeeds. Otherwise it fails and O is restored to its value before the Force step.

The inputs are O, G and g
                           0 (an upper bound to limit the local growing complexity). The output is a boolean which asserts that Repair is successful or failed. Repair can also modify O. Algorithm 3 presents function Repair in C style. Note that this algorithm looks like the one in Section 3.3. The main differences are (1) the 2-manifold tests are replaced by non-increase tests of the number of singular vertices and (2) the process can fail.
                              Algorithm 3
                              Repair 
                                    
                                       
                                          
                                          
                                             
                                                01: let Y be the list of vertices of the tetrahedra in G;
                                             
                                             
                                                02: let n be the number of singular vertices in Y;
                                             
                                             
                                                03: // ∗∗∗∗ initialization of priority queue Q ∗∗∗∗
                                             
                                             
                                                04: Q
                                                   =∅;
                                             
                                             
                                                05: for each tetrahedron Δ in G
                                                
                                             
                                             
                                                06: 
                                                   for each 4-neighbor tetrahedron Δ′ of Δ
                                             
                                             
                                                07: 
                                                   if (Δ′∈
                                                   F and Δ′∉
                                                   O)
                                             
                                             
                                                08: 
                                                   
                                                   Q
                                                   ←
                                                   Q
                                                   ∪{Δ′};
                                             
                                             
                                                09: // ∗∗∗∗ region growing of O ∗∗∗∗
                                             
                                             
                                                10: while (Q!=∅) {
                                             
                                             
                                                11: pick from Q the Δ which has the largest r(Δ);
                                             
                                             
                                                12: 
                                                   if (Δ∈
                                                   O) continue;
                                             
                                             
                                                13: let 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                      
                                                    be true iff the i-th vertex of Δ is singular
                                             
                                             
                                                14: 
                                                   
                                                      
                                                         
                                                            
                                                               n
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         =
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                               =
                                                               1
                                                            
                                                            
                                                               4
                                                            
                                                         
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                      
                                                   ; // number of singular Δ-vertices
                                             
                                             
                                                15: 
                                                   O
                                                   ←
                                                   O
                                                   ∪{Δ};
                                             
                                             
                                                16: let 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                    be true iff the i-th vertex of Δ is singular
                                             
                                             
                                                17: 
                                                   
                                                      
                                                         
                                                            
                                                               n
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         =
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                               =
                                                               1
                                                            
                                                            
                                                               4
                                                            
                                                         
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               i
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                   ; // number of singular Δ-vertices
                                             
                                             
                                                18: 
                                                   if (n
                                                   0
                                                   ⩾
                                                   n
                                                   1 && 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               1
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         ⩾
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               1
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                    && 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               2
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         ⩾
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               2
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                    && 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               3
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         ⩾
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               3
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                    && 
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               4
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         ⩾
                                                         
                                                            
                                                               b
                                                            
                                                            
                                                               4
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                   ) {
                                             
                                             
                                                19: 
                                                   G
                                                   ←
                                                   G
                                                   ∪{Δ}; // G is used latter
                                             
                                             
                                                20: 
                                                   n
                                                   ←
                                                   n
                                                   +
                                                   n
                                                   1
                                                   −
                                                   n
                                                   0; // fast n update
                                             
                                             
                                                21: 
                                                   if (the size of G is g
                                                   0)
                                             
                                             
                                                22: 
                                                   
                                                   break; // too large computation: stop
                                             
                                             
                                                23: 
                                                   for each 4-neighbor tetrahedron Δ′ of Δ
                                             
                                             
                                                24: 
                                                   
                                                   if (Δ′∈
                                                   F and Δ′∉
                                                   O)
                                             
                                             
                                                25: 
                                                   
                                                   Q
                                                   ←
                                                   Q
                                                   ∪{Δ′};
                                             
                                             
                                                26:} else 
                                                   O
                                                   ←
                                                   O⧹{Δ}; // failure of Δ addition
                                             
                                             
                                                27: }
                                             
                                             
                                                28: // ∗∗∗∗ check the result ∗∗∗∗
                                             
                                             
                                                29: if (n) {
                                             
                                             
                                                30: 
                                                   O
                                                   ←
                                                   O⧹G;
                                             
                                             
                                                31: 
                                                   return 0;
                                             
                                             
                                                32: } else return 1;
                                             
                                          
                                       
                                    
                                 
                              

Here we evaluate the time complexities of the 2-manifold tests (Section 5.2) and region growing (Section 5.3) using notations and data structures in Section 5.1. Then Section 5.4 discusses the worst case complexities of these steps and others. We use the standard “big o” notation 
                        
                           O
                        
                     ; x is bounded if 
                        
                           x
                           =
                           O
                           (
                           1
                           )
                        
                     .

The 3D Delaunay triangulation T is the labeled graph defined in Section 2.1. We note ∣L∣ the number of elements of list L; ∣T∣ is the number of tetrahedra. Let v be the number of tetrahedra vertices. We assume that every tetrahedron Δ stores a label outside-inside, the number r(Δ) of intersected rays, the list of 4 vertices, and the list of 4 neighbor tetrahedra. The tetrahedra and their vertices are referenced by integers in the lists above. There is a table of vertices and a table of tetrahedra. Note that Δ∈
                        F if and only if r(Δ)>0. Let d be the maximum vertex degree, i.e. the number of tetrahedra incident to every finite vertex (every vertex except v
                        ∞) is less or equal to d.

In Section 2.3.3, we add A to O if and only if δO remains 2-manifold, i.e. if every vertex of W is regular. According to Sections 3.3 and 3.4, A has a single tetrahedron or several tetrahedra sharing a surface vertex. This vertex cannot be v
                        ∞ since all v
                        ∞-incident tetrahedra are matter and every surface vertex is incident to a free-space tetrahedron. Thus, ∣A∣⩽
                        d. Since W is the list of the vertices of the tetrahedra in A, its complexity is 
                           
                              O
                              (
                              d
                              )
                           
                        . Furthermore, the complexity to check that a vertex is regular using the Graph-Based Test in Section 2.3.2 is 
                           
                              O
                              (
                              d
                              )
                           
                        . Thus the time complexity of the 2-manifold test for list A is 
                           
                              O
                              (
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . If A has a single tetrahedron, both graph-based method (Section 2.3.2) and single tetrahedron method (Section B) are 
                           
                              O
                              (
                              d
                              )
                           
                        .

Here we estimate the time complexity of Algorithm 1. Let q
                        0 be the number of tetrahedra in list Q
                        0. Let g be the number of grown tetrahedra, i.e. the difference between the number of tetrahedra in the output O and the number of tetrahedra in the input O of this algorithm. A tetrahedron Δ is definitely added at most one time into O. In this case, at most four tetrahedra are added to Q. There is no other addition to Q, except at the initialization of Q where there are at most 
                           
                              O
                              (
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                           
                         additions to Q. Thus, the number of “while” iterations is 
                           
                              O
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                           
                        .

Now the time complexity of one iteration is estimated. Picking the best tetrahedron in heap Q is 
                           
                              O
                              (
                              log
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                              )
                           
                        . The other instructions in one “while” iterations are 
                           
                              O
                              (
                              d
                              )
                           
                         due to the 2-manifold test (Section 5.2 using ∣A∣=1).

If we start from O
                        =∅, we should add the complexity of Q initialization: the time complexity of one region growing is 
                           
                              O
                              (
                              ∣
                              T
                              ∣
                              +
                              g
                              (
                              d
                              +
                              log
                              (
                              g
                              )
                              )
                              )
                           
                        . If we start from O
                        ≠∅, this time complexity is 
                           
                              O
                              (
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                              (
                              d
                              +
                              log
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                              )
                              )
                           
                        .

The number of tetrahedra is 
                           
                              |
                              T
                              |
                              =
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         and the maximum vertex degree is 
                           
                              d
                              =
                              O
                              (
                              v
                              )
                           
                         since T has v vertices [3,34]; the worst case exists but it is rare. Furthermore, a theoretical study starting from these numbers provides time complexities that are not tight enough to be interesting. Here are two examples. First, the time complexity in the worst case to trace a single ray is 
                           
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . Indeed, one line segment can intersect all tetrahedra [34], but this is almost impossible in practice. A second example is the region growing which is 
                           
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    3
                                 
                              
                              )
                           
                         in the worst case (use 
                           
                              d
                              =
                              O
                              (
                              v
                              )
                           
                         and 
                           
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              =
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         in Section 5.3), but it is quite smaller in practice. So we will use neither 
                           
                              |
                              T
                              |
                              =
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         nor 
                           
                              d
                              =
                              O
                              (
                              v
                              )
                           
                         in the complexity analysis below.

Section 6.1 introduces two new assumptions: the bounded density of the SfM points and the addition in T of a Cartesian grid of Steiner vertices. Section 6.2 lists all our assumptions and Section 6.3 provides the worst case time complexities for the steps of our method.

We assume that the density of reconstructed points in 3D is bounded: there are p
                        >0 and q
                        >0 such that every p-ball contains at most q points. A p-ball is a ball with radius p. This could be justified as follows: (1) only interest points are reconstructed and (2) the scene surface has texture such that the interest points, which are detected due to gray-level 2D variations in their neighborhood, have a bounded density (e.g. no fractal-like texture).

We also use a bounding box of the reconstructed points, which is computed from the point coordinates. This box has Delaunay mesh T with two kinds of vertices: the reconstructed vertices (Section 3.1) and Steiner vertices located at the corners of a Cartesian grid. The adding of Steiner vertices (i.e. extra points) is a standard method in Computational Geometry to generate meshes with good properties, e.g. to guarantee a linear-size 3D Delaunay triangulation with bounded vertex degree [3]. Every Steiner vertex has an empty visibility list. In practice, the number s of Steiner vertices is quite smaller than the number m of reconstructed vertices (v
                        =
                        m
                        +
                        s
                        ≈
                        m).

Thanks to the bounded density of the SfM points and the Cartesian grid of Steiner vertices, Section D shows that the tetrahedron density is also bounded, i.e. there are p′>0 and q′>0 such that every p′-ball intersects at most q′ tetrahedra. The proof has two steps: first the tetrahedron diameter is bounded by the diagonal length l of a grid voxel, second we use the bounded density of the points in the p′+
                        l-ball which includes all tetrahedra intersecting the p′-ball. If the p′-ball is centered at a finite vertex, we see that the maximum vertex degree d is bounded.

This list is used in the complexity proofs.
                           
                              H0:
                              
                                 T has m reconstructed and s Steiner vertices where s
                                 <
                                 m,

the tetrahedron density is bounded,

the maximum vertex degree d is bounded,

the access to the 4 neighbors of a tetrahedron is 
                                    
                                       O
                                       (
                                       1
                                       )
                                    
                                 ,

the size of visibility list V
                                 
                                    i
                                  is bounded,

the distance between two consecutive view points is bounded.

H0–2 are in Section 6.1. H3 is in Section 5.1. In practice, the distance between the locations of two successive images is bounded (H5) and we assume that the track length (of interest point in successive images) is also bounded (H4).


                        Table 1
                         gives the time complexities of the steps of our method. Here we briefly summarize these results. The detailed proofs are in Section E.

Step “3D Delaunay Triangulation” has the largest complexity: 
                           
                              O
                              (
                              
                                 
                                    m
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . This is due to the computation of the Delaunay triangulation in 3D [14]. Fortunately, the experimental complexity is almost linear in m 
                        [10].

Step “Ray-Tracing” is 
                           
                              O
                              (
                              m
                              )
                           
                         since the ray length is bounded (using ∊
                        >0, H4 and H5) and thanks to H1–3.

Step “2-Manifold Extraction” is 
                           
                              O
                              (
                              m
                              log
                              m
                              )
                           
                        . Indeed, there are 
                           
                              O
                              (
                              m
                              )
                           
                         tetrahedra (since T has 
                           
                              O
                              (
                              m
                              )
                           
                         vertices (H0) and d is bounded (H2)) and we obtain the result thanks to Section 5.3 and H2.

Step “Topology Extension” is also 
                           
                              O
                              (
                              m
                              log
                              m
                              )
                           
                        . This is essentially due to the fact that the successive outside growings of this step are disjoint in the free-space.

Step “Post-Processing” is 
                           
                              O
                              (
                              cm
                              )
                           
                        , where c is the number of camera locations c
                        
                           k
                        . More precisely, Peak Removal and Surface Denoising are 
                           
                              O
                              (
                              m
                              )
                           
                        , Sky Removal is 
                           
                              O
                              (
                              cm
                              )
                           
                        . In practice, c is quite smaller than the number m of reconstructed vertices (c
                        <
                        m/85 in our experiments).

Step “Handle Removal” in Section 4.2 has no “
                           
                              O
                           
                        ” additional complexity. Indeed, it adds to T a number of Steiner vertices which is linear to c, and the complexities of all steps of the methods do not change since c
                        <
                        m.

Step “Handle Removal” in Section 4.3 is 
                           
                              O
                              (
                              cm
                              +
                              
                                 
                                    wg
                                 
                                 
                                    0
                                 
                              
                              log
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              )
                           
                        , where w is the number of critical edges. Term cm is due to the detection of the critical edges; term wg
                        0
                        log
                        g
                        0 is due to the force and repair operations (region growings whose sizes are bounded by g
                        0). In practice, the main term is w g
                        0logg
                        0 where g
                        0
                        =10d and w is smaller than m (w
                        <
                        m/4.6 in our experiments). We obtain complexity 
                           
                              O
                              (
                              cm
                              )
                           
                         using 
                           
                              w
                              =
                              O
                              (
                              m
                              )
                           
                         (H2) and 
                           
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              =
                              O
                              (
                              1
                              )
                           
                        .

@&#EXPERIMENTS@&#

Section 7.1 provides an overview of the results (both SfM and surface reconstruction) in the case of a still image sequence. Then we experiment and discuss the manifold constraint in Section 7.2, varying densities of reconstructed and Steiner points in Sections 7.3 and 7.4, comparison with the Poisson surface reconstruction [21] in Section 7.5, handle removal in Section 7.6. Last, Section 7.7 gives quantitative experiments for a synthetic image sequence and Section 7.8 shows results for a 1.4km long video sequence.

We use equiangular catadioptric cameras, which are hand/helmet-held. The view field is 360∘ in the horizontal plane and about 50–60∘ above and below. This is adequate for the 3D modeling of complete environments at low cost. The calculation times are given for an Intel Core 2 Duo E8500 at 3.16GHz. Suffix k multiplies numbers by 1000.

Except in Sections 7.7 and 7.8, we use a still jpeg image sequence taken by the 0–360 mirror mounted with the Nikon Coolpix 8700 thanks to an additional adapter ring. We take 343 images during a complete walk around a church. Fig. 8
                         (left) shows top view of our SfM; it also estimates radial distortion parameters using a central model [24]. There are 136k 3D points and 872k Harris (inlier) points. The final RMS error is 0.74 pixels. A 2D point is considered as an outlier if the reprojection error is greater than 2 pixels.


                        Fig. 8 (right) shows the surface estimated using ∊
                        =10∘ (Delaunay Step), without the Steiner vertices of the tight time complexity (Section 6), with the second Handle Removal method (HR2) and α
                        =5∘, and using post-processing thresholds: w
                        0
                        =
                        π/2 steradians (Peak Removal), β
                        =45∘ (Sky Removal). The parameter setting in this Section is the default setting of our paper. The VRML model is computed in 35s. It has 152k triangles, which are few for a scene like this. The lines “still” in Table 2
                         provides information for this sequence, including the computation times for every step, number of images, trajectory length, and performance of the outside growing in free-space (ratio between the numbers of free-space and outside tetrahedra). More details are given on several steps in the next Sections. See also the Joint video referenced in Section F.

Here are additional informations on the 2-manifold constraint in the experiment of Section 7.1. First, there are several methods to test that a surface is manifold (Section 2.3). We use the Single Tetrahedron Test for the 2-Manifold Extraction step (adding the tetrahedra one-by-one in O), and the Graph-Based Test for the Topology Extension step (adding the tetrahedra several-at-once in O). In our implementation, the Polygon-Based Test is slower: if we use it, it multiplies the computation time of the 2-Manifold Extraction step by 1.4 and that of the Topology Extension step by 1.9. We also check that the different tests provide the same surface.

Now, we study the advantage of the 2-manifold constraint. We start from two closed surfaces: δF (non-manifold) and δO (manifold) generated by the 2-Manifold Extraction step. 24.6% of the δF vertices are singular. Then the denoising step is used, and we obtain four surfaces: denoised manifold, non-denoised manifold, denoised non-manifold, non-denoised non-manifold. For the remainder of Section 7.2, the further steps of our method are not applied.


                        Fig. 9 shows that the manifold constraint helps surface denoising: the denoised manifold surface is smoother than the denoised non-manifold surface. The use of several denoising does not change this observation. Fig. 9
                         also shows that the texturing of the denoised 2-manifold is better than the texturing of the non-denoised 2-manifold.

Since our goal is the 2-manifold estimation from a small number of SfM points (and their visibility), it would be interesting to experiment on the same data as in Section 7.1, but with a yet smaller number of points. Thus we reduce the size of the images by several coefficients, and for each resulting sequence, we apply the whole process (both SfM and surface estimations) with the same parameter settings. This reduces the number of reconstructed points as if we use a different camera to reconstruct the same scene. Image reduction also increases the image noise impact on the 3D result. We think that this experiment is more interesting than the surface calculations from random selections of the SfM points in Section 7.1.


                        Table 3
                         provides numbers for reduction coefficients rc
                        ∈{1,1.5,2,2.5}. The number of reconstructed points is roughly linear to 1/(rc)2, the ratio between the numbers of tetrahedra and vertices of the Delaunay is almost constant, and the calculation times are very small for large rc (a few seconds). We also see that relations 
                           
                              |
                              T
                              |
                              =
                              O
                              (
                              
                                 
                                    v
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         and 
                           
                              d
                              =
                              O
                              (
                              v
                              )
                           
                         are not tight enough to be used in the proofs of time complexities. Fig. 10
                         shows the surfaces for different rc values. We see the progressive reduction of the level of details.

Here we study the effects of the Steiner vertices located at the corners of the Cartesian grid introduced in Section 6. The length of voxel edges of the grid is a multiple sz of the camera step between two consecutive images (the length is szmean
                           j
                        ∥c
                        
                           j+1
                        −
                        c
                        
                           j
                        —∣).


                        Fig. 11
                         shows views for sz
                        ∈{2,5,10,20}. The smaller sz, the greater decrease of surface quality. The negative effect of the Steiner vertices is essentially in the areas where the density of reconstructed vertices is low (sky and parts of ground in our example). In the sky, there are too much tetrahedra for a fixed number of rays, then small matter tetrahedra appears if sz is small. Thus sz should not be too small.


                        Table 4
                         shows the experimental computation times for large enough sz (the grid is unused if sz
                        =∞). We see that the grid does not really have complexity advantage in practice, and we conclude that the grid essentially has a theoretical interest: it guaranties the worst case complexities derived in Section 6. The fact that the smallest d in Table 4 is obtained without the grid might be surprising, but this is not in contradiction to the fact that every finite grid size sz guaranties an upper bound for d (Section 6.1). Note that d can be smaller than d(sz
                        =∞), e.g. d(sz
                        =5)=264.

Our method is also compared to the Poisson surface reconstruction [21]. Remember that this method starts from a set of points and their oriented normals. We use parameter depth
                        =12 to obtain a large enough resolution (the mesh size is moderated thanks to an octree-based sampling).

There are several surfaces depending on the method used to compute the oriented normal n
                        
                           i
                         of reconstructed point p
                        
                           i
                        :
                           
                              •
                              
                                 S
                                 
                                    ray
                                 : n
                                 
                                    i
                                  is the mean of directions of all p
                                 
                                    i
                                 ’s rays


                                 S
                                 6nn
                                 : n
                                 
                                    i
                                  is the normal of the plane Π minimizing the sum of the squared point-plane distances between Π and the 6-nearest neighbors of p
                                 
                                    i
                                 
                              


                                 S
                                 
                                    man
                                 : n
                                 
                                    i
                                  is a weighted sum of normals of the p
                                 
                                    i
                                 -incident triangles separating outside and inside tetrahedra.

And let S
                        
                           ours
                         be the surface of our method.

In the four cases, the point filtering of Section 3.1 is applied and there is no Sky Removal step. Note that S
                        
                           man
                         is obtained by a combination of two methods: ours and Poisson. Furthermore, the weight is the incident triangle angle at p
                        
                           i
                         
                        [5], and p
                        
                           i
                         is not used by S
                        
                           man
                         if its normal cannot be computed due to the p
                        
                           i
                        -tetrahedra labeling.


                        Fig. 12
                         shows views of the four surfaces. The better accuracy of normal computation, the better quality of the Poisson surface: S
                        
                           man
                         is better than S
                        6nn
                        , which is better than S
                        
                           ray
                        . The quality of S
                        
                           ours
                         is between those of S
                        6nn
                         and S
                        
                           man
                        , although S
                        
                           man
                         is oversmoothed compared to S
                        
                           ours
                        . Regarding the processing time, S
                        
                           ours
                         has 154k triangles computed in 35s and S
                        
                           man
                         has 178k triangles computed in 35+93s, which is about 3.5 times of S
                        
                           ours
                        .


                        Fig. 13
                         compares the two handle removal methods. HR1(ns) adds randomly a given number ns of Steiner points in the ball neighborhood of every camera pose (Section 4.2). The radius coefficient is 10. HR2 detects, forces and repairs the spurious handles (Section 4.3). We compare HR2 to HR1(ns) with several values of ns
                        ∈{0,1,5,10} (handles are not removed if ns
                        =0). The right column shows the largest spurious handles of the surface if ns
                        =0. These handles are reduced by HR1(1) and are removed by HR2 and HR1(ns), ns
                        ∈{5,10}. However, HR1(ns), ns
                        ∈{1,5,10} are not able to remove spurious handles at other locations (two examples are shown in the two columns on the right). Furthermore, we notice that ns should not be too large for the same reasons as sz should not be too small in Section 7.4. HR2 gives the best results and removes the large handles at the locations viewed by Fig. 13 (and others). Note that the sky is not removed in these experiments since we would like to examine the Handle Removal step only. Indeed, Sky Removal also removes spurious handles in a special case: if they are above the camera poses (they are intersected by the open rectangles of Section 3.5.3).

Remember that the main parameter of HR2 is the angle α, which selects the minimal size of critical edges where the computations are done. We found that the α default value (5∘) is a good compromise: (1) HR2 misses visually noticeable handles if α is larger than 5 and (2) the calculation times increases while the improvement is negligible if α is smaller than 5. 1.5% of the 581k Delaunay edges are critical edges using α
                        =5.

The synthetic scene is manually generated from real images taken in a city. The trajectory is a 230m long closed loop around a building including several shops. The images are generated by ray-tracing and taking into account the ray reflection on the catadioptric mirror. The large circle, which contains the scene projection in the image, has a 600 pixel radius. Fig. 14
                         (left) shows two images of the synthetic sequence. SfM [24] reconstructs 600 camera poses and a sparse cloud of 257k 3D points from the sequence.

Now we explain how to estimate the reconstruction error. Let Z be the similarity transformation which minimizes 
                           
                              E
                              (
                              Z
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    599
                                 
                              
                              ‖
                              Z
                              (
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              )
                              -
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    g
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                        , where c
                        
                           i
                         and 
                           
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    g
                                 
                              
                           
                         are the estimated locations and the ground truth locations of the camera, respectively (c
                        
                           i
                         is the camera center and 
                           
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    g
                                 
                              
                           
                         is the mirror apex). We use Z to map the estimated geometry (poses and point cloud) in the ground truth coordinate system. Our error is based on ray tracing. Let q be a pixel. Let p
                        
                           e
                         be the intersection of the estimated surface and the back-projected ray of q by the estimated camera pose. Let p
                        
                           g
                         be the intersection of the ground truth surface and the back-projected ray of q by the ground truth camera pose. In both cases, if there are several intersections, we take the intersection which is the closest to the camera pose. Then we use error 
                           
                              e
                              (
                              q
                              )
                              =
                              ‖
                              
                                 
                                    p
                                 
                                 
                                    e
                                 
                              
                              -
                              
                                 
                                    p
                                 
                                 
                                    g
                                 
                              
                              ‖
                           
                        . If p
                        
                           g
                         does not exist or e(q)>
                        μ
                        0 (where μ
                        0
                        =2m), we assume that the point matching (p
                        
                           e
                        , p
                        
                           g
                        ) is outlier (e.g. for the pixels of the sky).

The pose-registration provides 
                           
                              
                                 
                                    E
                                    (
                                    Z
                                    )
                                    /
                                    600
                                 
                              
                              =
                              5.1
                              
                              cm
                           
                        . Then we uniformly sample pixels in the sequence and examine the distribution of e(q) for 6,000,000 pixels. 75.7% of sampled points are inliers, the error median of inliers is 8cm, the 90% quantile of inliers is 55cm. Lastly, the same experiment (both SfM and surface estimations) is re-done for the same images down-sampled by 2. We found 
                           
                              
                                 
                                    E
                                    (
                                    Z
                                    )
                                    /
                                    600
                                 
                              
                              =
                              56
                              
                              cm
                           
                        , which implies that the SfM drift is larger than in the previous case. 73.9% of sampled points are inliers, the error median of inliers is 64.3cm, the 90% quantile of inliers is 103cm. Fig. 14 shows the sparse point cloud by SfM and the surface.

Here the catadioptric camera is the 0–360 mirror mounted with the Canon Legria HFS10. We take an AVCHD video biking in a city. The trajectory length is about 1.4km long and the camera is mounted on a helmet.


                        Fig. 15
                         (top) shows a top view of the SfM result. First, a SfM method similar to [30] in the central case is applied. 2504 keyframes are selected from 24,700 frames such that about 600 Harris points are matched in three consecutive keyframes. Second, we use the loop closure method in [25] (the SfM drift is not corrected at both sequence ends). We obtain 385k 3D points reconstructed from 2230k Harris (inlier) points in 2504 keyframes.


                        Fig. 15 (bottom) shows views of the VRML model with the parameters in Section 7.1. The 416k triangles of the surface are estimated in 166s. The lines “video” in Table 2 provides information for this sequence, including the computation times for every step. The most costly step is Handle Removal; 3% of the 1548k Delaunay edges are critical edges.

The mean number of points reconstructed per meter is 275 (ratio between SfM and length in Table 2). Thus the scene model is very simplified and compact. The thin details such as electric posts, threes with low density foliage, window concavities in facades, are not modeled. Note that this number (275) is quite smaller than that of the “still” sequence (1320). Both image resolution and number of points contribute to the surface quality.

@&#CONCLUSION@&#

In this paper, a 2-manifold surface is reconstructed from the Structure-from-Motion output: a sparse cloud of reconstructed Harris points and their visibilities in the images. The potential adjacencies between the points are encoded in a 3D Delaunay triangulation, then the point visibilities are used to label the tetrahedra, last a 2-manifold is extracted thanks to a greedy method and the use of Steiner vertices. The time complexity is also studied. Furthermore, the experiments show the interest of the manifold constraint (neglected in the previous work using the same sparse SfM data), results using several densities of reconstructed/Steiner vertices, comparisons to the Poisson surface reconstruction, comparisons between variants of our method, quantitative evaluation, both still and video (catadioptric) image sequences.

The current system is able to reconstruct the main components of environments (ground, building, dense vegetation, etc.), but the main limitation is due to the lack of points to reconstruct thin scene details. Future work can improve the surface quality while staying in our sparse feature scheme and maintaining a low computational cost: reconstruct and integrate the image contours in the 3D Delaunay triangulation, improve the interest point matching (especially in the video case), design a dedicated surface denoising method for sparse SfM point clouds, investigate other cost functions r. Otherwise, the accuracy could be improved by a dense stereo refinement.

@&#ACKNOWLEDGMENTS@&#

Thanks to CNRS, Université Bslaise Pascal (UBP) and Institut Pascal for funding Maxime Lhuillier and Shuda Yu. Thanks to the CRISTAL project for providing the ground truth VRML model used in the quantitative evaluation.

Here we use theory on planar graphs and duality in [33] to show that the Graph- and Edge-based tests in Section 2.3 are equivalent.

First, we introduce notations G and G
                     ∗. Let v be a vertex on surface δO. Let V
                     ∗ be the list of v-incident tetrahedra of the Delaunay T. Let E
                     ∗ be the list of triangles between adjacent tetrahedra in V
                     ∗. Graph G
                     ∗
                     =(V
                     ∗, E
                     ∗) has vertices V
                     ∗ and edges E
                     ∗, and G
                     ∗
                     =
                     g
                     
                        v
                     . Let V be the list of vertices of the tetrahedra of V
                     ∗, except v. Let E be the list of edges of the tetrahedra of V
                     ∗ without endvertex v. Graph G
                     =(V, E) has vertices V and edges E.


                     Fig. A.16
                      shows an example: there are height v-incident tetrahedra whose union is an octahedron centered at v, G has the vertices and edges of the octahedron, G
                     ∗ has the vertices and edges of a cube. Note that G
                     ∗ is also the adjacency graph of the v-opposite triangles in the v-incident tetrahedra.

Second we detail the duality between G and G
                     ∗. Graph G is planar since it lies on the border of a v-star-shaped volume which is homeomorphic to a 2-sphere. Remember that a planar graph is embedded in 
                        
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        
                     , it cuts 
                        
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        
                      into regions called faces such that every edge has two faces (one on the left and one on the right). The dual graph of G is defined as follows: its vertices are the faces of G, its edges connect the left and right faces of an edge in G. Now we see that G
                     ∗ is the dual graph of G.

Third we explicit the duality between edges due to the inside-outside labeling. We have a nontrivial bipartition of V
                     ∗: 
                        
                           
                              
                                 V
                              
                              
                                 I
                              
                              
                                 ∗
                              
                           
                        
                      (inside tetrahedra) and 
                        
                           
                              
                                 V
                              
                              
                                 O
                              
                              
                                 ∗
                              
                           
                        
                      (outside tetrahedra). This implicitly defines a bipartition of inside and outside (v-opposite) triangles. Let F
                     ∗ be the edges of graph G
                     ∗ having an endvertex in 
                        
                           
                              
                                 V
                              
                              
                                 I
                              
                              
                                 ∗
                              
                           
                        
                      and an endvertex in 
                        
                           
                              
                                 V
                              
                              
                                 O
                              
                              
                                 ∗
                              
                           
                        
                     . Let F be the edges of graph G having an inside triangle and an outside triangle as its two faces. The edges F
                     ∗ of graph G
                     ∗ are the duals of edges F of graph G (Fig. A.16).

Last we show that Graph-based and Edge-based tests give the same result. According to the Graph-Based Test, v is regular iff (if and only if) 
                        
                           
                              
                                 V
                              
                              
                                 I
                              
                              
                                 ∗
                              
                           
                        
                      and 
                        
                           
                              
                                 V
                              
                              
                                 O
                              
                              
                                 ∗
                              
                           
                        
                      are connected in the graph (V
                     ∗, E
                     ∗⧹F
                     ∗), i.e. iff F
                     ∗ is a minimal edge-cut of G
                     ∗. According to the Edge-based test, v is regular iff F is a cycle in graph G. Now we use Proposition 7 in [33]: “Let G
                     =(V, E) be a connected plane multigraph. A set F included in E is a cycle in G if and only if F
                     ∗ is a minimal edge-cut in G
                     ∗”. We obtain the result. Note that a multigraph is a graph allowing loop edges and parallel edges, that our graphes have not.

Assume that δO is a 2-manifold. In Section 2.3.4, we would like to add one tetrahedron Δ in O such that δO remains a 2-manifold using the structures in Section 5.1. Let f be the number of Δ facets (i.e. triangles) which are included in δO. If f
                     =0, Δ will be added to O if and only if the Δ vertices do not have incident tetrahedron in O. If f
                     =1, Δ will be added to O if and only if the Δ vertex, which is not in the Δ facet included in δO, does not have incident tetrahedron in O. If f
                     =2, Δ will be added to O if and only if the Δ edge, which is not an edge of the two Δ facets included in δO, does not have incident tetrahedron in O. If f
                     ∈{3,4}, Δ will be added to O.

The complexity of this step is needed in Section 5.2. Cases f
                     ∈{3,4} are 
                        
                           O
                           (
                           1
                           )
                        
                     . Since the computation of the list L
                     
                        v
                      of tetrahedra incident to a (finite) vertex v is a traversal of graph g
                     
                        v
                     , it is 
                        
                           O
                           (
                           d
                           )
                        
                     . Then cases f
                     ∈{0,1} are 
                        
                           O
                           (
                           d
                           )
                        
                     . Case f
                     =2 requires the computation of the list L
                     
                        e
                      of tetrahedra which include an edge e. Let v
                     1 and v
                     2 be the endvertices of e. Since Δ′∈
                     L
                     
                        e
                      if and only if Δ′∈
                     L
                     
                        v
                      and Δ′ has vertex v
                     2, case f
                     =2 is also 
                        
                           O
                           (
                           d
                           )
                        
                     .

In practice, we greatly accelerate these computations and others by precalculating for every vertex the list (stored as a table) of its incident tetrahedra. This is done in 
                        
                           O
                           (
                           |
                           T
                           |
                           )
                        
                      from the data structure in Section 5.1.


                     Fig. C.17
                      explains how Peak Removal (Section 3.5.1) can remove a spurious concavity due to bad point p (Section 3.6). Here p carves a peak due to its rays, the peak apex is p and the acute side of the peak is the spurious concavity. The larger density of the good points, the smaller the angle of the peak, the better is the success rate of the spurious concavity removal.

Since T is Delaunay, every tetrahedron has a circumscribing sphere such that the interior does not contain any Delaunay vertex [4]. These vertices include the Steiner vertices of the grid introduced in Section 6.1. Then Appendix D.1 shows the intuitive result that the tetrahedron diameter is less than (or equal to) the diagonal length of a grid voxel. Last we finish the proof thanks to Appendix D.2.

To make the proof easier, the grid is increased by an additional layer of Steiner vertices as shown in Fig. D.18
                        . Let A
                        ={−1,0,1,2}. Without loss of generality, the grid contains vertices A
                        3
                        =
                        A
                        ×
                        A
                        ×
                        A, point p is in the cube [0,1]3, the length of the cube diagonal is 
                           
                              
                                 
                                    3
                                 
                              
                           
                        . Let c be the center of a circumscribing sphere 
                           
                              S
                           
                         of a tetrahedron which has vertex p. Here we show that 
                           
                              ‖
                              c
                              -
                              p
                              ‖
                              ⩽
                              
                                 
                                    3
                                 
                              
                              /
                              2
                           
                         (then the tetrahedron diameter is less than 
                           
                              
                                 
                                    3
                                 
                              
                           
                        ).

Assume (reductio ad absurdum) that c
                        ∉[−1,2]3. We show that
                           
                              (D.1)
                              
                                 
                                    
                                       
                                          min
                                       
                                       
                                          s
                                          ∈
                                          
                                             
                                                A
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                 
                                 ‖
                                 c
                                 -
                                 s
                                 ‖
                                 <
                                 ‖
                                 c
                                 -
                                 p
                                 ‖
                                 .
                              
                           
                        Using coordinates of vectors c, s and p, Eq. (D.1) means that
                           
                              (D.2)
                              
                                 
                                    
                                       
                                          min
                                       
                                       
                                          
                                             
                                                s
                                             
                                             
                                                x
                                             
                                          
                                          ∈
                                          A
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             x
                                          
                                       
                                       -
                                       
                                          
                                             s
                                          
                                          
                                             x
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          min
                                       
                                       
                                          
                                             
                                                s
                                             
                                             
                                                y
                                             
                                          
                                          ∈
                                          A
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             y
                                          
                                       
                                       -
                                       
                                          
                                             s
                                          
                                          
                                             y
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          min
                                       
                                       
                                          
                                             
                                                s
                                             
                                             
                                                z
                                             
                                          
                                          ∈
                                          A
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             z
                                          
                                       
                                       -
                                       
                                          
                                             s
                                          
                                          
                                             z
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        is less than
                           
                              (D.3)
                              
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             x
                                          
                                       
                                       -
                                       
                                          
                                             p
                                          
                                          
                                             x
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             y
                                          
                                       
                                       -
                                       
                                          
                                             p
                                          
                                          
                                             y
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             z
                                          
                                       
                                       -
                                       
                                          
                                             p
                                          
                                          
                                             z
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 .
                              
                           
                        Using u
                        ∈{x, y, z}, we introduce
                           
                              (D.4)
                              
                                 
                                    
                                       f
                                    
                                    
                                       u
                                    
                                 
                                 =
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             u
                                          
                                       
                                       -
                                       
                                          
                                             p
                                          
                                          
                                             u
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 -
                                 
                                    
                                       
                                          min
                                       
                                       
                                          
                                             
                                                s
                                             
                                             
                                                u
                                             
                                          
                                          ∈
                                          A
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             u
                                          
                                       
                                       -
                                       
                                          
                                             s
                                          
                                          
                                             u
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 .
                              
                           
                        It can be shown that
                           
                              (D.5)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   p
                                                
                                                
                                                   u
                                                
                                             
                                             ∈
                                             [
                                             0
                                             ,
                                             
                                             1
                                             ]
                                             
                                             and
                                             
                                             
                                                
                                                   c
                                                
                                                
                                                   u
                                                
                                             
                                             ∈
                                             [
                                             -
                                             1
                                             ,
                                             
                                             2
                                             ]
                                             ⇒
                                             
                                                
                                                   f
                                                
                                                
                                                   u
                                                
                                             
                                             ⩾
                                             -
                                             
                                                
                                                   
                                                      min
                                                   
                                                   
                                                      
                                                         
                                                            s
                                                         
                                                         
                                                            u
                                                         
                                                      
                                                      ∈
                                                      A
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         s
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             ⩾
                                             -
                                             1
                                             /
                                             4
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   p
                                                
                                                
                                                   u
                                                
                                             
                                             ∈
                                             [
                                             0
                                             ,
                                             
                                             1
                                             ]
                                             
                                             and
                                             
                                             
                                                
                                                   c
                                                
                                                
                                                   u
                                                
                                             
                                             ⩽
                                             -
                                             1
                                             ⇒
                                             
                                                
                                                   f
                                                
                                                
                                                   u
                                                
                                             
                                             =
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         p
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             -
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   +
                                                   1
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             ⩾
                                             1
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   p
                                                
                                                
                                                   u
                                                
                                             
                                             ∈
                                             [
                                             0
                                             ,
                                             
                                             1
                                             ]
                                             
                                             and
                                             
                                             2
                                             ⩽
                                             
                                                
                                                   c
                                                
                                                
                                                   u
                                                
                                             
                                             ⇒
                                             
                                                
                                                   f
                                                
                                                
                                                   u
                                                
                                             
                                             =
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         p
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             -
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   -
                                                   2
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             ⩾
                                             1
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        Since c
                        ∉[−1,2]3, there is u
                        ∈{x, y, z} such that c
                        
                           u
                        
                        ∉[−1,2]. Thus f
                        
                           x
                        
                        +
                        f
                        
                           y
                        
                        +
                        f
                        
                           z
                        
                        ⩾1−1/4−1/4>0 and Eq. (D.1) is met.

However, 
                           
                              ‖
                              c
                              
                              −
                              
                              p
                              ‖
                           
                         is the 
                           
                              S
                           
                         radius and Eq. (D.1) means that the interior of 
                           
                              S
                           
                         contains a vertex s of the grid. This is not possible in a 3D Delaunay triangulation [4]. Thus assumption c
                        ∉[−1,2]3 is wrong.

Since c
                        ∈[−1,2]3, c is in a cube of A
                        3 grid. So there is a vertex s
                        ∈
                        A
                        3 such that 
                           
                              ‖
                              s
                              
                              −
                              
                              c
                              ‖
                           
                        
                        2
                        ⩽(1/2)2
                        +(1/2)2
                        +(1/2)2, i.e. 
                        
                           
                              ‖
                              s
                              -
                              c
                              ‖
                              ⩽
                              
                                 
                                    3
                                 
                              
                              /
                              2
                           
                        . Since the interior of 
                           
                              S
                           
                         does not contains s, we see that 
                           
                              ‖
                              c
                              -
                              p
                              ‖
                              ⩽
                              ‖
                              s
                              -
                              c
                              ‖
                              ⩽
                              
                                 
                                    3
                                 
                              
                              /
                              2
                           
                        .

Let l be the diagonal length of a grid voxel. Let p′>0 and L(z) be the list of tetrahedra which intersect the p′-ball centered at point z. Thanks to the triangular inequality, the tetrahedra of L(z) are in the p′+
                        l-ball centered at z. In 
                           
                              
                                 
                                    R
                                 
                                 
                                    3
                                 
                              
                           
                        , we can cover the p′+
                        l-ball with a finite number b of p-balls (b does not depend on z). According to Section 6.1, each p-ball contains at most q vertices. Thus the p′+
                        l-ball contains at most bq vertices. Since a tetrahedron is a 4-tuple of vertices, we see that the number of tetrahedra in L(z) is bounded. We conclude that the tetrahedron density is bounded.

Here are the proofs for results in Section 6.3 using assumptions in Section 6.2.

Firstly, we estimate the complexity of tracing one ray (line segment) c
                        
                           j
                        
                        p
                        
                           i
                        . The ray is covered by a number of p′-balls which is linear to the euclidean distance 
                           
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              -
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ‖
                           
                        . Since every p′-ball intersects at most q′ tetrahedra (H1), c
                        
                           j
                        
                        p
                        
                           i
                         intersects a number of tetrahedra which is 
                           
                              O
                              (
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              -
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ‖
                              )
                           
                        . Furthermore, c
                        
                           j
                        
                        p
                        
                           i
                        -tracing is a walk (Section 3.2) in graph T restricted to these tetrahedra and started from p
                        
                           i
                        , which is a T vertex. Now we see that c
                        
                           j
                        
                        p
                        
                           i
                        -tracing has time complexity 
                           
                              O
                              (
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              -
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ‖
                              )
                           
                         thanks to H3.

Secondly, we show that ray length 
                           
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              -
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ‖
                           
                         is bounded. Let h be the orthogonal projection of c
                        
                           j
                         into the line crossing c
                        
                           k
                         and p
                        
                           i
                        . This implies 
                           
                              ‖
                              h
                              -
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              ‖
                              ⩽
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                              -
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              ‖
                           
                         and 
                           
                              sin
                              (
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                              )
                              =
                              ‖
                              h
                              -
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              ‖
                              /
                              ‖
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              ‖
                           
                        . Furthermore, reconstructed point p
                        
                           i
                         is added to T if it meets the ray-angle criterion 
                           
                              π
                              -
                              ∊
                              ⩾
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          c
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                              ⩾
                              ∊
                              >
                              0
                           
                         (Section 3.1). We obtain
                           
                              (E.1)
                              
                                 ‖
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 ‖
                                 =
                                 
                                    
                                       ‖
                                       h
                                       -
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ‖
                                    
                                    
                                       sin
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                
                                                   j
                                                
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   c
                                                
                                                
                                                   k
                                                
                                             
                                          
                                          
                                             ^
                                          
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       ‖
                                       
                                          
                                             c
                                          
                                          
                                             k
                                          
                                       
                                       -
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       ‖
                                    
                                    
                                       sin
                                       ∊
                                    
                                 
                                 .
                              
                           
                        Now, H4 and H5 imply that 
                           
                              ‖
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              -
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                              ‖
                           
                         is bounded if j
                        ∈
                        V
                        
                           i
                         and k
                        ∈
                        V
                        
                           i
                        . Thus, 
                           
                              ‖
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              ‖
                           
                         is also bounded and c
                        
                           j
                        
                        p
                        
                           i
                        -tracing is 
                           
                              O
                              (
                              1
                              )
                           
                        .

Lastly, the time complexity is 
                           
                              O
                              (
                              m
                              )
                           
                         since there are m reconstructed vertices (H0), every vertex has 
                           
                              O
                              (
                              1
                              )
                           
                         rays (H4), and tracing one ray is 
                           
                              O
                              (
                              1
                              )
                           
                        .

Remember that Topology Extension alternates two steps:
                           
                              1.
                              switching from inside to outside tetrahedra around a surface vertex

region growing in F starting from the neighborhood of these tetrahedra.

Step 2 only occurs if step 1 is successful. If it is not successful, step 1 includes the reverse switching (from outside to inside). This process is tried a finite number of times for every surface vertex.

There are 
                           
                              O
                              (
                              m
                              )
                           
                         surface vertices, and H2–H3 imply that step 1 is 
                           
                              O
                              (
                              1
                              )
                           
                         for one vertex. So the complexity of all steps 1 is 
                           
                              O
                              (
                              m
                              )
                           
                        . The ith growing from the ith vertex (step 2) has complexity 
                           
                              O
                              (
                              (
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              )
                              (
                              d
                              +
                              log
                              (
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              )
                              )
                              )
                           
                         where g
                        
                           i
                         is the number of grown tetrahedra and q
                        
                           i
                         the number of tetrahedra in Q
                        0. We have 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                              =
                              O
                              (
                              m
                              )
                           
                         since the total number of tetrahedra is 
                           
                              O
                              (
                              m
                              )
                           
                        . We have 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              O
                              (
                              1
                              )
                              =
                              O
                              (
                              m
                              )
                           
                         since 
                           
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              =
                              O
                              (
                              1
                              )
                           
                         thanks to H2. Thus,
                           
                              (E.2)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                 
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       q
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 (
                                 d
                                 +
                                 log
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       q
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 )
                                 ⩽
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                 
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       q
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 (
                                 d
                                 +
                                 log
                                 (
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ′
                                          ∈
                                          I
                                       
                                    
                                 
                                 
                                    
                                       g
                                    
                                    
                                       i
                                       ′
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ′
                                          ∈
                                          I
                                       
                                    
                                 
                                 
                                    
                                       q
                                    
                                    
                                       i
                                       ′
                                    
                                 
                                 )
                                 )
                                 =
                                 O
                                 (
                                 m
                                 (
                                 d
                                 +
                                 log
                                 m
                                 )
                                 .
                              
                           
                        Thanks to H2, the complexity of all steps 2 is 
                           
                              O
                              (
                              m
                              log
                              m
                              )
                           
                        . We see that Topology Extension is 
                           
                              O
                              (
                              m
                              log
                              m
                              )
                           
                        .

Trying to remove one peak p
                        
                           i
                         of the surface S is 
                           
                              O
                              (
                              1
                              )
                           
                        : the access to the data (tetrahedra and vertices) to do this is 
                           
                              O
                              (
                              1
                              )
                           
                         thanks to H2 and H3, the manifold test at a vertex is 
                           
                              O
                              (
                              1
                              )
                           
                         thanks to H2. Since S has 
                           
                              O
                              (
                              m
                              )
                           
                         vertices and every vertex is tried a finite number of times, Peak Removal is 
                           
                              O
                              (
                              m
                              )
                           
                        .

Remember that p′ is calculated from p and list 
                           
                              N
                              (
                              p
                              )
                           
                         of vertices which are connected to p by an edge of S. Thanks to H2 and H3, the calculation of 
                           
                              N
                              (
                              p
                              )
                           
                         is 
                           
                              O
                              (
                              1
                              )
                           
                        . Since S has 
                           
                              O
                              (
                              m
                              )
                           
                         vertices, Surface Denoising is 
                           
                              O
                              (
                              m
                              )
                           
                        .

Now we study Sky Removal. The rectangle-triangle intersections are 
                           
                              O
                              (
                              cm
                              )
                           
                         since S has 
                           
                              O
                              (
                              m
                              )
                           
                         triangles (thanks to H2) and there are c open rectangles. The border growing is bounded by the number of S triangles. Thus Sky Removal is 
                           
                              O
                              (
                              cm
                              )
                           
                        .

The first method (Section 4.2) adds to T a number of Steiner vertices which is linear to c. In practice, there are no more than 10 Steiner vertices per camera location and they act as reconstructed vertices with empty visibility lists. Since c
                        <
                        m, the complexities of all steps of the methods do not change.

Now we study the second method (Section 4.3). Thanks to H2, T has 
                           
                              O
                              (
                              m
                              )
                           
                         edges and the complexity of step “Detect” for every edge is 
                           
                              O
                              (
                              d
                              +
                              c
                              )
                              =
                              O
                              (
                              c
                              )
                           
                        . Then “Detect” is 
                           
                              O
                              (
                              cm
                              )
                           
                        .

In the “Force” step, the vertices of the split edges are finite. Then the complexity of one split edge is 
                           
                              O
                              (
                              1
                              )
                           
                         thanks to H2 and H3. Furthermore, every critical edge generates 3 vertices v
                        
                           i
                        , and the time and space complexities of L
                        
                           i
                         is 
                           
                              O
                              (
                              1
                              )
                           
                         for every v
                        
                           i
                         (thanks to H2 and H3). We see that the computation time of “Force” for one critical edge is 
                           
                              O
                              (
                              1
                              )
                           
                        . Thus the Force complexity is 
                           
                              O
                              (
                              w
                              )
                           
                        , where w is the number of critical edges.

“Repair” is a best first region growing which increases O using a heap Q as the method in Section 3.3. Thus, it can be shown (as in Section 5.3) that the number of “while” iterations is 
                           
                              O
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                           
                         where g is the number of grown tetrahedra and q
                        0 the number of tetrahedra in the initialization of heap Q. Furthermore, the complexity of one “while” iteration is 
                           
                              O
                              (
                              d
                              +
                              log
                              (
                              g
                              +
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              )
                              )
                           
                         as in Section 5.3. In the Repair case, 
                           
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              =
                              O
                              (
                              1
                              )
                           
                         (since 
                           
                              |
                              
                                 
                                    L
                                 
                                 
                                    i
                                 
                              
                              |
                              =
                              O
                              (
                              1
                              )
                           
                        ) and g
                        ⩽
                        g
                        0. We see that the complexity of one “Repair” is 
                           
                              O
                              (
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              log
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              )
                           
                        . There are 
                           
                              O
                              (
                              1
                              )
                           
                         uses of “Repair” for every critical edge since 
                           
                              |
                              
                                 
                                    L
                                 
                                 
                                    i
                                 
                              
                              |
                              =
                              O
                              (
                              1
                              )
                           
                        . Thus the complexity of all “Repair” uses is 
                           
                              O
                              (
                              
                                 
                                    wg
                                 
                                 
                                    0
                                 
                              
                              log
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              )
                           
                        . We conclude that the second removal method is 
                           
                              O
                              (
                              cm
                              +
                              
                                 
                                    wg
                                 
                                 
                                    0
                                 
                              
                              log
                              
                                 
                                    g
                                 
                                 
                                    0
                                 
                              
                              )
                           
                        .

Supplementary data associated with this article can be found, in the online version, at http: //dx.doi.org/10.1016/j.cviu.2013.08.002.


                     
                        
                           Supplementary Video 1
                           
                              The joint video (supplementary content) has three parts: catadioptric images (input) and the corresponding panoramic images, walkthough in the 3D model from pedestrian’s-eye views (the sky is not removed to obtain an immersive 3D model), full turn around the 3D model from bird’s-eye view (the sky is removed). Both textures and triangle normals are shown in colors.
                           
                           
                        
                     
                  

@&#REFERENCES@&#

