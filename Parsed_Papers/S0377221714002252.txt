@&#MAIN-TITLE@&#Loading, unloading and premarshalling of stacks in storage areas: Survey and classification

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Survey of loading, unloading, and premarshalling of stacks and combined problems.


                        
                        
                           
                           New classification scheme.


                        
                        
                           
                           Survey of complexity results, solution algorithms, and computational results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Loading

Unloading

Premarshalling

Storage

Stack

Classification scheme

@&#ABSTRACT@&#


               
               
                  Problems of loading, unloading and premarshalling of stacks as well as combinations thereof appear in several practical applications, e.g. container terminals, container ship stowage planning, tram depots or steel industry. Although these problems seem to be different at first sight, they hold plenty of similarities. To precisely unite all aspects, we suggest a classification scheme and show how problems existing in literature can be described with it. Furthermore, we give an overview of known complexity results and solution approaches.
               
            

@&#INTRODUCTION@&#

The interim storage of items in a storage area leads to different kinds of optimization problems. On the one hand, if incoming items arrive at a storage area, they need to be assigned to positions which causes loading problems. On the other hand, unloading problems arise if outgoing items need to be retrieved from the storage area and one has to decide which items will leave the storage in which order and which relocations are performed. Premarshalling occurs if items have to be sorted inside the storage area such that all items can be retrieved without any further reshuffle afterwards. If incoming items need to be stored while outgoing items need to be retrieved, combined loading/unloading problems appear.

In this paper, we concentrate on storage problems where the storage area is organized in stacks and items are put on top of each other in these stacks. Each stack may have a limited height and its own fixed position in a two-dimensional area. The items are assumed to be cuboids, e.g. containers or wooden/steel plates. Problems dealing with the storage of round items require another layout and other stacking conditions 
                        
                           (
                        
                     cf. Tang, Zhao, and Liu (2012) and Zäpfel and Wasner (2006)
                     
                        
                           )
                        
                     .

A storage area can either be a yard, a warehouse or a tram/bus depot, but also a container ship where containers are stored in the bunt. For a comparative survey of different stacking policies in container terminals see Dekker, Voogd, and van Asperen (2006). An overview of warehouse management problems and different warehousing models can be found in van den Berg and Zijm (1999). De Koster, Le-Duc, and Roodbergen (2007) provide a survey of how to retrieve items in high rack warehouses where items are stored in racks and accessible from the side. High rack warehouses with movable shelves are also called “puzzle-based storage systems” 
                        
                           (
                        
                     cf. Gue and Kim (2007) and Alfieri, Cantamessa, Monchiero, and Montagna (2012)
                     
                        
                           )
                        
                      since the problem of moving a shelf to the exit is similar to the so-called 15-puzzle (a classical children’s game).

In practice, all operations to move and get items are executed by cranes located above the stacks so that direct access is possible only to the topmost item of any stack, i.e. the items are arranged in LIFO-order (last in, first out). This implies that if an item stacked below has to be retrieved, so-called reshuffling (or relocation) is necessary. We assume that once a required item is the topmost item of a stack, it can be retrieved instantaneously. An example with two stacks and four items is given in Fig. 1
                     . If the gray item at the bottom of the left stack has to be retrieved, two reshuffling operations are needed to free this item. Since reshuffling operations are usually very time-consuming, they should be avoided as often as possible.


                     Loading problems deal with the storage of incoming items. Each item reaching the storage area has to be assigned to a feasible location. In a pure loading problem, it is assumed that no outgoing item is retrieved during the loading phase. Loading problems typically arise in container terminals where containers arrive by truck, train or vessel and have to be stored until they are required to be retrieved. Since the individual retrieval times of the items are usually unknown at the time of loading, the objective often aims at minimizing the number of expected reshufflings 
                        
                           (
                        
                     cf. Jang, Kim, and Kim (2013) and Kim, Park, and Ryu (2000)
                     
                        
                           )
                        
                     .


                     Unloading problems deal with the retrieval of items from a storage area. Depending on the type of problem one has either to define the order in which items are retrieved or decide which items are to retrieve in order to fulfil certain requests. Additionally, the way, how relocations are performed, has to be determined. In Fig. 2
                     , an example for an unloading problem with 8 items can be found. Given an area with four stacks, each limited to hold three items at the most, the items have to be retrieved in the order 
                        
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           8
                        
                     . In order to do this, 4 reshuffles are needed in total. This is the minimum number of reshuffles since item 4 needs to be reshuffled to get access to item 2, item 6 needs to be reshuffled to get access to item 3, item 8 needs to be reshuffled to get access to item 1 and no matter which stack item 8 will be reshuffled to, at least one more reshuffle becomes necessary.

In a pure unloading problem, it is assumed that there are no incoming items during the unloading phase. Many storage unloading problems are inspired by retrieving containers from container terminals to store them onto vessels, trains or trucks 
                        
                           (
                        
                     for an overview see e.g. Caserta, Schwarze, and Voß (2011a)
                     
                        
                           )
                        
                     . Other practical applications for storage unloading occur in steel industry or tram/bus depots. In the former, steel slabs are stored in stacks and have to be retrieved in a given order to a hot rolling mill. In the latter, items are stored on sidings with dead ends, so they can be modeled as (vertical) stacks, organized in LIFO-order. The waggons stored on the sidings have to be retrieved to join several waggons to one tram. Since access is only possible from one end of the siding, shunting might be necessary to retrieve a required waggon. For example, Blasum et al. (1999), Gallo and Di Miele (2001) and Gatto, Maue, Mihalák, and Widmayer (2009) deal with shunting problems in tram/bus depots. In both, steel industry and tram depots, items are often grouped into families. Then, a retrieval request does not ask for a specific item, but for any item of a specific family 
                        
                           (
                        
                     cf. for example Tang, Liu, Rong, and Yang (2002)
                     
                        
                           )
                        
                     .


                     Premarshalling problems occur if items inside a storage area have to be sorted such that they can be retrieved without any additional reshuffle afterwards. The difference to an unloading problem is that during premarshalling no item leaves the storage area, i.e. the area always contains the same set of items 
                        
                           (
                        
                     cf. for example Lee and Hsu (2007), Caserta and Voß (2009a) and Bortfeldt and Forster (2012)
                     
                        
                           )
                        
                     . In Fig. 3
                     , one can find an example for a premarshalling problem with 8 items. The initial layout is the same as in Fig. 2 with an area of four stacks each limited to hold at most three items. The items have to be sorted such that they can be retrieved in the order 
                        
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           8
                        
                     . This can again be done with 4 reshuffles in total (which is the minimum number of reshuffles, see the explanation above).


                     Combined problems mostly occur as a combination of loading and unloading, which means that new items arrive and need to be stored simultaneously to the retrieval process. Predominantly, combined problems can be found in container stowage planning where vessels are used to transport containers and call sequentially at several ports 
                        
                           (
                        
                     see e.g. Aslidis (1989) and Avriel, Penn, Shpirer, and Witteboon (1998)
                     
                        
                           )
                        
                     . The containers’ departure and destination ports are known in advance determining the loading and unloading processes, respectively. Other combined problems occur as a combination of loading and premarshalling 
                        
                           (
                        
                     see Malucelli, Pallottino, and Pretolani (2008)
                     
                        
                           )
                        
                     . In this case, several sets of incoming items have to be stored sequentially. During the loading process, premarshalling may be performed with the goal that at the end of the loading process all items can be retrieved without any additional reshuffle.

Since storage problems originate from a wide range of practical applications, a lot of scientific literature exists dealing with problems motivated from practice. Although these problems are described in different terms and notions, they share several similar features. For example, both in warehouses and in container yards, items are piled up on each other accessible from the top only. A main difference is that warehouses have higher stacks (30–40 items may be stacked in contrast to approximately 4–5 containers in a container yard) and handle much more items. Furthermore, the item flow of retrieving and storing is done in parallel while in container yards these operations are done one after another 
                        
                           (
                        
                     cf. Caserta et al. (2011a)
                     
                        
                           )
                        
                     .

Reviews dealing with various optimization problems in container terminals can be found in Vis and De Koster (2003), Carlo, Vis, and Roodbergen (2014a, 2014b), Steenken, Voß, and Stahlbock (2004); and Stahlbock and Voß (2008). Vis and De Koster (2003) give an overview of different processes at a container terminal involving the arrival, unloading and loading of a ship as well as the transport and stacking of containers. They deal with berth allocation for vessels, assignment of containers to locations, crane scheduling and vehicle routing problems. Further overviews have recently been published by Carlo et al. (2014a, 2014b). In the former, the authors propose a classification scheme for storage yard operations in container terminals including yard design, material handling equipment selection and routing, as well as storage space design. In the latter, the authors focus on transport operations such as selecting, routing and dispatching of vehicles. Another extensive survey can be found in Steenken et al. (2004). The authors provide detailed problem descriptions for different (sub) problems arising in container terminals involving a detailed literature review for each of the subproblems. An update can be found in Stahlbock and Voß (2008), additionally including an overview of integrative approaches like analytical, simulation and multi-agent approaches.


                     Bierwirth and Meisel (2010) focus on the berth allocation and crane scheduling problem and integrated approaches. In the former, different layouts, temporal constraints and objectives are considered. After the crane assignment has been done (i.e. cranes are assigned to vessels such that all tasks can be executed), the crane scheduling problem has to be solved defining starting and ending times for every task while usually minimizing the makespan. Integrated approaches avoid to solve these problems sequentially, but try to find a solution for the problem on the whole. The authors propose classification schemes for each of these three problems.

Crane scheduling problems in warehouses are treated in van den Berg and Gademann (1999). It is assumed that sets of incoming and outgoing items are given and their locations are known. The problem is to sequence the crane moves such that the total traveling distance is minimized. This problem is equivalent to the traveling salesman problem and hence in general is 
                        
                           NP
                        
                     -hard. However, in van den Berg and Gademann (1999) a special case of the TSP is identified which can be solved in polynomial time.

In the problems considered in the paper at hand, it is assumed that loaded containers have to be treated. The problem how to pack smaller three-dimensional items into a three-dimensional container is surveyed in Bortfeldt and Wäscher (2013). The authors classify problems into several problem types with various constraints, e.g. weight limits, loading priorities and stacking constraints. They give an overview of modeling approaches as well as exact and heuristic algorithms. Another survey for cutting and packing problems can be found in Wäscher, Haußner, and Schumann (2007). The authors describe the structure of cutting and packing problems and provide an improved typology on the basis of the typology suggested in Dyckhoff (1990). They differentiate several assortments, and categorize basic, intermediate and refined problem types.

In order to classify practical problems and existing literature, it is always helpful to have a clear (and more abstract) description combining all basic characteristics. Classification schemes have been proposed for several kinds of optimization problems 
                        
                           (
                        
                     e.g. Graham, Lawler, Lenstra, and Rinnooy Kan (1977) for machine scheduling, Desrochers, Lenstra, and Savelsbergh (1990) for vehicle routing and Boysen, Fliedner, and Scholl (2007) for assembly line balancing problems
                        
                           )
                        
                     . To the best of our knowledge, no such scheme exists for loading, unloading and premarshalling problems so far. In this paper, we suggest a scheme which is applicable to all three problem classes and combinations thereof. Its objective is to have a clear description combining the characteristics of problems considered in practice or literature in a unified way. Moreover, in combination with elementary reductions it simplifies drawing the borderline between 
                        
                           NP
                        
                     -hard and polynomially solvable problems.

The remainder of this paper is organized as follows: In Section 2, we describe basic problem variants and possible constraints more formally. A classification scheme is presented in Section 3 which is applied to existing literature in Section 4. There we summarize known complexity results and solution approaches for loading, unloading, premarshalling, combined and further problems. The paper concludes with some remarks in Section 5.

In this section, we describe the studied problems in more detail. In Section 2.1 we define the general storage layout and some basic assumptions. In Section 2.2 we discuss several ways how incoming and outgoing items may be specified. Different problem variants and constraints that occur in connection with loading, unloading and premarshalling problems are presented in Section 2.3.

We focus on problems where the storage area is arranged in stacks and each stack has its own fixed position in a two-dimensional area. This means that one cannot decide where to position a stack in the area but which stack to use for putting an item. In contrast, Jaehn (2013) considers a storage loading problem occuring in rail–road terminals where the storage area does not contain fixed positions for the stacks but is divided into parallel lanes. Then a stack can be opened at any (continuous) position in a lane with respect to safety distances.

Let 
                           
                              M
                              =
                              {
                              1
                              ,
                              …
                              ,
                              m
                              }
                           
                         be the set of stacks. The set of all items is denoted as 
                           
                              I
                              =
                              {
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              n
                              }
                           
                         where normally the inequality 
                           
                              m
                              <
                              n
                           
                         holds, i.e. some items have to be stacked on other ones. In practice, items might be of different size (e.g. 20-feet and 40-feet containers). Since containers with different lengths are usually not stored in the same subarea, we assume that all items have the same size. The items are moved by one or more cranes which are located above the stacks. Therefore, the cranes limit the height of the presented stacks so that one stack cannot hold more than a certain number b of items.

It is assumed that the stacks are arranged in a single line, i.e. the storage area is only 2-dimensional (although in reality it is 3-dimensional since the columns themselves are arranged in a 2-dimensional area). This is illustrated in Fig. 4
                        : While in (a) the 3-dimensional area is shown, the corresponding stacks are depicted in two dimensions in (b).

An item is said to be blocked if one or more items with later retrieval times (so-called blocking items) are stacked above it. To retrieve the current target item, all blocking items need to be removed from the current stack and pushed onto other ones until the target item is free (i.e. it is the topmost item). Moving an item from one stack to another is counted as one reshuffling (or relocation) operation.

In some applications 
                           
                              (
                           
                        e.g. Aslidis (1989) and Avriel et al. (1998)
                        
                           
                              )
                           
                        , the storage area is represented as a rectangular bay which is divided into C columns, each having R rows (levels) which are filled from the bottom level 
                           
                              r
                              =
                              1
                           
                         to the top level 
                           
                              r
                              =
                              R
                           
                        . Relating C and R to our notation, C defines the number of stacks m and R corresponds to the number of items in each stack, i.e. the height b.

In container terminals, items are usually stored in “bays” and “blocks” where a bay consists of several stacks and a block consists of several bays. If items are reshuffled within the same bay, the number of relocations is normally taken as measure of workload for the cranes. Since the distance between two bays of the same block or even two blocks is much higher than between items inside the same bay, one has to sum up the number of relocations and the traveling distances for the cranes. In this paper, we do not distinguish between relocations between bays and blocks. If problems with relocations between bays of the same block or different blocks have to be classified, the objective function will cover the number of relocations and transportation costs.

A very important feature of storage problems is the way how incoming and outgoing items are specified. In the following, we describe how this is typically done in practical applications (considering loading, unloading and combined problems).
                           
                              •
                              In loading problems, it is common to store a set of incoming items since for example a train containing several containers has to be unloaded. In this case, the sequence of storage operations does not matter, but all items in the set have to be loaded to the storage area.

A sequence of incoming sets is given if several trains arrive consecutively at the storage area and have to be unloaded in the order of their arrival. In this case, all items belonging to the same train have to be loaded before any item of another set can be stored.

In unloading problems, items often have to be retrieved in a predefined sequence given by the order in which trucks arrive or items are needed for production. A pure unloading problem where a sequence of items has to be retrieved while minimizing the total number of reshuffles, is also called blocks relocation problem (BRP), see e.g. Caserta et al. (2011a).

Another common feature is that a sequence of outgoing item sets is given 
                                    
                                       (
                                    
                                 named the container relocation problem (CRP) in Forster and Bortfeldt (2012a)
                                 
                                    
                                       )
                                    
                                 . A typical example is a container terminal where stowage plans of several container ships are given determining which vessel has to be loaded with which containers (but with unknown sequence for each vessel). Other practical applications are based on items which are grouped according to destination or customer, length or weight class and which have to be delivered consecutively in these groups.

Sometimes, a set of sequences may be of special interest. This applies for example in storehouses where (wooden) plates need to be delivered to two or more saws for cutting, with one sequence for every saw. In this case, the sequences themselves have to be respected but might be mixed in delivery (by determining a schedule for a single crane).

To get an overview of the different ways in which outgoing items can be specified, look at the example in Fig. 5
                                  where the retrieval of a sequence, a set, a sequence of sets and a set of sequences is illustrated. We assume that the storage area consists of three stacks each limited to hold at most three items. The initial storage layout is given in Fig. 5a.
                                    
                                       –
                                       In Fig. 5b, the retrieval process for the retrieval sequence 
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      out
                                                   
                                                
                                                =
                                                (
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                ,
                                                5
                                                ,
                                                6
                                                ,
                                                7
                                                )
                                             
                                           is depicted. It requires three reshuffles in total.

In Fig. 5c, two reshuffles are necessary to retrieve the set 
                                             
                                                
                                                   
                                                      I
                                                   
                                                   
                                                      out
                                                   
                                                
                                                =
                                                {
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                }
                                             
                                          . Since the order of retrievals does not matter in this case, item 4 can be retrieved at first. Afterwards, items 5 and 6 are reshuffled so that items 
                                             
                                                1
                                                ,
                                                2
                                             
                                           and 3 can be retrieved in any order.

In Fig. 5d we are given a set of sequences, 
                                             
                                                
                                                   
                                                      {
                                                      
                                                         
                                                            π
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      }
                                                   
                                                   
                                                      2
                                                   
                                                
                                                =
                                                {
                                                (
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                )
                                                ,
                                                (
                                                5
                                                ,
                                                6
                                                ,
                                                7
                                                )
                                                }
                                             
                                          , where the retrieval order for each sequence has to be respected. In this example, no reshuffle is necessary because items 5 and 6 can be retrieved first (respecting the order of 
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      out
                                                   
                                                
                                             
                                          ), items 
                                             
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                             
                                           are retrieved afterwards (respecting the order of 
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      out
                                                   
                                                
                                             
                                          ) and, finally, item 7 is retrieved (as last item of sequence 
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      out
                                                   
                                                
                                             
                                          ).

In Fig. 5e, we are given a retrieval sequence of sets, 
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      2
                                                   
                                                
                                                =
                                                (
                                                {
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                }
                                                ,
                                                {
                                                5
                                                ,
                                                6
                                                ,
                                                7
                                                }
                                                )
                                             
                                          . First, the set 
                                             
                                                {
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                }
                                             
                                           has to be retrieved (in any order) which requires two reshuffles. Second, set 
                                             
                                                {
                                                5
                                                ,
                                                6
                                                ,
                                                7
                                                }
                                             
                                           can be retrieved without any reshuffle.

In combined problems, sequences of sets are often given. For example, in the container stowage problem (CSP), a vessel is considered calling sequentially at K different ports. At each port, a set of containers needs to be retrieved from the vessel while another set of containers needs to be stored into it 
                                    
                                       (
                                    
                                 see e.g. Aslidis (1989) and Avriel and Penn (1993)
                                 
                                    
                                       )
                                    
                                 . So, we are given a sequence consisting of K entries, where each entry contains a tupel (set of outgoing items, set of incoming items). These sets can be extracted directly from the upper triangular transportation matrices 
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             ij
                                          
                                       
                                    
                                  which specify the number of containers going from port i to port j. In each row i, one can identify all items that have to be loaded at port i, in each column j, one can identify all items that have to be unloaded at port j. Consider the example in Fig. 6
                                  where a transportation matrix is given on the left and the corresponding sets of incoming and outgoing items are depicted on the right. The set of incoming items at port i is denoted by 
                                    
                                       
                                          
                                             I
                                          
                                          
                                             i
                                          
                                          
                                             in
                                          
                                       
                                    
                                 , the set of outgoing items at port j is denoted by 
                                    
                                       
                                          
                                             I
                                          
                                          
                                             j
                                          
                                          
                                             out
                                          
                                       
                                    
                                 . If h items are going from port i to port j, they will be named 
                                    
                                       
                                          
                                             ij
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             ij
                                          
                                          
                                             h
                                          
                                       
                                    
                                 .

In this subsection, we describe variants and additional constraints that occur in loading, unloading and premarshalling problems.
                           
                              •
                              
                                 Pushing back items: After having retrieved the current target item, two procedures are conceivable. It is either possible to push-back all reshuffled items so that the stack is in the same order as before except the missing retrieved item, or to let the items stay in the stacks they have been pushed onto 
                                    
                                       (
                                    
                                 cf. Tang et al. (2002)
                                 
                                    
                                       )
                                    
                                 . In the former, the items are pushed back immediately after the target item has been retrieved. Relocating an item and pushing it back is counted as two reshuffle moves. In the example of Fig. 1, pursuing push-back will enforce putting back the two reshuffled items to the first stack after having retrieved the gray one. Although in the push-back strategy additional relocations are necessary, sometimes this procedure is preferred (e.g. if some items may only be stored in certain stacks or to avoid that items change their initially assigned stacks).


                                 Forced vs. voluntary moves: For storage loading and unloading problems two kinds of reshuffling moves are distinguished 
                                    
                                       (
                                    
                                 cf. Caserta, Schwarze, and Voß (2012)
                                 
                                    
                                       )
                                    
                                 : forced and voluntary ones 
                                    
                                       (
                                    
                                 also called “cleaning moves” in Petering and Hussein (2013)
                                 
                                    
                                       )
                                    
                                 . In an unloading problem, forced moves only reshuffle blocking items in order to retrieve the next outgoing item, while voluntary moves allow relocations of arbitrary items. In a loading problem, forced moves only handle incoming items (and put them on top of a stack), while voluntary moves may relocate arbitrary items (by this, incoming items may also be put inside a stack). The notions do not apply for pure premarshalling problems since there are no incoming or outgoing items. In combined loading/premarshalling problems, the distinction between forced and voluntary moves may be used in the loading phase.

To differentiate between strategies that only use forced moves or additionally allow voluntary moves, we give a small example of unloading stacks. Consider a storage area consisting of three stacks each able to hold at most three items. The items are numbered according to the sequence in which they have to be retrieved. In a rather simple strategy for relocations, a blocking item will be put on the nearest stack which does not contain three items yet. If several such stacks are available, the stack with the highest number of the topmost item will be chosen to avoid further relocations (this might not be the best strategy but suffices for this small example). If the current target item is freed, it will be retrieved immediately.

Consider the retrieval process in Fig. 7
                                  where the items have to be retrieved in the order 
                                    
                                       1
                                       ,
                                       2
                                       ,
                                       …
                                       ,
                                       6
                                    
                                  and only forced moves are allowed. In the first step, items 4 and 3 are put on the stack nearby to free item 1. After item 1 has been retrieved, items 3 and 4 have to be reshuffled again to get access to item 2. Since afterwards items 2, 3 and 4 can be retrieved without any further relocation, there is only one more reshuffle to provide access to item 5. In total, 5 relocation moves are needed to retrieve the six items in sequence.

If also voluntary moves are allowed, only 4 relocations are needed in total (cf. Fig. 8
                                 ): in the first step, put item 2 on the third stack such that items 4 and 3 do not block it on stack two. Afterwards, items 1 to 4 can be retrieved without any further relocations such that only one more reshuffle is needed to free item 5.

As the example shows, using voluntary moves may lead to a reshuffling process with less relocations. However, often in practice and in most of the literature only forced moves are considered in order to simplify the process and reduce the number of possible movements in each step.


                                 Grouping of items into families: In many problems, all items are assumed to be unique. But it is also possible that items of the same specifications are grouped into item families. This situation arises in warehousing of wooden plates or iron sheets where several plates of same size and type of wood/iron may exist 
                                    
                                       (
                                    
                                 see e.g. Tang et al. (2012)
                                 
                                    
                                       )
                                    
                                 . Other practical applications where items occur in families can be found in tram yards/railway stations 
                                    
                                       (
                                    
                                 cf. Blasum et al. (1999) and Freling, Lentink, Kroon, and Huisman (2005), for example
                                    
                                       )
                                    
                                 . If we look at an unloading problem where items are grouped into families and the retrieval asks for one specific family, all items of that family serve as potential candidates for retrieval. In this situation, one has to decide which candidate will be chosen. In Fig. 9
                                  an example for an unloading problem with families is shown. We assume that the sequence 
                                    
                                       
                                          
                                             π
                                          
                                          
                                             out
                                          
                                       
                                       =
                                       (
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       ,
                                       4
                                       )
                                    
                                  of outgoing items has to be retrieved. On the left, the storage area contains two stacks each able to hold at most three items. In this case, all items are unique so that three reshuffles are needed to retrieve the items in the given sequence. On the right, items are grouped into families. We assume that there are four families 
                                    
                                       
                                          
                                             F
                                          
                                          
                                             i
                                          
                                       
                                    
                                  with 
                                    
                                       
                                          
                                             F
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       {
                                       
                                          
                                             i
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             i
                                          
                                          
                                             2
                                          
                                       
                                       }
                                    
                                  for 
                                    
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       4
                                    
                                 . In each step i of retrieving, we can choose 
                                    
                                       
                                          
                                             i
                                          
                                          
                                             1
                                          
                                       
                                    
                                  or 
                                    
                                       
                                          
                                             i
                                          
                                          
                                             2
                                          
                                       
                                    
                                  to retrieve one element from family 
                                    
                                       
                                          
                                             F
                                          
                                          
                                             i
                                          
                                       
                                    
                                 . Thus, if we choose the sequence 
                                    
                                       (
                                       
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             2
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       
                                          
                                             3
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             4
                                          
                                          
                                             2
                                          
                                       
                                       )
                                    
                                 , one can retrieve all items in the desired sequence without any reshuffle.


                                 An additional temporary storage area: In some problems, a temporary storage area is available for the interim storage of items that need to be removed from the stack to retrieve the current target item. If the temporary storage area is large enough, sorting can easily be done since every item can be assigned to an own stack in the temporary storage area and all items can be pushed back to the stack in a sorted order. In this case, putting an item to the temporary storage area and pushing it back is counted as two relocation moves. For example, such an (unlimited) temporary storage area is often implicitly assumed in combined problems where a vessel calls at many ports in sequence (each port has such an area) and in problems where the storage area contains only one stack since otherwise no reshuffling would be possible 
                                    
                                       (
                                    
                                 cf. Malucelli et al. (2008)
                                 
                                    
                                       )
                                    
                                 .


                                 Stacking restrictions have to be respected if not every item may be stacked on any other item (for example, an item with a larger weight may not be stacked on top of a lighter one).


                                 Location restrictions: Sometimes, especially in container stowage planning, items may only be placed to some of the locations (described by tuples 
                                    
                                       (
                                       stack
                                       ,
                                       level
                                       )
                                    
                                 ) in the stacking area. For example, reefer containers need a power plug, so only locations with an appropriate configuration are possible for storage. Such location restrictions may be given as hard or soft constraints.


                                 Objective functions: Various objective functions arise in storage loading or unloading problems. Typically, reshuffles are very time-consuming and therefore form the bottleneck of storage processes. That is why it is conventional to minimize the number of reshuffles. In storage loading problems where retrieval times are unknown but can be estimated by a probability distribution, the number of expected reshuffles often serves as objective.

Sometimes, not the exact number of required reshuffles is determined but a lower bound value. For this purpose, “unordered stackings” are counted (e.g. the total number of blocking items with respect to retrieval times). As another objective, one may want to minimize costs for assigning items to specific locations, e.g. given by travel costs or penalty costs for violated (soft) location restrictions. A further possibility is to penalize assignments where items belonging to the same ship or having the same destination port are not stored nearby.

The minimization of hatch overstows is a further objective which occurs in the context of container ship stowage planning. The storage area inside a ship is separated in “below deck” and “on deck” by so-called hatches. If a container below deck has to be retrieved, all containers on the hatch have to be removed first. Therefore, overstowage between containers below and on deck should be avoided 
                                    
                                       (
                                    
                                 cf. Tierney, Pacino, and Jensen (2014)
                                 
                                    
                                       )
                                    
                                 .

In this section we propose a classification scheme which is applicable to loading, unloading, premarshalling problems and combinations thereof. Its objective is to have a clear and abstract description combining characteristics of the most common problems considered in practice or literature. It is designed in such a way that it is easily extendable to capture additional hard or soft constraints for further (more specific) problems. Additionally, we present some elementary reductions which in combination with known complexity results imply further results. If on the one hand, a problem is polynomially solvable, also all special cases are polynomially solvable. If on the other hand, a problem is 
                        
                           NP
                        
                     -hard, then also all generalizations are 
                        
                           NP
                        
                     -hard.

The scheme we suggest consists of three fields 
                        
                           α
                           |
                           β
                           |
                           γ
                        
                     . The 
                        
                           α
                        
                     -field specifies the problem type (loading/unloading, premarshalling, combined problem) and contains information about the parameters describing the storage area, e.g. number of stacks and their maximum stacking height. The 
                        
                           β
                        
                     -field includes details of the items themselves, e.g. stacking restrictions or other additional constraints, where at last the 
                        
                           γ
                        
                     -field holds the objective function. The empty symbol 
                        
                           ∘
                        
                      is always used to represent the standard situation.


                     The 
                     
                        
                           α
                        
                     
                     -field
                  

The first parameter in the 
                        
                           α
                        
                     -field is 
                        
                           
                              
                                 α
                              
                              
                                 1
                              
                           
                           ∈
                           {
                           L
                           ,
                           U
                           ,
                           P
                           ,
                           LU
                           ,
                           LP
                           }
                        
                     . It states whether we look at a loading, unloading, premarshalling or combined (loading/unloading or loading/premarshalling) problem.
                        
                           
                              
                                 
                                    α
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                L
                                             
                                             
                                                if
                                                
                                                a
                                                
                                                loading
                                                
                                                problem
                                                
                                                is
                                                
                                                considered
                                                ,
                                             
                                          
                                          
                                             
                                                U
                                             
                                             
                                                if
                                                
                                                an
                                                
                                                unloading
                                                
                                                problem
                                                
                                                is
                                                
                                                considered
                                                ,
                                             
                                          
                                          
                                             
                                                P
                                             
                                             
                                                if
                                                
                                                a
                                                
                                                premarshalling
                                                
                                                problem
                                                
                                                is
                                                
                                                considered
                                                ,
                                             
                                          
                                          
                                             
                                                LU
                                             
                                             
                                                if
                                                
                                                a
                                                
                                                combined
                                                
                                                loading
                                                /
                                                unloading
                                                
                                                problem
                                                
                                                is
                                                
                                                considered
                                                ,
                                             
                                          
                                          
                                             
                                                LP
                                             
                                             
                                                if
                                                
                                                a
                                                
                                                combinedloading
                                                /
                                                premarshalling
                                                
                                                problem
                                                
                                                is
                                                
                                                considered
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     A LP problem is defined as loading items in several stages such that at the end of the complete loading process, all items can be retrieved without any additional reshuffle. During loading, premarshalling is allowed. Note that it does not make sense to define a combined premarshalling/unloading problem in an analogous way since it decomposes into several independent premarshalling problems.

To specify the parameters of the storage area, we use
                        
                           
                              
                                 
                                    α
                                 
                                 
                                    2
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                m
                                                =
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             
                                                if
                                                
                                                the
                                                
                                                number
                                                
                                                m
                                                
                                                of
                                                
                                                stacks
                                                
                                                is
                                             
                                          
                                          
                                             
                                             
                                                
                                                equal
                                                
                                                to
                                                
                                                a
                                                
                                                fixed
                                                
                                                number
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                ∈
                                                N
                                                ,
                                             
                                          
                                          
                                             
                                                m
                                                ⩾
                                                n
                                             
                                             
                                                if
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                stacks
                                                
                                                is
                                                
                                                larger
                                                
                                                or
                                             
                                          
                                          
                                             
                                             
                                                
                                                equal
                                                
                                                to
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                items
                                                ,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                if
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                stacks
                                                
                                                m
                                                
                                                is
                                             
                                          
                                          
                                             
                                             
                                                
                                                given
                                                
                                                as
                                                
                                                part
                                                
                                                of
                                                
                                                the
                                                
                                                input
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     and
                        
                           
                              
                                 
                                    α
                                 
                                 
                                    3
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                b
                                                =
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             
                                                if
                                                
                                                the
                                                
                                                limit
                                                
                                                b
                                                
                                                on
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                items
                                                
                                                in
                                                
                                                each
                                                
                                                stack
                                                
                                                is
                                                
                                                given
                                                
                                                by
                                                
                                                a
                                                
                                                fixed
                                                
                                                number
                                                
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                ∈
                                                N
                                                ,
                                             
                                          
                                          
                                             
                                                b
                                                =
                                                ∞
                                             
                                             
                                                if
                                                
                                                no
                                                
                                                limit
                                                
                                                on
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                items
                                                
                                                in
                                                
                                                each
                                                
                                                stack
                                                
                                                is
                                                
                                                given
                                                ,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                if
                                                
                                                the
                                                
                                                limit
                                                
                                                b
                                                
                                                on
                                                
                                                the
                                                
                                                number
                                                
                                                of
                                                
                                                items
                                                
                                                in
                                                
                                                each
                                                
                                                stack
                                                
                                                is
                                                
                                                given
                                                
                                                as
                                                
                                                part
                                                
                                                of
                                                
                                                theinput
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     The distinction whether m and b are part of the input or are fixed values may be important for complexity considerations. For example, if m is fixed, an algorithm with complexity 
                        
                           O
                           (
                           
                              
                                 n
                              
                              
                                 m
                              
                           
                           )
                        
                      can be classified as polynomial. Besides writing 
                        
                           m
                           =
                           2
                        
                      or 
                        
                           m
                           =
                           3
                        
                      with a specific number we also write 
                        
                           m
                           =
                           
                              
                                 m
                              
                              
                                 ′
                              
                           
                        
                      in order to indicate that m is an arbitrary, but fixed value.

In order to specify the size of a temporary storage area, we use
                        
                           
                              
                                 
                                    α
                                 
                                 
                                    4
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      tmp
                                                   
                                                
                                                =
                                                (
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                ,
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                )
                                             
                                             
                                                if
                                                
                                                a
                                                
                                                temporary
                                                
                                                storage
                                                
                                                area
                                                
                                                consisting
                                                
                                                of
                                             
                                          
                                          
                                             
                                             
                                                
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                
                                                stacks
                                                
                                                with
                                                
                                                limit
                                                
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                
                                                is
                                                
                                                available
                                                ,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                if
                                                
                                                no
                                                
                                                temporary
                                                
                                                storage
                                                
                                                area
                                                
                                                is
                                                
                                                available
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     Fig. 10
                      shows elementary (polynomial-time) reductions between the entries of the parameters 
                        
                           
                              
                                 α
                              
                              
                                 2
                              
                           
                        
                      to 
                        
                           
                              
                                 α
                              
                              
                                 4
                              
                           
                        
                     . In this graph there is an arc between two possible entries 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           ,
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ″
                              
                           
                        
                      of one parameter 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                           
                        
                      if 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                        
                      reduces to 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ″
                              
                           
                        
                      (i.e. 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                        
                      is a special case of 
                        
                           
                              
                                 α
                              
                              
                                 i
                              
                              
                                 ″
                              
                           
                        
                     ).


                     The 
                     
                        
                           β
                        
                     
                     -field
                  

As described in Section 2, incoming and outgoing items can be specified either as a sequence, a set, a sequence of sets or a set of sequences.

For loading problems we use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      in
                                                   
                                                
                                             
                                             
                                                if a sequence of incoming items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      I
                                                   
                                                   
                                                      in
                                                   
                                                
                                             
                                             
                                                if a set of incoming items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            in
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      K
                                                   
                                                
                                             
                                             
                                                if a sequence of length
                                                
                                                K
                                                
                                                containing sets
                                             
                                          
                                          
                                             
                                             
                                                of incoming items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      {
                                                      
                                                         
                                                            π
                                                         
                                                         
                                                            in
                                                         
                                                      
                                                      }
                                                   
                                                   
                                                      K
                                                   
                                                
                                             
                                             
                                                if a set of
                                                
                                                K
                                                sequences of incoming items is given.
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Note that 
                        
                           
                              
                                 π
                              
                              
                                 in
                              
                           
                        
                      is a special case of 
                        
                           
                              
                                 (
                                 
                                    
                                       I
                                    
                                    
                                       in
                                    
                                 
                                 )
                              
                              
                                 K
                              
                           
                        
                      where each set 
                        
                           
                              
                                 I
                              
                              
                                 in
                              
                           
                        
                      only contains one element. Obviously, 
                        
                           
                              
                                 I
                              
                              
                                 in
                              
                           
                        
                      and 
                        
                           
                              
                                 π
                              
                              
                                 in
                              
                           
                        
                      are special cases of 
                        
                           
                              
                                 (
                                 
                                    
                                       I
                                    
                                    
                                       in
                                    
                                 
                                 )
                              
                              
                                 K
                              
                           
                        
                      and 
                        
                           
                              
                                 {
                                 
                                    
                                       π
                                    
                                    
                                       in
                                    
                                 
                                 }
                              
                              
                                 K
                              
                           
                        
                     , respectively with 
                        
                           K
                           =
                           1
                        
                     .

For unloading problems we use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      out
                                                   
                                                
                                             
                                             
                                                if a sequence of outgoing items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      I
                                                   
                                                   
                                                      out
                                                   
                                                
                                             
                                             
                                                if a set of outgoing items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      K
                                                   
                                                
                                             
                                             
                                                if a sequence of length
                                                
                                                K
                                                
                                                containing sets of
                                             
                                          
                                          
                                             
                                             
                                                outgoing items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      {
                                                      
                                                         
                                                            π
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      }
                                                   
                                                   
                                                      K
                                                   
                                                
                                             
                                             
                                                if a set of
                                                
                                                K
                                                
                                                sequences of outgoing items is given.
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     In unloading problems where items are grouped in families, a subscripted 
                        
                           F
                        
                      will be added, so that we have 
                        
                           
                              
                                 π
                              
                              
                                 F
                              
                              
                                 out
                              
                           
                        
                     . The special case of disjoint families is indicated by 
                        
                           
                              
                                 π
                              
                              
                                 disj
                                 -
                                 F
                              
                              
                                 out
                              
                           
                        
                     . If the retrieval times of items are unknown and estimated by past statistics, we will use 
                        
                           
                              
                                 
                                    
                                       π
                                    
                                    
                                       ̃
                                    
                                 
                              
                              
                                 out
                              
                           
                        
                      to indicate a stochastic output sequence.

For combined loading/unloading problems, often several iterations of loading/unloading take place. We use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      in
                                                   
                                                
                                                ,
                                                
                                                   
                                                      π
                                                   
                                                   
                                                      out
                                                   
                                                
                                                )
                                             
                                             
                                                if at first one sequence of incoming items and
                                             
                                          
                                          
                                             
                                             
                                                afterwards one sequence of outgoing items is given,
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            in
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      K
                                                   
                                                
                                                ,
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      
                                                         
                                                            K
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                if at first one sequence of length
                                                
                                                K
                                             
                                          
                                          
                                             
                                             
                                                containing sets of incoming items and
                                             
                                          
                                          
                                             
                                             
                                                afterwards one sequence of length
                                                
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                                containing sets of outgoing items is given,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            in
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            I
                                                         
                                                         
                                                            out
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      K
                                                   
                                                
                                             
                                             
                                                if a sequence of length
                                                
                                                K
                                             
                                          
                                          
                                             
                                             
                                                containing sets of incoming and outgoing items is given.
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Note that in the third case some of the sets may also be empty (i.e. we may have several incoming or outgoing sets consecutively). For combined loading/premarshalling problems, no combination of incoming and outgoing items occurs (specifying the incoming items is sufficient in this case).

Stacking restrictions may be encoded by a 2-dimensional matrix 
                        
                           S
                           ∈
                           
                              
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                              
                                 n
                                 ×
                                 n
                              
                           
                        
                      where
                        
                           
                              
                                 
                                    s
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                if item
                                                
                                                i
                                                
                                                is stackable on top of item
                                                
                                                j
                                                ,
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     In the classification scheme we use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    2
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      s
                                                   
                                                   
                                                      ij
                                                   
                                                
                                             
                                             
                                                if stacking restrictions have to be respected,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Sometimes, items may have additional characteristics like weights or heights. Then, in addition to the number b that limits the number of items in each stack, one has a height or weight limit for each stack. We use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    3
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                weight
                                                -
                                                limit
                                             
                                             
                                                if the total weight of each stack is limited,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     and
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    4
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                height
                                                -
                                                limit
                                             
                                             
                                                if the total height of each stack is limited,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Note that if all items are of the same height, it is sufficient to specify the limit b. 
                        
                           
                              
                                 β
                              
                              
                                 4
                              
                           
                           =
                           height
                           -
                           limit
                        
                      is only used if items have different heights. In this case, 
                        
                           
                              
                                 α
                              
                              
                                 3
                              
                           
                        
                      can either contain 
                        
                           b
                           =
                           ∞
                        
                      or a limited b. In the former, only the height-limit has to be respected while in the latter, each stack has to respect the height-limit and the limit b for the number of items.

If location restrictions have to be respected, we may assume that for each item i a set 
                        
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                        
                      is given which contains all locations in the storage area to which i may be assigned. We use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    5
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                             
                                                if location restrictions for the items are given,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     In storage loading and unloading problems, forced moves are always allowed. To indicate whether also voluntary moves are allowed, we use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    6
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                v
                                                -
                                                moves
                                             
                                             
                                                if voluntary moves are allowed,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     To denote that items have to be pushed back after they have been reshuffled to retrieve a target item, we use
                        
                           
                              
                                 
                                    β
                                 
                                 
                                    7
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                push
                                                -
                                                back
                                             
                                             
                                                if items have to be pushed back,
                                             
                                          
                                          
                                             
                                                ∘
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     Fig. 11
                      shows elementary (polynomial-time) reductions for the 
                        
                           β
                        
                     -field.


                     The 
                     
                        
                           γ
                        
                     
                     -field
                  

The 
                        
                           γ
                        
                     -field involves the objective function:
                        
                           •
                           
                              
                                 
                                    -
                                 
                              : Decide whether a feasible solution for the given problem exists.


                              
                                 
                                    #
                                    RS
                                 
                              : Minimize the number of reshuffles.


                              
                                 
                                    #
                                    RS
                                    =
                                    0
                                 
                              : Decide whether the problem can be solved without any reshuffles.


                              
                                 
                                    E
                                    (
                                    #
                                    RS
                                    )
                                 
                              : Minimize the expected number of reshuffles. This applies to problems where the retrieval times are unknown but can be estimated by a probability distribution.


                              TC: Minimize transportation costs, mostly given as workload for cranes. The workload consists of the time needed to lift up and lower down an item, the time needed per shuffle and the time to retrieve an item.


                              
                                 
                                    #
                                    US
                                 
                              : Minimize the number of unordered stackings (sometimes also called “mis-overlays” or “overstowage”) with respect to retrieval orders given by 
                                 
                                    
                                       
                                          π
                                       
                                       
                                          out
                                       
                                    
                                 
                               or 
                                 
                                    
                                       
                                          (
                                          
                                             
                                                I
                                             
                                             
                                                out
                                             
                                          
                                          )
                                       
                                       
                                          K
                                       
                                    
                                 
                              . In the following, we present different possibilities to measure unordered stackings. For illustration we use the example in Fig. 12
                               where the items have to be retrieved according to non-decreasing numbers.
                                 
                                    –
                                    
                                       
                                          
                                             #
                                             
                                                
                                                   US
                                                
                                                
                                                   adj
                                                
                                             
                                          
                                       : Every two adjacent items in a stack are counted as unordered if the upper item blocks the lower one. It is easy to see that this number is a lower bound on the total number of reshuffles in order to retrieve all items in a given sequence 
                                          
                                             (
                                          
                                       i.e. for the BRP, cf. Voß (2012)
                                       
                                          
                                             )
                                          
                                       . In the example, in the left stack item 3 blocks item 1; in the right stack, item 6 blocks item 5 which in turn blocks item 4. Therefore, 
                                          
                                             #
                                             
                                                
                                                   US
                                                
                                                
                                                   adj
                                                
                                             
                                             =
                                             3
                                          
                                       .


                                       
                                          
                                             #
                                             
                                                
                                                   US
                                                
                                                
                                                   dep
                                                
                                             
                                          
                                       : For each stack we determine the largest depth (counted from above where the top element is assumed to have depth 0) in which a blocked item occurs. The sum of these depths gives a lower bound on the total number of reshuffles in a premarshalling problem 
                                          
                                             (
                                          
                                       cf. Lee and Chao (2009)
                                       
                                          
                                             )
                                          
                                       . In the example, the depth is 1 for the left stack (item 1 in depth 1 is the deepest blocked item). In the right stack, the depth is 3 (caused by item 4). Therefore, the sum amounts to 
                                          
                                             #
                                             
                                                
                                                   US
                                                
                                                
                                                   dep
                                                
                                             
                                             =
                                             4
                                          
                                       .


                                       
                                          
                                             E
                                             (
                                             #
                                             
                                                
                                                   US
                                                
                                                
                                                   adj
                                                
                                             
                                             (
                                             
                                                
                                                   w
                                                
                                                
                                                   ̃
                                                
                                             
                                             )
                                             )
                                          
                                       : Minimize the number of expected unordered stackings with respect to estimated weights 
                                          
                                             
                                                
                                                   w
                                                
                                                
                                                   ̃
                                                
                                             
                                          
                                        of the items. This objective occurs in some loading problems where the weight (or weight group) of an arriving item is uncertain and estimated by past statistics. Since often heavier containers have to be retrieved earlier (e.g. when storing them on a ship afterwards), they should not be stacked below lighter ones.


                              
                                 
                                    #
                                    HO
                                 
                              : Minimize the number of hatch overstows. One hatch overstow occurs if items are stored on a hatch and have to be removed to retrieve an item below it.


                              f: Minimize a given objective function f.

The introduced functions can be considered independently or in a combined way. For example, 
                        
                           
                              
                                 w
                              
                              
                                 1
                              
                           
                           #
                           RS
                           +
                           
                              
                                 w
                              
                              
                                 2
                              
                           
                           TC
                        
                      denotes a weighted sum of the number of reshuffles and transportation costs with associated weights 
                        
                           
                              
                                 w
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 w
                              
                              
                                 2
                              
                           
                           ⩾
                           0
                        
                     .

@&#LITERATURE REVIEW@&#

In this section, we give an overview of different versions of storage problems regarded in literature and point out some similarities and differences. First, the more common problems (i.e. basic problems which have been considered by several authors) are discussed and summarized in tables using the notation introduced in Section 3. Afterwards, extended problem variants are described.

In the following subsections we summarize complexity results, solution algorithms and computational results for loading (Section 4.1), unloading (Section 4.2) and and premarshalling (Section 4.3) of stacks and combinations thereof (Section 4.4). Finally, in Section 4.5 further problems are surveyed.

Since several basic problem versions are already proven to be 
                        
                           NP
                        
                     -hard, most practical problems are also assumed to be hard to solve. Therefore, often MIP formulations and heuristic approaches are proposed. Used abbreviations for solution methods are summarized in Table 1
                     .

This subsection is concerned with loading problems which fit into our classification scheme, i.e. deal with the assignment of incoming items to locations in stacks (described by tupels 
                           
                              (
                              stack
                              ,
                              level
                              )
                           
                        ). No complexity results exist, an overview of solution approaches can be found in Table 2
                        
                        
                           
                              )
                           
                        . Beyond that, several other loading problems have been tackled which we will describe in Section 4.5 offering an enlarged view at loading in general.


                        Kim et al. (2000) consider a loading problem where a sequence of containers needs to be stored in a storage yard. The authors assume that each item belongs to one of three weight groups but at the time of arrival the weight group is not known. After having stored the items inside the storage area, they have to be put onto a vessel. Since the heavier ones have to be put in the bottom of the vessel (due to stability constraints), they have to be retrieved earlier from the storage area. Therefore, they should not be put below items that are retrieved later. The distribution of the weight groups is estimated from empirical data and used to determine the storage slot for an arriving container minimizing the expected number of relocations. A dynamic programming approach has been developed based on the probability of the weight group of the next arriving item. The number of expected relocations is computed taking into account this arrival probability and the marginal expected number of movements that become necessary if an item of a specific weight group is assigned to a specific stack. Zhang, Chen, Shi, and Zheng (2010) showed that the objective function contains an error and corrected it.


                        Kang, Ryu, and Kim (2006b) tackle a similar problem where the arriving items have uncertain weight information and a probability distribution from past statistics is used. They provide a simulated annealing algorithm to find a good stacking strategy regarding different stack types of different weight combinations. The stacking strategy is evaluated by applying it to a simulation environment which randomly generates a sequence of incoming items according to the probability distributions of the weight classes. Afterwards, the stacking strategy is applied to the sequence. The number of expected relocations for unloading all items is calculated by using the conditional probability of the actual weight group given an estimated weight group. For further improvement, they applied a decision tree learning algorithm.

Another version of a loading problem has been tackled by Delgado, Jensen, Janstrup, Høyer Rose, and Høj Andersen (2012). The storage area is a container ship that needs to be loaded with a set of items. According to the vessel’s stability, weight and height restrictions are given for each stack and since some containers need a power plug, there are location restrictions as well. The objective function f is a weighted sum of four components penalizing unordered stackings, storing different kinds of containers in the same stack, opening a stack and storing non-reefer containers in a power plug location. The authors show that the subproblem of minimizing the number of opened stacks is already 
                           
                              NP
                           
                        -hard (reduction from the bin-packing problem). They further provide an integer programming and a constraint programming model to calculate lower bounds by solving relaxed versions of a subproblem. Experimental results showed that the constraint programming model performs better (more instances solved and smaller computation times).

This subsection is concerned with unloading problems. We start with complexity results, which are summarized in Table 3
                        .

The basic unloading problem is the so-called blocks relocation problem (BRP) or container relocation problem (CRP). Here, a sequence 
                           
                              
                                 
                                    π
                                 
                                 
                                    out
                                 
                              
                           
                         or a sequence of sets 
                           
                              
                                 
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          out
                                       
                                    
                                    )
                                 
                                 
                                    K
                                 
                              
                           
                         is given determining the priorities for the retrieval of the items (the second case corresponds to the more general situation where several items may have the same priority). The objective is to minimize the number 
                           
                              #
                              RS
                           
                         of reshuffles.

The BRP with a sequence 
                           
                              
                                 
                                    π
                                 
                                 
                                    out
                                 
                              
                           
                         is studied in two versions in Caserta et al. (2012). The authors differentiate between using only forced moves or also allowing voluntary moves. They provide an upper bound for the number of reshufflings and prove that both versions of the problems are 
                           
                              NP
                           
                        -hard by a reduction from Mutual Exclusion Scheduling (MES) 
                           
                              (
                           
                        cf. Jansen (2003)
                        
                           
                              )
                           
                        . On the other hand, the problem becomes trivial if the number of stacks is greater than the number of items (i.e. 
                           
                              m
                              ⩾
                              n
                           
                         holds).

In Blasum et al. (1999) families of items are considered. Here, tram waggons of different types have to be retrieved from a depot in a given type sequence. Deciding whether an assignment without any reshuffles exists is shown to be 
                           
                              NP
                           
                        -complete for 
                           
                              b
                              =
                              3
                           
                         by a reduction from 3-dimensional matching (3DM). However, if the number of stacks is fixed (i.e. 
                           
                              m
                              =
                              
                                 
                                    m
                                 
                                 
                                    ′
                                 
                              
                           
                         holds), the decision problem is polynomially solvable in 
                           
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    
                                       
                                          m
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              )
                           
                         by dynamic programming even in the more general situation where the stacks may have different heights.


                        Malucelli et al. (2008) consider a rather different problem since they assume that there is only one stack and an unlimited temporary stacking area for reshuffling. They propose an optimal unloading strategy which is able to solve the problem in polynomial time.

Next, we survey solution methods and computational results for loading problems, which are summarized in Table 4
                        . Kim and Hong (2006) tackled the BRP where a sequence 
                           
                              
                                 
                                    π
                                 
                                 
                                    out
                                 
                              
                           
                         or a sequence of sets 
                           
                              
                                 
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          out
                                       
                                    
                                    )
                                 
                                 
                                    K
                                 
                              
                           
                         is given. They propose a branch-and-bound algorithm with the initial state of the storage area as root node. Each node in level l represents the area’s state after l items have been retrieved. In each step, the depth-first search algorithm chooses a node in the highest level with a minimum lower bound (computed as the sum of reshuffles needed to obtain the current state plus the number of unordered stackings 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    adj
                                 
                              
                           
                        ). Additionally, the authors developed a heuristic rule based on the expected number of additional relocations, called ENAR. The expected additional relocations are estimated using the probability that an item with a certain priority will be pushed onto a stack which either causes or does not cause one more relocation.

The same problem has also been tackled by Wan, Liu, and Tsai (2009). The authors offer an integer programming model and an IP-based heuristic method which they compare to other heuristics 
                           
                              (
                           
                        
                        Zhang, 2000; Murty, Liu, Wan, and Linn, 2005; Kim and Hong, 2006
                        
                           
                              )
                           
                        . In conclusion, their heuristic took larger computational times for large stacks but reduced the number of reshuffles.


                        Ünlüyut and Aydin (2012) adopted the idea of the branch-and-bound algorithm proposed by Kim and Hong (2006) and proposed a modification that leads to fewer nodes. They further involved another objective function which, in addition to the number of relocations, takes into account transportation costs (modeled as horizontal moves). For both objectives, two heuristic approaches have been developed. First, a greedy approach Greedy that always chooses a child node with the best lower bound (calculated as the sum of movements already done plus the number of movements that are unavoidable due to unordered stackings). Second, a heuristic that tries to relocate to stacks where as few further relocations as possible will occur (named Difference). Computational results have shown that the branch-and-bound algorithm is able to solve larger instances than the branch-and-bound algorithm in Kim and Hong (2006). Comparing the heuristics depicted that Difference performs best for the objective function 
                           
                              #
                              RS
                           
                         and Greedy performs best for 
                           
                              
                                 
                                    w
                                 
                                 
                                    1
                                 
                              
                              #
                              RS
                              +
                              
                                 
                                    w
                                 
                                 
                                    2
                                 
                              
                              TC
                           
                        .

In Caserta et al. (2012), Caserta et al. present two binary linear programming models. In the first model, each time period is characterized by a single move, either a relocation or a retrieval move. Moreover, voluntary moves are allowed. In the second model, moves are restricted to forced ones and each time period is characterized by a set of moves (containing all moves necessary to retrieve the next item, relocation moves included). Computational results show that the second model is able to solve much larger instances. Nevertheless, the first model is more general and provides a more detailed view on the relocation process. Finally, a heuristic is offered which has been compared to ENAR. The computational results show that for small and medium scale instances the average gap from optimality is 
                           
                              1.91
                              %
                           
                         improving the value 
                           
                              13.5
                              %
                           
                         from ENAR in Kim and Hong (2006). For large scale instances, the heuristic also improves the number of reshuffles compared to Kim and Hong (2006).

Further research on the BRP by Caserta et al. can be found in Caserta, Schwarze, and Voß (2009) and Caserta, Voß, and Sniedovich (2011b). In Caserta et al. (2009), the authors propose an alternative (binary) encoding scheme representing the states of a yard. For two items 
                           
                              i
                              ,
                              j
                           
                         the binary entry 
                           
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                           
                         equals 1 if i is located below j in the same stack. This binary matrix is then used in a heuristic approach. If relocations are necessary, a “look-ahead”-heuristic uses a measure of attractiveness where to put a relocated item and a “roulette wheel”-mechanism to choose the next state randomly. Test results showed that the algorithm decreases the number of reshuffles in comparison to the ENAR-heuristic from Kim and Hong (2006) and the corridor method (CM) from Caserta et al. (2011b) (which is used with a dynamic programming algorithm as subroutine.) The CM has been designed by Sniedovich and Voß (2006) to restrict a large solution space in such a way that an exact method can be used to explore efficiently this restricted space. For a current solution, the CM builds a neighborhood which can be searched through for an optimal solution. So, the corridor method limits the number of states generated from the current configuration. In use for the BRP, a corridor is built by defining horizontal and vertical limits around the current configuration. Horizontal limits restrict the stacks to which an item can be reshuffled while vertical limits define a maximum number of items for each stack. Test results for small, medium and large scale instances showed that CM is able to keep up with ENAR: the running times for the corridor method are larger but the number of reshuffles could be reduced. In Caserta and Voß (2009b, 2009c), the authors present two extensions of the CM based upon metaheuristic approaches. In the former, the corridor width is adjusted dynamically by using a statistical analysis while in the latter, a stochastic construction process is used to randomly select moves among a set of possible moves. Computational results show that both algorithms are competitive to ENAR and the CM.
                           1
                           The code for the corridor method algorithm and instances for the BRP can be found at the website http://iwi.econ.uni-hamburg.de/IWIWeb/Default.aspx?tabId=1055.
                        
                        
                           1
                        
                     

An improved MIP-formulation and a much better heuristic were recently proposed by Petering and Hussein (2013). The authors developed a MIP that uses fewer decision variables and results in a better running performance than the model proposed by Caserta et al. (2012). Their heuristic is a look-ahead algorithm (LA) which allows voluntary moves for items blocking the next N target items. Clearly, if 
                           
                              N
                              =
                              1
                           
                        , the algorithm is restricted to use only forced moves. Test results show that LA outperforms previous algorithms. The number of relocations computed by LA depends on the size of N where a problem size of 
                           
                              40
                              ×
                              40
                           
                         containers in an area of 40 stacks with a maximum height of 79 is a threshold. Below this threshold, the number of relocations decreases as N increases while above this threshold, the number of relocations increases as N increases.

The problems considered by Lee and Lee (2010) and Tang et al. (2012) can be seen as small extensions of the BRP since the objective function is a weighted sum of the number of relocations and transportation costs. Lee and Lee (2010) use a three-phase heuristic where the first phase creates an initial feasible movement sequence to retrieve all items. The second phase tries to reduce the number of relocations building a super sequence of movement paths while the third phase uses a mixed integer program to reduce the working time for the crane. In comparison to ENAR, the three-phase heuristic outperforms it with respect to the number of reshuffles. Tang et al. (2012) use the structure of the model in Wan et al. (2009) to formulate the problem with additional consideration of the crane traveling distance. They additionally develop heuristics using tabu search based on a rolling horizon and provide upper as well as lower bounds for the number of reshuffle operations. Different test cases show that the computation of lower bounds is quite satisfactory and that the rolling horizon heuristic achieves nearly the same quality as ENAR.

A stochastic version of an unloading problem is studied by Kim (1997) who proposes a methodology to estimate the expected number of reshuffles when items are picked up randomly. The author assumes that the pick-up probability is uniformly distributed among all items and evaluates where to put a relocated item. He further derives regression equations and an approximation formula.


                        Forster and Bortfeldt (2012a) examine the CRP where a sequence of sets has to be retrieved. They propose a method for calculating lower bounds which they use in their tree search heuristic. An initial solution is computed using a greedy approach and given as input to the tree search (root node). A successor of a node is a layout that can be reached by a so-called compound move (a move sequence), the leafs represent the final layouts. In comparison to ENAR, CM and the look-ahead heuristic in Caserta et al. (2009), the tree search found solutions with 
                           
                              47.3
                              %
                              ,
                              9.6
                              %
                           
                         and 
                           
                              5.4
                              %
                           
                         less relocations, respectively. The tree search algorithm for the CRP has been changed to be applicable for the container retrieval problem in Forster and Bortfeldt (2012b). In this problem, containers have to be retrieved from several bays (in the CRP, only one bay is considered) such that the total time for crane moves is minimized. The tree search algorithm for the container retrieval problem has been compared to results by Lee and Lee (2010). It has been shown that the mean number of crane moves was reduced by 
                           
                              8.7
                              %
                           
                         and the mean crane move time was reduced by 
                           
                              15.7
                              %
                           
                        .

The slab stack shuffling (SSS) problem has been considered by Tang and Ren (2010). The difference to the problems described above is that items occur in families such that all items of a family are appropriate candidates for a specific retrieval request. Additionally, deadlines of the items and crane workloads are taken into account. A constraint programming and a dynamic programming model are developed. Due to the intractability of real-world instances, a segmented dynamic programming based heuristic is proposed. Tang et al. (2002) consider the SSS with the push-back-strategy and present a non-linear integer programming model as well as a genetic algorithm.

This subsection is concerned with premarshalling problems, which have predominantly been considered in the setting of container terminals and hence are also called container premarshalling problems (CPMP). Premarshalling problems are special cases of the more general remarshalling problems which are similar to “blocks-world” problems. These kinds of problems are well known in artificial intelligence 
                           
                              (
                           
                        cf. Gupta and Nau (1992)
                        
                           
                              )
                           
                        . Here, an initial and a goal state of items arranged in stacks are given and the aim is to reach the goal state with a minimum number of moves 
                           
                              (
                           
                        cf. Kim and Bae (1998), Kang, Oh, Ahn, Ryu, and Kim (2006a), Meisel and Wichmann (2010) and Choe, Park, Oh, Kang, and Ryu (2011)
                        
                           
                              )
                           
                        .

In premarshalling problems, contrary to the BRP, no item leaves the storage area, i.e. the set of items in the storage area always remains the same. For this reason, there is no large difference in the situations where a sequence 
                           
                              
                                 
                                    π
                                 
                                 
                                    out
                                 
                              
                           
                         or a sequence of sets 
                           
                              
                                 
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          out
                                       
                                    
                                    )
                                 
                                 
                                    K
                                 
                              
                           
                         is given. Therefore, most of the authors tackle the second (more general) situation where several items may have the same priority. Up to now, no complexity results have been published for premarshalling problems. Although the authors of heuristic methods implicitly assume that problem 
                           
                              P
                              |
                              
                                 
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          out
                                       
                                    
                                    )
                                 
                                 
                                    K
                                 
                              
                              |
                              #
                              RS
                           
                         is 
                           
                              NP
                           
                        -hard, no formal proof has been given. Table 5
                         summarizes solution methods for premarshalling problems.


                        Lee and Hsu (2007) were the first who tackled the premarshalling problem. They developed an integer programming model with an embedded multi-commodity network flow problem which describes the movement of containers in time and space. The nodes correspond to the stacks’ locations while the arcs represent the container movement opportunities. The flows in the network model the containers’ movements and one container movement is allowed in each time segment. For each location in a stack there is one “in node” and one “out node” which are connected by an upward, a downward, an internal, a stationary or a movement arc representing a movement upwards or downwards in a stack, a connection between consecutive time segments of the same location, a disposition in a location over two consecutive time segments or a movement between two stacks, respectively. Since the mathematical model is hard to solve, the authors also present a simple two-phase heuristic. This heuristic approach has further been considered in Lee and Chao (2009) who developed a neighborhood search and a binary integer program using three minor subroutines. The neighborhood search randomly adds, deletes or changes movements with certain probabilities and aims at minimizing the weighted sum of the length of the movement sequence and 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    dep
                                 
                              
                           
                         (as lower bound). The integer programming routine shortens a given feasible sequence conserving its feasibility by replacing container paths with shorter ones leading to the same layout. The three minor subroutines are used to empty stacks, to further shorten sequences and to reduce 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    dep
                                 
                              
                           
                        .


                        Huang and Lin (2012) use the research from Lee and Hsu (2007) and Lee and Chao (2009) for extension. Besides looking at the “standard” problem 
                           
                              P
                              |
                              
                                 
                                    (
                                    
                                       
                                          I
                                       
                                       
                                          out
                                       
                                    
                                    )
                                 
                                 
                                    K
                                 
                              
                              |
                              #
                              RS
                           
                        , they consider a second version where items of different types are mixed up in the storage area. The objective is to move all items of each type to a specific subarea (more specifically, all items of type k have to assigned to any location in the k-th sector which can be seen as a special case of location restrictions). Heuristic algorithms are developed for both problems. If no location restrictions have to be respected, stacks are labeled as either correctly arranged or incorrectly arranged. Correctly arranged stacks with a certain minimum height are then filled up, while correctly arranged stacks which are not high enough are deconstructed. Afterwards, incorrectly arranged stacks have to be cleared away by moving the items to empty stacks. If location restrictions have to be respected, stacks are labeled with the number of items that have to be removed and those which can stay. If a stack holds at least one item that has to be removed, a moving path has to be found which ends at the target stack.

Another heuristic solution method has been developed by Expósito-Izquierdo, Melián-Batista, and Moreno-Vega (2012). Moreover, the authors provide an instance generator which is able to create instances of varying difficulty degree. The lowest priority first heuristic iteratively moves the items in the reverse order of their priorities to well-located (ordered) stacks. The performance is compared with the corridor method from Caserta and Voß (2009a) showing that the number of movements in each test case is smaller than that of the CM.


                        Bortfeldt and Forster (2012) provide lower bounds for the number of moves and use a tree search heuristic to solve the CPMP 
                           
                              (
                           
                        similar to their work Forster and Bortfeldt (2012a) for the CRP
                           
                              )
                           
                        . The nodes of the tree represent yard layouts where the root is the initial layout and the leafs are final layouts. A direct successor of a layout node is created by a compound move. Due to efficiency, the number of successors is limited. The authors compare their results to the ones of Lee and Hsu (2007), Lee and Chao (2009) and Caserta and Voß (2009a). In conclusion, one can say that the tree search heuristic performs better (in time and in the number of moves) than the other heuristics.

Similarly to the BRP 
                           
                              (
                           
                        
                        Caserta et al., 2011b
                        
                           
                              )
                           
                        , Caserta and Voß use the corridor method for the PMP 
                           
                              (
                           
                        
                        Caserta and Voß, 2009a
                        
                           
                              )
                           
                        . First, a target stack is chosen randomly where the probability of choosing a stack is proportional to 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    adj
                                 
                              
                           
                        . Second, a score is computed for every other stack based on a measure of attractiveness. This score helps to decide which stack belongs to the corridor (i.e. a subset of stacks around the target stack). Afterwards, a neighborhood is defined within this corridor which is searched through with two heuristic schemes after selection of promising solutions. The first heuristic scheme is based on swaps and aims at building sorted sequences in a stack such that 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    adj
                                 
                              
                              =
                              0
                           
                        . The second heuristic scheme tries to build tight sequences within stacks such that the blocks’ priorities are 
                           
                              j
                              ,
                              
                              j
                              +
                              1
                              ,
                              
                              j
                              +
                              2
                              ,
                              
                              …
                           
                         from top to bottom. The algorithm has been tested with the benchmark instance from Lee and Chao (2009) and with instances generated from the data generation procedure in Kim and Hong (2006). The solution provided in Lee and Chao (2009) has been improved considerably.

The calculation of 
                           
                              #
                              
                                 
                                    US
                                 
                                 
                                    dep
                                 
                              
                           
                         can be used as a lower bound for the number of reshuffling moves 
                           
                              (
                           
                        as done in Lee and Chao (2009), for example
                           
                              )
                           
                        . Voß (2012) extended this computation by distinguishing between direct and indirect forced relocations. He showed that the lower bound for the benchmark instance in Lee and Chao (2009) can be further improved and proposed an optimal solution for this instance achieving the lower bound value.

This section deals with combined problems. Most of them are combinations of loading and unloading, only one reference has been found which considers a combined loading/premarshalling problem 
                           
                              (
                           
                        
                        Malucelli et al., 2008
                        
                           
                              )
                           
                        .

We start with complexity results, which are summarized in Table 6
                        . In his thesis, Aslidis (1989) tackled different settings of the container stowage problem (CSP). He distinguishes between problems with one stack of unlimited height and problems with more than one stack having either 
                           
                              b
                              =
                              ∞
                           
                         or a limited b. The former is proven to be polynomially solvable by dynamic programming while heuristics were developed for the latter problem versions.


                        Malucelli et al. (2008) considered a combined loading/premarshalling as well as a combined loading/unloading problem. In the former, a single (empty) stack and an unlimited additional temporary storage area for performing reorderings exist. The stack has to be loaded in a sequence of K stages and afterwards unloaded in 
                           
                              
                                 
                                    K
                                 
                                 
                                    ′
                                 
                              
                           
                         stages. The stack does not have to be ordered at the end of the loading phase, i.e. reorderings are allowed in the loading and unloading phase. It is shown that the total number of pop and push operations can be minimized in 
                           
                              O
                              (
                              n
                              +
                              
                                 
                                    KK
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         time by dynamic programming. In the latter, a sequence of sets has to be loaded to a stacking area containing only one stack. At each step, items already stored inside the stack are allowed to be temporarily removed from and pushed back together with the items that have to be loaded (premarshalling). The aim is to reach an ordered stack after loading all sets where the number of pop operations is minimal. The authors showed that this problem can be solved in 
                           
                              O
                              (
                              n
                              )
                           
                         time.


                        Avriel, Penn, and Shpirer (2000) derived additional complexity results by relating the CSP problem to coloring of circle graphs. For the problem with unlimited b and at most 3 stacks it can be decided in polynomial time whether a solution without relocation exists. On the other hand, for every fixed 
                           
                              m
                              ⩾
                              4
                           
                         the problem is 
                           
                              NP
                           
                        -complete. The latter result implies that minimizing the number of reshuffles is 
                           
                              NP
                           
                        -hard for 
                           
                              m
                              ⩾
                              4
                           
                        , for two or three stacks the complexity of this optimization problem is still open. Recently, Tierney et al. (2014) solved an open problem introduced by Avriel et al. (2000) and proved that minimizing the number of reshuffles for the combined problem with a fixed number of stacks 
                           
                              m
                              =
                              
                                 
                                    m
                                 
                                 
                                    ′
                                 
                              
                           
                         and fixed stacking limit 
                           
                              b
                              =
                              
                                 
                                    b
                                 
                                 
                                    ′
                                 
                              
                           
                         is polynomially solvable by dynamic programming.

Another version of the CSP with limit 
                           
                              b
                              ⩾
                              6
                           
                         and one sequence for incoming and one sequence of outgoing items is given, has been proven to be 
                           
                              NP
                           
                        -complete by König, Lübbecke, Möhring, Schäfer, and Spenke (2007) by a reduction of the Mutual Exclusion Scheduling Problem for permutation graphs. Note that for the problems considered by Avriel et al. (2000) and König et al. (2007) it does not make any difference whether a temporary storage 
                           
                              
                                 
                                    S
                                 
                                 
                                    tmp
                                 
                              
                           
                         is added or not since the objective asks for a solution with zero reshuffles.

In container ship stowage planning where containers are stored on and below deck a further objective is to minimize the number of hatch removals. Hatch lids serve as separation and first have to be freed from all the containers that are stored on it before removing the hatch lid itself to get access to containers below deck. Minimizing the number of hatch overstows has been shown to be 
                           
                              NP
                           
                        -hard in Tierney et al. (2014) by a reduction from the set cover problem.

Next, we survey solution methods and computational results for combined problems, which are summarized in Table 7
                        . Aslidis (1989) was the first to develop heuristics for the CSP with one stack of unlimited height and problems with more than one stack having 
                           
                              b
                              =
                              ∞
                           
                         or a limited b.


                        Rei, Kubo, and Pedroso (2008) and Rei and Pedroso (2012, 2013) consider release and due dates for items. However, this problem is basically the same as the problem above if we interpret the release and due dates as decision points where sets of incoming and outgoing items are released. In Rei et al. (2008), a heuristic and a set of benchmark instances are proposed. For a set of incoming items, the items are stored in the inverse order of their due dates (removal). All stacks are scored and one stack is chosen randomly among a list of best candidates. For a set of outgoing items, the items are retrieved in the inverse order of their depths. To determine where to put reshuffled items, the heuristic for incoming items is applied. The authors further suggest three different stacking strategies which all try to avoid unordered stackings. Test results for easy and hard instances showed that the third stacking strategy performs best. In Rei and Pedroso (2012), the authors propose an integer programming model and an improvement of the stacking strategies. The conflict minimization heuristic tries to avoid unordered stackings by simply concerning the retrieval times of the items inside the stack. The flexibility optimization heuristic (FO) uses the range of item retrieval times that can be placed in a stack without becoming unordered to decide where to put an item. Beside FO, a tree search procedure has been developed in Rei and Pedroso (2013). It uses a best-first scheme to prune some branches of the tree and a diving step to obtain upper bounds. Test results have shown that in most cases the tree search achieves better solutions than FO.

The IP-based heuristic method proposed by Wan et al. (2009) for unloading of stacks (see Section 4.2) has been extended to be useable for the dynamic setting where items arrive and have to be retrieved simultaneously. Computational results have shown that the heuristic is competitive to the heuristics proposed by Zhang (2000), Murty et al. (2005) and Kim and Hong (2006) (see Section 4.2). These heuristics have been extended for the combined problems by Wan et al. (2009) to be comparable to their heuristic.


                        Avriel and Penn (1993) and Avriel et al. (1998) provide a binary linear program using a transportation matrix 
                        
                           
                              
                                 
                                    T
                                 
                                 
                                    ij
                                 
                              
                           
                         (cf. Section 2.2), which is known in advance. Due to the computational intractability for large instances, in Avriel and Penn (1993) the authors developed the Whole Column Heuristic Procedure based on reduced transportation submatrices. Since this heuristic was unsatisfactory, in Avriel et al. (1998) the Suspensory Heuristic (SH) has been developed. It allows reordering (using voluntary moves) of items, decides how to fill empty slots and where to put an item such that as few reshuffles as possible are caused. The same problem has been tackled by Dubrovsky, Levitin, and Penn (2002) implementing a genetic algorithm. Test results have shown that the genetic algorithm performs nearly as good as the SH.


                        Wilson and Roach (1999, 2000) propose to divide the CSP into two subprocesses, the strategic planning phase and the tactical planning phase. In the former, items are pre-assigned to blocks. The objective function f is a weighted sum of five components minimizing the number of occupied blocks, the number of reshuffles, the number of hatch-lids movements and the space used for storage, and maximizing the number of cranes in each port. The assignment is done by using a branch-and-bound search. In the latter, items are assigned to exact locations inside stacks such that the number of reshuffles is minimized and the items are located from heaviest (bottom) to lightest (top). This assignment is done by using tabu search.


                        Yang and Kim (2006) look at a grouped storage location problem where a storage demand unit (SDU) is a set of items in the same stack for which no relocation occurs. Therefore, any SDU can be seen as one item. For each SDU its arrival and departure time as well as its height is known, the objective is to assign all SDUs to stacks respecting the maximum height and minimizing the number of reshuffles. For the case where the arrival and the retrieval times of items are unknown, they propose a kind of “online” strategy.

In this section, we give a short overview of several other papers dealing with problems that have to be tackled before the loading process, e.g. the space allocation for incoming containers or the computation of optimal plans for stowing containers into vessels with the help of ramps (not cranes). Since we understand loading as the assignment of incoming items to a specific level in a specific stack, these papers do not fit into our classification scheme. However, to complete our survey, we discuss them here.

The storage space allocation problem (SSAP) has been considered by e.g. Zhang, Liu, Wan, Murty, and Linn (2003) and Bazzazi, Safaei, and Javadian (2009). The storage area is divided into several blocks each containing some lanes which in turn contain a number of stacks. The SSAP is to temporarily allocate incoming items to the blocks such that the workload between blocks is balanced. The authors propose a mathematical programming model which has been extended by Bazzazi et al. (2009) in such a way that items are of different types (regular, empty, reefer). Another approach to solve the problem of allocating blocks for container groups of vessels (also known as Blocks Allocation Problem, BAP) has been considered by Hu, Min, and Du (ahead-of-print). The authors apply a modified “unified neutral theory of biodiversity and biogeogaphy” model to the BAP.


                        Taleb-Ibrahimi, de Castilho, and Daganzo (1993) consider a loading problem where the space needed to store the containers is computed. Results have shown that storage handling is wasteful since more than half of the storage area is empty all the time. Therefore, the authors propose the usage of a “roughpile” where items are stored temporarily. This requires less space but more item handling since every item has to be moved twice (to the roughpile and to one of the stacks inside the storage area). They developed a heuristic trying to minimize the number of item handlings by carefully assigning items either to the roughpile or the storage area directly.

A similar problem has been tackled by Jiang, Lee, Chew, Han, and Tan (2012). The strategy they developed is based on a space-sharing concept. In the first step, a block reservation is done for each vessel while in the second step, the size of the sharing space and the number of incoming items for each block is decided. The objective is to minimize land utilization and to maximize the yard’s efficiency.


                        Imai, Sasaki, Nishimura, and Papadimitriou (2006) propose a multi-objective integer program and a genetic algorithm for simultaneous stowage and load planning. Usually, the stowage planning is separated from the loading-sequence planning but it might be promising to solve the problems together since the objective is to ensure the vessel’s stability and to minimize the number of rehandles needed to load all items.

The master bay plan problem (MBPP) has been considered by Ambrosino, Sciomachen, and Tanfani (2004). It is the problem of finding optimal plans for stowing containers into a vessel with respect to some additional constraints. The authors distinguish two kinds of containerships which either load and unload containers through ramps or with the help of cranes. Moreover, there are several operational constraints such as location restrictions for different types of containers (e.g. reefer, standard, hazardous) and the total weight limit of the ship, for example. The authors present a binary linear programming model with the objective to minimize the total stowage time. Ambrosino, Sciomachen, and Tanfani (2006) suggest a decomposition approach and an algorithm to check the ship’s stability.

In Jang et al. (2013), the authors try to find a good stacking strategy for locating incoming items belonging to one of three groups. They developed a genetic algorithm which is used to find the best priority sequence by arranging different stack states such that the first stack state in sequence has the highest priority for an item of the specified group. For evaluation, the authors have proposed formulas (for different probability distributions) which calculate the number of movements becoming necessary for retrieving an item (i.e. the number of items above the demanded one is counted). Additionally, a method for determining the optimal number of stacks in a storage area is presented.


                        Li, Tian, Cao, and Ding (2008) look at a version of a container stowage problem where some more additional constraints have to be respected and another type of container ships is considered. Beside loading a ship with the help of cranes, loading with ramps located at the bow and the stern is possible. The authors assume that items differ in length (20-feet and 40-feet containers) and both the number of 20-feet and the number of 40-feet containers to be loaded on the ship is limited. Moreover, the vessel must not exceed a certain weight limit and its stability has to be respected. The objective is to minimize the total number of reshuffles. The authors present an integer linear programming model which has been tested by simulation.

Beside the CSP with one stack, Aslidis (1989) suggested two more stacking problems. The first is called “use-and-restack” and appears in warehouses where tools are stored in boxes which are piled up in stacks. If a tool is demanded and not in the topmost box, reshuffling becomes necessary. After the tool has been used, the box with the tool has to be stacked back. The second problem supposes more than one access point for stacks, i.e. not only the topmost item can be retrieved but all other items are accessible from the side (by forklifts, for example). If the stacking area holds more than one stack, an item on demand can be retrieved either horizontally or vertically.

An example for a loading problem where one sequence of incoming and outgoing items is given, can be found in Nishi and Konishi (2010). This problem slightly differs from the others since the objective aims at maximizing the number of groupings (containers belonging to the same customer should be stacked nearby). The authors provide an integer program as well as a beam search heuristic.

@&#CONCLUSION@&#

In this paper we have surveyed different problems arising in practice in the context of storage areas organized in stacks. Different problem classes have been identified, namely loading, unloading, premarshalling and combined problems. To be able to categorize all these problems in a more abstract way, we developed a classification scheme which has been used to summarize complexity results and solution methods for all problem classes.

Most of the problems deal with the loading or unloading of a sequence, a set or a sequence of sets, respectively. Several problems are inspired by the handling of containers in terminals, other problems originate from the production of steel slabs or shunting problems in tram yards.

In conclusion, many problems have already been solved by exact or heuristic methods in all four considered problem classes. Nevertheless, due to the diversity of the problems, various other versions exist. For further research, a major challenge is the development of more efficient solution algorithms integrating additional constraints coming from practical applications. Especially for the loading problem, there are quite few results. One could start considering a basic loading problem, e.g. storing a set of incoming items while minimizing the number of expected reshuffles or transportation costs and extend it to be more practical (by integrating the concept of families, for example.) To be able to compare different solution methods, setting up a website with benchmark instances applicable to different problem variants and the best known results would be beneficial. Additionally, there are some problems for which the complexity status is still open (e.g. several loading problems, the general premarshalling problem, or minimizing the number of reshuffles in combined problems with two or three stacks).

@&#ACKNOWLEDGMENT@&#

We gratefully acknowledge the constructive comments of three anonymous referees leading to an improved presentation of the paper.

@&#REFERENCES@&#

