@&#MAIN-TITLE@&#Long-bone fracture detection in digital X-ray images based on digital-geometric techniques

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Input: Bone X-ray image.


                        
                        
                           
                           Output: Segmentation of bone-contour from the surrounding region.


                        
                        
                           
                           Correct false discontinuities in the bone-contour based on digital-geometry.


                        
                        
                           
                           Generate an isothetic outer-cover of the bone contour.


                        
                        
                           
                           Identify fracture-points and the line-of-fracture.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Medical imaging

Bone X-ray

Adaptive thresholding

Chain code

Segmentation

Digital straight line segment (DSS)

@&#ABSTRACT@&#


               
               
                  Automated fracture detection is an essential part of a computer-aided tele-medicine system. In this paper, we have proposed a unified technique for the detection and evaluation of orthopaedic fractures in long-bone digital X-ray image. We have also developed a software tool that can be conveniently used by paramedics or specialist doctors. The proposed tool first segments the bone region of an input digital X-ray image from its surrounding flesh region and then generates the bone-contour using an adaptive thresholding approach. Next, it performs unsupervised correction of bone-contour discontinuities that might have been generated because of segmentation errors, and finally detects the presence of fracture in the bone. Moreover, the method can also localize the line-of-break for easy visualization of the fracture, identify its orientation, and assess the extent of damage in the bone. Several concepts from digital geometry such as relaxed straightness and concavity index are utilized to correct contour imperfections, and to detect fracture locations and type. Experiments on a database of several long-bone digital X-ray images show satisfactory results.
               
            

@&#INTRODUCTION@&#

Automated X-ray analysis is an integral part of telemedicine that is widely used in the rural areas where there is an acute shortage of medical practitioners. An analysis of an orthopaedic X-ray image can help the paramedical staff in remote areas to identify the severity of the condition and take proper action in a timely fashion. X-ray analysis can be done in two different phases: (i) segmentation of bone region from the surrounding flesh component followed by the extraction of bone-contour, and (ii) identification of the presence of fracture in the bone X-ray, if any.

Long-bone fracture is a very common ailment among senior citizens. They often suffer from bone injury because of osteoporosis, stress, or accidental fall. Automated fracture detection can assist doctors and paramedical staff to analyze the severity of the situation and to choose a proper course of action on urgent basis. Moreover, several computer-based training (CBT) programs in medical science focus on specialized fields like orthopaedics [22]. Also, simulators based on virtual reality [8,9,29] are now becoming increasingly popular among the medical residents and interns for the purpose of self-tutoring. A tool for automated fracture detection will be very useful in orthopaedic diagnosis, treatment, and management of patients as well.

The nature of bone fracture in different types of bone in human body widely differs from each other. Thus, designing a generalized algorithm for fracture identification in all types of bone is impracticable. In this paper, we have focused on the identification of fractures in a long-bone and proposed a new tool based on digital geometry [1,4]. The segmentation of a bone region of a digital X-ray image from its flesh part and generation of exact bone-contour play a crucial role in fracture detection. The proposed tool integrates an entropy-based segmentation method [3] with an adaptive thresholding-based contour tracing [2] to generate the bone-contour of an X-ray image. The algorithm traverses the bone-contour and rectifies the false discontinuities using certain new geometric techniques. This corrected bone-contour is then used for the detection of fracture locations using the concept of concavity index of a digital curve, and relaxed digital straight line segment (RDSS). When run on a large number of test cases, our tool is observed to have identified various types of fractures, successfully, in long-bone X-ray images.

@&#RELATED WORK@&#

The class of long-bones in human anatomy includes bones like humerus, radius, ulna, femur, tibia, and fibula. Several researchers have proposed different algorithms for bone-contour generation and fracture detection in long-bones. The extraction of bone-contour plays an important role in X-ray, computerized tomography (CT), and in magnetic resonance (MR) based image analysis. An approach based on 2D-region growing can be applied for the segmentation and labeling of fractured or wrongly-joined bones from a CT image [26]. Other researchers have used 3D Log-Gabor filters to perform phase-symmetry-based surface extraction for segmenting the bone region from a three-dimensional (3D) ultrasound image [14]. Lin et al. have proposed automated teeth segmentation from dental radiographs using Otsu's thresholding, connected component analysis, snake boundary tracking, and morphological operations [18]. In a review paper, Ma et al. [20] have critically surveyed the comparative performance of several medical image segmentation methodologies, and shown their application for the extraction of organ and tissue regions that are present in a female pelvic cavity.

Because of the diversity of human anatomy and the inherent lack of sharp contrast in a bone X-ray image, computer-aided automated fracture detection turns out to be a challenging task. Various computational models have been proposed by earlier researchers for the automation of fracture detection. Tian et al. [28] proposed a method for detecting femur fracture based on the observed angle between the axis of the femur-neck and that of the shaft. Yap et al. [30] have also suggested a method for detecting femur-fracture that relies on the analysis of disruption found in the trabecular-texture patterns present in the femoral neck. Other methods based on deformable models such as active contour, were used for the detection of bone-boundary discontinuities observed in fractured-bone X-ray images [24]. The parametric cylinder model, Monte Carlo simulation, and active contour model are also used by researchers to develop computer-assisted diaphyseal long bone fracture detection techniques [31].

Among others, mathematical morphology has been widely used in bone-fracture detection [17]. A computer-aided system for long-bone fracture detection had been proposed by Donnelley et al. [10], where a scale-space approach is used for edge detection, Hough transform for parameter approximation, and gradient analysis for diathesis segmentation and fracture detection. A frequently used data mining technique called classification, had also been widely used to detect the presence of fracture. These systems combine various image features such shape, texture, and colour, and deploy machine learning algorithms to identify fractures [19].

The contour of a fractured-bone often reveals a significant change in curvature in the neighborhood of the injury. Hence, this local property of a fracture can be successfully utilized for its identification, and for the purpose of analysis in this work, we will deploy some geometric concepts such as digital straight line segment (DSS), digital arc, and digital curve (DC). In the last few decades, many researchers in the digital-geometry community have extensively studied the underlying mathematical properties [4], [27]. Nguyen et al. have reported a technique for the decomposition of a digital curve into digital arcs and straight line segments, which also aids in locating dominant points in the arc-regions [23]. Fairly straight contours can be represented by a set of DSS alone.

In previous work [3], an entropy-based thresholding approach was used for segmenting a bone X-ray image from its surrounding flesh region. Elementary analysis of fractured-bone contours and correction of discontinuities therein, also appeared in prior work [1,2].

The goal of this work is to integrate some of the earlier approaches with a new geometry-based technique of fracture identification and elimination of segmentation errors so as to build a complete automated analysis tool. The rest of the paper is organized as follows. Section 3 discusses various design considerations. Section 4 describes an overview of the flow and details the methodologies used in this work. Section 5 focuses on implementation issues, and reports experimental results on several test cases. Section 6 provides a demonstration of the proposed tool.

In the domain of digital geometry, the contour of a digital object (or a binary image) can be approximated with a sequence of DSS's [27], or with approximate digital straight line segments (ADSS) [4]. The underlying geometric properties of an image, captured by such representations, have been shown be very powerful for their shape extraction and analysis. In the proposed work, we have introduced a new concept called relaxed digital straight line segment (RDSS) that is specially tailored for the purpose of fast bone-contour correction and fracture detection. A few definitions related to this work are given below.


                     
                        Chain code
                     : The direction around the border between pixels is encoded using chain code. If m(i, j) is a grid point, then the grid point (i′, j′) is a neighbor of m, provided that max(|i
                     −
                     i′|, |j
                     −
                     j′|)=1. The chain code [11] of m with respect to its neighboring grid point in P can have a value in 0, 1, 2, …, 7 as shown in Fig. 1
                     (a). The chain code of an open-ended digital curve shown in Fig. 1(b), is (1,3)(210756543) when traversed from the start-point S = (1, 3); Fig. 1(c) shows a close-ended digital curve, whose chain code is (3,3)(6543121075) with the start point S = (3, 3).


                     
                        Digital straight line segment (DSS)
                     : The properties of a DSS are defined in terms of its chain code as follows [27,4]:
                        
                           (F1)
                           The runs in the chain code should have at most two directions, differing by 45∘, and the run length in one of them must be 1.

The runs can have only two lengths, which are consecutive integers.

One of the run lengths can occur only once at a time.

For the run length that occurs in runs, these runs can themselves have only two lengths, which are consecutive integers, and so on.

In order to reduce the complexity of contour decomposition, the concept of ADSS was introduced earlier, which is defined as follows [4]:


                     
                        Approximate digital straight line segment (ADSS)
                     : ADSS has used (F1) along with certain modifications in (F2) but dropped condition (F3) and condition (F4) imposed on DSS. Such a modification of (F2) allows the run-length to vary by more than unity depending on the minimum run length. Thus, an ADSS will satisfy the following properties:

(F1′) The runs can have at most two directions (n and s), differing by 45°, and for one of these directions (singular element s), the run length must be 1. (F2′) The runs can have a range of possible lengths ([p, q], excepting l and r) such that,

(i) q−
                     p
                     ≤
                     d
                     =⌊(p
                     +1)/2⌋

(ii) (l
                     −
                     p), (r−
                     p)≤
                     e
                     =⌊(p
                     +1)/2⌋ where l is the length of the leftmost run of n, r is the length of the rightmost run of n, d and e represent the allowance of approximation.


                     
                        Relaxed digital straight line segment (RDSS)
                     : For the proposed work, we further relax the conditions on digital straightness to define a relaxed digital straight line segment (RDSS) by modifying the first two properties of ADSS as follows:
                        
                           (R1)
                           The runs have at most two directions, differing by 45°.

Both directions can have at-most three run lengths, which are consecutive integers.

Rule (R1) is a truncated version of the first property of both DSS and ADSS [4], [27], and Rule (R2) is a modified version of the second property (F2′) of ADSS.

Property (R2) mandates that if a RDSS is generated with two directions C
                     1 and C
                     2 such that l
                     
                        i
                     's represent run length of C
                     1 and m
                     
                        i
                     's represent run length of C
                     2, then |l
                     
                        i
                     
                     −
                     l
                     
                        j
                     |⩽2 for i
                     ≠
                     j and i,j
                     ∈{1, 2, 3} and |m
                     
                        i
                     
                     −
                     m
                     
                        j
                     |⩽2 for i
                     ≠
                     j and i,j
                     ∈{1, 2, 3}. This definition of RDSS allows us to approximate a visibly straight-looking digital curve having a small curvature with a single straight line segment.

While defining RDSS, we have retained one component of the first property of DSS (F1). Otherwise, if more than two directions are considered in a single line segment, then at least two among the three consecutive directions in the chain code differ by 90°. As a result, a curved line with a sharp curvature may also be falsely identified as a straight line thus destroying the basic shape of the image.

RDSS relaxes the constraint on single occurrence of runs. The major advantages of this relaxation includes:
                        
                           •
                           approximation of a curved line with a small curvature as a straight line segment.

avoidance of stringent constraints required by DSS and ADSS so as to identify small curves as a single straight line segment.

The second property of RDSS is included so as to restrict the number of run lengths in each direction. If the run-lengths of the chain code are consecutive integers, then a short curved segment therein can also be approximated with a single RDSS.


                     Fig. 2
                      shows various examples of DSS, ADSS, and RDSS with chain-code directions ‘0’ and ‘1’. In this example, C1 satisfies all properties of DSS, ADSS, and RDSS. In C2, both run lengths have multiple occurrences. Thus, the property of single occurrence of one run length (3rd property of DSS [27]), is not satisfied. Hence, C2 cannot be treated as a DSS; however, by definition, it will be recognized as an ADSS [4]). The digital curve C3 has multiple occurrences of both directions. Therefore, it violates the basic property of both DSS and ADSS. Hence, C3 will neither be recognized as a DSS nor as an ADSS. Curve C3 has three run lengths for each of the two directions which are consecutive integers (‘2’,‘3’,‘4’ and ‘3’, ‘4’, ‘5’, respectively). Hence, C3 satisfies both properties of RDSS. The digital curve C4 also has multiple occurrences of run-lengths with each direction. However, the run lengths in direction ‘0’ are not consecutive integers and the maximum difference between two run lengths of ‘0’ is 3. Thus, C4 violates the first condition of DSS and ADSS; furthermore, it violates the second condition (R2) of RDSS as well. Hence, it does not fulfil the necessary conditions for being categorized as DSS, ADSS, or RDSS.

As mentioned earlier, RDSS allows us to represent a single-pixel curve having a small curvature with a single straight line segment. For example, in Fig. 3
                     (d), the curved line (shown in Fig. 3(a)) can be approximated with five consecutive RDSS's. Since the conditions for being a DSS or an ADSS are tighter than those needed by a RDSS, the decomposition of a digital curve into DSS or ADSS components will, in general, produce a larger number of straight line segments compared to RDSS-based decomposition (as shown in Fig. 3(b) and (c)). An increase in the number of straight line segments renders the approximation of a curve with straight segments overly accurate than what is needed for solving our problem; further, such instances become more complex and costly to analyze. Hence, in the proposed algorithm, we decompose a bone-contour into a number of RDSS's, and this strategy helps us to remove most of the false discontinuities that may arise because of segmentation errors.

In our analysis, we have used another important geometric property of a digital curve called concavity index, as defined below.


                     
                        Concavity index
                      (
                        α
                     ). While traversing the contour of an image, each pixel point m
                     
                        i
                      on the contour is assigned a concavity index, (α
                     
                        i
                     ) where α
                     0 and α
                     1 are initialized to 0 and 1, respectively. To obtain α
                     
                        i+1, α
                     
                        i
                      is incremented (decremented) by the difference of the directions, d
                     
                        i
                      and d
                     
                        i+1, if the contour is traversed in clockwise (counter-clockwise) direction from m
                     
                        i
                      to m
                     
                        i+1, where d
                     
                        i
                      is the incident direction at m
                     
                        i
                     .

Note that if the curve-traversal advances in the clockwise (anti-clockwise) direction, the concavity index increases (decreases). In the latter case, it may assume a negative value. On the other hand, if the traversal continues in the same direction, the concavity index remains unchanged. Thus, a large variation of α meaning some sudden and unexpected change in the directionality, indicates a possible location of a fracture.


                     Fig. 4
                     (b) shows the plot for concavity index as obtained by traversing the curve of Fig. 4(a) from the top side. An anti-clockwise movement on segments R2 and R4 leads to low-concavity values in C2 and C4, whereas, a clockwise movement on segment R3 shows a high-concavity as in C3. No change of directionality on the curve is indicated by C1 and C5.

An overview of different stages of the proposed method is depicted in Fig. 5
                     . In this block diagram, the preprocessing phase is represented by Stage (b). Stage (c) and Stage (d) represent the blocks for contour correction and fracture identification, respectively. Once the presence of a fracture is confirmed, its exact location and fracture points are identified on the bone-contour. The main contribution of this work includes (i) identification of probable fracture points (Stage (e), Stage (f), and Stage (g)), (ii) detection of fracture locations (Stage (h)), and (iii) categorizing the nature of fracture (Stage (i)).

In an X-ray image, the bone parts appear along with the surrounding tissues or muscles (i.e., flesh). Hence, segmentation of the bone region and generation of exact bone-contour are needed for automated fracture detection. The proposed tool (Fig. 5) has two preprocessing steps: (a) segmentation of bone region from surrounding flesh, and (b) extraction of contour from the segmented bone image.

Extraction of bone region from overlapping muscles and tissue shadow is a challenging task in digital X-ray image segmentation. Each X-ray image has three distinct regions - a black background region, a low-intensity flesh region, and a high-intensity bone region. We have observed that traditional thresholding-based approaches such as ‘OTSU’ [25] often result in over-segmentation or under-segmentation for most of the X-ray images. Also, an edge-detection approach such as ‘Canny’ method [7] is observed to generate multiple false edges because of the presence of flesh-shadow surrounding the bone components. Another widely used segmentation method is k-means clustering [15,16] that segments the region of interest (ROI) more efficiently than classical segmentation approaches such as ‘Canny’ or ‘OTSU’. We have evaluated k-means clustering and an entropy-based method for bone-region segmentation.

A k-means clustering based segmentation approach can be used to compute pixel-cluster memberships for segmenting the image [15,16]. This method classifies the input data points into multiple classes on the basis of their inherent distances from each other. The points are clustered around centroids μ
                              
                                 i
                               ∀i
                              =1, 2,…,
                              k, which are obtained by minimizing the objective function, known as squared error function V:
                                 
                                    (1)
                                    
                                       V
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          k
                                       
                                       
                                          ∑
                                          
                                             
                                                x
                                                j
                                             
                                             ∈
                                             
                                                S
                                                i
                                             
                                          
                                       
                                       
                                          
                                             (
                                             
                                                x
                                                j
                                             
                                             −
                                             
                                                μ
                                                i
                                             
                                             )
                                          
                                          2
                                       
                                    
                                 
                              where there are k clusters S
                              
                                 i
                              , i
                              =1, 2,…,
                              k, and μ
                              
                                 i
                               is the centroid or mean point of all points x
                              
                                 j
                              
                              ∈
                              S
                              
                                 i
                              . Based on the intensity distribution in the input image, segmentation is performed using k-means clustering. In this approach, the centroid is initialized with k random intensities, and pixels are clustered according to their distances from the centroid intensity.

It has been observed that k-means clustering may produce over-segmented bone regions in many X-ray images. Thus, we have evaluated another method based on entropy-standard deviation [2,3] for bone-region segmentation.

Entropy-based segmentation techniques [2,3] can also be used for bone-image segmentation. In this method, local-entropy represents the grayscale intensity variation in the neighborhood of a pixel. As the uncertainty associated with the belongingness of a pixel in the flesh-to-bone transition region is much higher compared to smooth regions, the local entropy value of a pixel increases at the transition region. In this segmentation approach, we compute the local entropy for each pixel (for a 9×9 window) of the input image and multiply it with local standard deviation value for that pixel (for the same window size). The image generated from the product matrix shows relatively high intensity values at bone-boundary regions (as shown in Fig. 9(b) Fig. 6
                              (b) shows the segmentation of input X-ray image obtained by the k-means segmentation, and Fig. 6(c) shows the contour of the segmented image obtained by the entropy-based segmentation and adaptive thresholding approach.

We have compared the entropy-based segmentation approach [2] with k-means clustering [16] using the precision-recall metric [21]. It is observed that the entropy-based method exhibits higher precision-recall values compared to the k-means approach for all test-cases from the medical image database compiled by us (http://oldwww.iiests.ac.in/component/content/article/155-itcategory/3282-medical-image-database) (shown in Fig. 7
                              ). Thus, we have adopted the segmentation method based on entropy-standard deviation for bone-contour generation.

The proposed approach generates the bone-contour from a segmented bone image (entropy-standard-deviation image) using adaptive thresholding [6]. The segmented bone image J is traversed through every pixel α, and a small window around it with 8-neighboring pixels are examined (see Fig. 8
                           (b)). The window is divided into four cells, top-left (CE
                           1), top-right (CE
                           2), bottom-left (CE
                           3) and bottom-right (CE
                           4). All these four cells are incident on α. The contour traversal algorithm analyses the intensity values of neighboring pixels and selects the next pixel position whenever it identifies a pixel with an intensity value higher than the adaptive-threshold value of the present pixel (Fig. 8(a)). If the pixel is visited for the first time, it adds the current pixel in the visited list and decides the direction for the next move [2].

Let max
                                 i
                               and min
                                 i
                               denote the respective maximum and minimum gray level values in CE
                              
                                 i
                              . The global maximum (max
                                 g
                              ), is defined as the largest among all max
                                 i
                              's for i
                              =1, 2, 3, 4, corresponding to the four cells incident on α. Similarly, the global minimum (min
                                 g
                              ) is defined as the smallest among all min
                                 i
                              's for i
                              =1, 2, 3, 4. Based on max
                                 g
                               and min
                                 g
                              , we define the local threshold value as 
                                 
                                    τ
                                    loc
                                 
                                 =
                                 
                                    1
                                    2
                                 
                                 
                                    
                                       
                                          
                                             max
                                             g
                                          
                                          −
                                          
                                             min
                                             g
                                          
                                       
                                    
                                 
                              . The adaptive value of the threshold τ
                              
                                 adpt
                               is now computed as:
                                 
                                    (2)
                                    
                                       
                                          τ
                                          adpt
                                       
                                       =
                                       γ
                                       
                                          τ
                                          loc
                                       
                                       +
                                       
                                          
                                             
                                                1
                                                −
                                                γ
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   τ
                                                   loc
                                                
                                                +
                                                
                                                   τ
                                                   prev
                                                
                                             
                                          
                                       
                                    
                                 
                              where γ ∈ [0,1] represents the smoothing factor for the exponential moving average, and τ
                              
                                 prev
                               represents the adaptive threshold calculated for the previous point lying on the boundary of the cellular region. For computational simplicity, we consider 
                                 γ
                                 =
                                 
                                    1
                                    2
                                 
                               
                              [6]. Hence, the computation of τ
                              
                                 adpt
                               can be effected by a right-shift operation only. Once the adaptive threshold τ
                              
                                 adpt
                               for a given common point is computed, a cell C
                              
                                 i
                               is said to contain a portion of bone boundary, provided max
                                 g
                              
                              −min
                                 g
                              
                              ⩾
                              τ
                              
                                 adpt
                              .

The initial value (τ
                              0) is selected from the histogram of the intermediate entropy-standard-deviation image. As the bone boundary consists of a few pixels of an intermediate image, we consider the intensity value that corresponds to 99.95 percentile of the intermediate image as τ
                              0.

Based on the computed adaptive threshold value, the algorithm decides the direction of next movement. Fig. 8(b) shows an object with high- and low-intensity pixels. Green pixels belonging to the contour are identified using the adaptive thresholding approach. During each traversal, the object remains on the right side (left side) of the contour for a counter-clockwise (clock-wise) move. Fig. 9(c) shows the final contour of the bone generated from an input X-ray image.

A bone fracture may cause a disconnected or an uneven bone-contour. Hence, any discontinuity in the contour that appears due to segmentation or contour generation error (see region ‘A’ of Fig. 11(a)), can mislead the fracture-detection process. In order to overcome this problem, we have proposed a novel approach based on RDSS.

In the proposed method, the bone-contour generated using adaptive thresholding approach is traversed and the corresponding chain code is constructed. Next, the code is analyzed to approximate the underlying curve with a sequence of RDSS's. Any discontinuity in a long-bone contour should appear as two disconnected RDSS's, aligned in the same direction. Two segments of a contour may not be traversed in one pass because of discontinuity. Hence, the end-points of the two fragmented contours can have the same or complemented direction in the corresponding chain code. Either R
                        1 or R
                        2 can be extrapolated to generate a new RDSS (R
                        3, with chain code C
                        31 and C
                        32) that can correct the contour discontinuity. If RDSS R
                        1 has chain code C
                        11 and C
                        12, and R
                        2 has chain code C
                        21 and C
                        22, then the extrapolated RDSS R
                        3 with chain code C
                        31 and C
                        32 should satisfy the following relation:
                           
                              (3)
                              
                                 
                                    R
                                    3
                                 
                                 =
                                 
                                    R
                                    1
                                 
                                 
                                 |
                                 |
                                 
                                 
                                    R
                                    2
                                 
                              
                           
                        where 
                           {
                           
                              C
                              21
                           
                           ,
                           
                              C
                              22
                           
                           }
                           ∈
                           {
                           
                              C
                              11
                           
                           ,
                           
                              C
                              12
                           
                           ,
                           
                              C
                              11
                              ′
                           
                           ,
                           
                              C
                              12
                              ′
                           
                           }
                        , and {C
                        31, C
                        32}∈{C
                        11, C
                        12} ∪ {C
                        21, C
                        22}; 
                           
                              C
                              i
                              ′
                           
                           =
                           (
                           
                              C
                              i
                           
                           +
                           4
                           )
                         
                        mod 8, and ‘∥|’ denotes the merging of R
                        1 and R
                        2 after extrapolation of any one of them.

The proposed algorithm searches for all such closely positioned RDSS pairs that cover the bone-contour with its complementary chain code string. For example, a RDSS with a chain code consisting of {6, 7} can be paired with another having the code {6, 7} or {2, 3} since the RDSS covering the two line segments across the break can be traversed in same or opposite direction, with the pixels of one end of the line segments are lying in 16 neighborhood of each other (see RDSS R
                        2 and R
                        22 of Fig. 10
                        (a)). After finding such RDSS pairs, if they are sufficiently close enough, any one of these two respective contour segments is extended in the direction of traversal to connect them into a single contour segment, which in turn, can be represented by a single RDSS.

In Fig. 10(a), the two lines R
                        1 and R
                        2 that intersect like a ‘+’ symbol, are disconnected at the middle intersection point. So four RDSS pairs (R
                        1, R
                        11, R
                        2 and R
                        22) will be generated during the traversal of the contour. The proposed RDSS matching algorithm rectifies the contour by connecting each RDSS with its respective counterpart (see Fig. 10(b)). Similar effects will be observed when lines R
                        3 and R
                        4 intersect like a ‘×’ symbol, but do not touch at the middle intersection point (see Fig. 10(c)). Here, RDSS R
                        1 and R
                        11 have the same chain code (chain code value 6) as they have been traversed in the same direction, whereas, RDSS R
                        4 and R
                        44 have the complementary chain code (chain code 1 and 5, respectively). The proposed algorithm uses Relation (3) to connect them into a single RDSS. Finally, the corrected contour lines R
                        1, R
                        2, and R
                        3, R
                        4 are generated (Fig. 10(b) and (d)).

A discontinuity appearing in a contour may also correspond to a fracture, which will indeed show up as two different RDSS's. Any such discontinuity in the bone-contour caused by a fracture (see region ‘B’ of Fig. 11(a)) will have contour segments that cannot be aligned as a single straight line segment. So the chain-code-string of consecutive RDSS pairs will not satisfy the relation given in Eq. (3) (R13 and R14 of Fig. 11(c)). Therefore, the sequence of RDSS's that approximate the contour cannot be merged into fewer RDSS's. On the other hand, the contour discontinuities caused by segmentation or contour-generation errors can be corrected by projecting two neighboring RDSS's towards each other and merging them.

Approximation of bone-contours can also be performed using DSS or ADSS; however, the number of segments required to cover the contour would become higher because in a single-pixel wide long-bone image, the contour usually changes the direction at an interval of every 5 to 10 pixels. Thus, the use of RDSS helps to reduce the number of approximating straight line segments, and to rectify the false breaks in the contour, while reporting the correct fracture locations.

The proposed technique identifies the presence of fracture by analyzing the changes in concavity-indices of the pixels on the bone-contour. Once the presence of fracture is confirmed, the break-points and the region of break are identified. Finally, the line-of-break is reconstructed by joining the break-points to mark the region of fracture.

The boundary of a fracture-region in a long-bone appears as an irregular curve on its contour. The chain-code directions are observed to change sharply when the contour around these regions, is traversed pixel-by-pixel. Note that the concavity index remains unchanged over a long straight contour; however, it increases (decreases) if the curve turns around in clock-wise (anti-clockwise) direction. This property of concavity index is utilized here to detect the presence of fracture in a long-bone.

Experimental evidence shows that during contour traversal in the neighborhood of a fractured region, the chain code changes rapidly in both clock-wise and anti-clockwise directions within a short range of 5-10 pixels. As a consequence, the concavity index changes rapidly over a short span during pixel traversal. A plot of concavity-indices thus shows sharp rise and fall when the contour around a fractured region is traversed. Fig. 12
                           (c) shows the nature of variation of concavity index during the traversal of a healthy long-bone. Note that the direction of traversal remains unchanged from top-left to bottom-right and from top-right to bottom-left. Thus, the concavity-indices remains steady throughout the traversal. On the other hand, contour traversal around a fractured region results in frequent increments and decrements in concavity-indices. Region ‘A’ and Region ‘B’ of Fig. 12(f) show the rise and fall of concavity-indices within a small range of 5-10 pixels. These regions correspond to fractured-locations ‘A’, ‘B’ and ‘C’ shown in Fig. 12(e) respectively. However, a sharp variation of concavity-index may also be falsely observed in certain instances. This situation may occur when a curved contour of a normal bone is traversed. Such cases of false-acceptance can be minimized by detecting the line-of-break in the bone-contour.

In order to generate the outer isothetic cover of a bone-contour, a prior algorithm [5] is used. Next, we decompose the outer cover into a sequence of RDSS components, and compute the angle between each pair of consecutive components. The probable fracture points are then identified on the basis of these angles.

Given a specific pixel-grid size that is used for digitization, an isothetic (axes-parallel) cover of a digital object is a contour that tightly encloses the object [5]. This concept is utilized here for efficient localization of fracture-regions. The contour around a fracture appears with an irregular boundary. However, the contours for normal bone-joints also show certain amount of irregularity. While concavity analysis of bone-contour aids in identifying fracture-regions, it often becomes difficult to localize the line-of-break correctly. Since a fracture in a long-bone contour shows up symmetric abnormality on the contour along the line-of-fracture, the analysis of an isothetic cover that tightly encloses the fractured-region helps us to locate the proper position of line-of-fracture in the bone.


                              Fig. 13
                               (b) shows the fractured-bone contour with the probable regions of abnormalities identified during contour traversal (‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, and ‘G’). Fig. 13 (c) shows the isothetic cover of the bone-contour. Region ‘A’ and Region ‘B’ of the isothetic cover represent the symmetric-abnormality regions. The line-of-break passes through these regions. Note that a traversal along the periphery of the isothetic cover aids in identifying the line-of-break correctly, and at the same time, it minimizes the effects of false-positive breaks that were identified during concavity analysis.

The symmetric-abnormality locations in a fractured-bone contour can be identified by computing the angle between consecutive RDSS's in these regions. In order to estimate the angles at all curved-contour regions the proposed algorithm checks the chain-code around the boundary of the isothetic cover of the contour, and generates the sequence of RDSS's that approximates the boundary. Two consecutive RDSS's with different chain-codes, indicate the presence of some abnormal curvature in the corresponding region.


                              Fig. 14
                               (d) shows the RDSS-approximation for the boundary of the isothetic cover of the contour shown in Fig. 14(a). In this figure, two consecutive RDSS's have been colored differently. The change in chain-code between the RDSS-pair (R1, R2), and (R8, R9), indicates the presence of certain abnormality in the contour.

The proposed algorithm identifies the consecutive RDSS-pairs that have different chain-codes and computes the internal angle between them (excluding the top and bottom corners). A training set of thirty X-ray images (including both fractured and normal healthy long-bones) are used in our experiments. Table 1
                               shows the typical values of the angle subtended by two consecutive RDSS components. The X-ray images used in Table 1 are taken from the http://www.becs.ac.in/component/content/article/155-itcategory/3282-medical-image-databasemedical image database (MD) (http://www.becs.ac.in/component/content/article/155-itcategory/3282-medical-image-database).

We observe that all angles are acute and in the case of a fracture, such an angle is usually above 10°. For healthy long-bones, these angles are normally below 10°. Based on such data, we conclude that an acute angle (>10°) between RDSS pairs is likely to indicate the presence of contour abnormality in the corresponding regions. Once the angles between all consecutive RDSS-pairs are estimated, the pair that subtends the maximum acute angle is used to identify the possible fracture site on the bone-contour. It is also observed that when two fracture points are identified on the same or opposite side of the bone-contour, the value of one angle always becomes greater than >30°. Fig. 15
                               (b) shows the acute angle created between consecutive RDSS pairs (‘R1’-‘R2’ and ‘R8’-‘R9’) in break-regions. Table 2
                               shows the results for each test image at the points of fracture.

The point of intersection of two consecutive RDSS components that subtend an acute angle (10°) at the intersection point, represents a fracture point on bone-contour. However, for a complex type of fracture, multiple RDSS-pairs may appear having an acute angle between them. In such a situation, the selection of probable fracture points is made based on the following criteria.
                                 
                                    (i)
                                    The directions along which the two fracture points are visited during contour-traversal should be opposite. This ensures the presence of two points in the opposite side of the bone-contour.

The acute angle subtended at a probable fracture should be significantly larger compared to that at other points on the bone-contour traversed in the same direction.

If all probable points have the same direction of traversal, then the two largest angles are selected to indicate the end points of a line-of-break.

After selection of two probable fracture points on the bone-contour, the line-of-fracture is generated. Fig. 15(a) shows the direction of traversal at the point of fracture. Note that the directions of traversal at the two fracture points ‘X’ and ‘Y’, are opposite to each other. Fig. 15(b) shows the angle of intersection between two consecutive RDSS-pair (R1, R2) at the fracture-point ‘X’, and the angle between RDSS-pair (R8, R90) at the fracture-point ‘Y’.

The proposed method categorizes a fracture on the basis of the severity of injury. Evidences from the medical literature [12] indicate that a simple fracture results in a single break with loosely-connected fragments, whereas, in the case of complex or compound fracture, multiple bone splinters appear with external skin injury. We perform connected component analysis [13] on the segmented bone-contour to count the number of disconnected components in the fractured bone. A fracture that shows up a single connected component is classified as being simple and that with multiple or disjoint components is classified as being complex. Further, a fracture may appear in the top (proximal), middle (diaphyseal), or bottom (distal) region of the bone. The proposed approach identifies the location of fracture-points and categorizes the fracture accordingly. If the points appear within the upper 30% of an bone image, then it is termed as proximal region fracture. Fracture points within the lower 30% of the image indicate distal fracture, and those in the middle part of the bone (middle 40%) represent diaphyseal region fracture. Table 3
                            reports the type of fractures for several test images.

The proposed algorithm is tested on several X-ray images with long-bone fracture. In most of the cases, identification of the presence of fracture and detection of the line-of-fracture are performed correctly. The results generated in different phases of the proposed method are shown in Figs. 16 and 17
                     
                     . The first column in each of Figs. 16 and 17 shows the input X-ray image. The second and third columns show the isothetic cover of the bone-contour and its RDSS representation where each colored-line represents an RDSS. Column 4 displays the detected line-of-fracture observed on the bone-contour. The bone-image in Fig. 16(a1) shows a fracture in the diaphyseal region of Humerus. Fig. 16(a4) shows the line-of-fracture where the end-points are marked. The fracture is correctly classified as being simple, and occurring in the diaphyseal region (as shown in Table 3).


                     Fig. 16(b1) shows an X-ray image of a fractured tibia bone in which two components are connected loosely. The isothetic cover of the bone-contour is shown in Fig. 16(b2). The image has three connected components, and hence, it has been categorized as a complex fracture (Table 3). The line-of-fracture and its end points are marked in Fig. 16(b4). In this X-ray image, the line-of-fracture extends from the top part of the image to the middle region. The algorithm has identified the region of fracture correctly as having occurred in the proximal region (see Table 3). A femur-fracture image is shown in Fig. 16(c1), where the fracture has affected a small area in the diaphyseal part of the bone. The proposed method has identified the region of fracture correctly as being simple and diaphyseal. In some situations, a fracture may affect only one side of the bone-contour as shown in Fig. 16(d1). In this case, all probable fracture points will appear having the same direction of traversal.

The fracture points with maximum acute angle values are selected as the end points of the line-of-break (Fig. 16(d4)). As the line-of-break has appeared in the middle part of the image with multiple connected components, the fracture is classified as being complex and having occurred in the diaphyseal region.

Long-bone fractures near a bone-joint may consist of multiple possible fracture points in a curved region as shown in Figs. 16(e1) and 17(b1). In such situations, the nearby values of the acute angles between consecutive RDSS pairs at probable fracture points, help to identify the line-of-fracture accurately (see Figs. 16(e4) and 17(b4)). All X-ray images shown in Fig. 17(a1), (c1), (e1), (d1), indicate simple fracture. Fig. 17(c1), (e1) have a fracture in the diaphyseal part of the bone whereas Fig. 17(d1) has a fracture in the distal part of the bone. In Fig. 17(d3), an acute angle is also subtended by the RDSS’S at the bottom part; this is observed because of the natural curvature of the bone. The proposed algorithm only examines the long-bone part and ignores such boundary cases. The line-of-fracture along with end points is marked (see Fig. 17(d4)) based on RDSS-approximation. However, the fracture-region in Fig. (c1) is wrongly classified as being diaphyseal (see Table 3).

The efficiency of the proposed method depends on the quality of segmentation and the sharpness and clarity of bone-contour. Over-segmentation or under-segmentation may lead to incorrect identification of fracture points. Hence, the choice of a suitable segmentation tool is important for successful implementation of this technique.


                     Table 2 shows the decisions taken regarding the type and location of the fracture in an X-ray. A fracture with a single connected component is categorized as being simple and that with more than one connected components is categorized as being complex (multi-fragmentary). The location of a fracture is decided on the basis of the average position of break-points in the bone-image. In some cases, it shows incorrect results because of the absence of a complete X-ray image.


                     Table 3 reports the CPU time (in ms) needed by the proposed fracture detection technique on various types of fractured bone X-ray images. It is observed that for an image of size around 10KB, the proposed algorithm takes less than 2ms time (on Intel Core 560 PC with clock speed 3.33GHz, 64 bit OS and 4 GB RAM) to complete the entire process.

The proposed tool has been developed using Matlab R2013b with Windows 7 OS on Intel Core 560 PC with clock speed 3.33GHz, 64 bit OS, and 4GB RAM. We have built a graphic user's interface (GUI) with which a demonstration with four different images can be viewed. The display-boxes for viewing the output image are also provided. The tool allows the user to select a demonstration option among four available examples. After selection, the user may click on the ‘show demonstration’ button. This will initiate the background process and display the input image in the leftmost box. As the execution continues, the entropy-standard deviation image, RDSS-approximation of the bounding isothetic cover, and the line-of-fracture are shown on the GUI platform. Finally, the location of the fracture in the given X-ray image is determined and displayed on the screen. In the case of a normal healthy bone, the ’No Fracture Detected’ message will appear in the dialogue box. For details, one may click ‘Demonstration’ in the linked page http://oldwww.iiests.ac.in/it-abiswas-research Demonstration link (http://oldwww.iiests.ac.in/it-abiswas-research).

@&#CONCLUSION@&#

We have proposed an integrated tool for contour correction, fracture detection, line-of-break identification and for the classification of long-bone fractures based on digital-geometric analysis of an input X-ray image. We have shown that certain geometric features can be successfully utilized for providing fast and accurate solutions to the automation of medical image analysis. Our experiments on several X-ray image databases demonstrate the suitability and effectiveness of the proposed approach for the purpose of fracture detection in human long-bone structures. This work can further be extended in the future for automated fracture classification and for virtual simulation of orthopaedic surgery.

@&#ACKNOWLEDGEMENTS@&#

Authors would like to acknowledge Department of Science & Technology, Government of India for financial support vide reference no. SR/WOS-A/ET-1022/2014 under the Woman Scientist Scheme to carry out this work. The laboratory and computing facilities used at the Nanotechnology Research Triangle, ACMU, Indian Statistical Institute, Kolkata, are also thankfully acknowledged.

@&#REFERENCES@&#

