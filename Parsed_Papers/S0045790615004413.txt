@&#MAIN-TITLE@&#Throughput optimization in cognitive wireless network based on clone selection algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A clone selection algorithm was proposed for the throughput problem in cognitive wireless network.


                        
                        
                           
                           The proposed algorithm presents a very reasonable tradeoff between computational complexity and performance.


                        
                        
                           
                           The proposed solution is more suitable for slowly varying spectral environments such as IEEE 802.22 networks in realistic network settings.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cognitive wireless network

Throughput optimization

Immune clone algorithm

Constraint optimization

@&#ABSTRACT@&#


               Graphical abstracts
               
                  
                     
                        
                           Image, graphical abstract
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

The increasing growth in wireless communication demand has intensified the shortage crisis for the radio spectrum, but a significant amount of the licensed spectrums have not been effectively utilized [1], it is far more underutilized rather than naturally scarce. Cognitive wireless network (CWN) is a kind of intelligent communication system, which enables the devices to opportunistically access the licensed spectrum, and thereby it enhances the utilization of the existing spectrum resources [2]. The nodes in a cognitive wireless network can be classified as primary users (PUs) and secondary users (SUs). A PU is a licensed user that has exclusive rights to access spectrum. An SU is an unlicensed user that can utilize the spectrum opportunistically with PUs under interference restrictions.

Throughput optimal scheduling for cognitive wireless network under interference temperature constraints is an open research issue [4]. The throughput scheduling determines how many packets and with which frequency each SU will transmit in each time slot [5]
                     . The goal of it is to maximize the total throughput of the SUs in the cell. The throughput scheduling issue in conventional networks has been widely studied [6]. Nonetheless, cognitive radio paradigm brings new challenges into the issue because of the coexistence of the PUs and the SUs. The throughput scheduling problem considered in this paper can be distinguished from these works by its cognitive radio specific nature. That is, not only the availability of different frequencies but also the maximum allowable transmission rates of the frequency bands are time-varying [5].

Researchers have done some works on throughput optimization problem with different scenarios. In Ref. [6], a throughput optimization algorithm was proposed which does not enable true coexistence of the PUs and the SUs. The authors in Ref. [7] formulate a distributed heuristic algorithm to determine the channels and time slots for the cognitive nodes. However, they don't consider the interferences to the PUs either in their formulation or in their suboptimal heuristic algorithm. The interference temperature model provides true coexistence of licensed and unlicensed users. The throughput optimization is a binary integer programming problem, so the formulated scheduling methods have high computational complexity [3–7]. In Ref. [3], its optimal solution was obtained by the branch-and-bound algorithm with very high computational complexity. In Ref. [4], the author focused on throughput scheduling optimization under interference temperature constraints and formulated the throughput maximization problems. Then the author proposed suboptimal scheduling models, denoted as MFS (Maximum Frequency Selection) and PFS (Probabilistic Frequency Selection), with low complexity at the expense of poor throughput performances. Hence, it is very meaningful to design a suboptimal scheduling algorithm with better performance and reasonable complexity.

It is known that bio-inspired methods are ideal for such nonlinear optimization problems [8]. Some bio-inspired methods have been used in conventional (non-cognitive) scheduling, such as genetic algorithm [9] and particle swarm optimization [10]. In this paper, an improved immune clone selection algorithm is introduced to solve the throughput optimization problem. The inspiration comes from the fact that clone selection algorithm is ideal for nonlinear optimization problems with a large feasible solution space where a quick suboptimal solution will suffice. Also, to the best of our knowledge, the use of clone selection algorithm for scheduling in cognitive wireless network has not previously been explored. The simulation results show that the proposed algorithm is more suitable for slowly varying spectral environments.

The remainder of the paper is structured as follows. In Section 2, the system model is described and the problem of throughput optimization is formulated. In Section 3, the proposed algorithm is presented. Simulation results are discussed in Section 4. Finally, Section 6 concludes the paper.

Considering a time-slotted IEEE 802.22 system in which the SUs are controlled and guided by the CBS(cognitive base station) [4,5]. The scheduling is done at the CBS. We assume that the interference temperature perceived by the PUs is within the interference temperature limits, reliable communication between the CBS and the SUs is achieved, and collisions among the SUs are avoided [4]. Unf
                      is the maximum number of packets that each SU(denoted as n) can transmit for a frequency (denoted as f) in a time slot. The calculation procedure for Unf
                      within the interference temperature limits. The CBS then constitutes a matrix called U = [Unf
                     ].

The throughput optimization problem can be formatted as [3,5]:

                        
                           (1)
                           
                              
                                 Q
                                 =
                                 max
                                 
                                    ∑
                                    
                                       n
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    
                                       ∑
                                       
                                          f
                                          =
                                          1
                                       
                                       F
                                    
                                    
                                       
                                          ∑
                                          
                                             t
                                             =
                                             1
                                          
                                          T
                                       
                                       
                                          
                                             
                                                U
                                                
                                                   n
                                                   f
                                                
                                             
                                             
                                                X
                                                
                                                   n
                                                   f
                                                   t
                                                
                                             
                                          
                                          T
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1a)
                           
                              
                                 Subject
                                 
                                 to
                                 
                                 
                                    ∑
                                    
                                       f
                                       =
                                       1
                                    
                                    F
                                 
                                 
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       T
                                    
                                    
                                       
                                          X
                                          
                                             n
                                             f
                                             t
                                          
                                       
                                       ≥
                                       1
                                       
                                       ∀
                                       n
                                       ∈
                                       
                                          (
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          N
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1b)
                           
                              
                                 
                                    X
                                    
                                       n
                                       f
                                       t
                                    
                                 
                                 +
                                 
                                    X
                                    
                                       
                                          n
                                          ′
                                       
                                       f
                                       t
                                    
                                 
                                 ≤
                                 1
                                 
                                 
                                 ∀
                                 n
                                 ,
                                 
                                    n
                                    ′
                                 
                                 ∈
                                 
                                    (
                                    1
                                    ,
                                    2
                                    ,
                                    .
                                    .
                                    .
                                    N
                                    )
                                 
                                 ,
                                 n
                                 ≠
                                 
                                    n
                                    ′
                                 
                                 ,
                                 
                                 ∀
                                 f
                                 ,
                                 ∀
                                 t
                              
                           
                        
                     where N, F, T is the total number of SUs, frequencies, time slots respectively, and Xnft
                     is a binary variable such that Xnft
                      = 1 if user n transmits with frequency f in time slot t and 0 otherwise. Here, Eq. (1a) guarantees that at least one time slot is assigned to each SU, whereas Eq. (1b) makes certain that at most one user can transmit in a particular time slot and frequency combination, and consequently preventing collisions among the cognitive nodes. Moreover, the schedule length T is the time period in which the spectral and network environment changes slowly enough so that the Xnft
                     values are not affected. For example, the TV bands used by an IEEE 802.22 network constitute a slowly varying spectral environment, and hence enable T to be quite large [4].

Artificial immune system (AIS) is inspired by the human immune system. AIS-based algorithms typically extract ideas from the human immune system, which can learn and solve some complicated problems [10].The most immune-clone-inspired-optimization algorithms are based on clone selection theory. Clone selection is a dynamic process simulation of the immune system against the antigen. Now, the immune clone selection algorithm for optimization has been widely used in engineering-oriented fields, such as spectrum allocation [11], job scheduling [12], and image segmentation [13] and so on. These algorithms get solutions to problems by repeating a cycle of clone, affinity maturation (via mutation) and selection for a candidate population, and remaining good solutions in the population [10–12]. Immune clone selection algorithm is also known as immune algorithm or clone algorithm for short.

Some related terms are described briefly as follows:

                           
                              (1)
                              Antigen. An antigen represents one sample in the solution space of the problem. In this paper, antigen refers to the throughput schedule problem to be solved and the total constraints.

Antibody. An antibody represents a candidate solution to the problem in this paper.

Antibody population. The entire antibodies consist of antibody population.

Affinity. Affinity is the fitness measurement for an antibody, which exhibits the extent that antigen satisfies the problem requirements.

Clone. In immunology, cloning means asexual propagation so that a group of identical cells can be descended from a single common ancestor. It is used to enlarge search space.

Mutation. In immunology, mutation means the immune system recognizes external pattern by antibody gene mutation in order to gain higher affinity. Mutations take the search procedure out of a locally optimal region, and enable it to possibly enter into a better region of the search space.

Selection. An immune algorithm takes a group of antigens from a population using an operation called selection. The selection operation serves the purpose of eliminating the relatively bad solution candidates and focusing the search operation on a relatively good region of the solution space.

Our motivations for utilizing clone selection algorithm for the throughput optimal scheduling problems are manifold. First, clone algorithm is proper for problems with large search space. It is Equipped with many tools to reduce computational complexity and produce a diverse set of solutions. The fact that clone algorithm operates on a population rather than a single solution implies that the algorithm makes parallel searches in the search space. Considering that the solution space in the throughput scheduling problems is enormous (even for 5 nodes, 3 frequencies, and 3 time slots, the size of the solution space is 245), clone algorithm seems to be a suitable tool. Second, clone algorithm can be conveniently implemented. The binary decision variables Xnft
                         can be easily encoded to a binary string.

Some key techniques are as follows:

                           
                              (1)
                              Antigen representation (encoding). We use binary to encode antigen, which contain Xnft
                                  values. Thus, the Antigen size is Equal to N×F×T. For N = 3, F = 2, and T = 3, the single antigen, denoted as p, whose one structure can be [X111, X211, X311, X112, X212,…, X123, X223, X323], whereas the other structure is [X111, X112, X113, X121, X122,…, X322,X323]. Xnft
                                  is a gene bit of antibody

Affinity evaluation. In this paper, the optimization model is described in (1). The affinity is a map of the value of Eq. (1) for a given antibody. Because Q is to be maximized, it can be stated that if an antibody has the higher affinity, it is the better one.


                        Fig. 1
                         Illustrates the flowchart of our proposed algorithm for throughput optimal scheduling problem.

The algorithm is implemented as follows (Step 1–Step 7)


                        Step 1: Initialization. Set the maximum iterative generation t
                        max . Set 
                           
                              t
                              =
                              0
                           
                        , where t is termed as current iterative generation. Create an initial antibody population A(t) with size k in accordance with antibody encoding. That is,

                           
                              (2)
                              
                                 
                                    A
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    (
                                    
                                       p
                                       1
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    
                                       p
                                       2
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    …
                                    .
                                    ,
                                    
                                       p
                                       k
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                 
                              
                           
                        
                        p
                        
                           i
                        (1 ≤ i ≤ k) is a candidate throughput scheduling scheme, A(t) is a set of candidate throughput scheduling schemes.

Here, some pre-knowledge is used to initialize the antibody p
                        
                           i
                         in order to accelerate algorithm convergence, which is proved by the latter simulation experiments. From constraint (1a), it is known that at least one time slot is assigned to each SU. Constraint (1b) makes certain that at most one user can transmit in a particular time slot and frequency combination. Each antibody p
                        
                           i
                        (1 ≤ i ≤ k) that satisfies the constraints (1a) and (1b) will be a candidate.


                        Step 2: Affinity evaluation. Calculate the affinities of all antibodies in A(t) according to Eq. (1). It is denoted as:

                           
                              (3)
                              
                                 
                                    f
                                    
                                       (
                                       A
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    =
                                    
                                       (
                                       f
                                       (
                                    
                                    
                                       p
                                       1
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    f
                                    
                                       (
                                       
                                          p
                                          2
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    
                                       ,
                                       …
                                       .
                                       ,
                                       f
                                       (
                                    
                                    
                                       p
                                       k
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                 
                              
                           
                        
                     

Here, if an antibody p
                        
                           i
                        (t)(1 < i < k) has higher affinity, the throughput scheduling scheme is the better one.


                        Step 3: Proportional Clone Tc
                        . In this study, we obtain B(t) by applying clone proliferation Tc
                         to A(t). It is defined as follows:

                           
                              (4)
                              
                                 
                                    B
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    
                                       T
                                       c
                                    
                                    
                                       (
                                       A
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    =
                                    
                                       [
                                       
                                          T
                                          c
                                       
                                       
                                          (
                                          
                                             p
                                             1
                                          
                                          
                                             (
                                             t
                                             )
                                          
                                          )
                                       
                                       ,
                                       
                                          T
                                          c
                                       
                                       
                                          (
                                          
                                             p
                                             2
                                          
                                          
                                             (
                                             t
                                             )
                                          
                                          )
                                       
                                       ,
                                       …
                                       .
                                       ,
                                       
                                          T
                                          c
                                       
                                       
                                          (
                                          
                                             p
                                             k
                                          
                                          
                                             (
                                             t
                                             )
                                          
                                          )
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     

Here, the clone scale qi
                         for each antibody p
                        
                           i
                        (1 ≤ i ≤ k) is proportional to its affinity f(p
                        
                           i
                        (t)). That is,

                           
                              (5)
                              
                                 
                                    
                                       q
                                       i
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    I
                                    n
                                    t
                                    
                                       (
                                       
                                          n
                                          c
                                       
                                       ×
                                       
                                          
                                             f
                                             (
                                             
                                                p
                                                i
                                             
                                             
                                                (
                                                t
                                                )
                                             
                                             )
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                k
                                             
                                             
                                                f
                                                (
                                                
                                                   p
                                                   i
                                                
                                                
                                                   (
                                                   t
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

Where Int( ) denotes the integer function, nc
                         is a given value (nc
                         > k). The antibody with larger affinity value (objective function value of Eq. (1)) has a larger qi
                        .

Let 
                           
                              z
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 k
                              
                              
                                 q
                                 i
                              
                           
                        , then B(
                        t
                        ) can be expressed as

                           
                              (6)
                              
                                 
                                    
                                       B
                                       (
                                    
                                    t
                                    )
                                    =
                                    {
                                    p
                                    
                                       
                                       1
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    p
                                    
                                       
                                       2
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    …
                                    .
                                    ,
                                    p
                                    
                                       
                                       z
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    }
                                 
                              
                           
                        
                     

Actually, clone proliferation on antibody p
                        
                           i
                        (t) is to make multiple identical copies of it.


                        Step 4: Mutation
                        
                           
                              T
                              m
                           
                        . In this study, it is defined as 
                           
                              
                                 C
                                 (
                              
                              t
                              )
                              =
                              
                                 T
                                 m
                              
                              
                                 (
                                 
                                    
                                       B
                                       (
                                    
                                    t
                                    )
                                 
                                 )
                              
                           
                        . An adaptive mutation which associates the mutation probability mp
                         with the evolutionary generation is designed. That is,

                           
                              (7)
                              
                                 
                                    
                                       m
                                       p
                                    
                                    =
                                    
                                       m
                                       p
                                    
                                    ×
                                    
                                       (
                                       1
                                       −
                                       
                                          t
                                          
                                             t
                                             max
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                        t is current evolutionary generation, t
                        max  is the maximum evolutionary generation.

The advantage of the mutation is that it can search solution in a large scope in early evolution process while it searches in a local scope in late evolution process, which will accelerate the convergence. After mutation, the population becomes:

                           
                              (8)
                              
                                 
                                    
                                       C
                                       (
                                    
                                    t
                                    )
                                    =
                                    {
                                    
                                       
                                          p
                                       
                                       ′
                                    
                                    
                                       
                                       1
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    
                                       
                                          p
                                       
                                       ′
                                    
                                    
                                       
                                       2
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    …
                                    .
                                    ,
                                    
                                       
                                          p
                                       
                                       ′
                                    
                                    
                                       
                                       z
                                       ′
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    }
                                 
                              
                           
                        
                     

In this paper, the mutation is done by changing the element one and element zero with each other with probability mp
                        . The proposed mutation is easy to realize and doesn't violate the constraints.


                        Step 5: Affinity evaluation. Calculate the affinities of all antibodies in C(
                        t
                        ) according to Eq. (1). It is defined as:

                           
                              (9)
                              
                                 
                                    f
                                    
                                       (
                                       C
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    =
                                    
                                       (
                                       f
                                       (
                                    
                                    
                                       
                                          
                                             p
                                             1
                                          
                                       
                                       
                                          ′
                                          ′
                                       
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    f
                                    
                                       (
                                       
                                          
                                             
                                                p
                                                2
                                             
                                          
                                          
                                             ′
                                             ′
                                          
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    ,
                                    .
                                    .
                                    .
                                    .
                                    ,
                                    f
                                    
                                       (
                                       
                                          
                                             
                                                p
                                                z
                                             
                                          
                                          
                                             ′
                                             ′
                                          
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        
                     


                        Step 6: Clone selection
                        
                           
                              T
                              s
                           
                        . Clone Selection
                           
                              T
                              s
                           
                        is defined as:

                           
                              (10)
                              
                                 
                                    A
                                    
                                       (
                                       t
                                       +
                                       1
                                       )
                                    
                                    =
                                    
                                       T
                                       s
                                    
                                    
                                       (
                                       C
                                       
                                          (
                                          t
                                          )
                                       
                                       ∪
                                       A
                                       
                                          (
                                          t
                                          )
                                       
                                       )
                                    
                                    =
                                    
                                       (
                                       
                                          p
                                          1
                                       
                                       
                                          (
                                          t
                                          +
                                          1
                                          )
                                       
                                       ,
                                       
                                          p
                                          2
                                       
                                       
                                          (
                                          t
                                          +
                                          1
                                          )
                                       
                                       ,
                                       …
                                       ,
                                       
                                          p
                                          k
                                       
                                       
                                          (
                                          
                                             t
                                             +
                                             1
                                          
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

That is, select k antibodies having higher affinity from C(t) and A(t) to form the next population 
                           
                              A
                              (
                              t
                              +
                              1
                              )
                           
                        .


                        Step 7: Termination test. If t
                        max  has been reached, stop the algorithm. Output the antibody with the maximum affinity in 
                           
                              A
                              (
                              t
                              +
                              1
                              )
                           
                         as the result of throughout scheme. Otherwise, 
                           
                              t
                              =
                              t
                              +
                              1
                           
                        , go to Step 3.

Recall N denotes the number of SU, F denotes the number of available frequency. For the clone-based scheme, the total computational complexity is mainly composed of that for initialization, affinity evaluation, clone, mutation, and selection. Given the population size k, clone scale nc
                         (nc
                         > k) and the maximum generation t
                        max , the procedure of population initialization, affinity evaluation and proportional clone (step 1–step 3) has the same computational complexity of O(k × F × N) in each generation, while the procedure of mutation, affinity evaluation, selection (step 4–step 6) has the computational complexity of O(k × nc
                         × F × N) in each generation. Hence, for each generation, the total computational complexity is 
                           
                              O
                              (
                              3
                              
                                 (
                                 k
                                 ×
                                 F
                                 ×
                                 N
                                 )
                              
                              +
                              3
                              
                                 (
                                 k
                                 ×
                                 
                                    n
                                    c
                                 
                                 ×
                                 F
                                 ×
                                 N
                                 )
                              
                              )
                           
                        . Since nc
                         > k, according to the properties of Symbolic O 
                        [10,13,14], it can be denoted as O(nc
                         × F × N)). When the throughout scheduling is finished, it has the total computational complexity of O(t
                        max  × (nc
                         × F × N)).

The computer simulations show that t
                        max  implicitly depends on F and N (see Section 4.1). The more complex the search space is, the larger the number of generations should be. Thus, for given nc
                         and t
                        max , the gradual computational complexity of the proposed algorithm is O(N × F) in accordance with the properties of symbolic O.

A brief summary of the complexities of previous typical algorithms and our proposed algorithm is shown in Table 1
                        .

We simulated the suboptimal scheduling and acquired the Unf
                         values in OPNET Modeler, whereas we solved the optimization problems in CPLEX [15]. Additive white Gaussian noise (AWGN) channels are considered. In all the simulations, each SU has three primary neighbors in its interference range. The simulation results are the average of 100 independent tests. The parameters settings are as same as that of ref. [4,5]: There are three frequencies with interference temperature thresholds of 1000, 2000, and 3000 K.

Four parameters are to be set at the initialization phase: the antibody population size k, the clone population size nc
                        , the mutation probability mp
                        , and the maximum number of generations t
                        max . The sequential experimental design method of employing a series of smaller experiments each with a specific objective is a common method in experimental design [15], because the experimenter can quickly learn crucial information from a small group of runs that can be used to plan the next experiment. k and nc
                         directly influence the computational complexity of the algorithm [10–13]. Given k and nc
                         large enough, the diversity of the population can be enhanced and the prematurity can be avoided in some extent, but the computational complexity will also be very high. t
                        max  depends on F and N obviously. The more complex the search space is, the larger the number of generations should be. mp
                         is very important for local search in algorithm. A larger mp
                         has the ability to produce more new antibodies, but it also has the probability to destroy some good antibodies. When mp
                         is too small, the convergence speed is not quick enough to find the best solution in specific generations.

Since the optimal choice is hard to determine by theoretical analysis, it is important to analyze the performance influence by experiments in different cases. After trial and error, the parameters employed in the proposed algorithm are: number of generations 
                           
                              
                                 t
                                 max
                              
                              =
                              100
                           
                        , population size 
                           
                              k
                              =
                              50
                           
                        , clone scale 
                           
                              
                                 n
                                 c
                              
                              =
                              10
                           
                        , mutation probability 
                           
                              
                                 m
                                 p
                              
                              =
                              0.3
                           
                        .

In order to evaluate the performances of the proposed algorithm, the effect of number of iterations (evolutionary generation) on throughput scheduling (Mbps) is studied, the number of SUs is set to 5. As it is evident from Fig. 2
                        , the throughput initially increases with the number of evolutionary generation and then gradually converges to the higher value, a near optimal point. It is also can be seen that proposed method provides significant gain in throughput and faster convergence rate. The simulation results prove the effectiveness of the proposed immune operators. Fig. 2 presents the throughput for optimal [3], MFS, and PFS [4] scheduling schemes compared with our proposed scheduling scheme. The algorithm in ref. [3] can be regarded as the upper-bound of the proposed heuristic algorithm.

It also can be seen from Fig. 3
                        , the evolutionary generation to convergence increases with the numbers of SUs.

The others results of different number of SUs are shown in Table 1a.
                     

It can be seen that the proposed algorithm gives consistent good results. First of all, our proposed solution yields better results than the MFS and PFS proposed in ref. [4], at the same time being very close to the throughput optimal performance in ref. [3] .

The scheduling delay is also be evaluated, the results are shown in Table 2
                        . From Table 2, we can see that the proposed algorithm get better performances compared with the relative algorithms.


                        Fig. 4
                         shows the performances comparisons of relative algorithms with the increasing of numbers of SUs. It can be seen that the proposed algorithm performs excellently. It is very close to optimal performances in ref. [3] and better than algorithm in ref. [4].

All in all, our proposed optimization algorithm achieves very close performances to the optimal scheduling operating with much lower complexity. However, the simulation results reveal that our proposed algorithm cost more iterations than the MFS and the PFS in ref. [4]. Nevertheless, when they are compared with the throughput performance, we can see that our proposed algorithm is approximately twice better than the MFS and the PFS. Moreover, our proposed algorithm is computationally more efficient than the classical branch and bound algorithm which is used to solve binary integer programming problems.

@&#CONCLUSIONS@&#

Throughput scheduling optimization is an important research issue in the field of cognitive wireless network. Available solutions have either high computational complexity or relatively poor performances. Considering the NP-hard feature of the problem, we proposed an intelligent optimization solution to the throughput problem in cognitive wireless network, which we called the immune-clone based suboptimal scheduling algorithm. The simulation results show that our proposed algorithm can obtain near optimal performance with a relatively lower complexity. Therefore, our proposed algorithm presents a very reasonable tradeoff between computational complexity and performance. Hence, it can be concluded that our proposed solution is more suitable for slowly varying spectral environments. Considering that IEEE 802.22 networks operate on TV broadcast bands which are slowly varying, it can be confidently concluded that our proposed algorithm can operate in realistic network settings, and provide useful solution to the open research problem.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the following Foundation Items: the National Natural Science Foundation of China (no. U1504613, U1204618 and 61202099); Open topic of Universal Wireless Communications Key Laboratory of Education Ministry (Beijing University of Posts and Telecommunications) (no. KFKT-2013101); the Research Foundation for the Doctoral Program of China (no. 2013M541586)

@&#REFERENCES@&#

