@&#MAIN-TITLE@&#A multi-objective local search heuristic for scheduling Earth observations taken by an agile satellite

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A realistic and interesting space application is studied.


                        
                        
                           
                           The use of multi-objective combinatorial optimization is investigated.


                        
                        
                           
                           A multi-objective local search heuristic is proposed and compared to state-of-the-art genetic algorithm.


                        
                        
                           
                           Comparisons are conducted on a set of real-life inspired instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi-objective optimization

Earth observing satellite

Scheduling

Local search

@&#ABSTRACT@&#


               
               
                  This paper presents an indicator-based multi-objective local search (IBMOLS) to solve a multi-objective optimization problem. The problem concerns the selection and scheduling of observations for an agile Earth observing satellite. The mission of an Earth observing satellite is to obtain photographs of the Earth surface to satisfy user requirements. Requests from several users have to be managed before transmitting an order, which is a sequence of selected acquisitions, to the satellite. The obtained sequence has to optimize two objectives under operation constraints. The objectives are to maximize the total profit of the selected acquisitions and simultaneously to ensure the fairness of resource sharing by minimizing the maximum profit difference between users. Experiments are conducted on realistic instances. Hypervolumes of the approximate Pareto fronts are computed and the results from IBMOLS are compared with the results from the biased random-key genetic algorithm (BRKGA).
               
            

This paper addresses a multi-objective optimization problem associated with selecting and scheduling observations of an agile Earth observing satellite. We consider the case where multiple users order requests to the satellite. A local search is proposed to solve the problem and experiments are conducted on realistic instances.

The mission of Earth observing satellites (EOSs) is to obtain photographs of the Earth surface, in order to satisfy the requirements from users. EOSs can acquire photographs, while moving along their orbits. They spend a period of several days to perform a cycle of orbit. The whole area of the Earth is viewed, when the satellites complete a full cycle (Habet, Vasquez, & Vimont, 2010). EOSs carry different instruments depending on their usages, e.g. optical camera or infrared camera. Most of them operate at low altitudes. Hence, when they move over the visible areas of the required photographs, the photographs can be captured as in Fig. 1. Then, the satellites will try to transfer the data of the acquired images directly to the ground station center after acquiring them, if possible. Otherwise, the data are stored in the on-board limited memory until the satellites are in the possible transferring range to the ground station center.

Among the various types of EOSs, only so-called “agile” satellites are considered in this paper. An agile EOS is equipped with only one fixed on-board camera, but the satellite uses an attitude and orbit control system (AOCS) to be able to turn around three axes: roll, pitch, and yaw (Lemaître, Verfaillie, & Jouhaud, 2000). An example of an agile satellite is PLEIADES, which was developed by the CNES, the French Space Agency. The starting time for taking each image of this satellite is not fixed, but it must be in a given time interval, which is called a time window. Therefore, an agile satellite has an important advantage when compared to a non-agile satellite. On the one hand, this gives agile satellite better efficiency of the whole system. On the other hand, the problem of selecting and scheduling the candidate images is more difficult to solve, since the search space under consideration is larger (Lemaître, Verfaillie, Jouhaud, Lachiver, & Bataille, 2002b).

In this work, the satellite management process is considered when several users order requests to a ground station center. The requests cannot be assigned directly to a satellite; the ground station center has to select and schedule the candidate images, according to some limitations of the satellite, before the obtained sequence is transmitted.

For solving the Earth observation scheduling problem, there are several studies on agile EOSs. For example, a combination of genetic algorithm and simulated annealing was proposed to solve this problem in Li, Xu, and Wang (2007). The performance of the proposed algorithm was compared with the simulated annealing alone. In Lemaître et al. (2002b), four methods consisting of a greedy algorithm, a dynamic programming procedure, a constraint programming model, and a local search method were applied in order to solve a simplified version of the scheduling problem for agile EOSs.

The ROADEF 2003 challenge was about the management problem of an agile EOS mission (see http://challenge.roadef.org/2003/en/). The challenge aims at finding a feasible schedule that maximizes the total profit, computed from the sum of request gains, which are associated with the complete or partial acquisition of each request. All the data description and optimization criterion are explained in Verfaillie, Lemaître, Bataille, and Lachiver (2002). Note that the problem considered in this challenge was a simplified version of the real Earth observation satellite management problem; for example, neither data download nor energy and thermal limitations are taken into account.

The winner of this challenge used an algorithm based on simulated annealing for solving the scheduling problem (Kuipers, 2003). The second prize winner proposed an algorithm based on tabu search (Cordeau & Laporte, 2005). The authors adapted the unified tabu search algorithm (Cordeau, Laporte, & Mercier, 2001), which was developed for the vehicle routing problem with time windows. Moreover, a tabu search algorithm hybridized with a systematic search was applied to solve this problem in Habet et al. (2010). All these works considered the scheduling problem for an agile EOS as a mono-objective optimization problem (total profit maximization).

Our work considers the acquisition scheduling problem of an agile EOS, where the requests emanate from several different users. We need to optimize two objective functions, which are to maximize a total profit and simultaneously ensure the fairness of resource sharing for all users. Thus, this problem is modeled as a multi-objective optimization problem. The second objective, which is added in order to ensure the fairness, amounts to minimize the maximum profit difference between users. Some researchers studied multi-objective optimization problems for space applications (Arias-Montaño, Coello, & Mezura-Montes, 2012; Gabrel & Vanderpooten, 2002; Wang, Jing, Li, & Chen, 2007). Furthermore, some literature considered as an objective the fairness among users (Lemaître et al., 2002a). Multiple end-users of agile EOSs were considered and sharing principles were adopted to select the subset of candidates based on utility levels. In Bataille, Lemaître, and Verfaillie (1999) and Lemaître, Verfaillie, and Bataille (1999), the use of two objective functions related to fairness and efficiency was proposed. Three ways were discussed for solving this sharing problem: the first one gives priority to fairness, the second one to efficiency, and the third one computes a set of trade-offs to help a human to make decisions. For the multicriteria methods, instead of building a complete set of nondominated solutions, the authors only searched for a decision close to the line with a specified slope on the objective function plane. In Bianchessi, Cordeau, Desrosiers, Laporte, and Raymond (2007), the selecting and scheduling requests for the multi-satellite, multi-orbit, and multi-user were studied, and tabu search was used to solve the problem. The fairness was taken into account, but it was not considered as an objective function. The authors borrowed an ordered weighted average from Yager (1988) to ensure the fairness of the solutions. The experiments test these algorithms with the data instances provided by the CNES.

This paper proposes an indicator-based multi-objective local search, which is a multi-objective metaheuristic algorithm, for selecting and scheduling the subset of candidate photographs. Section 2 presents the description of the multi-user Earth observation scheduling problem. Then, the indicator-based multi-objective local search is explained in Section 3. Section 4 presents the computational results. This section compares the results from the indicator-based multi-objective local search and from the biased random-key genetic algorithm. Finally, conclusions and perspectives are discussed in Section 5.

The instances, which are modified from the ROADEF 2003 challenge instances, will be described in detail. They will be used in the experiments, for testing the performance of the proposed algorithm in our work.

Each request can be of two types: mono or stereo. Each area is taken only once for mono requests, whereas for stereo requests, each area must be acquired twice in the same direction but from different angles. Two possible shapes of request, which are a spot or a polygon, can be required. The spot is a small circular area with a radius of less than 10 km. The polygon is a polygonal area ranging from 20 to 100 km. Both shapes have to be managed by transforming the requests into several rectangular shapes called strips. Each polygon is decomposed into several strips of the same width but with variable lengths. A spot is considered as a single strip. Each strip can be taken once at a time by the camera on the satellite. An example of request shapes and order for taking the strips after management is illustrated in Fig. 2
                        . There are two possible directions to acquire each strip. Both directions are parallel to the length of the strip, but in the opposite directions as shown in Fig. 3
                        . Among two of them, only one acquired direction can be selected. The strip, associated with one possible acquired direction, is called an acquisition. Thus, each strip consists of two possible acquisitions. The interval of possible starting times for taking each acquisition can be computed, depending on the acquired direction, from the earliest and latest visible time of the two extremities of the strip, and the acquired duration time of the strip.

Each acquisition generates a profit. Thus, for the observation scheduling problem, the objective is total profit maximization. The total profit is computed depending on the acquired area of each request. The profit of each acquired request can be computed by using a piecewise linear function of gain. This function is associated with a fraction of the acquired useful area over the whole area of each request, as illustrated in Fig. 4
                        . The more area of the request is acquired, the more profit is generated.

A set of nr
                         requests originate from the users. These requests lead to handling ns
                         strips from which 2ns
                         acquisitions are possible. To each request i, are associated the user 
                           
                              U
                              
                                 
                                    [
                                    i
                                    ]
                                 
                                 
                                    i
                                    =
                                    1
                                    .
                                    .
                                    
                                       n
                                       u
                                    
                                 
                              
                           
                         who orders it, its gain G[i] for a complete acquisition, its surface area S[i], and its mono/stereo characteristic St[i] ∈ {0 / 1}.

The major constraints to fulfill are related to the start time to process a selected acquisition within its time window according to the duration time to acquire it, necessary transition times between two consecutive acquisitions, and satisfying stereo constraints.

A solution is defined by a sequence of selected acquisitions and a sequence of acquisition starting times. Then, given a set of request profits 
                           
                              {
                              r
                              
                                 p
                                 1
                              
                              ,
                              r
                              
                                 p
                                 2
                              
                              ,
                              …
                              ,
                              r
                              
                                 p
                                 i
                              
                              ,
                              …
                              ,
                              r
                              
                                 p
                                 
                                    n
                                    r
                                 
                              
                              }
                           
                         and a set of user profits 
                           
                              {
                              u
                              
                                 p
                                 1
                              
                              ,
                              u
                              
                                 p
                                 2
                              
                              ,
                              …
                              ,
                              u
                              
                                 p
                                 j
                              
                              ,
                              …
                              ,
                              u
                              
                                 p
                                 
                                    n
                                    u
                                 
                              
                              }
                              ,
                           
                         the following objective functions values are computed:

                           
                              (1)
                              the total profit:


                                 
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             n
                                             u
                                          
                                       
                                       u
                                       
                                          p
                                          j
                                       
                                    
                                 
                              

the maximum profit difference between each pair of users:


                                 
                                    
                                       
                                          max
                                          
                                             (
                                             j
                                             ,
                                             j
                                             
                                             
                                                
                                                ´
                                             
                                             
                                             )
                                          
                                       
                                       
                                          (
                                          |
                                          u
                                       
                                       
                                          p
                                          j
                                       
                                       −
                                       u
                                       
                                          p
                                          
                                             j
                                             
                                             
                                                
                                                ´
                                             
                                          
                                       
                                       
                                          |
                                          )
                                       
                                       ,
                                    
                                 
                              


                                 
                                    
                                       
                                          ∀
                                          j
                                          ≠
                                          j
                                          
                                          
                                             
                                             ´
                                          
                                          :
                                          u
                                          
                                             p
                                             j
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                
                                                |
                                                
                                                U
                                                [
                                                i
                                                ]
                                                =
                                                j
                                             
                                          
                                          r
                                          
                                             p
                                             i
                                          
                                          ,
                                       
                                    
                                 
                              


                                 
                                    
                                       ∀
                                       i
                                       :
                                       r
                                       
                                          p
                                          i
                                       
                                       =
                                       G
                                       
                                          [
                                          i
                                          ]
                                       
                                       ·
                                       S
                                       
                                          [
                                          i
                                          ]
                                       
                                       ·
                                       P
                                       
                                          (
                                          
                                             
                                                s
                                                i
                                             
                                             
                                                S
                                                [
                                                i
                                                ]
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              

where si
                                  is the area partially taken for request i.

In this work, the set of solutions on the approximate Pareto front will be obtained after solving the model briefly presented above by maximizing the first objective and minimizing the second objective. It should be noted that a lot of objective functions are possible to ensure fairness between the users. Notably, the choice made only compares two users and is not as precise as for instance the minimization to the average. It can also lead to solutions that are of no interest to a decision maker (for instance, the one taking no picture). However, the choice is motivated by the fact that it is easy to compute, notably in an incremental way. Moreover, the obtained solutions must satisfy the imperative constraints. Then, the decision maker can choose the preferred sequence from the set of solutions on the approximate Pareto front and transmits it to the satellite for operating the mission.

In this section, we propose an indicator-based multi-objective local search (IBMOLS) approach to solve the multi-user observation scheduling problem for an agile EOS. IBMOLS is a generic algorithm, which combines the use of basic local search and a binary indicator from IBEA. It was initially proposed in Basseur and Burke (2007).

IBMOLS is an iterated local search. Before starting the first iteration, the approximate Pareto front PO is generated as an empty set and it is updated at the end of each iteration. In each iteration of IBMOLS, it starts by generating the initial population P. Adapted to our problem, two procedures are used in this work. The first one is applied for the first iteration and the second one is applied for the other iterations. Then, the nondominated solutions in the population P are stored in the archive set A. The fitness values of all individuals in the population P are computed by using the indicator based on the hypervolume concept from Zitzler and Künzli (2004) and the local search step is applied for each individual. After that, the updated population P is combined with the archive set A and the nondominated solutions of this combined set are stored in the new archive set A. If the archive set A changes, the process returns to apply the local search step. Otherwise, this iteration is finished and the final archive set A is obtained. Then, the approximate Pareto front PO will be updated by combining the obtained archive set A with the approximate Pareto front PO, and the set of nondominated solutions from the combined set becomes the new approximate Pareto front PO. If it does not satisfy the stopping criteria, a new initial population P is generated for the next iteration of IBMOLS. The flowchart of the IBMOLS overview is illustrated in Fig. 5
                     .

For the first iteration of IBMOLS, N individuals are randomly generated to become the initial population. Each individual represents one solution, which is a sequence of selected acquisitions.

The flowchart of the initial population generation for the first iteration is shown in Fig. 6
                        . All acquisitions are assigned to be the members of the selected acquisition set. For each acquisition depending on a random order, it is checked whether it satisfies the sufficient transition time constraint and the time window constraint. The solution is coded as a sequence and it is easy to precompute intervals and check feasibility. Note that a more advanced alternative should be to use Simple Temporal Networks (Pralet & Verfaillie, 2013). If it satisfies both constraints, the starting time is computed and fixed in the starting time set. Moreover, the acquisition, which concerns the opposite acquired direction of the same strip, is removed from the selected acquisition set. Otherwise, the considered acquisition is removed. The process for checking these constraints is repeated until all acquisitions in the selected acquisition set are tested. After that, the temporary selected acquisition set and starting time set are obtained. In this step, the stereo constraint has to be checked for each selected acquisition one by one in the temporary set. If the considered acquisition comes from the stereo strip, its twin must also be assigned. If its linked acquisition is not assigned, the considered acquisition is removed. When all selected acquisitions are checked, the starting time set is re-computed.

In IBMOLS, an iterated local search is used for searching for the nondominated solutions by starting the search from different initial populations. A perturbation mechanism is applied in order to escape from local optima. However, the number of modified solution components must be accurately defined. If too high number of modified components is set, better solutions could be found but with a very low probability. On the other hand, if too small number of modified components is defined, the local search will fall back into the local optimum just visited (Lourenço, Martin, & Stützle, 2002).

For the perturbation, an individual is generated by modifying a solution from the approximate Pareto front PO of the current iteration. In this work, the solutions in the approximate Pareto front are randomly selected. The number of selected solutions is equal to the size N of the initial population. Each solution contains the selected acquisition set. It is modified by removing some acquisitions in the random position j from the selected acquisition set. In this work, we set the number of removed elements about 1/4 of the size #orig of the original selected acquisition set. Moreover, during removing, the stereo constraint has to be checked. If the removed acquisition is a part of the stereo request, its twin must also be removed. The acquisition removing is repeated until the number #modif of the remaining acquisitions in the selected acquisition set is less than or equal to 3/4 of the size #orig of the original set. Then, the modified selected acquisition set will become a part of the individual, which is a member of the initial population in the next iteration. The population generation by using the perturbation is depicted in Algorithm 1.
                     

In the process of perturbation, we have to avoid the generation of any already visited solution. Therefore, the number of removed acquisitions is pre-computed. If it is less than or equal to one, the perturbation will generate the individual, which has been visited. In this case, the random generation will be used to generate the individual, instead of using the perturbation.

The local search step starts from an individual in population P and move iteratively to a neighbor. In the original IBMOLS, a first improvement strategy is used to select the neighbor. However, in this work, a best improvement strategy is preferred. During the neighborhood exploration, the fitness values of each neighbor are computed. The neighbor with the best fitness is generated and selected for replacing the worst solution in the population. The neighborhood of all individuals in population P are explored. The population and the archive set are updated. If the updated archive set A does not change, the local search step will be stopped. Otherwise, another local search step is performed.

From the selected solution in the archive, the best neighbor is searched as follows. Each acquisition is considered in a given order. If the acquisition is scheduled in the sequence, the process is straightforward: removing the acquisition just leads to the new solution objectives to be updated. If the acquisition is a stereo one, both scheduled acquisitions are removed from the sequence. If the acquisition is not in the sequence, we try to insert it in the sequence. In the case of a stereo acquisitions, both tasks are tested for inclusion but the principle remains the same as follows.

The acquisition is tried for insertion between two scheduled ones in the sequence. However, the feasibility of the insertion has to be checked as the operational constraints must hold. The insertion of an acquisition implies that the already scheduled ones after the insertion place may need to be shifted to the right, delaying them as illustrated in Fig. 7
                        . This can be checked easily by a precomputing process. For a scheduled acquisition id, the latest possible starting time Q(id) is computed as follows. For the last scheduled acquisition saN
                        , its latest starting time Q(N) can be computed by

                           
                              
                                 
                                    Q
                                    
                                       (
                                       N
                                       )
                                    
                                    =
                                    
                                       T
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    
                                       (
                                       s
                                       
                                          a
                                          N
                                       
                                       )
                                    
                                 
                              
                           
                        where Tmax
                         denotes the latest starting time of an acquisition.

For the other acquisitions said
                        , where 1 ≤ id ≤ N − 1, their latest starting times Q(id) are given by

                           
                              
                                 
                                    Q
                                    
                                       (
                                       i
                                       d
                                       )
                                    
                                    =
                                    min
                                    (
                                    
                                       T
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    
                                       (
                                       s
                                       
                                          a
                                          
                                             i
                                             d
                                          
                                       
                                       )
                                    
                                    ,
                                    Q
                                    
                                       (
                                       i
                                       d
                                       +
                                       1
                                       )
                                    
                                    −
                                    D
                                    u
                                    
                                       (
                                       s
                                       
                                          a
                                          
                                             i
                                             d
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                    −
                                    D
                                    t
                                    
                                       (
                                       s
                                       
                                          a
                                          
                                             i
                                             d
                                          
                                       
                                       ,
                                       s
                                       
                                          a
                                          
                                             i
                                             d
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                    )
                                 
                              
                           
                        where Du and Dt stand for the duration time of an acquisition and the transition time between two acquisitions, respectively.

Example of the latest starting time Q(id) computation is shown in Fig. 8
                        .

Then the possibility to insert an acquisition Acq 
                        k is tested using the following rules:

                           
                              •
                              the acquisition Acq 
                                 k can be inserted in the first position (position 1) of the selected acquisition set, only if

                                    
                                       
                                          
                                             
                                                T
                                                
                                                   m
                                                   i
                                                   n
                                                
                                             
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                             +
                                             D
                                             u
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                             +
                                             D
                                             t
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                ,
                                                s
                                                
                                                   a
                                                   1
                                                
                                                )
                                             
                                             ≤
                                             Q
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 
                              

the acquisition Acq 
                                 k can be inserted in the middle position id (position 2 to N) of the selected acquisition set, only if

                                    
                                       
                                          
                                             t
                                             
                                                a
                                                
                                                   i
                                                   d
                                                   −
                                                   1
                                                
                                             
                                             +
                                             D
                                             u
                                             
                                                (
                                                s
                                                
                                                   a
                                                   
                                                      i
                                                      d
                                                      −
                                                      1
                                                   
                                                
                                                )
                                             
                                             +
                                             D
                                             t
                                             
                                                (
                                                s
                                                
                                                   a
                                                   
                                                      i
                                                      d
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                             ≤
                                             
                                                T
                                                
                                                   m
                                                   a
                                                   x
                                                
                                             
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                          
                                       
                                    
                                 and

                                    
                                       
                                          
                                             T
                                             k
                                             +
                                             D
                                             u
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                             +
                                             D
                                             t
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                ,
                                                s
                                                
                                                   a
                                                   
                                                      i
                                                      d
                                                   
                                                
                                                )
                                             
                                             ≤
                                             Q
                                             
                                                (
                                                i
                                                d
                                                )
                                             
                                          
                                       
                                    
                                 where Tk  =  max (Tmin
                                 (Acq 
                                 k), ta
                                 
                                    id − 1  +  Du(sa
                                 
                                    id − 1)  +  Dt(sa
                                 
                                    id − 1, Acq 
                                 k))

the acquisition Acq 
                                 k can be inserted in the last position (position N + 1) of the selected acquisition set, only if

                                    
                                       
                                          
                                             t
                                             
                                                a
                                                N
                                             
                                             +
                                             D
                                             u
                                             
                                                (
                                                s
                                                
                                                   a
                                                   N
                                                
                                                )
                                             
                                             +
                                             D
                                             t
                                             
                                                (
                                                s
                                                
                                                   a
                                                   N
                                                
                                                ,
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                             ≤
                                             
                                                T
                                                
                                                   m
                                                   a
                                                   x
                                                
                                             
                                             
                                                (
                                                A
                                                c
                                                q
                                                
                                                k
                                                )
                                             
                                          
                                       
                                    
                                 
                              

The methods were tested on modified instances from the ROADEF 2003 challenge (http://challenge.roadef.org/2003/en/sujet.php) (TestSet A, B, and X). They are modified for 4-user requirements and the format of instance names are changed to a_b_c, where a is the number of requests, b is the number of stereo requests, and c is the number of strips. The modified instances are publicly available and can be downloaded from: http://www.laas.fr/files/ROC/4U-EOS.zip.

We presented the biased random-key genetic algorithm (BRKGA) for solving this Earth observation scheduling problem in Tangpattanakul, Jozefowiez, and Lopez (2012) and Tangpattanakul, Jozefowiez, and Lopez (2013). Genetic algorithms are metaheuristic search methods, which can solve large-size problem instances and obtain satisfying solutions in an acceptable time (Talbi, 2009). They start by generating a population of p chromosomes, and then involve three mechanisms: selection, crossover, and mutation, to generate the new chromosomes for the next generation and repeat the iterations until some stopping conditions are satisfied. BRKGA combines genetic algorithm and the concept of random key (Gonçalves & de Almeida, 2002). It has different ways to select two parents for the crossover operation, compared with the original of random-key genetic algorithm (RKGA) (Bean, 1994). In Tangpattanakul et al. (2012, 2013), parameter values of BRKGA were experimentally tuned. The population size of BRKGA was set equal to the length of the random-key chromosome or twice the number of strips. For next population generation of BRKGA, the size of the three parts (the elite set, the mutant set, and the crossover offspring set) was set in accordance with the recommended values in Gonçalves and Resende (2011). For the elite set part, all the objective functions must be taken into account for the fitness of each chromosome. Thus, we chose a selecting method from several efficient algorithms, e.g., Nondominated Sorting Genetic Algorithm (NSGA-II) (Deb, Pratep, Agarwal, & Meyarivan, 2002), 
                           S
                         
                        metric selection Evolutionary Multi-objective Optimization Algorithm (SMS-EMOA) (Beume, Naujoks, & Emmerich, 2007), Indicator-Based Evolutionary Algorithm (IBEA) (Zitzler & Künzli, 2004) in order to use in the selection process. The size of the elite set was equal to the number of non-repeated schedules from the nondominated solutions, but it was not over 0.15p. The size of mutant set was equal to 0.3p. The probability of elite element inheritance for crossover operation was set to 0.6. Moreover, BRKGA used encoding and decoding steps for managing the solution. For the decoding step, the basic decoding was implemented in Tangpattanakul et al. (2012). Several decoding procedures have been proposed in Tangpattanakul et al. (2012, 2013). We will test IBMOLS against the best version of the algorithm.

In each iteration of BRKGA, the nondominated solutions were stored in an archive. If there was at least one solution from the current population that can dominate some solutions in the archive, the archive was updated. Therefore, we used the number of iterations since the latest archive improvement to be a stopping criterion. The stopping value was set to 50. The hybrid decoding method obtained the best solutions.

In this work, the indicator-based multi-objective local search (IBMOLS) is used to solve the Earth observation scheduling problem. The obtained results are compared with the results from BRKGA. Some parameter values have to be tuned. Thus, we set a value of 10 for the population sizes. Moreover, as previously, we chose a number of 50 iterations since the latest approximate Pareto set improvement to be the stopping criterion.

As suggested in Knowles and Corne (2002), the hypervolume metric (Zitzler, 1999) was used. The hypervolume represents the size of the area dominated by the approximation generated by an algorithm. It is based on computing the volume (area in the bi-objective case) dominated by a given Pareto-front approximation. The hypervolume metric requires a reference point consisting of a reference value for each of the two objectives. Here we use 0 for total profit maximization and the maximum sum of profits per user for the second objective. These values are the worst possible values for each objective.

Both proposed algorithms are implemented in C++ and thirty runs per instance are tested. Hypervolumes of the approximate Pareto front are computed by using a reference point of 0 for the first objective (maximizing the total profit) and the maximum of the profit summations of each user for the second one (minimizing the profit difference between users). The hypervolume values, which are obtained from both proposed algorithms, are plotted by box plots.

We compare the results between BRKGA and IBMOLS. For BRKGA, the results were obtained from the hybrid decoding, which used the selection method of indicator-based evolutionary algorithm (IBEA) for selecting the preferred chromosomes to become the elite set. Moreover, the selection of the dominant solution was used to manage the elite set in the hybrid decoding process. For IBMOLS, the results are obtained by using the neighborhood structure, which consists of the insertion and removing of the mono and stereo acquisitions. The method of feasibility checking, which computes the latest starting time before checking insertion feasibility, is applied. For generating the initial population, the random generation is used in the first iteration and the perturbation is applied in the other iterations. The number of 50 iterations since the latest archive improvement is used as a stopping criterion for both BRKGA and IBMOLS. The box plots of hypervolume values and the average computation time of BRKGA and IBMOLS for TestSet A, B, and X are presented in Figs. 9–11
                        
                        
                        
                        
                        , respectively. For each instance, the first column illustrates the results from BRKGA and the second column shows the results from IBMOLS. Moreover, we also use a Mann–Whitney statistical test (Knowles, Thiele, & Zitzler, 2006) for comparing the results from both algorithms.

For BRKGA, the results of the smallest instance (instance 2_0_2) cannot be reached. Indeed, the population size, which is equal to twice of the number of strips, is too small for generating the new generation from the three sets of chromosomes in BRKGA process.

In the comparison, the box plots show that IBMOLS obtains better median values of the hypervolume for all instances and better standard deviations for most of the results. Moreover, IBMOLS spends less computation time than BRKGA, especially for large instances. Additionally, the statistical test reveals that the results of IBMOLS are significantly better than those of BRKGA. Fig. 12 illustrates the improvement of the hypervolume values versus the computation times for some instances of TestSet A, B, and X. In each graph, the improvement of hypervolume values between BRKGA process and IBMOLS process is analyzed. The results show that IBMOLS obtains solutions closer to the Pareto optimal solutions for medium and large instances. Moreover, it can also converge to the Pareto optimal solutions faster than BRKGA.

Finally, the best approximate Pareto fronts of some instances in TestSet A, B and X, which are obtained from IBMOLS, are illustrated in Fig. 13. For each instance, the total profit is presented on x-axis and the maximum profit difference between users is presented on y-axis. The hypervolume value of each approximate Pareto front is also indicated. The figure shows that IBMOLS can obtain good nondominated solutions on the approximate Pareto fronts for all instances. Moreover, the best total profit values of TestSet A, B, and X, which are obtained from IBMOLS and from the winners of ROADEF 2003 challenge (Cordeau & Laporte, 2005; Kuipers, 2003), are compared in Table 1
                        . Although our work considers two objective functions simultaneously, IBMOLS can reach values of best total profit, the values of which are quite close to the results from the winners of ROADEF 2003 challenge. Indeed, for TestSet A, B, and X, the relative deviation of IBMOLS is 1.7 percent, 3.7 percent, and 3.4 percent, respectively; over all instances, this deviation is then only 3.0 percent.

An indicator-based multi-objective local search (IBMOLS) is used for solving a multi-objective optimization problem associated with selecting and scheduling observations of an agile Earth observing satellite. The ROADEF 2003 challenge instances are modified in order to take account explicitly of four-user requirements. Two objective functions, maximizing the total profit and minimizing the maximum profit difference between users for the fairness of resource sharing, are considered and the imperative constraints must be satisfied. The implementation was done and the results, which are obtained from IBMOLS and the biased random-key genetic algorithm (BRKGA), are compared.

For BRKGA, random-key encoding generates each chromosome in the population and the chromosomes are decoded to be the sequences of the selected acquisitions. A hybrid decoding is presented in this paper. The elite selecting method from IBEA is used for selecting the preferred solutions to become the elite set of the population. An elite set, a crossover offspring set, and a mutant set are combined to become the next population. The selection of the dominant solution is used to manage the elite set in the hybrid decoding process.

IBMOLS is implemented by generating the initial population using a random generation for the first iteration and a perturbation for the other iterations. The indicator-based fitness assignment with the hypervolume concept from IBEA is applied for comparing the solutions in the population. The hypervolume values from IBMOLS and BRKGA are compared. Most of the results show that IBMOLS obtains better solutions and it spends less computation time.

As perspectives, we present short term and long term further works. Concerning the short term works, it may be possible to improve the results obtained from IBMOLS. The initial population generation step for the first iteration by using data of the problem instances may be used instead of the random generation. For example, the order to assign each acquisition in the initial sequence can depend on the acquiring duration time of each acquisition. The acquisition with the longest acquiring duration time should be assigned firstly in the sequence. Moreover, the number of removed elements in the perturbation for the initial population generation in the other iterations can also be modified. For the long term works, other perturbation rules and other neighborhood structures can be explored. An example of perturbation rule is to insert some feasible acquisitions for replacing the removed elements.

@&#ACKNOWLEDGMENTS@&#

This research was partially funded by the THEOS Operational Training Programme (TOTP) of Geo-Informatics and Space Technology Development Agency in Thailand (GISTDA). This research was initiated while the first author was with LAAS-CNRS, Université de Toulouse, France. The authors are indebted to anonymous referees for their numerous constructive remarks.

@&#REFERENCES@&#

