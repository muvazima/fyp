@&#MAIN-TITLE@&#Integrated projects planning in IS departments: A multi-period multi-project selection and assignment approach with a computerized implementation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The paper is an inter-disciplinary research of applying OR in projects management.


                        
                        
                           
                           Address a sustainability issue of handling continuous IS project demands in contemporary IT departments.


                        
                        
                           
                           Features mixed-integer-programming model to optimize the selection and assignment of projects on a multi-period, multi-project basis.


                        
                        
                           
                           It innovatively considers the losses due to unselecting or delaying projects in each time of selection and assignment.


                        
                        
                           
                           It implements a computerized solution that automatically enables the sustainability of continuous and cumulative selections and assignments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Project management

Information system (IS) development projects

Projects selection and assignment

Multi-project multi-period

Mixed integer programming

@&#ABSTRACT@&#


               
               
                  This paper highlights the subject of integrated projects planning (IPP) in contemporary IS departments, and presents a multi-period, multi-project selection and assignment approach (MPPA) to assist the departments in handling continuous project-based IS requests. The MPPA features a model to optimize the selection and assignment of IS projects. In the scope of multi-project, multi-period planning, the model innovatively considers the losses due to (1) the accumulated postponement of a previously unselected IS request and (2) the expected delay of ongoing projects when inserting a new project request. The MPPA also features an event-based decisional process for cumulative selection and assignment on a multi-period basis. Due to the complex and contextual nature of data in this paper, a computerized system is implemented for aiding the execution of the model and the process. The paper reports on an industrial case for a demonstration of the proposed work. Finally the paper compares the MPPA with related work to summarize the value and role it may play in the IPP context.
               
            

@&#INTRODUCTION@&#

@&#BACKGROUND@&#

Information system (IS) departments play a critical role in today’s computerized enterprise. Within an enterprise, the IS departments receive requests from other departments to implement or maintain all sorts of information systems. These IS requests are often handled in the form of a project, due to today’s “projectized” business operations (Engwall, 2003; Huemann et al., 2006; Goncalves et al., 2008). The increasing reliance of firms on computers has resulted in a continuous IS project demand in IS departments, many of which have limited or insufficient developer resources to handle the ongoing stream of requests. As a result, some IS requests with less initial nominal value are put on hold and never have a chance for development. It also happens that an ongoing project with a previously optimized schedule is negatively impacted due to the insertion of new projects. In view of these issues, the question of how to effectively select projects and assign developer resources, as well as maintain the optimal planning results from one period to the next, has become a critical challenge in IS departments. The research refers to this challenge as integrated projects planning (IPP).

In the literature, IPP is an emerging research. While the subject of multiple projects selection in IPP has received considerable scholarly attention, most studies are scoped to one-time aggregate planning (Goncalves et al., 2008; Chang et al., 2008; Harper et al., 2005; Wiley et al., 1998). They rarely consider the re-planning of projects, which is a critical issue due to project dynamics. These dynamics include the arrival of new requests, the completion of current projects and developer leave, which may occur during the development. As for the assignment of developers, existing studies mostly focus on their assignment to a single project (Barreto et al., 2008; Tsai et al., 2003; Elonen and Artto, 2003). There is little or no research that considers this assignment as a continuing and collective effort in order to maintain the maximum organizational benefits. However, the selection and assignment results in previous periods should be considered in the current period. This is especially important considering that developers are often shared in projects; and they are often engaged in existing work when new tasks are assigned to them.

In this paper, the issue concerning the demands that may aggravate the complexity of projects planning is theorized as a multi-period, multi-project selection and assignment problem, and is elaborated as follows: (1) IS departments need a systematic process to continuously perform project selection and oversee the assignment of developers in dynamic operational environments; (2) during each period of selection and assignment, IS departments need to effectively select projects and assign shared developer resources, and decide whether to postpone or delay projects and re-plan them in subsequent periods; (3) in the re-planning, IS departments need to consider the criticality for an IS request if it continues to be unselected, as well as take into account the costs of delaying ongoing projects due to the insertion of new requests.

To address these concerns, this paper suggests a multi-period, multi-project selection and assignment approach (abbreviated as MPPA). The MPPA has three features. The first feature is a mixed-integer programming model for optimizing the selection and assignment of IS projects. In the task of projects selection, the model applies the Taguchi Loss Function (Ross, 1996; Antony and Kaye, 2000) to consider and describe the increasing criticality of previously unselected requests or delayed projects. In the assignment task, the model allocates IS developers’ capacities to the selected projects under a M:M relationship. The second feature is an event-based decisional process for systematically operating the optimization model on a multi-period basis. Such a process enables the sustainability of continuous and cumulative selection and assignment decisions. Due to the multi-project and continuous planning manner, the data are complicated. Thus, a computerized prototype is implemented as the third feature for aiding the execution and handling of the MPPA and the data.

To demonstrate the proposed work, this paper reports on an industrial case and presents several major use cases to walk through the application of the work. The paper also compares the MPPA with related work to summarize the value and role it may have in the IPP context. The organization of the paper is as follows. The next section presents a survey of the related literature. Section 3 introduces the MPPA. Section 4 reports on an industrial case and Section 5 presents the comparative evaluation. Finally, Section 6 concludes the study.

@&#LITERATURE REVIEW@&#

In this paper, IPP focuses on the integration of project selection with the optimized assignment of developer resources that occurs in a multi-project setting and on a multi-period basis. This holistic focus reflects the directive of the Project Management Institute (2008), which states that project planning requires a plan for maximizing organizational value. This means that organizations in contemporary business environments should no longer plan projects individually (Engwall, 2003; Zika-Viktorsson et al., 2006; Krüger and Scholl, 2009; Gonçalves et al., 2008). One reason that individual planning is considered ineffective is that projects often share limited resources (Santhanam and Kyparisis, 1996; Lova et al., 2000; Bouleimen and Lecocq, 2003; Hartmann and Briskorn, 2010). Also, in any sustainable business, projects planning needs to consider the impact of previous planning results on resource engagements. Due to these concerns, the assignment of projects requires a collective and continuous effort.

Human resources plays an important role in sustaining the effort required of integrated projects planning (IPP), and this is especially true in IS projects where knowledgeable and volatile project work is conducted (Marchewka, 2010; Drezet and Billaut, 2008; Teasley et al., 2002; Tavares, 2002). In operations research, the project assignment issue refers to the mathematical programming for maximizing benefits when assigning people to project work (Lieberman, 2005). According to Patanakul et al. (2007), this assignment involves two tasks: (1) developing algorithms for optimizing the assignment and (2) establishing a process for performing the assignment. In terms of the projects assignment method and optimal solution, a number of approaches have been adopted. For example, Mian and Dai (1999) have adopted a technique called Analytic Hierarchy Process (AHP) that refers to the assignment of multiple projects. Their method features a pair-wise comparison of projects based on project requirements. The method considers the characteristics of project managers and also related technology support. However, the research focuses on a one-time assignment and assumes that all the projects are known in the beginning of the planning. In an attempt to simplify the project boundary in multi-project planning, Bassett (2000) has employed mathematical programming in chemical projects using a heuristic approach for maximizing the utilization of an organization’s internal human resources and minimizing the utilization of external resources. However, the report does not include an empirical demonstration of the method applied to actual business operations. In the civil engineering domain, LeBlanc et al. (2000) has used the binary integer programming technique, taking into consideration employee turnover during the development of construction projects. The study focuses on factors such as the maximum contribution and the minimum cost involved in assigning project managers to multiple projects.

In addition to addressing the difficulty of handling assignments in a multi-project scheme, IPP also takes multi-periods into pragmatic consideration. Owing to the dynamics of software development and operational environments in IS departments, dynamics that include the arrival of new IS requests, the completion of current projects, and developer leave during the development, the selection and assignment of projects must undergo continual re-planning in order to maintain the optimization result. This re-planning differs from the aggregate planning defined by Kalpic et al. (1995), which refers to a one-time collective effort for scheduling typical production batches. While the multi-period assignment problem is not addressed by the aggregate planning approach, it has been seen in the literature. For example, Miller and Franz (1996) have used Binary-Rounding Heuristics to address this problem. However, their study assumes that the arrival of tasks is predictable and can be determined by predefined regular budget proposals. This assumption does not hold true in the case of IS departments where the arrival of IS project requests may not be presumable (Romeijn and Morales, 2001).

To effectively handle IS requests and re-plan existing projects accordingly, the selection and assignment decision should consider the projects as a totality so as to maximize organizational benefits. Due to the uncertain IS project operational dynamics mentioned previously, consideration should also be given to the multi-period situation in order to maintain the maximization of organizational value. In the literature, there are few studies that consider both multi-project and multi-period situations. Smith et al. (2001) has reported an empirical assignment study between the tasks of an IS project and the developers. The study points out several assignment factors such as team size, task concurrency, and project fragmentation; however, the study is limited to single project assignment. Tsai et al. (2003) has combined Critical Resource Diagram (CRD) with an IS project assignment by using CRD to describe the relationship between developers and the tasks of an IS project. Here again, however, the study does not consider that developer resources among projects may be shared and that this may impact the effectiveness of the assignment result.

More recently, Chang et al. (2008) has applied the genetic algorithm to the planning and assigning of an IS project. Although their method is also scoped to a single project planning, it features a multi-period concept in modeling the dynamic relationship between the tasks of a phased project and the developers. In addition, Barreto et al. (2008) has defined a constraint satisfaction problem in their multi-period assignment optimization model. In this model, the assignment is performed based on the professional skills of developers and the mutual exclusion of tasks assigned to the same developer. In determining suitable developers for the tasks, the model uses the utility function to describe the diminishing return of the developer/task relationship. However, the mutual exclusion design of the developer-task assignment seems insufficient in IS departments where developers may handle more than one project. Another limitation, and one that applies to both studies, is that the “multi-period” concept they model refers to the various development phases inside a project, not to the multi-period projects planning situation.

Furthermore, losses may occur in multi-period IS projects selection and assignment, and these need to be considered. Ongoing projects may be delayed due to the insertion of some preemptive project requests, and project requests with lower priorities (less organizational value) may be postponed and have little chance to enter the development. Such losses and opportunity costs of postponement and delay may become critical and impact the original value of the projects to the organization. For example, postponing an IS project defers the benefit the project is supposed to bring to the organization. As the postponement continues, the loss incurred, along with the blame received from the acquiring department, accumulate and increase the criticality of the project. Such cost impacts should be taken into account in integrated projects planning.

Developed by Gen’ichi Taguchi, the Taguchi loss function is a concept of non-linear value that uses a graphical representation of loss to describe quantitatively a phenomenon in which production variables affect product quality (Ross, 1996; Antony and Kaye, 2000; Pi and Low, 2005). In the Taguchi function, quality is determined by the loss to society after the product has been delivered to the customer; quality loss results from the waste of expenses and resources when the quality characteristics do not meet the targeted value (Goetsch and Davis, 2009). This approach to quality loss differs from the traditional way of evaluating quality. In the past, qualified products were those that had a fixed amount of quality error, and the loss due to quality error had a linear relationship with the number of errors. In the Taguchi loss function, each product quality has its target value (T), and when the quality characteristics deviate from the target value T, an increasing square of loss due to the deviation is produced.

Taguchi’s loss function can be classified into five categories: nominal the best, smaller the better, larger the better, asymmetric, and zero-point proportional (Roy, 2001). The smaller the better, L(y)=
                        k y
                        2, indicates a desirability interval where the closer the delay, y, is to zero, the closer it is to the ideal value. If the y is bigger, then the resulting loss increases by the square rate of y. The mathematical formula of the Taguchi loss function can be expressed as: L(y)=
                        k(y
                        −
                        T)2, where k is a constant value.

In integrated projects planning, when a project is delayed or postponed, the impact extends not only to a monetary loss and waste of resources; it also includes blame from the acquiring departments as well as the reputation loss of IS departments. Such losses accumulate nonlinearly as the delay continues to increase, and the Taguchi loss function can be applied to describe the losses. This study applies the Taguchi loss function by considering the characteristic of the square increase in the function category of “the smaller the better.” Thus, it describes the objective of minimizing the expected schedule impact when trying to interrupt an ongoing project; it also describes and highlights the criticality of the loss and impact that accrue when a project has been delayed from one period to the next.

@&#METHODOLOGY@&#

The MPPA includes an optimization model for selection and assignment optimization, and a continual optimization process design for running the model. Before going into the details of the approach, the study defines the relevant terms.


                        
                           
                              (1)
                              
                                 Project scale: Information system projects vary in scale, which is determined by project size and complexity (Marchewka, 2010). In the MPPA, project scale is considered when decomposing and breaking down larger IS projects into functional segments/modules for the purpose of assigning the work to an individual developer. As the case presented in a later section shows, there are two scales of IS projects: mini projects (e.g., modifying Web pages for existing systems) and standard projects (e.g., building a new system). Mini projects are done by one developer. Standard projects are larger and need more developers. To be consistent in the assignment of small and large projects, the MPPA divides standard projects into segments, and each segment is assigned to an individual developer.


                                 Project queue: Project requests that do not enter the development schedule are put into the project queue zone. Each time the model performs the selection and assignment task, it reconsiders the projects from the queue zone along with existing ongoing projects and the newly arrived project requests.


                                 Assigned capacity, development capability, reserved space, and experience level: Empirically, a developer may not be fully available for a new project. In the MPPA, the total development capacity of a developer includes the engaged/assigned space, available space, and reserved space. The model assumes that developers are introduced at the beginning of a project when they are assigned to the project. In addition, an assigned developer’s development capacity is based on his/her capability, which studies typically define in terms of experience level. This study uses accumulated IS project experiences to define a developer’s capability, and it ranks this capability in terms of new/entry, medium, and senior levels. As the project case reported in a later section shows, a senior developer has a higher development capability (1.5) than that (1.0) of a developer with a medium level of experience. This means that more projects can be assigned to developers with higher capabilities.


                                 A project’s organizational value: For each project request, the value and benefits that are brought to the firm must be quantified and presented by the acquiring unit/client. This value refers to the Measurable Organizational Value (MOV) (PMI, 2008), which ought to be available during the project initialization stage. The MPPA model takes the MOV of each project request in optimizing the selection and assignment of projects.

In the MPPA, the goal of the model is to maximize the overall organizational benefits obtained in the planning process, where this process refers to the selection and assignment of projects. The model first prioritizes the projects based on their MOV and assigns projects to suitable developers according to their capability levels. It then takes the previous planning results into account. If a suitable developer is fully engaged in existing projects, the program analyzes all the possible decisions. These include assigning the new project to the suitable but fully engaged developer, in which case ongoing projects will be delayed; handing the new project to other developers; or simply putting it in the queue zone for reconsideration in a later period. During the analysis, the model innovatively considers the losses when decisions are made to delay ongoing projects or to postpone new project requests. In this way, the model highlights the criticality and urgency of postponed or delayed projects, thus increasing the chance of starting new projects or speeding up the remaining development work.

The aforementioned losses are calculated on the basis of a project’s MOV. For example, suppose that the MOV of a project is 10,000 USD/month. A delay of 3months means a loss of 10,000×3=30,000 USD that would have been obtained had the project been on schedule. Such a loss is dramatically exaggerated when the intangible damage to business reputation resulting from customer blame is taken into consideration. The model includes this damage in its computation of a project’s total organizational benefit, which is defined as the weighted project value. Among possible projects, the one with the highest weighted project value has the greatest chance of being assigned for development. Table 1
                         below shows the descriptions of the variables used in the model.
                           
                              (1)
                              
                                 The objective function: With the goal of maximizing the value of IS projects brought to an organization, the objective function is expressed as:
                                    
                                       (1)
                                       
                                          MAX
                                          
                                          Z
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                B
                                             
                                             
                                                ijk
                                             
                                          
                                          ×
                                          
                                             
                                                X
                                             
                                             
                                                ijk
                                             
                                          
                                       
                                    
                                 
                              


                                 The benefit function: In the objective function, the benefit Bijk
                                  is further formulated as:
                                    
                                       (2)
                                       
                                          
                                             
                                                B
                                             
                                             
                                                ijk
                                             
                                          
                                          =
                                          [
                                          
                                             
                                                M
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                L
                                             
                                             
                                                i
                                                ,
                                                k
                                                -
                                                1
                                             
                                          
                                          -
                                          
                                             
                                                O
                                             
                                             
                                                ik
                                             
                                          
                                          ]
                                          ×
                                          
                                             
                                                E
                                             
                                             
                                                jc
                                             
                                          
                                       
                                    
                                 As Eq. (2) indicates, the formula is computed by the total weighted value of project i minus the expected losses due to the current planning result. The total weighted value of project i refers to the MOV (Mi
                                 ) plus the accumulated loss (Li,k−1
                                 ) of the project. The design of adding Li,k−1
                                  to the project value is to highlight the postponement of an IS project request and to increase the priority of the project so as to speed up the development. The subtraction item Oik
                                  refers to the possible delay of project i due to the insertion of other preemptive projects. In order to maximize Bijk
                                 , the model minimizes Oik
                                 , indicating that the project underway should be continued on schedule unless new projects with a higher weighted value arrive. The benefit function includes Ejc
                                  for a design purpose of assigning the project to the developer who has higher experience level of project type (c). Code c is a numeric number denoting various project types, for example, 1 for the production system projects, 2 for the HR projects, etc. The organization can maintain experience levels of the developers to provide the information of Ejc
                                 . For example, as it is shown later in the reported case, the company has an experience table (see Fig. 4
                                 ) that is automatically updated for providing the model with the current Ejc
                                  information.

The loss function of project delay or postponement
                                    
                                       (3)
                                       
                                          
                                             
                                                O
                                             
                                             
                                                ik
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            q
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            
                                                               
                                                                  ∑
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                            
                                                               
                                                                  r
                                                               
                                                               
                                                                  ijk
                                                               
                                                            
                                                            /
                                                            
                                                               
                                                                  D
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  q
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                          ×
                                          
                                             
                                                K
                                             
                                             
                                                1
                                             
                                          
                                          ;
                                          
                                          
                                             
                                                L
                                             
                                             
                                                i
                                                (
                                                k
                                                -
                                                1
                                                )
                                             
                                          
                                          =
                                          
                                             
                                                t
                                             
                                             
                                                i
                                                ,
                                                k
                                                -
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          ×
                                          
                                             
                                                K
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 Eq. (3) expresses the accumulated losses due to project delay and the expected loss due to current planning. In (3), the default development rate, qi
                                 , of each project is normally set to 1 in order to provide a full scale of development effort (i.e., 1 man-period). In the case of multiple projects (including project i) being assigned to a developer at period k and qi
                                  equaling 1, the development rate for the project is less than 1 and causes a possible delay (Oik
                                 ). In Oik
                                 , the value of a possible delay (i.e., the expected loss) is based on the project’s development ratio. Suppose that at period k the model assigns the developer’s capacity as 0.5 (=rijk
                                 ) to a two-segment (Di
                                 
                                 =2) project and qi
                                  is set to 1; then the development assignment ratio of the project at period k can be expressed as 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             r
                                          
                                          
                                             ijk
                                          
                                       
                                       /
                                       (
                                       
                                          
                                             D
                                          
                                          
                                             i
                                          
                                       
                                       ×
                                       
                                          
                                             q
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       =
                                       (
                                       2
                                       ×
                                       0.5
                                       )
                                       /
                                       2
                                       =
                                       0.5
                                    
                                 . The value (0.5) from qi
                                  (1 in this case) can then be subtracted to compute the possible delay due to the development rate of the assignment. Li,k−1
                                  refers to the accumulated delay of project i that has already occurred prior to period k. The value of Li,k−1
                                  exponentially increases as the delay continues across subsequent periods. Such a nonlinear growth pattern also represents the intangible loss of business reputation mentioned earlier. According to the definition of the Taguchi loss function, K1
                                  and K2
                                  are constants that are obtained experientially.


                                 Constraint: The sum number of assigned developers to project i is equal to the total segments of the project, or else it is set to 0. This can be expressed as:
                                    
                                       (4)
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                X
                                             
                                             
                                                ijk
                                             
                                          
                                          =
                                          
                                             
                                                D
                                             
                                             
                                                i
                                             
                                          
                                          
                                          or
                                          
                                          0
                                          
                                          for all
                                          
                                          i
                                       
                                    
                                 According to the first definition (i.e., of project scale) in Section 3.1, a standard project is divided into segments so that each segment can be assigned to an individual developer. Hence, the number of segments equals the number of developers assigned to the project. If the project is not assigned, none of the segments of the project are assigned.


                                 Constraint: The total development capacities of projects assigned to a developer must be less than the development capability of the developer. This can be expressed as:
                                    
                                       (5)
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ijk
                                                      
                                                   
                                                
                                             
                                          
                                          +
                                          
                                             
                                                er
                                             
                                             
                                                j
                                             
                                          
                                          ⩽
                                          
                                             
                                                e
                                             
                                             
                                                j
                                             
                                          
                                          
                                          for all
                                          
                                          j
                                       
                                    
                                 The summation of total assigned development capacities for projects plus the reserved space of capacity (erj
                                 ) must not be larger than the developer’s development capability (ej
                                 ). The value of erj
                                  may vary in organizations. In a functional organization (PMI, 2008), the value of erj
                                  can be higher than in a project-based organization, because developers here often spend more time on departmental work.


                                 Constraint: To obtain an objective assignment and to simplify the analysis, the segments are evenly divided. This can be expressed as:
                                    
                                       (6)
                                       
                                          
                                             
                                                r
                                             
                                             
                                                ijk
                                             
                                          
                                          =
                                          
                                             
                                                r
                                             
                                             
                                                
                                                   
                                                      ij
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                k
                                             
                                          
                                          
                                          for all,
                                          
                                             
                                                X
                                             
                                             
                                                ijk
                                             
                                          
                                          =
                                          
                                             
                                                X
                                             
                                             
                                                
                                                   
                                                      ij
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                k
                                             
                                          
                                       
                                    
                                 This constraint considers the rules of thumb in project management regarding the linear or equal division of group effort. For example, a four man-month job can be finished in 2months by two workers. In the case where the divided segment actually requires more effort than this even division specifies, the model allows the developer to use the reserved space (erj
                                 ) provided in the model to crash the extra workload. This space is reserved to accommodate this risk. Note that the transient index j′ is used in this formula to denote another developer (developer j′ who has the same X value as developer j) in the assignment.


                                 Constraint: The assignment value of an ongoing project must not be lower than the minimum development rate. This can be expressed as:
                                    
                                       (7)
                                       
                                          
                                             
                                                r
                                             
                                             
                                                ijk
                                             
                                          
                                          ⩾
                                          ez
                                          
                                          for all
                                          
                                          
                                             
                                                X
                                             
                                             
                                                ijk
                                             
                                          
                                          ≠
                                          0
                                       
                                    
                                 Since software development is highly contextualized, discontinuing an ongoing project often results in significant costs when the project is resumed. Therefore, the model gives underway projects a minimum capacity value (greater than 0). This is to ensure that once a project enters the development, it is not totally stopped due to the insertion of other projects. The value of ez may vary among organizations.


                                 Constraint: In order to avoid over assigning projects to the most capable developers, the model has the following upper-limit constraint on assignments:
                                    
                                       (8)
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         ijk
                                                      
                                                   
                                                
                                             
                                          
                                          ⩽
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              ∑
                                                                           
                                                                           
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           S
                                                                        
                                                                        
                                                                           i
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   j
                                                
                                             
                                          
                                          
                                          for all
                                          
                                          j
                                       
                                    
                                 To illustrate this constraint, suppose there are 14 projects assigned to six developers; the upper limit is 14/6=2.33, that is, three projects for each developer. The model then attempts to maximize the benefit under such a hold-back constraint.


                                 Constraint: The assignment priority is dependent on the project priority. It is expressed as:
                                    
                                       (9)
                                       
                                          
                                             
                                                
                                                   ⋃
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                
                                                   Mi
                                                
                                             
                                          
                                          
                                             
                                                X
                                             
                                             
                                                ijk
                                             
                                          
                                          ⩾
                                          
                                             
                                                
                                                   ⋃
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                
                                                   Mi
                                                
                                             
                                          
                                          
                                             
                                                X
                                             
                                             
                                                
                                                   
                                                      i
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                jk
                                             
                                          
                                          
                                          for all
                                          
                                          i
                                          ,
                                          
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                          
                                             
                                                P
                                             
                                             
                                                ik
                                             
                                          
                                          >
                                          
                                             
                                                P
                                             
                                             
                                                
                                                   
                                                      i
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                k
                                             
                                          
                                       
                                    
                                 The assignment of projects to developers considers the values, Pik, of projects. The formula indicates the mutual (project i and i′) comparisons of the projects. Pik
                                  is determined by the order of the summation regarding the MOV and the losses of delay (if any) of a project. If these values happen to be identical, the model chooses projects that have an earlier arrival.


                                 Model outputs: After the model is solved, two assignment outputs are obtained. We use two matrices to present the outputs. The project assignment matrix, Xij
                                 , presents the binary (0 or 1) values Xijk
                                  at period k. The other matrix, Rij
                                 , is the corresponding development capacities, rijk
                                 , for these assigned developers at period k. Fig. 1
                                  below gives an example of the two resulting matrices. In the first assignment matrix, value 1 of Xijk
                                  indicates that project i is assigned to developer j; value 0 means that project i is NOT assigned to developer j. In the second matrix, values such as 0.4 and 0.7 are obtained according to the model, especially the following constraints in the model: (5) all of a developer’s development space for the assigned projects cannot exceed his total capacity, for example, 1.2, (6) the development space assignments of different developers that are assigned to the same project are equal, (7) any rijk
                                  values of an ongoing project must not be lower than the minimum development rate, and then (3) finding the best rijk
                                  values for the largest model benefits.

In addition to the model development, this study establishes a decisional process for running the model on a multi-period basis. The process is event-based, and three triggering events are defined as follows:
                           
                              (1)
                              
                                 Completion of project. When a project is completed, the engaged development space of the assigned developers is released. The model is then called for re-planning. Under the objective of maximizing the total organizational benefits, the model reconsiders the awaiting project requests in the queue zone and selects suitable projects for entering the development; the model also re-plans and reconsiders current assignments of projects underway to adjust as necessary the developers’ development capacities.


                                 Arrival of new project. When new projects arrive, the model is called to select suitable projects for entry/insertion into the development schedule. The selection considers the benefits of the new project requests along with the benefits of awaiting project requests and underway projects. Developers’ capacities are reassigned accordingly.


                                 Developer change. Employee change is a dynamic issue that commonly occurs in IS environments. In the multi-period and multi-project context, developer change is a cause for re-planning. In the case of developer leave, the model updates the developer list and rearranges among other developers the projects assigned to the departing developer. For the projects underway, the minimum development capacity rule still applies.

The MPPA continual optimization process is designed to review the planning periodically. During each period of review, the optimization model is executed when any one of the aforementioned triggering events occur. To avoid an unnecessary transaction cost, IS departments may not choose to run the model on a per new project arrival basis or project completion basis. Instead, they may reconsider awaiting projects and review the developers’ assignment collectively at a fixed period of time, e.g., weekly or biweekly. If triggering events do not occur during a period of review, the model will retain the planning decision from the previous period. Fig. 2
                         shows the process of such an event-based, multi-project selection and assignment optimization process.

In Fig. 2, the notation k
                        =1 denotes the initialization of the MPPA process. Afterwards, at each period of review, if one or more events have occurred the process will call the model to re-select projects and rearrange the corresponding assignments. The value of period k can be one week, two weeks, etc., depending on the specific situation of an organization. For example, in an organization that has a high IS project demand, the IS department may set k to a smaller value to perform multi-project selection and assignment on a more frequent basis. The k can be a larger number when the developer’s resource is very insufficient or when the department prefers to have a more stable assignment.

XXX Technologies Corporation (the company name is abbreviated as NTC hereafter) is a leading DRAM (Dynamic Random Access Memory) manufacturer in Taiwan. Like other companies, NTC is constantly in need of developing and maintaining ad-hoc information systems due to a heavy reliance of its business environment on computers. This is also due to the fast changing and fierce competitive business environment of the global computer industry. Such a huge and continuous IS-related demand is quite a task for the Information Systems Department (abbreviated as ISD) of the company.

In ISD, all the IS-related requests are handled in projects. Based on the scale of system development (for example, to build a new production control system) or maintenance (for example, to modify some pages for an existing sales system), IS projects are classified into two types: standard projects and mini projects. As indicated in Table 2
                         below, IS project requests occupied about 80% of the entire business efforts of ISD. The remaining 20% of business efforts was reserved for the ISD staff to take care of the department’s functional affairs and meetings, and to fix ad-hoc small bugs in the firm’s information systems.

Due to the continual demand of IS project requests and the relative inadequacy of developers, some project requests with lower importance (i.e., projects with a comparatively small MOV) are postponed and might never have the chance to enter the development schedule. Such a delay often leads to blame from the acquiring departments and thus harms the reputation of ISD dramatically if the delay continues. Besides, when projects are selected and assigned to developers, attention must be given to the developers’ existing project loading obtained from the previous planning results. This study demonstrates how the MPPA is applied to address the aforementioned concerns by assisting the organization in planning projects effectively and continually.

When a request arrives, it needs to be accompanied by the following data: project name, defaulted development schedule, number of segments (for standard projects), and the expected MOV of the proposed project. In NTC, the acquiring departments provide the MOV of the IS requests. The ISD then reviews the project’s organizational value to avoid an inflated estimate that is due to an attempt to let the project enter the development ahead of others. The defaulted development schedule refers to the expected time for completing the project. The ISD sets the development rate at 1 for a mini project, and at 1/(number of segments) for a standard project. As shown in Table 2, 20% of the effort in the ISD is reserved for handling administrative jobs and departmental work. For simplification, the reserved capacity value (erj
                        ) for all developers is set to 0.2. In spite of this, the value of erj
                         still can have different values for different developers. The minimum engaged capacity value of developers is set to 0.15 for any underway projects, and the frequency of periodical review is set to a week, indicating that new project requests are reviewed collectively on a weekly basis. According to the above information and based on the definitions in Table 1, the model is configured as follows:
                           
                              
                                 
                                    
                                       
                                          
                                             Maximize
                                             :
                                             
                                          
                                       
                                       
                                          
                                             Z
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   B
                                                
                                                
                                                   ijk
                                                
                                             
                                             ×
                                             
                                                
                                                   X
                                                
                                                
                                                   ijk
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             Subject
                                             
                                             to
                                             :
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   B
                                                
                                                
                                                   ijk
                                                
                                             
                                             =
                                             [
                                             
                                                
                                                   M
                                                
                                                
                                                   i
                                                
                                             
                                             +
                                             
                                                
                                                   L
                                                
                                                
                                                   i
                                                   (
                                                   k
                                                   -
                                                   1
                                                   )
                                                
                                             
                                             -
                                             
                                                
                                                   O
                                                
                                                
                                                   ik
                                                
                                             
                                             ]
                                             ×
                                             
                                                
                                                   E
                                                
                                                
                                                   jc
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   O
                                                
                                                
                                                   ik
                                                
                                             
                                             =
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               q
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        j
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     r
                                                                  
                                                                  
                                                                     ijk
                                                                  
                                                               
                                                               /
                                                               
                                                                  
                                                                     D
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     q
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                             ×
                                             0.1
                                             
                                                
                                                   M
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   L
                                                
                                                
                                                   i
                                                   (
                                                   k
                                                   -
                                                   1
                                                   )
                                                
                                             
                                             =
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                   (
                                                   k
                                                   -
                                                   1
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                             ×
                                             0.2
                                             
                                                
                                                   M
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   X
                                                
                                                
                                                   ijk
                                                
                                             
                                             =
                                             
                                                
                                                   D
                                                
                                                
                                                   i
                                                
                                             
                                             
                                             or
                                             
                                             0
                                             
                                             for all
                                             
                                             i
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            ijk
                                                         
                                                      
                                                   
                                                
                                             
                                             +
                                             0.2
                                             ⩽
                                             
                                                
                                                   e
                                                
                                                
                                                   j
                                                
                                             
                                             
                                             for all
                                             
                                             j
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   r
                                                
                                                
                                                   ijk
                                                
                                             
                                             =
                                             
                                                
                                                   r
                                                
                                                
                                                   
                                                      
                                                         ij
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   k
                                                
                                             
                                             
                                             for all
                                             
                                             
                                                
                                                   X
                                                
                                                
                                                   ijk
                                                
                                             
                                             =
                                             
                                                
                                                   X
                                                
                                                
                                                   
                                                      
                                                         ij
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            ijk
                                                         
                                                      
                                                   
                                                
                                             
                                             ⩽
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 ∑
                                                                              
                                                                              
                                                                                 i
                                                                              
                                                                           
                                                                        
                                                                        Si
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      j
                                                   
                                                
                                             
                                             
                                             for all
                                             
                                             j
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   r
                                                
                                                
                                                   ijk
                                                
                                             
                                             ⩾
                                             0.15
                                             
                                             for all
                                             
                                             
                                                
                                                   X
                                                
                                                
                                                   ijk
                                                
                                             
                                             ≠
                                             0
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      ⋃
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      Mi
                                                   
                                                
                                             
                                             
                                                
                                                   X
                                                
                                                
                                                   ijk
                                                
                                             
                                             ⩾
                                             
                                                
                                                   
                                                      ⋃
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      Mi
                                                   
                                                
                                             
                                             
                                                
                                                   X
                                                
                                                
                                                   
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   jk
                                                
                                             
                                             
                                             for all
                                             
                                             i
                                             ,
                                             
                                                
                                                   i
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                             
                                                
                                                   P
                                                
                                                
                                                   ik
                                                
                                             
                                             >
                                             
                                                
                                                   P
                                                
                                                
                                                   
                                                      
                                                         i
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   k
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Because of the complexity of handling contextual planning data for multiple projects and multiple periods, a computerized system interface prototype is implemented. This paper demonstrates the MPPA via the system using a walkthrough analysis with four cases. In each case, the original Chinese screen has been translated into English to ensure readability. Also, the identity of the case organization has been obscured and some sensitive information adjusted for reasons of business security.


                        Fig. 3
                         illustrates the projects that enter the model during the first period. In the figure, Project A is a standard project which is evenly broken down into two segments. The determination of the number of segments for a standard project is arbitrary, and is based on the scale of functional requirements or modules of the project. The number 9 in the “Number of Required Periods” field represents a nine man-week, the estimated project time.

The MPPA needs information from the developers for the ongoing planning task; thus the system includes a developer master file that maintains basic information about developers and their accumulated project experiences. Fig. 4 is a screenshot of the developers’ experience table in such a file. When a developer finishes a standard project or a mini project, the developer’s experience value is updated by adding 2 or 1 respectively.


                        Fig. 5
                         below shows the resulting matrices of running the MPPA at period 1. Fig. 5a is the binary assignment result. This serves as a quick view for both the management and the developers regarding the assignment result. In the figure we can see that the standard projects A and G are assigned to developers {S002, S003} and {S003 and S006}. Senior developer S001 is assigned to project B and D with designated development capacities of 0.84 and 0.46; hence the total development capacity of S001 is 1.5. The developer S002 is assigned to project A and C with designated development capacities of 0.5 and 0.8, and a total development capacity of 1.5. After the initial period, the model re-plans the projects according to an event-based operational process. The four cases below provide a walkthrough analysis of this continual operation.

In order to stabilize the development, the model retains the assignment decision (refer to Fig. 5) in periods subsequent to project commencement until one of the three triggering events occurs. In this case example, the arrival of project request H in the 3rd period causes the model to re-plan the projects.

The model is now solved to see how to assign project H so that the overall maximum benefits can be obtained. At this time there are 6 developers and 10 project segments in total; according to Eq. (8) of the model, the upper limit of projects and segments assigned to each developer is 2. Hence only developers S004, S005 and S006 are considered for the project H assignment. In addition, because S005 has no experience of that project type (see Fig. 4), the model gives the lowest consideration to the assignment of project H to S005. This is shown by the zero Ejc
                            value in the objective function. The MPPA then comparatively computes the overall benefits of assigning H to S004, S006, or, alternatively, to no developer. Fig. 6
                            shows the planning result. Table 3
                            is the comparative analysis for verifying the results. As the comparisons in the table show, the recommendation (assigning H to S004 with the recommended capacity value) by the model yields the highest benefit (468,160).

During period 3, project F is completed. The administrator goes to the project master page and clicks on the Closed button (see Fig. 7
                           ) to change the status of the project. At this time, the engaged space of developer S005 for project F is released, causing the model to re-plan in order to allow the development assignment for S005 to be rescheduled. Meanwhile, because project F is a type of HR, the development experience (refer to Fig. 4) of S005 for that project type is updated by adding 1.

In reality, IS developers may leave during the development. When this happens, the system needs to update the developer information and call the optimization model for re-planning. To avoid costs due to stopping and resuming an IS project in NTC, any project once started should not be discontinued (see Eq. (7)), even in the case of developer leave. In the following example, suppose that a developer (S001) leaves at period 7. The administrator then opens the screen (Fig. 4) and clicks on the leaving developer to terminate the assignment. The program transfers the assigned projects to other developers by using the model.

After developer termination, the model re-assigns S001’s projects B and D to other developers. At this time the total number of project segments and developers is 10 and 5 respectively, indicating (according to Eq. (8)) that the maximum number of projects is 2. The model then comparatively computes the benefits of assigning B and D to developer S004 and S006. Fig. 8
                            is the case result after the re-planning. As this case shows, such a change often results in some impact, i.e., delay, to other ongoing projects. When this impact continually exists or aggravates planning, the organization may consider recruiting new developers. Also as shown in this figure, project A has two segments, which are assigned to developer S002 and S003, and each segment would require half (0.5) of the developer’s scheduled work time. In other words, if a week has 40 work hours, then the developer is scheduled to work 20hours on the project during this period. Another example, project K has three segments, so three developers are assigned to this project, and each of the developers is assigned a 0.45 development capacity for this project.

At period 8, two new projects, L and M (a standard project) arrive. If the two projects are included, the total number of project segments reaches 13; hence, the maximum number of projects that can be assigned will increase to 3. After the model is solved, as shown in Fig. 9
                           , L is assigned to S006 and M to {S002, S003} based on their competitive MOV values.

At period 9, another new project request, N, arrives, and the model is called to consider it. At this time because the projects assigned to developers S002, S003 and S006 have reached the upper limit (three projects), the model considers S004 and S005 for project N. However, the benefit of inserting N is less than doing nothing. Therefore, the model retains the current assignment setting and puts project N into queue. Table 4
                            below analytically verifies the comparisons among the different projects.

Although project N stays in queue, as time goes by its Bijk
                            value (in Eq. (2)) increases, and the model reconsiders the project at every period of review. After three periods of waiting, the loss of delay, Li,k
                           
                           −1, of N becomes 90,000, which makes its Bijk
                            large enough to enter the development. After the analytical computation as shown in Table 5
                           , the model assigns N to S005.

In this section, the contribution of the MPPA is evaluated. The MPPA is compared to related work in the literature to discuss the role it plays in integrated projects planning and project management. Table 6
                      on the next page presents a summary of the comparison results.

The evaluation centers on an efficient and effective algorithm design and is presented from three aspects in IPP: project selection, developer assignment, and the scale of projects. With respect to assignments, most of the studies contribute to the literature on a single project assignment (Tsai et al., 2003; Chang et al., 2008; Barreto et al., 2008). These studies, as most others in the project assignment literature, tend to be project-centric. In busy organizations like the IS departments, a developer often handles more than one project; hence, the developers’ concurrency problem is a critical factor to the success of an assignment. The MPPA and the algorithm design together provide a holistic and human-centric planning perspective, whereby projects are assigned to developers on a collective basis so as to improve efficiency and yield a more optimum result.

In many studies, assignment optimization is based on the developers’ set of skills. Chang et al. (2008), Tsai et al. (2003) and Smith et al. (2001) proposed their assignment models that consider skill requirements. Based on their work, this paper further points out that, in reality, developers are often in the middle of working on some other projects when a new project is assigned to them. In this case, aggregate planning may not be effective, especially when the arrival of new projects cannot be pre-determined.

To address this issue, the MPPA is designed to assign projects on a continuous basis (multiple periods), for the purpose of allowing for the re-planning of projects. This multi-period planning scope in the MPPA enhances the models of Chang et al. (2008) and Barreto et al. (2008) which are scoped to a one-time assignment. Such a holistic planning perspective also addresses the distortion mentioned in Engwall’s report (2003) whereby existing projects are isolated and planned individually, as in traditional project management. Moreover, in the continuous planning scheme, the MPP highlights an important consideration: in spite of their low initial project value, unselected projects become critical if they continue to be neglected. In view of this issue, this paper proposes a mathematical treatment to increase their chance of being reconsidered for development.

Finally, with respect to project scale, existing project management mostly focuses on large or standard projects. In fact, the IS departments often spend a significant amount of effort on handling smaller projects. For example, the IS department in the case study used a total of 66% of its entire business operations for handling one-man mini IS projects (refer to Table 2). If integrated project planning does not take into holistic consideration these small yet continually effort-consuming work requests, it becomes unrealistic and ineffective. Hence, the MPPA model plans the large and small projects collectively. It considers different scales of projects by dividing standard (larger) projects into comparable development segments for the purpose of planning them together with the mini projects.

@&#CONCLUSION@&#

Although integrated projects planning is important to the sustainability of IS departments, it has received inadequate attention in the literature; hence, the work introduced in this paper reflects a substantial need. The IS departments require an innovative model that provides a continual approach to projects selection and assignment. The MPPA, which includes an optimization selection and assignment model and a decisional process, fills this gap. The case report in this paper demonstrates the proposed benefits of this approach by its real use of the MPPA in industry. In follow up research, the author proposes to continue the development of the MPPA. For system design and implementation, there is a plan to include the integration of the system prototype with existing PM tools, for the purpose of developing an integrated environment of computer-aided project management. For theory development, the author proposes to continue exploring the subject of integrated projects planning in order to build a more comprehensive IPP theory in this area of study.

@&#ACKNOWLEDGEMENT@&#

This paper thanks relevant stakeholders from XXXX (NTC) Company, especially Wesley Chang (Senior Director), Gary Chang (Department Manager), and Walker Chen (Section Chief) for their support and collaboration in the research. The authors thank the Taiwan National Science Council for financially supporting this research (100-2628-E-008-009-MY2).

@&#REFERENCES@&#

