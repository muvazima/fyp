@&#MAIN-TITLE@&#A new approach for sheet nesting problem using guided cuckoo search and pairwise clustering

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new approach for solving sheet nesting problem is introduced.


                        
                        
                           
                           Cuckoo search combined with guided local search are used in this approach.


                        
                        
                           
                           Pairwise clustering is proposed to reduce the complexity of the nesting problem.


                        
                        
                           
                           The proposed approach provides significantly better results than the previous state of the art.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cutting

Nesting

No-fit polygon

Clustering

Cuckoo search

Guided local search

@&#ABSTRACT@&#


               
               
                  The nesting problem is commonly encountered in sheet metal, clothing and shoe-making industries. The nesting problem is a combinatorial optimization problem in which a given set of irregular polygons is required to be placed on a rectangular sheet. The objective is to minimize the length of the sheet while having all polygons inside the sheet without overlap. In this study, a methodology that hybridizes cuckoo search and guided local search optimization techniques is proposed.
                  To reduce the complexity of the nesting problem, pairwise clustering is introduced to group congruent polygons together in pairs. Pairwise clustering is done automatically to discover matched features among multiple present polygons. Computational experiments show that the implementation is robust and also reasonably fast. The proposed approach provides significantly better results than the previous state of the art on a wide range of benchmark data instances.
               
            

@&#INTRODUCTION@&#

The nesting problem is a very common problem and its economic and ecological impact is obvious in many industrial environments such as glass, paper, leather, textile, and sheet metal industries. This problem is a class of the cutting and packing problems and it is a combinatorial optimization problem that deals with various types of polygons including irregular or non-convex polygons, convex polygons, as well as rectangles. The problem involves placing a set of input polygons on a rectangular sheet or container of a fixed width (W) and variable length (L) ensuring that there are no overlapping polygons or protruding from the container. Using the typology of Wäscher, Haußner, and Schumann (2007), this problem is categorized as the two-dimensional irregular open dimensional problem (ODP). The main objective is to maximize the container utilization or to minimize its length while accommodating all polygons inside. The high utilization is greatly desirable in industry so as to minimize the waste material since the material cost is often the major part of the production cost. Fig. 1
                      shows an instance of the nesting problem with a feasible layout.

The nesting problem has a few variations relying on rotations of polygons: (1) rotations of any angle are allowed, (2) a finite number of angles are allowed, and (3) no rotation is allowed. In some industries such as textile or clothing industry, there is a restriction on the shape rotation due to the fabric drawing patterns and intrinsic characteristics, so it is limited to 0° or 180°. The nesting problem is known to be NP-hard even without rotation (Nielsen & Odgaard, 2003).

In the industrial environments this problem is usually tackled by experienced workers who build the nesting layout and this may be with the aid of CAD systems. The quality and utilization produced by those skilled workers is high when it is compared with that produced from the available commercial software packages. A list of semi-automatic commercial solutions is available in Hopper (2000) and Nielsen and Odgaard (2003). In this paper a new solution method for the nesting problem is presented. This is based on a hybrid algorithm that combines the cuckoo search and the guided local search optimization techniques. In order to reduce the search space for generating a good layout, pairwise clustering is introduced. Pairwise clustering aims to discover matched features of congruent polygons and group them in pairs. Experiments show that the proposed solution method is very efficient compared with other published methods and new better results of high quality have been attained for all benchmark data instances.

@&#LITERATURE REVIEW@&#

For the nesting problem, there exist many solution approaches researchers have attempted. A detailed survey by Dowsland and Dowsland (1995) exists and more recent surveys have also been done by Nielsen and Odgaard (2003) and Bennell and Oliveira (2009). The use of meta-heuristics and hybrid algorithms as powerful optimization tools has been impressively applied to this problem and a detailed discussion of these approaches can be found in Bennell and Dowsland (1999) and Hopper and Turton (2001). There are two main groups of methods for solving the nesting problem. The first group is representing the problem as a sequence of polygons, which is called searching over a sequence. The second group is working with the solution directly and moving polygons within the layout, which is called searching over the layout.

Constructing the initial layout requires polygon placement in a sequence sorted by area, length, width, irregularity, rectangularity, or in a random order (Oliveira, Gomes, & Ferreira, 2000). The solution is further altered by introducing some local neighborhood search techniques. These techniques include swap move, insert move, and change orientation move (Bennell & Oliveira, 2009).


                        Albano and Sapuppo (1980) proposed a construction algorithm which places each polygon to the left-most feasible position on the right envelope of the set of already placed polygons. They utilized the no-fit polygon (NFP) in addition to a profile simplification method to reduce the geometric complexity of the nesting process. This was the first time that the term “no-fit polygon” was used, but the concept had been introduced in Art (1966) who alternatively used the term “shape envelope”. Oliveira et al. (2000) implemented a more sophisticated placement strategy called TOPOS approach. This approach allows the layout to grow from a floating origin and both the next polygon to be placed and its position are determined using a range of criteria.


                        Gomes and Oliveira (2002) proposed a 2-exchange mechanism to search over a placement sequence where bottom-left procedure was adopted as the placement heuristic. Jakobs (1996), Babu and Babu (2001) and Wong, Wang, Mok, Leung, and Kwong (2009) used genetic algorithm for searching over polygon sequences where the sequence can be represented directly as a chromosome. Sato, Martins, and Tsuzuki (2012) adopted simulated annealing with collision free region in order to determine feasible layouts in containers with fixed dimensions. When searching over a sequence, it is necessary to decode the sequence into a packing layout to evaluate the solution quality. This implies more computational cost than that of evaluating a move within the layout.

This group involves two subgroups depending on two main characteristics. The first characteristic is related to the technique of searching over the solution space, or whether to use continuous or discrete space. The second one deals with the definition of the neighborhood of a solution, or how to alter the solution. The first subgroup involves local search approaches and the second one involves compaction and separation approaches.

Many local search methods cannot deal with a continuous solution space and therefore require some means of reducing it to a discrete set of points. Using grid-like discretization over the sheet is a common method, but this may remove potentially good placement points. Another most commonly used approach for this is using the concept of no-fit polygon since it provides direct promising placement points. Blazewicz, Hawryluk, and Walkowiak (1993) proposed a tabu search algorithm that reduces the infinite neighborhood. They utilized bottom-left heuristic that allows placing a polygon into a hole surrounded by placed polygons, in addition to the right envelope of the set of placed polygons.

Another consideration for defining solutions is whether to permit overlap between polygons, protrusion from the sheet or not. Having this allowance for solution progress provides a smoother continuous search space, however the final solution may include a small amount of overlap. Egeblad, Nielsen, and Odgaard (2007) formulated a polynomial time algorithm to determine the amount of overlap. Considering only vertical and horizontal translation, they proposed a fast neighborhood search in order to obtain minimum overlap and, consequently, feasible layouts. Umetani et al. (2009) developed a fast local search algorithm for minimizing the overlap by translating polygons in horizontal and vertical directions alternately. They also incorporated a variant of the guided local search algorithm to escape the local minima. Imamichi, Yagiura, and Nagamochi (2009) combined a swap procedure with iterative local search and a separation algorithm based on non-linear programming to solve the overlap minimization problem. Leung, Lin, and Zhang (2012) adopted a similar approach, but they used tabu search to escape local minima.

Compaction and separation approaches model and solve the problem as a linear program where the objective is to minimize length and the constraints prevent or remove overlap and ensure pieces remain within the sheet. Given a feasible nesting layout, a compaction algorithm is applied to shrink the container length at a certain amount while translating polygons or changing their orientations continuously. On the other hand, for a non-feasible layout which contains overlapped polygons, a separation algorithm is applied to translate polygons or change their orientations continuously in order to remove the overlap. The linear programming formulation varies between the different published implementations with respect to the objective function and selection of the no-overlap constraints.


                           Stoyan, Novozhilova, and Kartashov (1996) and Bennell and Dowsland (2001) define the objective function as minimizing length of packing. Gomes and Oliveira (2006) hybridized simulated annealing with linear programming to obtain feasible layouts. They also relaxed the no-overlap constraints by introducing a dummy variable that accounted for the overlap between polygons and attempted to minimize this in the objective function.

There are different techniques utilized for establishing intersection tests and overlap calculation between polygons with varying degrees of success. They include direct trigonometry, phi-function, and no-fit polygon techniques. The direct trigonometric technique is famous and widely incorporated for collision detection systems. It involves line segment intersection and point inclusion tests. Although these tests are more computationally complex in comparison to the raster methods, run time cannot be directly compared. For the raster method the time to check feasibility is quadratic in the grid size, whereas for direct trigonometry it is exponential in the number of edges of the polygons (Hopper, 2000).

The phi-function is the most recent innovation in dealing with geometric issues in nesting problems. It can express all mutual positions between two polygons through mathematical expressions. The phi-function can have one of three values; (1) greater than zero for separated polygons, (2) equal to zero for touching polygons, and (3) less than zero for overlapped polygons. The phi-function is able to convert the nesting problem to a classical optimization problem which can be solved by any standard linear or non-linear optimization method (Chernov, Stoyan, & Romanova, 2010).

The no-fit polygon has become an increasingly popular option for conducting intersection tests between pairs of polygons. It can also represent all the positions that two polygons may take so that they not only touch but also they can be moved closer together without intersecting one another. Given two polygons P
                     
                        i
                      and P
                     
                        j
                      of fixed orientations, their no-fit polygon is the trace of the reference point v
                     
                        j
                      of the orbiting polygon P
                     
                        j
                      while it slides on the fixed polygon P
                     
                        i
                      without intersection as shown in Fig. 2
                     . For definite allowable orientations, the calculation of the no-fit polygon can be done in the preprocessing stage and this will remain fixed, speeding up the nesting process rather than the direct trigonometric techniques. By utilizing no-fit polygons, the polygons collision detection can be reduced to a significantly less expensive point inside polygon test (Dowsland, Vaid, & Dowsland, 2002).

There are three main approaches for the generation of the no-fit polygon which are the orbiting algorithm (Mahadevan, 1984), Minkowski sums (Milenkovic, Daniels, & Li, 1991; Bennell, Dowsland, & Dowsland, 2001), and decomposition into star shaped polygons (Li & Milenkovic, 1995) or convex polygons (Watson & Tobias, 1999; Agarwal, Flato, & Halperin, 2002). In most cases, Minkowski sums yield faster running times than the fastest decomposition scheme (Wein, 2006) and also more efficient than the orbiting algorithm. In this paper, the Minkowski sum based on the reduced convolution technique (Behar & Lien, 2011) is applied to generate all the no-fit polygons. The mathematical formulation of generating the no-fit polygon between two polygons P
                     
                        i
                      and P
                     
                        j
                      using the Minkowski sum is defined as follows
                        
                           (1)
                           
                              NFP
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                              ⊕
                              (
                              -
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                              )
                              =
                              {
                              u
                              -
                              w
                              |
                              u
                              ∈
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              w
                              ∈
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                              }
                           
                        
                     
                  

The no-fit polygon has the following important properties:
                        
                           •
                           
                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               and P
                              
                                 j
                              
                              ⊕
                              
                                 v
                              
                              
                                 j
                               overlap if and only if 
                                 v
                              
                              
                                 j
                              
                              −
                              
                                 v
                              
                              
                                 i
                              
                              ∈
                              NFP(P
                              
                                 i
                              ,
                              P
                              
                                 j
                              ),


                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               touches P
                              
                                 j
                              
                              ⊕
                              
                                 v
                              
                              
                                 j
                               if and only if 
                                 v
                              
                              
                                 j
                              
                              −
                              
                                 v
                              
                              
                                 i
                              
                              ∈
                              ∂NFP(P
                              
                                 i
                              ,
                              P
                              
                                 j
                              ),


                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               and P
                              
                                 j
                              
                              ⊕
                              
                                 v
                              
                              
                                 j
                               are separated if and only if 
                                 v
                              
                              
                                 j
                              
                              −
                              
                                 v
                              
                              
                                 i
                              
                              ∉
                              cl(NFP(P
                              
                                 i
                              , P
                              
                                 j
                              )),

The inner-fit rectangle has the following important properties which are inherited from the no-fit polygon:
                        
                           •
                           
                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               protrudes from C if and only if 
                                 v
                              
                              
                                 i
                              
                              ∉
                              cl(IFR(C,
                              P
                              
                                 i
                              )),


                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               is contained in C and touches ∂C if and only if 
                                 v
                              
                              
                                 i
                              
                              ∈
                              ∂IFR(C,
                              P
                              
                                 i
                              ),


                              P
                              
                                 i
                              
                              ⊕
                              
                                 v
                              
                              
                                 i
                               is contained in C and does not touch ∂C if and only if 
                                 v
                              
                              
                                 i
                              
                              ∈
                              IFR(C,
                              P
                              
                                 i
                              ).

This section delivers a mathematical formulation to the sheet nesting problem. For the sheet nesting problem, it is given a list of polygons 
                        
                           P
                           =
                           (
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 P
                              
                              
                                 n
                              
                           
                           )
                        
                     , a list of their allowable orientations 
                        
                           O
                           =
                           (
                           
                              
                                 O
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 O
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 O
                              
                              
                                 n
                              
                           
                           )
                        
                     , where O
                     
                        i
                     (1⩽
                     i
                     ⩽
                     n) denotes the set of all orientations polygon P
                     
                        i
                      can take, and a rectangular sheet or container C
                     =
                     C(W,
                     L) with fixed width W
                     ⩾0 and variable length L
                     ⩾0. Polygons 
                        
                           P
                        
                      may be convex ornon-convex. For convenience, the container edges with length L are set parallel to x-axis as shown in Fig. 1.

A polygon 
                        
                           
                              
                                 P
                              
                              
                                 i
                              
                           
                           ∈
                           P
                        
                      rotated by o
                     ∈
                     O
                     
                        i
                      degree is denoted by P
                     
                        i
                     (o), which may be written as P
                     
                        i
                      for simplicity when its orientation is not specified or clear from the context. The position of a polygon P
                     
                        i
                      is described by a vector 
                        v
                     
                     
                        i
                     
                     = (x
                     
                        i
                     ,
                     y
                     
                        i
                     ) of its reference point, which is a point of P
                     
                        i
                     , for example, a vertex or the center of gravity of P
                     
                        i
                     . The polygon translation by 
                        v
                     
                     
                        i
                      is described by the Minkowski sum P
                     
                        i
                     
                     ⊕
                     
                        v
                     
                     
                        i
                     
                     ={
                        p
                     
                     +
                     
                        v
                     
                     
                        i
                     ∣
                        p
                     
                     ∈
                     P
                     
                        i
                     }. The main objective is to minimize the container length L while ensuring no overlap between polygons (the overlap minimization problem).

The solution of the sheet nesting problem is represented by lists of positions 
                        v
                     
                     = (
                        v
                     
                     1,
                     
                        v
                     
                     2,…,
                     
                        v
                     
                     
                        n
                     ) and orientations 
                        o
                     
                     = (o
                     1,
                     o
                     2,…,
                     o
                     
                        n
                     ) of all polygons P
                     
                        i
                     (1⩽
                     i
                     ⩽
                     n) and a solution (
                        v
                     ,
                     
                        o
                     ) uniquely determines the layout of the polygons. The length L of the container C is determined by
                        
                           (3)
                           
                              L
                              (
                              v
                              ,
                              o
                              )
                              =
                              
                                 max
                              
                              {
                              x
                              |
                              (
                              x
                              ,
                              y
                              )
                              ∈
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              ⊕
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              1
                              ⩽
                              i
                              ⩽
                              n
                              }
                              -
                              
                                 min
                              
                              {
                              x
                              |
                              (
                              x
                              ,
                              y
                              )
                              ∈
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              ⊕
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              1
                              ⩽
                              i
                              ⩽
                              n
                              }
                              .
                           
                        
                     
                  

The problem of the sheet nesting is formally described as follows:
                        
                           (4)
                           
                              
                                 
                                    
                                       minimize
                                       
                                       L
                                    
                                 
                                 
                                    
                                       subject
                                       
                                       to
                                       
                                       int
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       ⊕
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       ∩
                                       int
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             o
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       ⊕
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       =
                                       ∅
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       <
                                       j
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       ⊕
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       ⊆
                                       C
                                       (
                                       W
                                       ,
                                       L
                                       )
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             O
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             R
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       L
                                       ⩾
                                       0
                                       .
                                    
                                    
                                 
                              
                           
                        
                     
                  

Overlap minimization problem is a sub-problem of sheet nesting problem that must be solved in order to reach a feasible placement or solution (
                        v
                     ,
                        o
                     ) of given polygons 
                        
                           P
                        
                      for container C and given fixed length L
                     ∗. In this sub-problem, polygons are permitted to overlap each other, but do not protrude from the container C and the total amount of overlap is penalized in such a way that a solution with no overlap gives a feasible placement. Consider f
                     
                        ij
                      (
                        v
                     
                     
                        i
                     ,
                     
                        v
                     
                     
                        j
                     ,
                     o
                     
                        i
                     ,
                     o
                     
                        j
                     ) to be a function that measures the amount of overlap between a pair of polygons P
                     
                        i
                     (o
                     
                        i
                     ) and P
                     
                        j
                     (o
                     
                        j
                     ) placed at 
                        v
                     
                     
                        i
                      and 
                        v
                     
                     
                        j
                     , respectively. The objective of the overlap minimization problem is to find a solution (
                        v
                     ,
                     
                        o
                     ) that minimizes the total amount of overlap while ensuring that all polygons are placed inside the container C with fixed width W and fixed length L
                     ∗. Then this problem is formally described as follows:
                        
                           (5)
                           
                              
                                 
                                    
                                       minimize
                                       
                                       F
                                       (
                                       v
                                       ,
                                       o
                                       )
                                       =
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                n
                                                -
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                i
                                                +
                                                1
                                             
                                             
                                                n
                                             
                                          
                                       
                                       
                                          
                                             f
                                          
                                          
                                             ij
                                          
                                       
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                 
                                 
                                    
                                       subject
                                       
                                       to
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      P
                                                   
                                                   
                                                      i
                                                   
                                                
                                                (
                                                
                                                   
                                                      o
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ⊕
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                       ⊆
                                       C
                                       (
                                       W
                                       ,
                                       
                                          
                                             L
                                          
                                          
                                             ∗
                                          
                                       
                                       )
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             O
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       ,
                                    
                                 
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             R
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                    
                                    
                                       1
                                       ⩽
                                       i
                                       ⩽
                                       n
                                       .
                                    
                                 
                              
                           
                        
                     
                  

For the calculation of the overlap penalty, Egeblad et al. (2007) used the intersection area for each pair of polygons P
                     
                        i
                      and P
                     
                        j
                      as the overlap penalty. Imamichi et al. (2009) considered another formulation of the overlap minimization problem that allows the protrusion of polygons from the container in addition to overlap of polygons. For this problem, they used the penetration depth of each pair of polygons P
                     
                        i
                      and P
                     
                        j
                      as the overlap penalty, and the protrusion distance of P
                     
                        i
                      from the inner-fit rectangle as the protrusion penalty. Umetani et al. (2009) used the directional penetration depth to define the overlap penalty function of each pair of polygons P
                     
                        i
                      and P
                     
                        j
                     . The penetration depth δ(P
                     
                        i
                     ,
                     P
                     
                        j
                     ) of a pair of overlapping polygons P
                     
                        i
                      and P
                     
                        j
                      is defined as the minimum translational distance to separate them. If they do not overlap, then their penetration depth is zero. Formally, the definition of the penetration depth is given by
                        
                           (6)
                           
                              δ
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              min
                              {
                              ‖
                              u
                              ‖
                              |
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                              ∩
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              ⊕
                              u
                              )
                              =
                              ∅
                              ,
                              u
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                              }
                              ,
                           
                        
                     where ∥·∥ denotes the Euclidean norm.

The directional penetration depth ρ(P
                     
                        i
                     ,
                     P
                     
                        j
                     ,
                     
                        d
                     ) of a pair of overlapping polygons P
                     
                        i
                      and P
                     
                        j
                      is defined as the minimum translational distance in a given direction 
                        
                           d
                           =
                           (
                           
                              
                                 d
                              
                              
                                 x
                              
                           
                           ,
                           
                              
                                 d
                              
                              
                                 y
                              
                           
                           )
                           (
                           ‖
                           d
                           ‖
                           =
                           1
                           ,
                           d
                           ∈
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                           )
                        
                      to separate them (Dobkin, Hershberger, Kirkpatrick, & Suri, 1993). Formally, the definition of the directional penetration depth is given by
                        
                           (7)
                           
                              ρ
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              ,
                              d
                              )
                              =
                              min
                              {
                              |
                              t
                              |
                              |
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                              ∩
                              int
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              ⊕
                              (
                              t
                              d
                              )
                              )
                              =
                              ∅
                              ,
                              t
                              ∈
                              R
                              }
                              .
                           
                        
                     
                  

In this paper, as by Imamichi et al. (2009), the overlap penalty f
                     
                        ij
                     (
                        v
                     
                     
                        i
                     ,
                     
                        v
                     
                     
                        j
                     ,
                     o
                     
                        i
                     ,
                     o
                     
                        j
                     ) for a pair of polygons P
                     
                        i
                     (o
                     
                        i
                     ) and P
                     
                        j
                     (o
                     
                        j
                     ) placed at 
                        v
                     
                     
                        i
                      and 
                        v
                     
                     
                        j
                      is described by
                        
                           (8)
                           
                              
                                 
                                    f
                                 
                                 
                                    ij
                                 
                              
                              (
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    o
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              δ
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              (
                              
                                 
                                    o
                                 
                                 
                                    i
                                 
                              
                              )
                              ⊕
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              (
                              
                                 
                                    o
                                 
                                 
                                    j
                                 
                              
                              )
                              ⊕
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              )
                              .
                           
                        
                     
                  

In this section, an overall description of the proposed algorithm for solving problems (4, 5) is delivered. This algorithm is called guided cuckoo search (GCS) and it consists of two phases. The first phase is responsible for minimizing the sheet length while the second phase handles the overlap minimization problem. Fig. 4
                      shows successive improvements beginning with a low utilization feasible layout until reaching a higher utilization feasible layout.

The first phase generates an initial feasible solution (
                        v
                     
                     1,
                     
                        o
                     
                     1) by a construction algorithm which will be explained in Section 6. Then it computes the container length L so that it contains all polygons 
                        
                           P
                        
                      inside the container C without overlap. The execution of this phase is controlled by two parameters r
                     
                        dec
                      and r
                     
                        inc
                     . These parameters stand for the percentage of container length decreasing and increasing.

If the current solution (
                        v
                     
                     
                        cur
                     ,
                     
                        o
                     
                     
                        cur
                     ) is feasible, it is accepted and it replaces the best found solution (
                        v
                     
                     
                        best
                     ,
                     
                        o
                     
                     
                        best
                     ). The container length L is then shrunk to (1−
                     r
                     
                        dec
                     )L and it reallocates each protruding polygon at the least overlapping position (Fig. 4) inside the container and then it invokes the second phase. Using Eq. (9), all candidate placement points for the protruding polygons can be calculated. The least overlapping position can be identified by evaluating the overlap penalty by Eq. (8) at each point of set A, and choosing the point which leads to the minimum overlap penalty.

In order to resolve overlap, the second phase uses the cuckoo search optimization technique (Yang & Deb, 2009) to move polygons inside the container with guided local search (Voudouris & Tsang, 1995) in order to avoid trapping in local minima. If the current solution (
                        v
                     
                     
                        cur
                     ,
                     
                        o
                     
                     
                        cur
                     ) is not feasible, it increases the container length L to (1+
                     r
                     
                        inc
                     )L and also invokes the second phase again. The outline of the GCS algorithm is formally described in Algorithm 1.
                        Algorithm 1
                        GCS 
                              
                                 (
                                 P
                                 ,
                                 O
                                 ,
                                 W
                                 )
                              
                           
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   )
                                                   =
                                                   GenerateInitialSolution
                                                   (
                                                   P
                                                   ,
                                                   O
                                                   ,
                                                   W
                                                   )
                                                   
                                                   /
                                                   /
                                                
                                              
                                             Section 
                                             6
                                          
                                       
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   )
                                                   =
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          (
                                                v
                                             
                                             
                                                cur
                                             ,
                                             
                                                o
                                             
                                             
                                                cur
                                             )= (
                                                v
                                             
                                             1,
                                             
                                                o
                                             
                                             1)
                                       
                                       
                                          
                                             L
                                             
                                                best
                                             
                                             =
                                             L(
                                                v
                                             
                                             1,
                                                o
                                             
                                             1)// Using Eq. 
                                             (3)
                                          
                                       
                                       
                                          
                                             L
                                             = (1−
                                             r
                                             
                                                dec
                                             ) L
                                             
                                                best
                                             
                                          
                                       
                                       
                                          
                                             while time limit do
                                          
                                       
                                       
                                          
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   )
                                                   =
                                                   MinimizeOverlap
                                                   (
                                                   P
                                                   ,
                                                   O
                                                   ,
                                                   W
                                                   ,
                                                   L
                                                   ,
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             if (
                                                v
                                             
                                             
                                                cur
                                             ,
                                                o
                                             
                                             
                                                cur
                                             ) is feasible then
                                          
                                       
                                       
                                          
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   )
                                                   =
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         cur
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             L
                                             
                                                best
                                             
                                             =
                                             L
                                          
                                       
                                       
                                          
                                             
                                             L
                                             = (1−
                                             r
                                             
                                                dec
                                             )L
                                             
                                                best
                                             
                                          
                                       
                                       
                                          
                                             
                                             else
                                          
                                       
                                       
                                          
                                             
                                             L
                                             = (1+
                                             r
                                             
                                                inc
                                             )L
                                             
                                                best
                                             
                                          
                                       
                                       
                                          
                                             
                                             end if
                                          
                                       
                                       
                                          
                                             end while
                                          
                                       
                                       
                                          
                                             return 
                                             
                                                
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         o
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         best
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

This section describes the construction algorithm for generating initial feasible solution (
                        v
                     
                     1,
                     
                        o
                     
                     1). This is based on the bottom left heuristic that accepts a sequence of polygons P
                     
                        i
                     (1⩽
                     i
                     ⩽
                     n) sorted according to certain criteria (Oliveira et al., 2000). It then transfers them to a feasible placement utilizing the no-fit polygon and inner-fit rectangle. The initial layout and further the solution quality can be enhanced by grouping matched features of some polygons together in clustered pairs.

To generate the initial feasible layout, the bottom-left heuristic by Gomes and Oliveira (2002) is used. Given a container C and a set of polygons P
                        
                           i
                        ,1⩽
                        i
                        ⩽
                        n, already placed in coordinates (x
                        
                           i
                        ,
                        y
                        
                           i
                        ), then the next polygon P
                        
                           k
                         is placed according to a bottom-left strategy, i.e., at the point (x
                        
                           k
                        ,
                        y
                        
                           k
                        ) with smaller x and, for equal x with smaller y, so that P
                        
                           k
                         is inside the container and does not overlap any polygon P
                        
                           i
                         already placed.

Using the concepts of no-fit polygon and inner-fit rectangle, the set A of candidate placement positions for polygon P
                        
                           k
                         can be stated as follows:
                           
                              (9)
                              
                                 A
                                 =
                                 {
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 |
                                 (
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 ∈
                                 NFP
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       k
                                    
                                 
                                 )
                                 )
                                 ∧
                                 (
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 ∈
                                 int
                                 (
                                 IFR
                                 (
                                 C
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       k
                                    
                                 
                                 )
                                 )
                                 )
                                 ,
                                 1
                                 ⩽
                                 i
                                 <
                                 k
                                 ⩽
                                 n
                                 }
                                 ,
                              
                           
                        
                        
                           
                              (10)
                              
                                 B
                                 =
                                 {
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       min
                                    
                                 
                                 ,
                                 y
                                 )
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       min
                                    
                                 
                                 ⩽
                                 x
                                 ∀
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 ∈
                                 A
                                 |
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 
                                 ∉
                                 
                                 int
                                 (
                                 NFP
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       k
                                    
                                 
                                 )
                                 )
                                 }
                                 ,
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       min
                                    
                                 
                                 ,
                                 
                                    
                                       y
                                    
                                    
                                       min
                                    
                                 
                                 )
                                 |
                                 
                                    
                                       y
                                    
                                    
                                       min
                                    
                                 
                                 ⩽
                                 y
                                 ∀
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       min
                                    
                                 
                                 ,
                                 y
                                 )
                                 ∈
                                 B
                                 ,
                              
                           
                        and for the most bottom-left feasible placement of polygon P
                        
                           k
                        : where NFP(P
                        
                           i
                        ,
                        P
                        
                           k
                        ) is the no-fit polygon of polygon P
                        
                           k
                         relative to polygon P
                        
                           i
                         and IFR(C,
                        P
                        
                           k
                        ) is the inner-fit rectangle of polygon P
                        
                           k
                         relative to container C. Through Eq. (9), any vertex of the region A is:
                           
                              •
                              a vertex of the no-fit polygon NFP(P
                                 
                                    i
                                 ,
                                 P
                                 
                                    k
                                 ) or

a vertex of the inner-fit-rectangle IFR(C,
                                 P
                                 
                                    k
                                 ) or

the intersection of two edges of two no-fit polygons NFP(P
                                 
                                    i
                                 ,
                                 P
                                 
                                    k
                                 ) and NFP(P
                                 
                                    j
                                 ,
                                 P
                                 
                                    k
                                 ) or

the intersection of an edge of the inner-fit-rectangle IFR(C,
                                 P
                                 
                                    k
                                 ) and an edge of a no-fit polygon NFP(P
                                 
                                    i
                                 ,
                                 P
                                 
                                    k
                                 ).

Many nesting problems include multiple congruent polygons that have matched features. Grouping these features together in pairs, especially if large number of polygons is present, can result in better layouts within short running times. All pairs of convex polygons are discarded and only pairs which result in a concave no-fit polygon are only tested for congruence. It is apparent from Fig. 5
                         that a matched feature must be a result of at least one concave polygon and the other polygon may be either convex or concave.

Considering two polygons P
                        
                           i
                         and P
                        
                           j
                         having concave no-fit polygon are selected for clustering test, there are many positions for the orbiting polygon to have while sliding on the fixed one. The clustering criteria are only evaluated at the vertex which is the farthest from the convex hull boundary (denoted by thick line in Fig. 6
                        a) of the no-fit polygon. This vertex is referred to as dominant point (Dp) as shown in Fig. 6a.


                        Algorithm 2 formally describes how to find the dominant point (Dp).
                           Algorithm 2
                           
                              FindDominantPoint(NFP)
                                 
                                    
                                       
                                       
                                          
                                             
                                                V
                                                =
                                                CHV(NFP)// Contours of NFP convex hull vacancies
                                             
                                          
                                          
                                             
                                                OS
                                                =
                                                V
                                                ∩
                                                CH(NFP)// Set of opponent sides
                                             
                                          
                                          
                                             
                                                n
                                                =
                                                size(OS)
                                          
                                          
                                             
                                                maxDist
                                                =0
                                          
                                          
                                             
                                                // Iterate through opponent sides, each side is opposite to an element (contour) of V
                                             
                                          
                                          
                                             
                                                for 
                                                i
                                                =1 to n 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                for each p
                                                ∈
                                                V
                                                
                                                   i
                                                 
                                                do 
                                                // Iterate through points
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                Distance(p,
                                                OS
                                                
                                                   i
                                                )>
                                                maxDist 
                                                then
                                             
                                          
                                          
                                             
                                                
                                                
                                                maxDist
                                                =
                                                Distance(p,OS
                                                
                                                   i
                                                )
                                          
                                          
                                             
                                                
                                                
                                                Dp
                                                =
                                                p
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                end for
                                             
                                          
                                          
                                             
                                                return 
                                                Dp
                                             
                                          
                                       
                                    
                                 
                              
                           

In order to find this dominant point, each no-fit polygon is subtracted from its convex hull to yield a number of separate contours. Each contour is opposite to only one side of the convex hull which is called the opponent side. For polygon P, let CH(P) be the convex hull of P and CHV(P)=
                        CH(P)−
                        P, where CHV is a set of contours that results from the difference between polygon P contour and its convex hull as shown in Fig. 6b. For convenience, CHV(P) is called convex hull vacancies of polygon P and OS be the set of opponent sides of the no-fit polygon convex hull.

The clustering criteria involve two sub criteria to evaluate clustering efficiency. Given two polygons P
                        
                           i
                         and P
                        
                           j
                         as shown in Fig. 7
                        , the first sub criterion (Cr1) is a measure of the intersection areas between the first polygon and the second polygon’s convex hull vacancies.
                           
                              (11)
                              
                                 Cr
                                 1
                                 =
                                 max
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         Area
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                  
                                                                  ∩
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            ∑
                                                         
                                                         Area
                                                         (
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   ∀
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   ∈
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   |
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   =
                                                   CHV
                                                   (
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ∩
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   
                                                   ≠
                                                   
                                                   ∅
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                         
                                                         Area
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         ∩
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         
                                                            ∑
                                                         
                                                         Area
                                                         (
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   ∀
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                   ∈
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   |
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   =
                                                   CHV
                                                   (
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   ,
                                                   
                                                      
                                                         P
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ∩
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                   
                                                   ≠
                                                   
                                                   ∅
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The second sub criterion (Cr2) is a utilization measure of the two polygons inside their circumscribing convex hull.
                           
                              (12)
                              
                                 Cr
                                 2
                                 =
                                 (
                                 Area
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 Area
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 )
                                 /
                                 Area
                                 (
                                 CH
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 ∪
                                 
                                    
                                       P
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 )
                                 .
                              
                           
                        
                     


                        Table 1
                         shows the application of the clustering criteria to a part of swim benchmark data instance to get the best pair. The selected polygons for clustering test are shown in Fig. 8
                        .

Polygons P
                        2, P
                        3, P
                        4 and P
                        5 are tested for best matching against polygon P
                        1. Applying Eqs. (11) and (12) yields that the best clustered pair is pair 4 which is composed of polygons P
                        1 and P
                        5.

Pairwise clustering for polygons is done offline in the preprocessing stage similar to calculating the no-fit polygons. The application of clustering to nesting problems is controlled by choosing a clustering percentage (pr%). The clustering percentage is referred to as how many polygons from the entire input polygons have to be grouped together in pairs. Some problems may not allow high clustering percentage, due to presence of many convex polygons. A clustering percentage of 0% means no polygons are selected for clustering. Clustering of polygons starts by finding the dominant point Dp for each possible pair at which the ClusterValue is to be calculated. The clustered pairs are then sorted according to descending ClusterValue. The pairwise clustering algorithm is formally presented in Algorithm 3.
                           Algorithm 3
                           
                              Cluster(
                                 
                                    P
                                    ,
                                    O
                                    ,
                                    pr
                                 
                              )
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                      =
                                                      size
                                                      (
                                                      P
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                for 
                                                i
                                                =1
                                                to
                                                
                                                n 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                for 
                                                j
                                                =1
                                                to
                                                
                                                n, (i
                                                ≠
                                                j) do
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                NFP(P
                                                
                                                   i
                                                ,P
                                                
                                                   j
                                                ) is Concave then
                                             
                                          
                                          
                                             
                                                
                                                
                                                Dp
                                                =
                                                FindDominantPoint (NFP(P
                                                
                                                   i
                                                ,P
                                                
                                                   j
                                                ))
                                                //Algorithm 2
                                             
                                          
                                          
                                             
                                                
                                                Translate polygon P
                                                
                                                   j
                                                 with its reference point to Dp
                                             
                                          
                                          
                                             
                                                
                                                
                                                V
                                                1
                                                =
                                                CHV(P
                                                
                                                   j
                                                )
                                          
                                          
                                             
                                                
                                                
                                                V
                                                2
                                                =
                                                CHV(P
                                                
                                                   i
                                                )
                                          
                                          
                                             
                                                
                                                Calculate Cr1 from Eq. (11) and Cr2 from Eq. (12)
                                             
                                          
                                          
                                             
                                                
                                                
                                                ClusterValue
                                                =
                                                Cr1+
                                                Cr2
                                          
                                          
                                             
                                                
                                                
                                                
                                                   Pairs
                                                .insert(ClusterValue, pair(i,j))
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                end for
                                             
                                          
                                          
                                             Sort 
                                                   Pairs
                                                 according to descending ClusterValue
                                             
                                          
                                          
                                             Backtrack 
                                                   Pairs
                                                 to ensure that each composing polygon is used once
                                          
                                          
                                             
                                                R
                                                =
                                                
                                                   Pairs
                                                [1:pr∗n/2]
                                          
                                          
                                             Remove individual polygons constituting R from 
                                                   
                                                      P
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      P
                                                      =
                                                      P
                                                      ∪
                                                      R
                                                   
                                                
                                             
                                          
                                          
                                             
                                                return 
                                                
                                                   
                                                      P
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           


                        Cuckoo search(CS) is a meta-heuristic optimization algorithm which has been proposed by Yang and Deb (2009). The algorithm is inspired by the reproduction strategy of cuckoos. At the most basic level, cuckoos lay their eggs in the nests of other host birds, which may be of different species. If the host bird discovers that the eggs are not its own, it will either throw these alien eggs away or simply abandon its nest and build a new nest elsewhere. This has resulted in the evolution of cuckoo eggs which mimic the eggs of local host birds. To apply this as an optimization tool, Yang and Deb (2009) used three idealized rules:
                           
                              •
                              Each cuckoo lays one egg at a time, and dumps its egg in randomly chosen nest.

The best nests with high quality of eggs will carry over to the next generations.

The number of available host nests is fixed, and the egg laid by a cuckoo is discovered by the host bird with a probability P
                                 
                                    a
                                 
                                 ∈[0,1].


                        Yang and Deb (2009) used the following simple representations:
                           
                              •
                              Each egg in a nest represents a solution.

Each cuckoo can lay only one egg (thus representing one solution).

Cuckoo search algorithm uses a balanced combination of a local random walk and a global explorative random walk (Yang, Gandomi, Talatahari, & Alavi, 2013), controlled by a switching parameter P
                        
                           a
                        . The local random walk can be written as
                           
                              (12)
                              
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       t
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       t
                                    
                                 
                                 +
                                 α
                                 s
                                 ⊗
                                 H
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       a
                                    
                                 
                                 -
                                 ε
                                 )
                                 ⊗
                                 
                                    
                                       
                                          
                                             
                                                C
                                             
                                             
                                                j
                                             
                                             
                                                t
                                             
                                          
                                          -
                                          
                                             
                                                C
                                             
                                             
                                                k
                                             
                                             
                                                t
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where 
                           
                              
                                 
                                    C
                                 
                                 
                                    j
                                 
                                 
                                    t
                                 
                              
                           
                         and 
                           
                              
                                 
                                    C
                                 
                                 
                                    k
                                 
                                 
                                    t
                                 
                              
                           
                         are two different solutions selected by random permutation at generation t, H(u) is a Heaviside function, ε is a random number drawn from a uniform distribution, s is the step size and the product ⊗ means entry-wise multiplication. On the other hand, the global random walk is carried out using Lévy flights:
                           
                              (13)
                              
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       t
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                    
                                       t
                                    
                                 
                                 +
                                 α
                                 L
                                 (
                                 s
                                 ,
                                 λ
                                 )
                                 ,
                              
                           
                        where
                           
                              (14)
                              
                                 L
                                 (
                                 s
                                 ,
                                 λ
                                 )
                                 =
                                 
                                    
                                       λ
                                       Γ
                                       (
                                       λ
                                       )
                                       sin
                                       (
                                       π
                                       λ
                                       /
                                       2
                                       )
                                    
                                    
                                       π
                                    
                                 
                                 
                                    
                                       1
                                    
                                    
                                       
                                          
                                             s
                                          
                                          
                                             1
                                             +
                                             λ
                                          
                                       
                                    
                                 
                                 ,
                                 (
                                 0
                                 <
                                 λ
                                 ⩽
                                 2
                                 )
                                 ,
                              
                           
                        where α
                        >0 is the step size scaling factor which should be related to the scales of the problem of interest and Γ(z) is the Gamma function, 
                           
                              Γ
                              (
                              z
                              )
                              =
                              
                                 ∫
                                 
                                    0
                                 
                                 
                                    ∞
                                 
                              
                              
                                 
                                    t
                                 
                                 
                                    z
                                    -
                                    1
                                 
                              
                              
                                 
                                    e
                                 
                                 
                                    -
                                    t
                                 
                              
                              dt
                           
                        .

Lévy flights essentially provide a random walk while their random steps are drawn from a Lévy distribution for large steps. From the implementation point of view, the generation of random numbers with Lévy flights consists of two steps: the choice of a random direction and the generation of steps which obey the chosen Lévy distribution. The generation of a direction should be drawn from a uniform distribution, while the generation of steps is quite tricky. There are a few ways of achieving this, but one of the most efficient and yet straightforward ways is to use the Mantegna algorithm (Mantegna, 1994) for a symmetric Lévy stable distribution. Here “symmetric” means that the steps can be positive and negative. In Mantegna’s algorithm, the step sizes can be calculated by
                           
                              (15)
                              
                                 s
                                 =
                                 
                                    
                                       a
                                    
                                    
                                       |
                                       b
                                       
                                          
                                             |
                                          
                                          
                                             1
                                             /
                                             λ
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where a and b are drawn from normal distributions. That is
                           
                              (16)
                              
                                 a
                                 ∼
                                 N
                                 
                                    
                                       
                                          0
                                          ,
                                          
                                             
                                                σ
                                             
                                             
                                                a
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                                 ,
                                 
                                 b
                                 ∼
                                 N
                                 
                                    
                                       
                                          0
                                          ,
                                          
                                             
                                                σ
                                             
                                             
                                                b
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where
                           
                              (17)
                              
                                 
                                    
                                       σ
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Γ
                                                   (
                                                   1
                                                   +
                                                   λ
                                                   )
                                                   sin
                                                   (
                                                   π
                                                   λ
                                                   /
                                                   2
                                                   )
                                                
                                                
                                                   Γ
                                                   [
                                                   (
                                                   1
                                                   +
                                                   λ
                                                   )
                                                   /
                                                   2
                                                   ]
                                                   λ
                                                   
                                                      
                                                         2
                                                      
                                                      
                                                         (
                                                         λ
                                                         -
                                                         1
                                                         )
                                                         /
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       1
                                       /
                                       λ
                                    
                                 
                                 ,
                                 
                                    
                                       σ
                                    
                                    
                                       b
                                    
                                 
                                 =
                                 1
                                 .
                              
                           
                        This distribution (for s) obeys the expected Lévy distribution for ∣s∣⩾∣s
                        0∣, where s
                        0 is the smallest step. In principle, ∣s
                        0∣≫0, but in reality s
                        0 canbe taken as a sensible value such as s
                        0
                        =0.1 to 1 (Yang, 2010).

The cuckoo search algorithm is adapted for solving the sheet nesting problem in the following ways:
                           
                              •
                              Cuckoo search is responsible for moving a polygon P with a fixed orientation o inside the container C to a less overlapping position.

A cuckoo (egg or solution) corresponds to the position v of polygon P.


                        Fig. 9
                         shows the basic application of cuckoo search to the sheet nesting problem.

The initial population (nest) is constructed at random positions for the polygon to be moved. To guarantee no protrusion of the moving polygon from the container C, random positions are generated inside its inner-fit rectangle. Algorithm 4 describes the basic cuckoo search implementation for the sheet nesting problem.

Using only cuckoo search for moving the polygons is not always very efficient and that may lead to trapping in local minima. Guided local search algorithm based on the weighting method (Selman & Kautz, 1993) is used to help escaping from the local minima. The penalty weights μ
                        
                           ij
                         are updated iteratively after moving polygons, and then the search is resumed from the previously local optimal solution. Guided local search and the cuckoo search algorithm are combined to solve the overlap minimization problem (problem 5). The algorithm starts from a solution (
                           v
                        ,
                        
                           o
                        ) with some overlapping polygons, where the penalty weights μ
                        
                           ij
                         are initialized to 1.0. Fig. 10
                         shows solution steps starting from feasible layout, reducing its length, and through some iterations ending at a higher utilization feasible layout.


                        Algorithm 5 describes the MinimizeOverlapfunction which aims to resolve the overlap produced after shrinking the container length by reallocating polygons inside the container C. Algorithm 4 finds a new position 
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         in the container C in a way that the following weight overlap penalty function is minimized.
                           
                              (18)
                              
                                 
                                    
                                       F
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                             
                                                o
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       μ
                                    
                                    
                                       ij
                                    
                                 
                                 ·
                                 
                                    
                                       f
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                             
                                                v
                                             
                                             
                                                j
                                             
                                          
                                          ,
                                          
                                             
                                                o
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                             
                                                o
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where μ
                        
                           ij
                        
                        >0 are the penalty weights which are applied in the guided local search algorithm and f
                        
                           ij
                         is defined in Eq. (8). Whenever the Algorithm 4 is trapped in local minima, the penalty weights μ
                        
                           ij
                         are updated using the following rule as used by Umetani et al. (2009),
                           
                              (19)
                              
                                 
                                    
                                       μ
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 
                                    
                                       μ
                                    
                                    
                                       ij
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             f
                                          
                                          
                                             ij
                                          
                                       
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       max
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             kl
                                          
                                       
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             v
                                          
                                          
                                             l
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             o
                                          
                                          
                                             l
                                          
                                       
                                       )
                                       ,
                                       1
                                       ⩽
                                       k
                                       <
                                       l
                                       ⩽
                                       n
                                       )
                                    
                                 
                                 .
                              
                           
                        
                        
                           Algorithm 4
                           
                              CuckooSearch(P,
                              o,
                              W,
                              L)
                                 
                                    
                                       
                                       
                                          
                                             
                                                // Initialize a population of nc host nests 
                                                
                                                   C
                                                
                                                
                                                   i
                                                 (i
                                                =1,2,…,
                                                n)
                                          
                                          
                                             
                                                R
                                                =
                                                IFR(C(W,
                                                L),
                                                P(o))// Calculate inner-fit rectangle for polygon P
                                             
                                          
                                          
                                             
                                                for 
                                                i
                                                =1 to nc 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                   C
                                                
                                                
                                                   i
                                                
                                                ={randNum(R.minX,R.maxX),randNum(R.minY,
                                                R.maxY)}
                                          
                                          
                                             
                                                end for
                                             
                                          
                                          
                                             
                                                // Begin cuckoo search
                                             
                                          
                                          
                                             
                                                while (t
                                                <
                                                MaxGen)
                                          
                                          
                                             
                                                Get a cuckoo (
                                                   C
                                                
                                                
                                                   i
                                                ) randomly and generate a new solution by Lévy flights
                                          
                                          
                                             
                                                
                                                F
                                                
                                                   i
                                                
                                                =
                                                F′(
                                                   C
                                                
                                                
                                                   i
                                                ,
                                                o)// Using Eq. (18)
                                             
                                          
                                          
                                             
                                                Choose a nest among nc, (
                                                   C
                                                
                                                
                                                   j
                                                ), randomly
                                          
                                          
                                             
                                                
                                                F
                                                
                                                   j
                                                
                                                =
                                                F′(
                                                   C
                                                
                                                
                                                   j
                                                ,o)// Using Eq. (18)
                                             
                                          
                                          
                                             
                                                
                                                if (F
                                                
                                                   i
                                                
                                                <
                                                F
                                                
                                                   j
                                                ) then
                                             
                                          
                                          
                                             
                                                
                                                
                                                   C
                                                
                                                
                                                   j
                                                
                                                =
                                                
                                                   C
                                                
                                                
                                                   i
                                                ,
                                                F
                                                
                                                   j
                                                
                                                =
                                                F
                                                
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   bestPosition
                                                
                                                =
                                                
                                                   C
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                Abandon a fraction (P
                                                
                                                   a
                                                ) of worse nests and build new ones at new locations
                                          
                                          
                                             
                                                Keep the best solutions (or nests with quality solutions)
                                          
                                          
                                             
                                                Rank the solutions and find the current best
                                          
                                          
                                             
                                                end while
                                             
                                          
                                          
                                             
                                                return bestPosition
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           


                              MinimizeOverlap
                              
                                 
                                    (
                                    P
                                    ,
                                    O
                                    ,
                                    W
                                    ,
                                    L
                                    ,
                                    v
                                    ,
                                    o
                                    )
                                 
                              
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                      =
                                                      size
                                                      (
                                                      P
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             Initialize penalty weights μ
                                                
                                                   ij
                                                 to 1.0
                                          
                                          
                                             
                                                it
                                                =0
                                          
                                          
                                             
                                                Fitness
                                                =+∞
                                          
                                          
                                             
                                                while 
                                                it
                                                <
                                                N
                                                
                                                   mo
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                Generate random permutation Q of set S
                                                ={1,2,…, 
                                                n}
                                          
                                          
                                             
                                                
                                                for 
                                                i
                                                =1 to n 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                F
                                                =
                                                F′(v
                                                
                                                   i
                                                ,o
                                                
                                                   i
                                                )// Using Eq. (18)
                                             
                                          
                                          
                                             
                                                
                                                for each o
                                                ∈
                                                O
                                                
                                                   i
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      =
                                                   
                                                 
                                                CuckooSearch
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            
                                                               
                                                                  Q
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      o
                                                      ,
                                                      W
                                                      ,
                                                      L
                                                      )
                                                   
                                                
                                                
                                                // Find new position
                                             
                                          
                                          
                                             
                                                
                                                
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ,
                                                      o
                                                      )
                                                      <
                                                      F
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      F
                                                      =
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                               ,
                                                               o
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            o
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                               ,
                                                               o
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                F
                                                =
                                                F(
                                                   v
                                                ,
                                                   o
                                                )// Using Eq. (5)
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                F
                                                =0 then
                                             
                                          
                                          
                                             
                                                
                                                return (
                                                   v
                                                ,
                                                   o
                                                )
                                                // The solution is feasible
                                             
                                          
                                          
                                             
                                                
                                                else if 
                                                F
                                                <
                                                Fitness 
                                                then
                                             
                                          
                                          
                                             
                                                
                                                Fitness
                                                =
                                                F
                                             
                                          
                                          
                                             
                                                
                                                it
                                                =0
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                Increase penalty weights μ
                                                
                                                   ij
                                                 according to rule (19)
                                             
                                          
                                          
                                             
                                                
                                                it
                                                =
                                                it
                                                +1
                                          
                                          
                                             
                                                end while
                                             
                                          
                                          
                                             
                                                return (
                                                   v
                                                ,
                                                   o
                                                )
                                          
                                       
                                    
                                 
                              
                           

This section reports the results on the computational experiments of the algorithm GCS and previously published algorithms. Nesting problem instances available in the literature were used to evaluate the performance of the GCS algorithm. They are available online at EURO Special Interest Group on Cutting and Packing (ESICUP) website.
                        1
                        ESICUP: http://paginas.fe.up.pt/∼esicup/tiki-index.php.
                     
                     
                        1
                      The characteristics of these benchmark data instances are presented in Table 2
                     . The proposed algorithm has been implemented in C++ compiled by Visual Studio 2010. The working environment is a PC with core i7 2.2giga hertz processor and 6giga bytes memory utilizing only one core to run the program.

The GCS algorithm has the following parameters:
                           
                              •
                              
                                 r
                                 
                                    dec
                                 
                                 ∈ (0,1): the percent by which the sheet length is decreased.


                                 r
                                 
                                    inc
                                 
                                 ∈ (0,1): the percent by which the sheet length is increased.


                                 N
                                 
                                    mo
                                 : number of iterations allowable for MinimizeOverlap function.


                                 MaxGen: number of generations per run of cuckoo search algorithm.


                                 P
                                 
                                    a
                                 : probability of discovering an alien egg.


                                 n
                                 
                                    c
                                 : number of cuckoos (nests).


                                 α: step size scaling factor.

The values of parameters r
                        
                           dec
                        , r
                        
                           inc
                         and N
                        
                           mo
                         are set equal to 0.04, 0.01 and 200 as recommended by Imamichi et al. (2009). Fig. 11
                         shows the effect of parameter MaxGen on the average utilization of all benchmarks where all the experiments are done within a time limit. Selecting large values for MaxGen will make the program consume more time to resolve overlap for an infeasible layout rather than searching for the minimum possible container length. Hence, this will result in lower final utilization ratios within the experiment time limit.

Favored values for MaxGen falls in the range from 20 to 50 generations where the value 30 is selected to reasonably compromise running time and better average results. For the other cuckoo search parameters, they are set as follows P
                        
                           a
                        
                        =0.25, n
                        
                           c
                        
                        =15 and α
                        =1 as recommended by Yang and Deb (2009). The quality of the solution is judged by the ratio 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                              Area
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                              /
                              Area
                              (
                              Container
                              )
                           
                        .

The initial layout is generated by attempting several sorting criteria of input polygons which are area, length, width, irregularity and rectangularity. At each sorting criteria, all possible clustering percentages are tried starting from 0% with a step of 5%. From all trials, the maximum utilization layout is selected as the initial layout. Table 3
                         shows the best initial layouts utilization for different data instances.

During first 50% of the computational time, the two polygons of each clustered pair are kept moving glued together, and this is called the clustering stage. For the rest of the computational time, the two polygons of each clustered pair are allowed to move separately. Selecting the proper computational time portion for the clustering stage is left for the future work.

@&#RESULTS@&#

In this subsection, computational results of GCS algorithm are shown and compared with other existing algorithms. Table 4
                         compares the computational results of the GCS algorithm for obtaining best solutions with the best in literature. To the knowledge of the author, the best published results are found in Egeblad et al. (2007) (2DNest), Imamichi et al. (2009) (ILSQN), Leung et al. (2012) (ELS) and Sato et al. (2012) (CFREFP: Collision Free Region Exact Fitting Placement).

GCS obtained new better results than previously published results for all the 15 instances including the optimal proven solution for Dighe1 and Dighe2 which is 100%. It achieved the same results as ELS for Jakobs1 instance, however the obtained layouts are different. Comparison of average efficiencies and computational time of GCS and other algorithms is shown in Table 5
                        . Fig. 12
                         shows the best layouts achieved by GCS for all benchmark data instances. These best layouts are available online.
                           2
                           
                              http://www.kau.edu.sa/Show_Files.aspx?Site_ID=0055565&amp&Lng=AR.
                        
                        
                           2
                        
                     

The GCS algorithm is conducted 10 runs for each instance. Egeblad et al. (2007) conducted their algorithm 20 runs for each instance. Imamichi et al. (2009) and Leung et al. (2012) conducted their algorithms 10 runs for each instance. Sato et al. (2012) used different runs for instances. They conducted 4 runs for Dighe1, Dighe2, Fu and Jakobs1 instances, 7 runs for Albano, Dagli, Jakobs2, Mao, Marques, Shapes0, Shapes1, Shapes2 and Trousers instances and 6 runs for Shirts and Swim instances. GCS and other algorithms time limit for best results and for average results is shown in Table 4 and in Table 5, respectively.

@&#CONCLUSION@&#

In this paper, a new algorithm (GCS) is presented for solving the sheet nesting problem. The use of cuckoo search combined with guided local search algorithms has proved to be a competitive alternative to other published nesting algorithms. Introduction of pairwise clustering has a great advantage on solution quality along with reasonable running times. Computational experiments show that the implementation is robust and also reasonably fast. The proposed approach provides significantly better results than the previous state of the art on a wide range of benchmark data instances. For future work, it is proposed to extend the pairwise clustering to dynamic multi-stage clustering.

@&#ACKNOWLEDGMENTS@&#

This paper was funded by deanship of scientific research (DSR), King Abdulaziz University, Jeddah, under Grant No. (3–135-D1432). The authors, therefore, acknowledge with thanks DSR technical and financial support.

@&#REFERENCES@&#

