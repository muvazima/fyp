@&#MAIN-TITLE@&#A type-safe embedding of SQL into Java using the extensible compiler framework J%

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           The SQL queries are syntactically checked.


                        
                        
                           
                           Optionally the SQL queries can be validated against a specified SQL database schema.


                        
                        
                           
                           Each SQL query can be separately configured with different compile-time features.


                        
                        
                           
                           The integration between the Java and SQL is type-safe.


                        
                        
                           
                           The compiler automatically generates secure code against SQL injection attacks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Domain-specific languages

Programming languages

@&#ABSTRACT@&#


               
               
                  J% is an extension of the Java programming language that efficiently supports the integration of domain-specific languages. In particular, J% allows the embedding of domain-specific language code into Java programs in a syntax-checked and type-safe manner. This paper presents J%׳s support for the sql language. J% checks the syntax and semantics of sql statements at compile-time. It supports query validation against a database schema or through execution to a live database server. The J% compiler generates code that uses standard jdbc api calls, enhancing runtime efficiency and security against sql injection attacks.
               
            

@&#INTRODUCTION@&#

Domain-specific languages (dsls) [1–4] are designed specifically to address problems in a particular domain. Furthermore, they are used to improve the efficiency in a software development process [5,6]. Well-known dsls include regular expressions and sql.

General-purpose languages (gpls) have a wider scope, providing a set of processing capabilities applicable to various problem domains [4]. Typical examples of gpls are Java, C++ and Scala.

Modern software engineering paradigms indicate that dsls are often used together with gpls [7–10]. The integration of sql with various gpls constitutes a field that drew the attention of researchers and practitioners for many years [11–14]. This integration in the context of Java is realised with a jdbc (Java Database Connectivity) application library [15]. By using it, the programmer has to pass the sql query to the database as a string. Through this process, the Java compiler is completely unaware of the sql language contained within the Java code and usually many sql syntax and type errors are detected at runtime. Such errors remain undetected, even with extensive testing during the development process.

J% (pronounced J-mod and stands for modular Java) is an extension of the Java programming language [16] initially discussed in reference [17]. Its main contribution resides in the development of a generic framework, by which arbitrary dsls can be embedded in Java programs in a type-safe, syntactically correct fashion. dsl can be included on demand as module plug-ins.

This work analyses the case of sql integration. The prototype implementation focuses on mysql database backend, but in the future, we plan to expand the module׳s support to other rdbms too. The key contribution points are the following: 
                        
                           Query validation:
                        
                           The sql queries are syntactically checked, and optionally can be validated against a specified sql database schema. In addition, the queries can also be executed in a live database environment at compile-time to provide real-world testing.

The integration between the two languages is type-safe, and all problems are reported at compile-time. The current implementation uses J%׳s type mapping facility, which enables the declaration of compatible type relations between languages. This approach follows the standard type mapping conventions proposed in the jdbc apis (Application Programming Interfaces) [15].

Each sql query can be separately configured with different compile-time and runtime features. This is implemented with the utilisation of the external configuration concept, which was introduced by the J% compiler architecture [17].

The current jdbc standard does not support the sql operator in conveniently. Our approach supports it in a better, type-safe way. It simplifies the usage of this operator, which normally requires the programmer to write additional code to handle the translation from the Java composite types to an sql set.

The sql module uses the existing jdbc specification and does not require from programmers to learn and understand new apis. The generated code utilises prepared statements, therefore securing the application against sql injection attacks.

@&#MOTIVATION@&#

Consider the case of a Java application that stores its data in a relational database. The class SQLSimpleExample contains a method called execSQL that accepts a string type formal parameter, labelled id. A standard implementation for the Java programming language is presented in the listing below: 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     The value passed by the parameter is concatenated with the sql query string. From the previous listing, three issues arise:
                        
                           1.
                           The sql query is passed as a String and the compiler is not aware that this is an sql query at compile-time.

The parameter (id) is concatenated to the sql query and its actual value is never checked.

The above implementation is vulnerable to sql injection attacks [18].

A common technique to address the above issues is the use of prepared statements. This is a jdbc feature that offers an api to parameterise an sql query. By using the prepared statements, the above code would be transformed into the following listing: 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     In the code above, the effect of the second and the third issue is mitigated. The sql query parameter is sanitised by the application library, and type safety is guaranteed at compile-time. But the first issue still stands, since the compiler does not syntactically check the sql code. To counteract the aforementioned issues, researchers have introduced various approaches and techniques. In the following sections we present their main characteristics, advantages, and flaws.

Related research in the field can be examined based on the five design integration patterns for gpls and dsls, defined by Mernik et al. [20] (see Table 1
                     ). The following section is organised by categorising the related research approaches according to them.


                     Table 2
                      summarises the approaches and for every approach provides information about two functional characteristics and one non-functional. These are: 
                        
                           Syntax (functional):
                        
                           The approach supports dsl syntax checking.

Types are mapped between the dsl and the gpl and errors are detected at compile-time.

How complex is the approach for the average programmer that already knows the gpl. The complexity can be characterised as low, medium, or high. Low complexity denotes that a programmer with good knowledge of the base language could use the dsl integration framework with reasonable effort and high means the exact opposite.

All mainstream programming languages, like Java, Perl, and Python, are using the Implementation: embedding pattern to integrate sql. The concept of this pattern is simple; there is an application library, as jdbc in Java, that implements the sql connectivity with the server. An api is provided for the host language to access it. The sql queries are passed as strings to the application library and are executed in the server. All errors are reported upon execution at runtime.


                        orm (Object-Relational Mapping) approaches like Hibernate [32], jpa (Java Persistence api) [33], (Scala Language-Integrated Connection Kit) [34], and Squeryl [35] provide a way to access a relational database, by introducing a programming layer, typically supported by a custom querying dsl, or by extending the host language, in order to automatically generate and execute the sql code. This approach has several advantages; the database entities are closely coupled with the host language and the application is completely decoupled from any database backend. The main disadvantage of this approach is that the programmer needs to learn a new query language. In addition, this language is expressed via strings, thus it suffers from the same problems related to jdbc.

Anorm [36] is another Scala integration approach that enables database access within the Play! web application framework. It adopts the principle that sql has more than enough features and language richness to cover all database access uses cases that an application could want; thus it offers a Scala library that enhances sql integration, simplifying common usage patterns via a sophisticated api.

Similar approaches in C++ include odb 
                        [37] and dtl (Database Template Library) [38] 
                        soci 
                        [39] is a C++ library that provides advanced functionality when working with sql. Technically, it is a C++ extension, but it provides a series of techniques, only by using features of the standard C++ language, to enable sql embedding; among them, basic query support and basic orm capabilities.

The main difference of J% against these approaches is that it checks the sql queries at compile time and reports errors directly to the programmer as detailed error messages. Also, it does not rely on a programmatic layer to efficiently map the sql abstractions to appropriate gpl ones (e.g. the layers introduced by orms).

For this approach, the dsl syntax is translated to constructs in an existing, host language. Typical implementation includes the preprocessors of the C and C++ programming languages, where the macros, which act as the dsl for this case, are translated into C or C++ respectively.


                        jooq 
                        [40] is a Java application library and it offers a unique api that maps all database elements into Java code. This is realised with a code generation utility. This utility scans the target database and generates all the models and the code that represent the database as host language types. The generated code uses standard jdbc api calls. The advantage of this approach is the direct mapping of each database table and field to a Java program element. For example, it is impossible for a programmer to mistype a table name or any other sql identifier, since it is directly mapped into a Java class and the compiler. Hence, the ide (Integrated Development Environment) will catch the error and present it to the user.


                        jdbc Checker [22] acts as a preprocessor and searches Java code for jdbc calls and sql statements to detect possible errors. Notably, the sql statements are checked against the database schema. Annamaa et al. [24] use Eclipse׳s compiler infrastructure to efficiently embed sql queries in Java programs. The plug-in can detect common syntax sql errors, including misspelled table or column names. To embed dsls, Erdweg [23] proposes SugarJ, a framework used to extend gpls with specific syntax. The main contribution of this framework is that can be applied on many languages as host languages (Java, Haskell and Prolog).


                        jsquash [25] is a tool that analyses Java code and several by-products of a Java application and trace the existence of sql statements. Then, it automatically links the dynamic parts of sql queries with the variables of the program. Typically, the tool aims to identify this linkage and replace the contents of these variables accordingly, when the database schema changes.


                        sql dom 
                        [26] acts as a preprocessor and translates an sql database schema into C#. The generated collection of classes is used as an application library, thus ensuring type safety and syntax checking at compile-time.

Switch [27] is a compiler that can be used when developing in the Ruby programming language. Its goal is to provide an alternative for the Ruby on Rails active record library, focusing on query performance.

J% does not translate sql into Java, or any other intermediate language. It generates Java code, which utilises and exposes to the programmer existing jdbc api calls.

The sql statements are not altered and the type annotations are translated into prepared statements that use the jdbc mapping for types. Contrary to our work, the aforementioned frameworks generate code that should be included in the program during the compilation, or act as tools that help the programmer work with sql.

This integration pattern dictates that the host language is extended with new data types, semantic elements, and syntax to efficiently support the dsl.

Haskell/db 
                        [8] is a host language variant that has been extended to encapsulate sql queries. This implementation follows the Design: Language Exploitation (extension) pattern. sql is completely hidden from the developer and queries are expressed through a custom syntax embedded to the host language. This approach hinders productivity and forbids domain experts to become involved with the development process.

Cω
                        [28] integrates both sql and xml into its syntax, extending the C# programming language and introducing numerous changes to its type system and syntax. siq 
                        [29] (Scala Integrated Query) follows a similar approach.


                        linq is an integrated component for the .net languages (C# and Visual Basic) that adds querying capabilities to objects. It can be used to perform declaratively queries in collections of objects.


                        sqlj 
                        [31] is a language extension of Java to support sql. It offers type and syntax checking for both languages at compile-time.

These aforementioned frameworks use the gpl compiler to enforce syntax and type checking to the embedded dsl statements. J% adopts this concept. In particular, it allows the inclusion of modules to support an infinite number of dsls. Thus, it provides a platform on which many dsls could be used simultaneously and on demand by the programmer.

This approach focuses on the specialisation of a gpl to efficiently integrate with a dsl. As a result, gpl syntax is enriched with operators and statements to enforce type safety and syntax checking between the integrated languages. A weakness of this approach is that the gpl syntax becomes very complex and loses its generalisation.

Powerscript is the core development language of the rapid application development tool, Powerbuilder [41]. Compile-time query checks against a live database schema are supported through an active database connection.

J% offers similar efficiency in terms of sql integration, permitting compile-time type checking and execution to an active database, similarly with the aforementioned approach, but without sacrificing the gpl׳s general features.

This approach proposes the extension of a gpl with domain-specific optimisation rules and code generation. The work presented here is implemented as a module for the J% compiler, which follows this integration pattern [17] to enable this functionality. The basic concepts of the J% language are presented in Section 4.

Several other works [42–46] adopt this approach, but are not focusing on supporting sql efficiently or any other dsl. Actually, these works focus mainly on enforcing type safety and provide extensible language syntax. They are relevant to J% in terms of methodologies and techniques that are used to implement the language integration. Their similarities stop there, since the J% module exploit the language׳s features and mechanisms to implement novel functionalities, like compile-time sql query configuration, etc. All these features are described in the following sections.

The basic features of the J% programming language are presented in reference [17], which covers the basic features of J% like syntax and type mapping. It also presents a premature version of regular expressions and sql integration, but in the level of a working prototype. The extended version of the sql embedding module is presented here in more detail. In addition, these works cover all aspects of J%, like type mapping, type annotations and presents an evaluation of J% framework through a series of experiments.

The basic architecture of J% enables the development of compiler modules to support many dsls. The following section establishes a terminology and describes the J% basic syntax and features. Then type mapping is discussed, focusing on supporting the sql module. Finally, the module׳s specific technical aspects are examined in detail, like the overall compilation process and code generation schemes.

First, we need to establish the basic J% terminology: 
                        
                           External module:
                        
                           
                              External modules are compiler plug-ins that enable dsl support. Each module exposes two basic elements; one or more external types and one configuration type. The modules are automatically invoked by the compiler, when it detects dsl usage in the J% program.

They are user-defined Java reference types [16] with extended syntax, like Java enumerations that are marked by the keyword external and contain the dsl code. An external type always inherits the external base type or one of its subtypes. External types act like dsl code container. The compiler identifies them at compile-time and calls the specified external module. Its concept is similar to the assimilation type, introduced by Bravenboer and Visser in reference [42]. Are External types are subtypes from the External Base Type, which is offered by the J% framework.

Provides compile-time configuration for each external type. These typically represent compile-time and runtime options used for the generation and the execution of dsl code. These types are configure through type parameterisation. The concept of external type configuration is analysed in Section 4.2.


                              External references are type annotations between the Java code and the dsl code. They are used to define type mappings between the dsl statements and the Java code. This mechanism is thoroughly explained in Section 4.3.

The sql support of J% is implemented in the form of a compiler module. Only one type is declared, namely the SQLQuery. The declaration of the SQLQuery type is the following: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The above code fragment contains the declaration of the SQLQuery. It extends the ExternalBaseType class. All new queries must be SQLQuery subclasses. The following notation describes the aforementioned hierarchy:
                           
                              (1)
                              
                                 CustomQuery
                                 <
                                 :
                                 SQLQuery
                                 <
                                 :
                                 ExternalBaseType
                              
                           
                        The type must be parameterised by a descendant of SQLConfiguration type. The usage of configuration types is presented thoroughly in the next section. Its functionality includes two methods: getSQLStatement, which returns the sql query as a string literal and getStatement that returns an instance of a prepare statement object, given an open jdbc database connection.


                        sql configuration parameters are used for the compile-time configuration of each sql query. Practically, they initialise the sql module with a different context that drives the module׳s functionality. Configuration types are organised as a hierarchy, such as the one described with the following notation:
                           
                              (2)
                              
                                 CustomConfig
                                 <
                                 :
                                 SQLConfiguration
                                 <
                                 :
                                 ExternalConfiguration
                              
                           
                        
                     

The sql module with the default configuration checks only the sql syntax. Two more checking facilities can be enabled through the configuration system; one that checks the sql query against the database schema 
                           (
                           
                              SQLMOD_NS_AWARE
                           
                           )
                        , and a second that performs query check against a live database (SQLMOD_LIVE_TEST), by executing the queries with default values.


                        Fig. 1
                         depicts a configuration type hierarchy based on the options provided by the sql module. The configuration options typically affect compile-time options or runtime environment strategies. SQLConfiguration is the basic configuration type provided by the sql module. TestingConf and LiveTestingConf are two subtypes that override and set specific compile-time options. These options are realised as class fields. The following code fragment exhibits the usage of the TestingConf configuration type. The ExampleQuery type will check the sql query against the database schema provided by the file schema.sql, given as the value of SQLMOD_NS_URI configuration option. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        Some of the SQLConfiguration options are also available at runtime and can be retrieved via the getRuntimeConfigurartion method. The following listing contains the declaration of the basic ExternalConfiguration class. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        SQLConfiguration and all configuration types must directly inherit this type and provide an implementation for its abstractions. Table 3
                         summarises all available configuration options offered by the sql module. If the column Runtime is checked, then this configuration option is preserved in the runtime environment, if not, it is stripped during the compilation phase. Also note that the configuration options, which are related to the database connection, are used only in the case of live database testing (SQLMOD_LIVE_TEST).

J% offers a mechanism to support type mapping. To examine how it works, we introduce the following definitions: 
                           
                              Compatible types:
                           
                              All Java types that can be mapped to a series of dsl types and vice versa are defined as compatible types. A compatible type defines a mapping from the assimilated domain type from a dsl to an assimilating type from the gpl and vice versa [42].

Even if the type is compatible with other types, one type must be defined as dominant and be preferred when the compiler needs to resolve compile-time ambiguities regarding data conversion between the two languages. These types are referred to as dominant types.

Each module defines a series of compatible types that are used when the Java language and the embedded dsl need to exchange data. As an example, consider the case where an integer for the sql language (
                           
                              
                                 int
                              
                              
                                 
                                    sql
                                 
                              
                           
                        ) that needs to be mapped to a Java type. The following conventions are required:
                           
                              •
                              the int 
                                 sql type should be mapped to the int Java primitive type as dominant,

the int 
                                 sql type should also be mapped to the java.lang.Integer as compatible type.


                        Table 4
                         lists all the compatible and dominant types for the sql module. So far, the module supports on mysql data types.
                           1
                        
                        
                           1
                           
                              http://dev.mysql.com/doc/refman/5.0/en/data-type-overview.html
                           
                         Each database backend should have its own custom type mapping rules, since it is common for rdbms׳s to have unique data types. The types listed on the table provide the basic mapping between Java and mysql. sql sets and Java collections and composite types are also supported (see Section 4.6).

In J%, each dsl maintains its own syntax. For simple cases, where the dsl has no type system, such as regular expressions, the dsl is used completely unmodified. When the J% language needs to pass values with the dsl, an external reference must be defined, which is a type annotation that describes the convention between the two type systems.


                        Fig. 3
                         contains the bnf syntax for the external references. The main rule is named ExternalRef and it consists of two parts: the parameter name and the field type.


                        Parameter name (ParameterName) defines the name of the parameter that is going to be used in the code generation phase. The field type (FieldType) defines the corresponding Java type, according to the naming convention that is commonly used by the Java programming language.

The number of external references is bound to the maximum formal parameters that the method can have. This is defined in the Java Language Specification [16].

For example, for an sql query that accepts an int as a parameter as input (c_id): 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The expression 
                           
                              #[c_id]<int>
                         defines that the customerId expects an int base type. [c_id] is the parameter name and practically generates the following constructor for the SimpleSQL 
                        external type: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     


                        Table 5
                         lists a series of external reference examples along with their generated constructors.

The J% compiler adopts the language processing system architecture [47], more specifically it follows the pipe and filter compiler architecture variation. Fig. 4
                         illustrates the compilation process. Both the J% compiler and the sql module are implemented in Java. The compilation process is straightforward; the compiler scans the input source files (
                           ⁎.jmod and 
                           ⁎.java). Then it marks each file as external or Java. The external keyword denotes that an sql type is declared in this file, and the marker Java that it contained pure Java–compatible code. Configuration types are also Java files. All this information populates directly the symbol table and other type information structures. The code generator is invoked and intermediate Java-compatible code is generated. Finally, the Java compiler is invoked, and translates the code into executable jvm bytecode. All information regarding symbols, the external configuration and all the specifics of the external code are available to the module at compile-time. After its initialisation, the sql code is further analysed and checked for discrepancies, which are reported as compile-time errors. Table 6
                         presents a set of size metrics for the sql module.

Consider the following program: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The SelectExample 
                        external type extends the SQLQuery type. The query is written in sql, enhanced by the usage of external references. 
                           
                              #[prim]<int>
                         is the statement of an external reference. It declares that the sql query accepts an integer parameter and thus a formal parameter will implement it, in the form of the generated type׳s constructor. The declaration of the external configuration type, namely SimpleConf, follows: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The SimpleConf type parameter configures the compile-time part of SQLQuery. In this example, it instructs the compiler to check the query with the provided database schema. A part of this configuration is passed into the runtime environment, according to Table 3, enabling the developer to retrieve runtime information regarding the specific query. The configuration option SQLMOD_NS_AWARE will remain, indicating that the query has been checked against the specified database sql schema. On the other hand, the SQLMOD_NS_URI should be omitted, since the path to the schema is specific to the compilation environment. The configuration type may be different per external type without compile-time or runtime overhead. The following listing contains the generated code. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The generated constructor accepts one int formal parameter, according to the external reference declaration. Note that the parameter׳s name and its internal name is prim, which is the name that was used in the external reference declaration. The abstract method getStatement is implemented. The generated code uses prepared statements from the jdbc api, which carries along benefits, as the extra layer of type safety at compile-time and a transparent performance optimisation at runtime. In addition, the usage of prepared statements enhances application security and protects the application from injection attacks.

J% uses the type mapping mechanism to enhance the code generation process. The sql module uses prepared statements and according to each type it uses the appropriate method from the jdbc api. This is handled automatically by the sql module, and the programmer does not need to write anything more than the external reference declaration.

The sql operator in is a special case. The standard jdbc api does not provide a standard approach on handling this. Consider the following example: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The standard jdbc api requires to handle the creation of the sql set manually and a programmer may develop code like the following excerpt: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

J% augments the jdbc api usage. A straightforward implementation would require the creation of an external type with the following sql query: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The external reference is declared for the composite type String[], which is an array of java.lang.String types. Finally, to execute the query: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The underlying implementation of this feature follows in principle the standard approach that is proposed by jdbc.
                           2
                        
                        
                           2
                           
                              http://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html
                           
                         J% provides functions for all Java composite types that derive from the standard supported types (Table 4).

@&#EVALUATION@&#

We performed the evaluation of our approach with four small experiments; first, we analysed practically what it means for a developer to port a jdbc-based Java code to J% code, we exhibit how the sql errors are identified at and presented to the programmer, we ported five Java projects that are using sql, to examine what impact the J% code has on a project in terms of common size metrics, such as loc, and finally we measured the overall compilation overhead against the standard Java compiler. The results presented in the following sections should be used as an insight to J%׳s impact, since to evaluate it thoroughly thousands lines of code from many developers must be written and analysed. Still, we depict some early indications on the effectiveness of our approach.

Porting Java applications to use J%׳s sql module is straightforward. When a Java source file contains an sql query, the code is extracted, and a new external type is created. After that, we replace the standard jdbc calls with the api offered by the sql module. Consider the file add_user.java of the Examj
                        
                           3
                        
                        
                           3
                           
                              https://github.com/bkarak/jmod-ports/blob/master/examj/java/src/add_user.java
                           
                         project, which contains the following insert statement: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        In J% it should be rewritten as follows: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        External type 
                        InsertUserQuery should also be defined: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The above code retains the same functionality and without alterations in its logic, nor its basic structure.

Consider the RegisterItem class in the RUBiS project.
                           4
                        
                        
                           4
                           
                              https://github.com/bkarak/jmod-ports/blob/master/RUBiS/java/Servlets/edu/rice/rubis/servlets/RegisterItem.java
                           
                         It contains an sql statement, which is created by string concatenations. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        We created the InsertItemQuery type, similar to our porting strategy in the previous section: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        To compile it, we executed the following command: 
                           
                              
                                 
                                 
                                    
                                       $ jmodc --compile-with-javac -i RUBiS/jmod/
                                       
                                    
                                    
                                       
                                          [...]
                                       
                                    
                                    
                                       
                                          [INFO] .../rubis/servlets/RegisterItem.java parsed (Java)
                                       
                                    
                                    
                                       
                                          [...]
                                       
                                    
                                    
                                       
                                          [INFO] .../rubis/servlets/InsertItemQuery.jmod parsed (External)
                                       
                                    
                                    
                                       
                                          [...]
                                       
                                    
                                    
                                       
                                          [INFO] SQLModule module called for .../servlets/InsertItemQuery.jmod
                                       
                                    
                                 
                              
                           
                        The above is an excerpt from the compiler output. In the first phase, the compiler identifies the external type and then it calls the sql module to generate the code.

If we accidentally wrote a mistyped input like insrt instead of the sql keyword insert, a compile-time the error would be reported: 
                           
                              
                                 
                                 
                                    
                                       $ jmodc --compile-with-javac -i RUBiS/jmod/
                                       
                                    
                                    
                                       
                                          [...]
                                       
                                    
                                    
                                       
                                          [INFO] SQLModule module called for .../InsertItemQuery.jmod
                                       
                                    
                                    
                                       
                                          [ERROR] Could not parse SQL Statement - INSRT INTO items [...]
                                       
                                    
                                    
                                       
                                          [ERROR] .../InsertItemQuery.jmod, error in SQL syntax : [...]
                                       
                                    
                                    
                                       
                                          [...]
                                       
                                    
                                 
                              
                           
                        The compiler discovered the error in the sql query, then it reported it as an error message. Similarly, errors regarding the database schema are reported, like table and column identifier errors or type incompatibilities.

The evaluation process aims to analyse the impact of J% in real-world projects. J% demands that each sql code block should be declared as a new external type. This can be easily related with significant growth in terms of user-defined types and code. For that reason, the third evaluation experiment will focus on Size & Complexity (Table 7
                        ). To isolate efficiently the level of change that our approach imposes, we evaluate each project by comparing its original form with a J% version.

The selected projects include JCrontab an open source crontab replacement, AddressBook, the sample program that is distributed with the Java DB, ExamJ an open source Java editor, which aims to provide a framework to tutor and grade programming language students and the popular benchmarking web platform RUBiS [48]. All these applications use sql and a relational database as a backend to store and access their data. All ported applications are published in Github.
                           5
                        
                        
                           5
                           
                              https://github.com/bkarak/jmod-ports
                           
                        
                     


                        Table 8
                         summarises all size metric measurements for all projects. Table 9
                         contains the list of all the Java files per project that were modified during the porting process. Note that, in general, most files of the projects remained unaffected and only the files that contained sql statements were altered. The “Java” column contains the original loc of the file and the “J%” the loc after the porting.

The results show that by using J%, we should expect slightly increased loc and number of files. This is the main problem of J% in its current specification. For each sql query a new external type should be declared, which practically means the creation of a new source file. Consequently, the increased loc can be explained by the declaration of boiler-plate code that each external type requires. External loc (Ext. LOC) counts the lines of code for the external types’ source files. Since Java does not support external types, the count is always zero for the Java version of the projects. Note that the number of sql Queries is reduced in AddressBook, ExamJ and RUBiS. J% encourages query reusability and for the same queries, the same external type can be reused. For example, the RUBiS project has originally 44 sql queries and 16 of them could be reused.

The sql code is used almost unmodified, except the external reference declarations. These are the source of the second problematic situation. For each reference that is defined in an external type, a field parameter in the type׳s constructor is generated. This is good and bad simultaneously; the strict constructor enforces compile-time validation of each parameter that is passed to the sql code and in addition is backed-up by a prepared statement when it is passed onto the query. Its disadvantage is that the generation scheme is not very practical when one has many parameters, and it is complex to remember their order, when the external type is actually used with the Java code. The example code in Section 5.1 points out to this problem. The resulting generated code of InsertUserQuery type has five constructor parameters.

The next step in our evaluation included the measurement of the compiler׳s overhead, in terms of compilation time. The compilation process includes two phases; the code generation where the sql checking is performed, and Java code is generated, and the compilation of the generated code to Java bytecode. Consider the following program: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The code opens a connection to a mysql database, performs a select query, then iterates over the results and prints all the customers’ names. We ported this program and produced three variants of it; one that performed only a basic check on the sql statement (simple), a second that performed the basic check, then also examined if the query was valid against a specific database schema (ns-aware), and a third that executed the query to the actual database to validate it(live-db). Table 10
                         presents a set of size metrics for each variation of the program.

Observe that each version of the program differs in terms of loc. The original program had 31 lines of code, while the simple, ns-aware, and live-db versions were 26%, 39% and 42% bigger. This phenomenon was analysed in the previous sections, where we identified as the source of the problem, the declaration of the external types and their configurations.

The actual test included an iteration of 2,000 compilations for each version of the program. Table 11
                         lists the hardware and software characteristics of the benchmark environment. The results were analysed, and a list of basic statistical measures are presented in Tables 12 and 13
                        
                        . As expected, the Java version compiles faster with an average value of 705.74ms, while the imposed overhead for the simple, ns-aware, and live-db versions is 24.68% (936.94ms), 24.64% (936.45ms), and 38.80% (1153.10ms) respectively. The results show that is cheap to enable query check against a database schema. Of course, results may vary. In the case of a more complex schema, it is possible that the ns-aware could be slower. The live-db variation had the slowest performance, which was also expected, since it requires to connect to a live database server and execute each query.


                        Tables 14 and 15
                        
                         contain the result of a much simpler experiment. A simple Java program was compiled by jmodc (J%׳s compiler) and javac to measure compilation time. Since jmodc in pure Java code, it copies the file, then it compiles it with javac, the results proven that is slower than his contestant. The experiment included 100 iterations and jmodc was 13.3% slower than javac.

@&#CONCLUSIONS@&#

The contribution of J% sql module is that it supports embedding of sql code in Java programs in a type-safe and syntax checked way. Each sql statement is checked and all errors are reported at compile-time. In addition, Java types are mapped into sql types, and all interactions between the two languages are also checked at compile-time.

The integration of the sql query language to the J% compiler system provides developers with some notable features. The first involves an extensive query configuration. In essence, each query can be configured with different code generation and testing features. This is achieved with the utilisation of the external configuration concept introduced by our approach. Query validation is another key feature of J%. If this feature is enabled, queries can be checked against a specified database schema, which is provided as part of the query configuration.

The J% sql module utilises the existing jdbc specification, without alienating the developer with new apis or frameworks. In addition, our approach supports the transparent usage of prepared statements. Furthermore, J% employs the performance optimisations offered by the prepare statements compilation in a transparent manner. Finally, by using prepared statements, J% provides shielding against input validation attacks. This feature could be very useful, especially in the case of web applications.

One of the disadvantages of our approach is the fact that for every single query the developer must define a new external type, which may lead to significant external type pollution in large projects. Features like type mapping and compile-time configuration, greatly support the development process and permit the implementation of advanced features, such as live database testing in the sql module. To assess J%׳s impact to the software development process, more experiments must be performed; thus the measurements presented here were indicative.

@&#FUTURE WORK@&#

Enhancing J% and its sql support module in both features and design is planned in the future. Such enhancements could involve sql code reuse by further extensions of the sql module to support multiple backends. Within the boundaries of our research we intend to examine the following concepts: 
                        
                           Dynamic 
                           sql 
                           generation:
                        
                           Our extension deals only with static sql statements. In the future, we plan to utilise existing research such as [22] and provide mechanisms that support dynamically generated statements.

The introduction of annotations in Java since version 1.5 provided the solid foundation for developers to introduce a series of custom compile-time checks and generation of boilerplate code. J% sql module could also use annotations to provide compile-time information, a feature that is currently implemented with the concept of configuration types. Consider the following code: 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              The annotation (@sql) instructs the compiler to perform compile-time namespace checks to the following sql query. Traditionally this could be done by the sql configuration types.

The code generation process could be enhanced to include domain-specific optimisations that may boost performance in terms of execution, e.g. caching, like the ones presented in reference [49].

Our implementation focuses on the mysql database dialect. We plan to provide support for other major database systems. The support will include better analysis of custom sql statements and support for type mapping for unique types that each database backend offers. The work to support each rdbms will further expand the module׳s capabilities and provides the starting point to address next-level set of problems, like enhancing database security model at compile-time, etc.

With the current code generation approach, complex sql statements with many external reference definitions can lead to complex constructors, with many parameters. The code generation mechanism can be modified to generate parameter objects to group all the constructor parameters in one coherent class definition.

The present research is under the Action 2 of aueb׳s
                     6
                  
                  
                     6
                     Athens University of Economics and Business.
                   Research Funding Program for Excellence and Extroversion of the academic year 2014/2015. It is financed by the Athens University of Economics and Business Research Center, Grant Number ΕΡ-2166-01/01-01.

The authors would like to thank George Oikonomou and Christos kk Loverdos for their insightful comments and corrections during the compilation of this paper. J% is available in Github
                     7
                  
                  
                     7
                     
                        https://github.com/bkarak/jmod
                     
                   under the gnu Public License v3. A collection of ported programs and the benchmark harness are maintained in https://github.com/bkarak/jmod-ports.

@&#REFERENCES@&#

