@&#MAIN-TITLE@&#Temporal and multi-versioned XML documents: A survey

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           XML documents contain temporal information and evolve over time.


                        
                        
                           
                           Our work explores change detection, versioning and querying support in XML documents.


                        
                        
                           
                           It describes the storage structures to efficiently store and retrieve XML documents.


                        
                        
                           
                           It explains the change management features in some commercial tools.


                        
                        
                           
                           It highlights several open research issues for multi-versioned XML documents.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

XML documents

Multi-version

Evolving

Temporal

Data model

Change detection

@&#ABSTRACT@&#


               
               
                  Extensible Markup Language (XML) documents are associated with time in two ways: (1) XML documents evolve over time and (2) XML documents contain temporal information. The efficient management of the temporal and multi-versioned XML documents requires optimized use of storage and efficient processing of complex historical queries. This paper provides a comparative analysis of the various schemes available to efficiently store and query the temporal and multi-versioned XML documents based on temporal, change management, versioning, and querying support. Firstly, the paper studies the multi-versioning control schemes to detect, manage, and query change in dynamic XML documents. Secondly, it describes the storage structures used to efficiently store and retrieve XML documents. Thirdly, it provides a comparative analysis of the various commercial tools based on change management, versioning, collaborative editing, and validation support. Finally, the paper presents some future research and development directions for the multi-versioned XML documents.
               
            

@&#INTRODUCTION@&#

In today’s age, the challenge is to crack the business value of information available through the Web. The significance of enterprise information depends on the applications that manage it. An enterprise can publish its products catalogue on the Web, allow customers to browse and query the catalogue, and collect valuable suggestions from customers. XML promises to achieve such features of business functions including content integration, content intelligence, and content reuse. To fulfill the promises of XML, it is mandatory that we properly maintain XML documents.

XML provides storage and manipulation of meta-data to create vocabularies for exchanging information between operational data sources via the Web (Pokorny, 2002). The increasing requirement of applications that use and exchange XML data is creating a demand to store XML documents for future references. Additionally, the information contained in XML documents is dynamic and changes across time (Dyreson & Grandi, 2009). Multi-versioned XML documents are applicable in cooperative authoring, software configuration control, e-permanence of web documents, and web information warehouses. The versatile applicability of XML documents in different fields information maintenance and management is increasing the demand for their multi-versioning support. Therefore, different versions of XML documents are stored with time. However, storage of all versions of an XML document introduces redundancy, makes content-based searches hard due to the explosion of hits, and increases difficulty to answer queries on an evolving document. Therefore, efficient schemes are required to store and detect changes in dynamic XML documents. Furthermore, it is necessary to identify optimized schemes to efficiently execute queries that span over multiple versions of XML documents, known as cross-version queries.

Various surveys (Ali & Pokorný, 2009; Colazzo, Guerrini, Mesiti, Oliboni, & Waller, 2010; Guerrini & Mesiti, 2009; Hartung, Terwilliger, & Rahm, 2011) have been written on evolving semi-structured or XML data and schema. (Guerrini & Mesiti, 2009; Hartung et al., 2011) provide an overview of the schema evolution support in several commercial tools. (Colazzo et al., 2010) provides an overview of the various languages available for the specification, semantics, and handling of XML document updates. (Ali & Pokorný, 2009) gives a comparative analysis of several temporal XML data models. This study surveys schemes to store, retrieve, and query temporal and multi-versioned XML documents on the basis of different parameters, including versioning support for XML document and schema, temporal support for elements and attributes, supported time dimensions, change detection, change management, and supported query types. Further, it provides a comparative analysis of the various commercial tools and database management systems (DBMSs) based on their versioning support.

The remainder of this paper is organized as follows: Section 2 provides an overview of XML data model. Section 3 discusses some version control schemes for change detection and change management in dynamic XML documents. Section 4 discusses several schemes for query support of XML documents. Section 5 provides in-depth analysis of the literature work. Section 6 describes storage structures to usefully store XML documents. Section 7 provides a comparative analysis of various commercial tools and database management systems (DBMSs) for XML documents. Section 8 gives some future research and development directions for multi-versioned XML documents. Finally, Section 9 concludes this paper.

Web browsers use Hyper Text Markup Language (HTML) to compose textual, graphical, audible, and visual material in the form of Web pages. The standards for HTML are provided by World Wide Web Consortium (W3C). HTML has some limitations for representing Web content such as separately handling of web data (content) and its representation. Therefore, W3C designed a new language namely, Extensible Markup Language (XML), to resolve the limitations of HTML. XML is like HTML in format. However, it is more extensible and handles only content, while presentation is addressed separately. It also supports validation of external data. The XML Schema or Document Type Description (DTD) defines a structure of XML documents and helps applications to validate imported data.

Businesses appreciate XML as it removes many costly workarounds required in HTML to represent rapidly changing data. The widespread acceptance of XML demands its continuous support over the next decade.

Several standards are available for data sharing and management in XML such as Extensible Stylesheet Language (XSL) to transform an XML document and Document Object Model (DOM) to allow programs to dynamically access or update an XML document. Thus, XML with other related technologies provides great benefits and simplicity. XML and database technology are more complementary. The task of managing loads of XML data has increased the demand to explore the integration of these two fields. XML databases are equally beneficial for content-centric and change-centric applications. The change-centric applications such as software configuration and cooperative work may exploit dynamic XML documents since the content and structure of a dynamic XML document changes hourly, or weekly, depending on the underlying business processes, such as the content of a website of an online store. In contrast to a dynamic XML document, the content and structure of a static XML document remains unchanged. Whenever the content of a XML document changes, either of the two change management approaches may be used: (1) let the document evolve (2) create a new version for the document. The former approach is straightforward but no history is retained in this case. The latter approach creates an increasing number of XML documents and requires version control schemes to manage the content. A version control scheme may use object-referencing or deltas to detect and store the changes between multiple versions. In this paper, we study the three main issues related to multi-versioned XML documents: (1) how to detect changes between multiple versions, (2) querying multi-versioned XML documents, and (3) storage structures for multi-versioned documents. The significance of multi-versioned XML documents has motivated us to also highlight the commercial tools, which support the versioning feature for XML documents.

Furthermore, XML documents also contain temporal information such as relational databases published in XML (Wang & Zaniolo, 2003b) and cultural heritage (Grandi, 2002). Similar to the data models for temporal relational databases, the temporal data models are required to manage temporal information in XML documents. An XML temporal data model extends an XML data model by time dimensions.

Version control is required to manage and query the semi-structured nature of continuously changing XML documents. Various schemes have been proposed for controlling versions of XML data based on deltas (Chien, Tsotras, & Zaniolo, 2001b; Leonardi & Bhowmick, 2005; Leonardi, Bhowmick, & Madria, 2005; Rusu, Rahayu, & Taniar, 2005; Wong & Lam, 2002; Wuwongse, Yoshikawa, & Amagasa, 2004; Wang & Zaniolo, 2003a; Marian, Abiteboul, Cobena, & Mignet, 2001; Wong & Lam, 2003) and object references (Chien, Tsotras, & Zaniolo, 2001a; Chien, Tsotras, & Zaniolo, 2001c; Chien, Tsotras, & Zaniolo, 2002; Chien, Tsotras, Zaniolo, & Zhang, 2001). However, deltas are more intuitive as compared to object referencing because they can be directly applied to a version to obtain its previous version.

Section 3.1 discusses management of evolving XML documents and provides a comparative analysis of the various schemes based on versioning and temporal support. Section 3.2 describes how change is detected and provides a comparative analysis of the various schemes based on change management.

Versions and temporal data are inter-related. For example, a Web page management system maintains record of multi-versioned Web pages with respect to time. Some efforts have been made to unify these two concepts for effective management of evolving XML documents (Wuwongse et al., 2004; Wang & Zaniolo, 2003a; Gergatsoulis & Stavrakas, 2003; Grandi, Mandreoli, & Tiberio, 2005; Grandi, Mandreoli, Tiberio, & Bergonzini, 2003). Fig. 1
                         shows a temporal multi-versioned data model (TVDM), which integrates temporal information and delta namely, temporal delta (tDelta) (Wuwongse et al., 2004).

Data models for multi-versioned XML documents that treat a version as a snapshot are unable to effectively store historical information. The inclusion of temporal information with multi-versioned XML enhances the historical value of such documents. However, various schemes have been proposed to either manage temporal XML data (Amagasa, Yoshikawa, & Uemura, 2000; Dyreson, 2001; Dyreson, Lin, & Wang, 2004; Wang & Zaniolo, 2004; Zhang & Dyreson, 2002) or multi-versioned XML documents (Cavalieri, 2010; Cavalieri, Guerrini, Mesiti, & Oliboni, 2011; Guerrini & Mesiti, 2008; Guerrini, Mesiti, & Sorrenti, 2007). A comparative study of the schemes for managing multi-versioned XML documents requires the analysis of various parameters, including supported time dimension, temporal queries, temporal attributes, temporal elements, content versioning, schema versioning, collaborative editing, query language, and XML syntax. Each of these parameters has its own significance.

Schema evolution is the ability to adapt the deployed schemas to changing requirements and should not degrade the availability or performance of the changed system. It supports evolution transparency by storing different explicit versions of schemas and their associated instances. It should support backward compatibility, forward compatibility, versioning, and views to isolate the applications and other schema consumers from changes. In backward compatibility between schema versions S and S’, applications of the old schema version S can use S’ while in forward compatibility, applications of S’ can use S.

Two types of approaches are available for the adaptation of original schema instances to the evolved schema: (1) automatic (2) query-based. Automatic adaptation is feasible when there is an obvious way to correct documents, for example, upon minimal changes to schema such as renaming of an element.

The support of collaborative editing of multi-versioned XML documents by integrating the versioning technologies and fragment access is another important management feature for such documents.

Time dimensions may be applied to elements and attributes of an XML document.XML documents having temporal information are managed by associating a timestamp with each object in the document. Several time dimensions including valid, transaction, efficacy, and publication are used to represent temporal data in XML documents. The valid time (VT) indicates the time when the data is true in the real world. The transaction time (TT) indicates the recording time of data in the system. VT and TT combined are considered as bi-temporal time. Efficacy time represents the data validity. Furthermore, XML data models can be extended with a version stamp to manage non-linear versioning (Rosado, Márquez, & Gil, 2007; Wuwongse et al., 2004). XML databases with either time type or several time types lead to their various temporal data models (Amagasa et al., 2000; Dyreson, 2001; Rizzolo & Vaisman, 2008; Wang & Zaniolo, 2004; Zhang & Dyreson, 2002). In (Amagasa et al., 2000; Wang & Zaniolo, 2008; Zhang & Dyreson, 2002) a valid time support is added to XPath. In (Grandi et al., 2005; Wang & Zaniolo, 2003a; Wang & Zaniolo, 2004; Wang & Zaniolo, 2008) and (Grandi et al., 2005; Wang & Zaniolo, 2003a; Wang & Zaniolo, 2004) valid and transaction time supports are added to XQuery. This support results in an extended data model and query language.

Some approaches (Brahmia, Bouaziz, Grandi, & Oliboni, 2010; Cavalieri, 2010; Rizzolo & Vaisman, 2008; Rosado et al., 2007) adopt a particular language for addressing parts of an XML document as the basis of their data models while others (Chien et al., 2001c; Chien, Tsotras et al., 2001; Guerrini & Mesiti, 2008; Guerrini et al., 2007; Zholudev & Kohlhase, 2009) do not discuss anything about the use of a particular language. Some approaches (Grandi et al., 2005; Wang & Zaniolo, 2003a; Wang & Zaniolo, 2004; Wang & Zaniolo, 2008; Wong & Lam, 2002) describe how XQuery can be used to express queries in their representation scheme.


                        Table 1
                         provides a summary of the comparative analysis of the various schemes based on the abovementioned parameters.

Version detection is required in various applications such as web page ranking, software clone identification, plagiarism detection, and peer-to-peer searching. Versions can be detected by analyzing the similarities between various files for which selecting a similarity function and threshold value are important key factors. The similarities of content and structure, as well as application requirements are helpful in designing a similarity function for version detection. Various schemes have been proposed for detecting changes in multiple versions of an XML document based on the ‘diff’ algorithms (Cobena, Abiteboul, & Marian, 2002; Rusu, Rahayu, & Taniar, 2008; Saccol, Edelweiss, Galante, & Zaniolo, 2007; Wang, DeWitt, & Cai, 2003; Wong & Lam, 2002; Wong & Lam, 2003), textual content of documents (Baeza-Yates & Ribeiro-Neto, 2011), structure of document (Flesca & Pugliese, 2005; Gao & Chen, 2013; Wan & Yang, 2006), key-based (Viyanon & Madria, 2009), and document classification (Pon, Cárdenas, Buttler, & Critchlow, 2007; Wang, Hodges, & Tang, 2003). The diff-based schemes may use a delta document or a consolidated delta document for change-centric management of versions.

A delta document indicates the changes between two versions of an XML document whereas a consolidated delta document contains the data of the original version as well as all deltas. Further, a delta document can be of two types, backward delta and forward delta. The consolidated delta is more efficient (Rusu et al., 2008) as it provides a mapping between both types of deltas and, thus, reduces the space complexity for storing deltas. Given the first version of an XML document and completed delta, any successor or predecessor version can be calculated by following a set of rules. Consider a document having n versions at n time stamps, T
                        1, T
                        2,…,
                        Tn
                        . The version T
                        4 can be obtained at any time moment Tn
                         by using intermediate delta or consolidated delta, as shown in Fig. 2
                        . Former has two drawbacks (1) keeping all the delta documents introduces redundancy in case the elements of a document change often and (2) time overhead to recreate each previous version of the document by using intermediate deltas. The redundancy may come in three ways (1) data stored in deltas (2) recreating elements in consecutive versions, and (3) retrieving historical versions. Latter has a drawback of time overhead to query backward the unchanged parts of a document.

The comparative study of change detection schemes requires the analysis of various parameters including change detection between two versions of an XML document, use of relational, delta, or object-referencing approach for change detection, support for ordered XML documents, scalability, supported file size, and representation of unchanged parts. Each parameter has its own significance.

Some schemes can explicitly show the user the changed parts (Leonardi & Bhowmick, 2005; Leonardi et al., 2005; Rusu et al., 2005; Wong & Lam, 2002; Wuwongse et al., 2004) while other cannot (Cavalieri, 2010; Cavalieri et al., 2011; Guerrini & Mesiti, 2008; Guerrini et al., 2007; Rosado et al., 2007; Snodgrass, Dyreson, Currim, Currim, & Joshi, 2008; Wang & Zaniolo, 2008; Zholudev & Kohlhase, 2009). Schemes should be scalable to detect changes in large XML documents.

The storage of intermediate complete versions of XML documents improves the efficiency and space complexity as the required version can be created by using the appropriate intermediate complete version instead of the current version only. Query processing becomes efficient while a system stores the intermediate complete versions because there is no need to reconstruct the intermediate versions.

The schema-oblivious approaches use a fixed schema to store the logical order of an XML document and provide two benefits (1) handle XML schema evolution and (2) change detection does not require any modification in SQL queries.

The reference-based schemes use object references and preserve the logical order of dynamic XML documents. A version is represented by using objects, which can (1) reference records representing unchanged parts between two versions and (2) be the actual document objects records.

A valid XML document satisfies some constraints. As an XML document evolves, the validity of the updated part should be verified. Thus, validation of the time-varying multi-versioned XML documents is a hot research area (Brahmia et al., 2010).

The storage of multi-versioned XML documents with high-similarity introduces redundancy. The objective is to reduce redundancies without loss of significant information. The storage redundancy can be avoided by storing only once the elements which remain unchanged between multiple versions.


                        Table 2
                         gives a summary of the comparison between various schemes based on the above mentioned parameters.

Queries can be of two types (1) change-related, including queries spanning over a single version and queries spanning over multiple versions and (2) content-related. Queries spanning over a single version involve querying edit operations performed over a single document version. Queries spanning over multiple versions are processed over several deltas and their results are combined to answer a query. A query involving the version v is processed by reconstructing the version v for which a sequence of deltas is applied on the current version or the nearest complete version of the document. However, it is inefficient for queries which involve a range of versions as multiple versions have to be reconstructed. The queries can be of different types, including structural projection, path-expression, parent–child expression, content-based selection, version-interval, version aggregation, and diff-based queries, as described below briefly.
                        
                           •
                           The structural projection queries like “Project the document’s 20th version between the third and the sixth chapters” require a continuous chunk of the document from a given version.

The path-expression queries like “For 20th version, find all table elements under chapter 5” require a version and a regular path expression to output the elements that satisfy the expression for a specified version.

Parent–child expression queries like “Find all table elements under chapters in 20th version” combine the structural joins with a path expression.

Content-based selection queries output versions, which satisfy the predicates given in the where clause.

The version-interval queries are extended single-version queries, supporting multiple versions. For example, “Project the document from 20th version to 25th version between the third and the sixth chapters” or “Find all table elements within chapter 5 from 20th version to 25th version”.

The version aggregation query finds an aggregate value of elements, which are specified by a version-interval query. For example, “Find the word count of chapter 10 from versions 5 to 15”.

The diff query like, “Retrieve all the changes applied to chapter 10 from 20th version to the current version” answers the changes made to an element between versions.

Such queries are challenging to respond to efficiently, require identification of parent–child relationship between document elements, and can be answered efficiently by avoiding full traversal of the document sub-trees.

XML versioning approaches based on line-edit scripts and object references are inefficient to capture the logical order, parent–child relationship, or tree structure of a document. The logical order of the document can be captured by using the numbering schemes (Abiteboul, Kaplan, & Milo, 2001; Al-Khalifa et al., 2002; Bruno, Koudas, & Srivastava, 2002; Li & Moon, 2001; Wang, Park, Fan, & Yu, 2003). Such schemes are invariant to document updates, utilize unused numbers for tagging the elements in future, can adopt fixed-size or variable-length numbers for tagging elements, and facilitate full-document version retrieval queries.

Several numbering schemes are available such as durable node (Li & Moon, 2001), range-based (Abiteboul et al., 2001; Al-Khalifa et al., 2002; Bruno et al., 2002; Li & Moon, 2001), and prefix-based (Dyreson & Mekala, 2011; Sans & Laurent, 2008). In range-based numbering, each node is assigned a range of numbers to identify its position in the XML tree. The range-based numbering reduces path-expression queries to join operations. With the durable numbering scheme, the addition and deletion of elements do not affect the numbers assigned to elements and thus, it maintains the nodes in the pre-order traversal. Further, the space between numbers can be used for future insertions. In prefix-based numbering, the node number of a parent node is used as a prefix to assign a number to a child node. However, it uses variable length encodings and requires more space than other numbering schemes. Several schemes have been proposed to efficiently support queries for XML documents. Table 3
                      provides a summary of the comparative analysis of these schemes based on supported querying type.

The power of any model depends also on the support for powerful queries. (Wang & Zaniolo, 2003a; Wang & Zaniolo, 2008) describe support for powerful temporal queries expressed in XQuery for multi-versioned XML documents without requiring new constructs in the language. Similarly, (Rosado et al., 2007) discusses support for temporal queries expressed in XPath and XSLT for multi-versioned XML documents without requiring new constructs in the language. Other models in Table 3 do not discuss the issue of temporal queries. Several complex query types for multi-versioned XML documents are supported in (Chien et al., 2001a; Chien, Tsotras et al., 2001; Chien, Tsotras et al., 2002).

As the schema evolves over time, even an expert user may not be able to pose the correct query for her needs. Work in the area of multi-versioned XML documents does not explore the design independence property, as these systems must have full knowledge of the schema. In (Termehchy, Winslett, & Chodpathumwan, 2011) the benefits of design independence and the potential of statistical based methods to have such a property are introduced.

@&#RELATED WORK@&#

In this section, we present a summary of papers in the existing literature that describe various schemes for versioning support, temporal support, change detection and management, and querying support for XML documents. A comparative analysis of these schemes is presented in Tables 1–3.


                     Amagasa et al. (2000): Both, XSLT and XPointer, use XPath that treats an XML document as a tree and addresses its parts. This paper proposes a logical data model, which extends XPath to represent temporal XML documents histories. It extends XPath in some positions (1) use labels at edges to represent valid time, (2) use virtual nodes to model string-value of attribute and text nodes, and (3) multiple string-value nodes can exists in attribute and text nodes. It also presents various approaches to physically implement the model so that data represented in the model can be translated to XML documents. It investigates several issues at the implementation level, including temporal query expressions, physical implementations, and DOM API based operations. It queries temporal XML documents by taking a snapshot of the XML document and then querying it using a non-temporal query language.


                     Al-Khalifa et al. (2002): This paper develops two families of structural join algorithms, tree-merge and stack-tree, to find tree structured relationships in an XML database. It shows that tree-merge algorithms have performance comparable to stack-tree algorithms only for some cases; otherwise, they perform worse than these algorithms. The authors found that for sorted inputs, the stack-tree algorithms have worst-case I/O and CPU complexities linear in the sum of inputs and output sizes, while the tree-merge algorithms do not have the same guarantee.


                     Brahmia et al. (2010): τXSchema is a framework to create and validate time-varying XML documents. A τXSchema schema is an XML schema with logical and physical annotations. Its components can change over time to reflect changes in the reference world. This paper proposes a set of schema change primitives to deal with schema versioning in the τXSchema.


                     Bruno et al. (2002): This paper proposes TwigStack algorithm to match an XML query twig pattern. It uses a chain of linked stacks to compactly represent partial results to root-to-leaf query paths, which are then composed to obtain matches for the twig pattern. When the relationships between elements are ancestor–descendant, this algorithm is CPU and I/O optimal. It is linear in terms of the sum of input and final result lists sizes and is independent of the sizes of intermediate results. It uses a variant of B-trees to match query twig patterns in sub-linear time.


                     Cavalieri et al. (2011): The automatic management of data requires effective and efficient handling of updates on data and its corresponding schema. It is possible to collect a certain number of updates in a sequence and, later, collectively execute them to reduce the overall evolution costs, the revalidation costs, and system down-time. When dealing with update sequences, it is important to avoid the duplication of changes in the document/schema to store minimal changes and still be able to retrieve data from the previous versions. This paper proposes an algorithm to deal with reducing sequences of update operations on XML documents or schema, i.e., deriving a shorter sequence of update operations by collapsing their effects. It also proposes an efficient reduction algorithm and a set of reduction rules.


                     Cavalieri, 2010: XSUpdate is an SQL-like language to represent evolution statements over an XML schema. It allows identification and modification of XML schema parts. It also allows defining adaptation for associated documents. This paper presents an engine to evaluate and translate XSUpdate statements in XQuery Update expressions. It translates and evaluates XSUpdate statements within other applications, locally and over the network. It focuses on the key features of XML schema, including type definitions, references, element declarations, arbitrary nesting of sequence, and choice grouping operators.


                     Chien, Tsotras et al., (2001): This paper presents a version management scheme SPaR to efficiently store and retrieve multi-versioned XML documents. It uses timestamps of elements and durable node numbers to preserve the document history and structure. The durable node numbers are used as stable references to index the elements and decompose the documents in several linked files. It uses a page clustering technique to trade off storage efficiency with retrieval efficiency. It also explores the indexing and clustering strategies to efficiently support temporal and complex queries on schema and data evolution.


                     Chien et al. (2001a): This paper presents a reference-based scheme to preserve the logical structure of evolving XML documents. It uses a usefulness-based scheme at the storage level. It also presents an algorithm to support selection and projection queries. Additionally, it provides support for query evolving XML documents.


                     Chien, Tsotras et al. (2002): This paper shows that the RCS and SCCS version control schemes are unable to efficiently store, retrieve, exchange, and query the multi-versioned XML documents. It enhances RCS with a temporal page clustering to efficiently store and retrieve multi-versioned XML documents. The proposed clustering technique is based on page usefulness to trade off storage efficiency with retrieval efficiency. It derives the UBCC scheme by combining the clustering technique with an edit-based representation. It shows that the cost of version retrieval is less for UBCC scheme when compared with RCS. It also discusses reference-based versioning to efficiently exchange and query the multi-versioned XML documents.


                     Chien, Vagena, Zhang, Tsotras, and Zaniolo (2002): Structural joins are useful for finding structural relationship between tagged elements and selections on element contents. This paper proposes algorithms for structural joins based on B+-trees and R-trees. The paper shows how sibling pointers may be used to enhance the performance of proposed algorithms. It also shows that structural joins based on B+-trees are more robust than R-trees.


                     Cobena et al. (2002): This paper proposes a linear time diff algorithm for XML data. The proposed algorithm matches unchanged sub-trees between the old and new versions. It matches more nodes by considering ancestors and descendants of the matched nodes. It also considers the specificities of XML data, including attributes and elements. The new versions are compared with old ones without affecting the whole system. It represents changes using a delta. It provides a trade-off between speed and quality. The proposed algorithm was used in the Xyleme project, where the system continuously receives XML data from the Web crawlers. It can also be used for HTML documents by XMLizing them.


                     Gergatsoulis and Stavrakas (2003): It proposes the use of Multidimensional XML (MXML) to represent the history of XML documents. It demonstrates how MXML can represent change operations on XML documents and their corresponding schema.


                     Grandi et al. (2005): This paper presents a multi-version data model for the retrieval and maintenance of multi-version norm texts. It uses four temporal dimensions, including validity, transaction, publication, and efficacy to represent the norms evolution in time and their resulting versioning. It is based on an XML schema and allows to time-stamp meta-data at each hierarchical level. Well-defined inheritance semantics rule the interaction between hierarchal levels. Additionally, it extends keyword-based searches with the option of specifying additional temporal constraints.


                     Guerrini et al. (2007): This paper proposes an approach to efficiently validate documents, known to be valid for the original and updated schema. It also presents an adaptation algorithm to ensure that the invalidated portions of the document match with the evolved schema.


                     Guerrini and Mesiti (2008): This paper presents a Web-based tool, X-Evolution, for XSD schema evolution. It allows specification of the schema modifications by using a declarative language and a GUI. It allows schema revalidation only on the small changed portions of documents. In X-Evolution, the original schema instances can be adapted to the evolved schema by automatic and query-based adaptation. Query-based adaptation handles complex schema and semantic changes whereas automatic adaptation handles minimal schema changes.


                     Li and Moon (2001): This paper proposes a new system to index and store XML data based on a numbering scheme for elements. It finds the ancestor–descendant relationship between elements. It also proposes EE-Join, EA-Join, and KC-Join algorithms to search paths between elements, to find element-attribute pairs, and to find Kleene-Closure on repeated paths or elements.


                     Leonardi and Bhowmick (2005): This paper presents a relational approach namely, Helios, to detect changes in the unordered XML documents. It uses a schema-conscious approach as the underlying storage strategy. For large datasets having more than 1000 nodes, it is up to 6.7 and 52 times faster than Xandy and X-Diff, respectively. It produces delta of quality comparable to that of Xandy.


                     Leonardi et al. (2005): This paper proposes an XML enabled change detection system (Xandy). It detects structural and content changes in large unordered XML documents. It converts XML documents into relational tuples and use SQL queries to detect changes from these tuples. The proposed approach is scalable as compared to X-Diff. Its quality is comparable to that of X-Diff.


                     Marian et al. (2001): This paper proposes a change-centric method to manage versions in an XML warehouse. The authors obtain a sequence of snapshots of XML documents from the web and figure out the changes between two consecutive versions by using a diff algorithm. It uses persistent identifiers and completed deltas to represent the sequence of changes. It computes the changes and appends them in the history whenever a new version arrives. It uses forward and backward delta to reconstruct old versions. It also presents a GUI to display changes to the user.


                     Rizzolo and Vaisman (2008): It proposes a data model to deal with modeling and implementation of temporal data in XML. It analyzes the temporal constraints imposed by the data model, validates a temporal XML document against them, and fixes inconsistent documents. It introduces a temporal XML query language namely, TXPath. It also presents an approach to summarize and index temporal XML documents. It shows that by indexing continuous paths, query performance can be increased dramatically.


                     Ronnau, Scheffczyk, and Borghoff (2005): This paper checks the suitability of XML diff algorithms for OpenOffice XML documents. It identifies important features of diff approaches to handle versioning of office documents and implements an OpenOffice versioning API to be used in version control systems.


                     Rosado et al. (2007): This paper extends the XML data model to represent different versions of XML documents by marking tags with a version stamp. It stores the ancestral relations of the versions to create a version tree and defines the version validity of each versioned tag by a version stamp. It gives the advantages of easy management of multiple versions, its implementation by only using XML technology, and querying support using XML standard query languages.


                     Rusu et al. (2005): This paper proposes a consolidated delta approach to store changes in dynamic XML documents. It also shows the storage and retrieval efficiency of their versioning approach.


                     Snodgrass et al. (2008): This paper provides a versioning support for τXSchema. It describes an XML document with reference to a base schema, temporal annotations, and physical annotations. Additionally, it describes how a validator may be extended to validate documents.


                     Vagena and Tsotras (2003): This paper proposes a variation of the pattern-matching algorithm, Pathstack. It deals with the evaluation of path-expression queries on multi-versioned XML documents. It presents an easily updatable numbering scheme to efficiently capture structural relationships among the elements of multi-versioned XML documents.


                     Wang and Zaniolo (2003a): This paper presents a technique to manage and perform temporal query on the history of a multi-version document. It represents the successive versions of a document as a V-document, which is a temporally grouped data model and uses XQuery to express complex queries. It groups the identical nodes temporally and, thus, avoids storage redundancy.


                     Wang, DeWitt et al. (2003): This paper explores the benefits of publishing databases as XML documents. It shows that XML views and XQuery can support historical queries on the histories of database relations. It also shows that standard XQuery can easily express temporal queries as compared to SQL.


                     Wang and Zaniolo (2008): It presents techniques to manage and perform temporal query on the history of a multi-version document. It represents the successive versions of a document as an XML document that implements a temporally-grouped data model. It uses XQuery to represent complex queries on the temporal evolution of the elements and contents of a document.


                     Wang and Zaniolo (2004): This paper proposes an XML-based bi-temporal data model namely, XBiT. It shows that bi-temporal, transaction time, and valid time databases can be viewed in XML using temporally-grouped data models. It supports the temporal EER model, valid time and bi-temporal databases, and complex temporal update operations. Additionally, it supports evolution queries.


                     Wong and Lam (2003): This paper presents a content-based version management system to manage XML documents. It uses complete deltas to logically represent document versions and store complete document versions based on the amount of change in the document. The system performs well in terms of both space and time by adaptively selecting between forward and backward deltas.


                     Wuwongse et al. (2004): This paper presents a data model namely, Temporal Version Data Model (TVDM), that unifies the version control and temporal XML document databases. It is temporally change-centric and uses tDelta to represent the changes between two consecutive versions. A tDelta extends ordinary XML elements with temporal/ordinary variables to form a temporal XML expression (tXex). It models evolving XML documents by combining three existing approaches, including (1) timestamp-based by using version and valid times, (2) change-centric by using ordinary XML elements to represent the changed parts of a document, and (3) reference-based by using variables to represent the unchanged parts. Since it models time as XML elements, it can accommodate new time types. It is implemented by using a rule-based language namely, XET, to manipulate, match, and unify tXex. It can also perform computation and, thus, is capable of performing reasoning on temporal constraints and relationships.


                     Zhang and Dyreson (2002): This paper adds a list of valid time instants or disjoint intervals to each node to extend the XPath data model. It presents a valid time in a valid time view, which is query- and calendar- specific. The valid time for a node is constrained to be a subset of the valid time for a node’s parent. In contrast to Amagasa et al. (2000), which extends edges of XPath with valid time, it extends nodes with valid time.


                     Zholudev and Kohlhase (2009): This paper presents an open-source versioned XML database system namely, TNTBase, for sharing XML-based documents and for collaborative editing. It integrates Berkeley DB XML (Berkeley DB, 2013) into the Sub-version Server (SVNKit, 2013).

This section discusses different schemes for efficiently storing and retrieving the versioned documents with least processing. Minimizing the number of pages required to store the multi-version document and rebuild a specific version of the document to satisfy a query can optimize storage of an XML document.

Document version control schemes may adopt line-edit script or page usefulness. Line-edit script approaches store document’s evolution by storing current version of the document and delta document. An older version of an XML document can be generated by applying the reverse editing script to the current version of the document. This introduces storage or processing overhead. Such approaches are unable to retain the logical structure of the document and are expensive to support the structure-related queries. These schemes may read invalid segments as the read segments may no longer belong to the obtained version, causing processing overhead. For such schemes, the input/output cost is related to the size of changes required from the obtained version to the current version as well as the size of the current version. Such schemes maintain indexes on the valid parts of each version, which, in turn, reduce version retrieval cost. However, the valid parts might not be properly clustered and could be sparsely stored among pages created during multiple versions, which, in turn, increase the input/output overhead.

Page usefulness-based approaches, including multi-version B-Tree, usefulness-based copy control, and partially persistent list cluster data by using the page usefulness and minimize storage and processing costs.

The objects of a non-versioned XML document are stored according to their logical order and, thus, are properly clustered on secondary store. Consequently, the retrieval of these objects is efficient. However, this may not be true for a multi-version document where the objects of a version may be physically scattered on different pages, which increases the input/output cost.

Let us assume that the objects of a document’s initial version are physically stored according to their logical order. The changes made in the objects of a particular version may be physically stored in different pages. Conversely, the objects of different versions may be physically stored in the same page. Thus, a page may not be fully useful for accessing a specific version as the accessed page may contain objects that are invalid for the required version.

The usefulness of a page, p, for a required version, v, is the percentage of p that corresponds to valid objects for v. High usefulness indicates that the objects of a required version are well clustered, stored in a few pages, and, thus, only a few pages need to be accessed to reconstruct the target version. Furthermore, a particular page may be less useful for some versions and more for others.

Page usefulness based schemes, including Usefulness-Based Copy Control (UBCC), Multi-Version B+-Tree (MVBT), Partially Persistent B+-tree (PPBT), and Partially Persistent List (PPL) cluster valid objects of a version in a few data pages. As the number of valid page objects decreases below a certain value, they are copied to another page (Lomet & Salzberg, 1989; Salzberg & Tsotras, 1999; Tsotras & Kangelaris, 1995).

Line-edit script schemes perform well when the changes between versions are minimal. Such schemes perform worst when the changes are sizeable. In case when the changes are large, each version can be accessed with zero overhead and stored with limited overhead by storing the complete time-stamped version. However, documents have an intermediate level of revisions. The UBCC (Chien, Tsotras, & Zaniolo, 2000) adjusts this inter-mixed behavior of document revisions by merging line-edit scripts and complete time-stamped copies.

Further, line-edit script schemes have large script size as they store the edited script as well as the revised objects values, thus increasing the version reconstruction time. The script size can be reduced by separating the document objects and the edited script. The UBCC reconstructs a version by only accessing useful pages that contain valid objects for that version, incurring input/output cost related to the size of the version. The UBCC clusters valid objects and avoids access to unrelated objects during version reconstruction.


                           Fig. 3
                            shows the storage of three versions of a document by using the UBCC scheme. Fig. 3(a) shows the three versions v1, v2, and v3 of an XML document. Fig. 3(b) shows that changes in objects of a specific version may physically scatter them around different disk pages. The document objects of the first version v1 are physically stored in pages p1, p2, and p3 according to their logical order. After changes in <obj2>, it is physically moved to page p4. Fig. 3(c) shows the page usefulness for each version. In version v2, pages p2 and p3 become useless after changes in <obj2> and <obj3>.

The two variants of UBCC are UBCC with MVBT and UBCC with MVRT, as described below (Chien, Tsotras et al., 2002).

A document version can be reconstructed by finding the useful pages for the required version and reconstructing the tree structure of the document. Further, the range version retrieval queries are supported by using the order of elements managed by some numbering schemes such as durable node numbers (DNNs) (Li & Moon, 2001) within each version. As the UBCC data organization is unable to maintain the logical order of a document, it requires an MVBT secondary dense index to facilitate the above tasks where the leaf pages store pointers to the elements in the UBCC pages and element DNNs. This indexing scheme is helpful to implement the full-index or element-indexes. For example, the index on chapter elements can answer range version retrieval queries specified by a version number and a range of chapter DNNs. The ordered list of chapter DNNs, maintained by using an index on the Sparse Preorder and Range (SPaR) of chapter tags by version is required to satisfy queries like, “Find the DNN of the fifth chapter in version 10”.

The updates in the document elements result in the creation of a new version, page copying by using UBCC strategy, ordering of live/valid records from the copied pages and newly inserted elements by DNN, placing of elements by their DNN in UBCC pages, and updating the dense MVBT index. Further, a range version retrieval query searches the MVBT by using the given DNN range and version number(s).

A MVRT can also be used to index the range of element DNNs in each UBCC page. An MVRT record stores three values including UBCC page id, DNN range, and lifespan. The range of element DNNs is computed when a UBCC page becomes full. It is the largest DNN range because no more elements can be added in the page. This DNN range can decrease when elements are logically deleted from the page. However, the largest DNN range for every page is stored in MVRT to save update processing. The lifespan of a UBCC page’s record is updated in MVRT as it becomes useless.

A range retrieval query is answered by using index structure that identifies the UBCC pages satisfying the intersection of the query range at the given version. For a partial version retrieval query, elements in the query range should be in DNN order. One solution for this problem is to find all the elements that satisfy a query and sort them. A more appropriate scheme is to utilize the fact that elements of the data pages that belong to the same version are already in relative DNN order.

The MVBT, PPBT, and PPL treat the document evolution problem as a partially persistent problem. Various schemes are available to make a B+-tree partially persistent (Becker, Gschwind, Ohler, Seeger, & Widmayer, 1993; Lomet & Salzberg, 1989; Varman & Verma, 1997). A partially persistent data structure applies changes to its current state and maintains document evolution. It clusters records in pages. The clustering mechanism is based on the indexing attribute values and the lifetime interval.

The positions of a document’s objects are useful to access the document and describe the logical order of a document. Thus, an ordered list data structure, like a B+-tree, can be used to store a document. The MVBT (Becker et al., 1993) is a directed acyclic graph, which contains multiple root nodes. Each root points to a B+-tree representing a version’s evolution. An object is inserted or deleted in a version by first identifying the leaf page in the MVBT where the change has to be applied. The target page is searched by considering the lifetime intervals of index records.

Consider that the logical order of the first version of a document is indexed by using a B+-tree, where leaves hold records with integer keys representing the positions of the objects in the document. It is very inefficient to update this B+-tree as the position numbers of the objects change with the insertion/deletion of each object. Thus, object positions are encoded to avoid their alterations due to document changes. For example, sequence of large non-consecutive integers can be used to identify object positions. If an object is inserted between two objects associated with integers 100 and 200, the new insertion is indexed by their middle number, i.e., 150. The use of the numbering scheme depends on the document evolution. Large integers are used when the object changes between two positions are expected to be more frequent. The use of large integers maintains the logical order of the document as well as efficiently indexes a B+-tree. The changes in a document are maintained by using object ids. An object refers to its object id by using a hashing scheme. The hashing scheme identifies the integer associated with an object id, which is used to locate the position of insertion, deletion, or modification.

The MVBT is efficient for range version retrievals. However, the MVBT uses more space as compared to the UBCC.

The MVAS (Varman & Verma, 1997) is an MVBT, where leaf nodes contain data records and interior nodes contain index records. An index record and a data record contain the data field [key, start time, end time, pointer] and [key, start time, end time, information], respectively. The start time indicates the creation time of the data blocks to which they point. The pointer points to a node containing keys, which are not smaller than key.


                              Fig. 4
                               shows version maintenance using MVAS. It shows two examples of a sample scenario for a data block overflow assuming both data blocks and index blocks hold five records. Initially, at time t
                              4, there are three live records (A, 1), (B, 4), and (C, 4). In example 1, at time t
                              5, data block overflows when D is inserted. The number of live records becomes four. As there is no space in the block, two new data blocks are created and live records are split equally among two blocks. Two new entries (A, 5) and (C, 5), having start time 5, are added to the index node while the first index record now points to a dead data block.

Several tools are available to create, store, maintain, and query XML documents. They provide various features, including change detection between XML documents, collaborative editing, versioning support, and validation support. None of them provides support for temporal XML documents. Here is a brief description of the key features of these tools:
                        
                           •
                           Altova’s DiffDog can perform XML schema matching and diffing. It takes two XML schema instances and performs element-to-element matching. Its result (output) can be manually modified. It can thus handle renaming and reordering of elements. From a diff result, the tool generates an XSLT script that translates valid documents of one schema into valid documents of the other schema. It cannot incrementally alter schemas.

DeltaXML Sync works for the same document on concurrent editors. It identifies changes and merges them into a single synchronized document.

LiquidXML Studio can perform diffing and document validation but it is unable to handle reordering of elements.

oXygen’s XML editor provides only a limited versioning support. It can support concurrent edits on a document, validation, and reordering of elements.

Stylus Studio and XMLmind’s XML Editor only provide diff support.

SysOnyx’s xmlDraft provides versioning and document validation support.


                     Table 4
                      shows a summary of the comparative analysis of the various tools provided by Altova, Stylus Studio, oXygenXML, LiquidXML, SysOnyx, and XMLmind.

Both types of tools, XML native such as Tamino and XML enabled including Oracle, IBM DB2, and SQL Server DBMSs, are available for storing and querying XML documents. Native DBMSs rely on a data model specifically conceived for the management of XML, whereas enabled DBMSs are relational or object-relational which have been extended for the treatment of XML. Enabled XML DBMSs are more mature than the native ones because they are supported by big vendors and the integration of XML data with other company data is easier.

SQL Server, DB2, Tamino, and Oracle 11g are some of the most famous commercial database management systems.

All of them provide support for the storage of XML data validated against an XML schema at the time of publication.

In IBM DB2, schema validation occurs on a per-document basis. The schema is determined by attributes within the document to be inserted, or by manually specifying a schema as an argument to the XMLValidate function. Once a document has been validated, it is adorned with metadata that verifies this validation as well as contains information to help optimize query processing.

In contrast to Oracle, Tamino allows the stored data to determine reverse compatibility rather than the schema document versions themselves. One can pass a parameter to the _define command to attempt to do some static validation first – determining just from the documents themselves whether it is possible for reverse compatibility to be guaranteed – but eventually all documents are validated against the new schema at evolution time and, if any validation fails, the change is rejected.

Similar to Oracle, Microsoft SQL Server stores a collection of homogeneous XML documents in a relation column. Instances in an XML-typed column or table in Oracle must conform to a specific schema with a specific global element as root, whereas an XML-typed column in SQL Server validates against any schema in a collection of schemas and allows any global element as root.

The schema evolution replaces the old schema with a new one whereas the schema modification allows changes in the existing schema while the validity of schema remains unaffected.

Oracle offers two ways to evolve an XML schema (1) copy-based (2) in-place evolution. The copy-based mechanism allows a great deal of flexibility. Data from an XML document collection is copied to a temporary location, transformed according to a specification, and, finally, placed in its original location. The in-place evolution does not require any data copying but only supports a limited set of possible schema changes such as add a new optional element, attribute, or domain value to an enumeration, global element, global attribute, or global type.

SQL Server provides the ALTER statement to evolve the XML schema without manually dropping the schema, manually translating instances, and reestablishing the schema. In DB2, different versions of the same schema are stored as unconnected documents. It does not update instances of a document from one version of a schema to another. (Beyer, Oezcan, Saiprasad, & Van der Linden, 2005) has described how to support schema versioning in DB2.It supports a scenario that involves a relational table to correlate the schema versions. It also allows multiple schema versions to coexist in a single corpus. Documents exist in their original form, associated with their original schema. Tamino allows schemas to evolve under the same restrictions as Oracle’s in-place migration mechanism.


                     Table 5
                      provides a summary of the comparative analysis of SQL Server, DB2, Tamino, and Oracle 11g, based on validation, content modification, schema evolution, content versioning, and schema versioning support.

There are several open research issues for multi-versioned XML documents. Here are some of these research problems:
                        
                           1.
                           As discussed in Section 3.2, any two XML documents with high similarity are considered as versions of the same document. The documents can be similar in content, structure, or related subject. The version detection problem poses two important issues: (1) how to measure similarity between files (2) what is the minimum degree of similarity required for a file to be treated as a version of another. The similarity function must consider the content similarity, structure similarity, and application-specific features. As the distribution of the score values generated by distinct similarity functions may be completely different, finding the threshold value that should be used for similarity functions in version detection is a challenging task. For example, some XML similarity functions focus more on structure rather than content; others focus more on content than structure. However, for the version detection problem many different features must be considered together. Further, the similarity function for detecting versions of XML documents should not be restricted to a specific application. Therefore, finding similarity functions for XML documents that are effective for version detection is an open research issue.

As discussed in Section 7, the commercial DBMSs offer very limited support of XML schema evolution and semi-automatic revalidation of documents. In fact, a simplified version of adaptation is supported only by Oracle 11g through the copyEvolve function. Thus, temporal and versioning support in DBMSs needs further investigation.

As discussed in Section 6.1.1, the clustering schemes have been utilized for version storage. However, they have not been explored to store path expression queries where tags/elements repeat in the tree structure of a document. Thus, optimized storage of multi-versioned XML documents needs further exploration.

As discussed in Section 3.2, a delta document indicates the changes between two versions of an XML document. It is possible to compress evolving XML documents using compression schemes such as XQzip (Cheng & Ng, 2004) and find the delta document without decompressing them. As the storage of delta documents requires more storage and computation power, it creates a demand to compress delta documents. Finding compression schemes that support efficient query processing without decompression of delta documents needs further exploration.

Improved strategies to allocate persistent identifiers for the nodes of an XML tree to indicate the structure of the data needs further investigation. As discussed in Section 6.1.1.1, identifiers or numbering schemes capture the order of elements in the document structure. However, there is still a need of such numbering schemes that can efficiently execute complex queries like path-expression where tags/elements repeat in the tree structure of a document.

Well-suited integration of fields of XML and temporal databases, for instance, the use of page clustering schemes at the physical level optimizes the performance by the storage and retrieval trade-off. However, the combination of page clustering schemes and node numbering schemes need to be explored for optimizing the performance of queries.

@&#SUMMARY@&#

Data are stored over the World Wide Web (www) in the form of XML documents to achieve e-permanence and preserve critical information. The huge storage of data in XML form demands the efficient management of this data. Such data constantly evolve over time and may require querying over the previous versions of an XML document.

In contrast to static XML documents, the temporal, unpredictable, and changing nature of dynamic XML documents requires different handling. The management of temporal and multi-versioned XML documents is a new area. This paper explores several issues related to evolving XML documents, including change detection between versions of XML documents by using deltas, object references, or relational approaches, versioning support, and trend analysis queries. We also studied change management features in some commercial tools.

Finally, we point to several open research and development directions in the area of multi-versioned XML documents.

@&#REFERENCES@&#

