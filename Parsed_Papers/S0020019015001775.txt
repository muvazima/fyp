@&#MAIN-TITLE@&#A filtration method for order-preserving matching

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a sublinear solution based on filtration for order-preserving matching.


                        
                        
                           
                           Any algorithm for exact string matching can be used as a filtering method.


                        
                        
                           
                           If the filtration algorithm is sublinear, the total method is sublinear on average.


                        
                        
                           
                           We show by practical experiments that the new solution is more efficient than earlier algorithms.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Algorithms

Combinatorial problems

Order-preserving matching

String searching

@&#ABSTRACT@&#


               
               
                  The problem of order-preserving matching has gained attention lately. The text and the pattern consist of numbers. The task is to find all the substrings in the text which have the same length and relative order as the pattern. The problem has applications in analysis of time series. We present a new sublinear solution based on filtration. Any algorithm for exact string matching can be used as a filtering method. If the filtration algorithm is sublinear, the total method is sublinear on average. We show by practical experiments that the new solution is more efficient than earlier algorithms.
               
            

@&#INTRODUCTION@&#

String matching [1] is a widely known problem in Computer Science. Given a text T of length n and a pattern P of length m, both being strings over a finite alphabet Σ, the task of string matching is to find all the occurrences of P in T. The problem of order-preserving matching [2–6] has gained attention lately. It considers strings of numbers. The task is to find all the substrings (also called factors) u in T which have the same relative order as P, and 
                        |
                        u
                        |
                        =
                        |
                        P
                        |
                     . Suppose 
                        P
                        =
                        (
                        10
                        ,
                        22
                        ,
                        15
                        ,
                        30
                        ,
                        20
                        ,
                        18
                        ,
                        27
                        )
                      and 
                        T
                        =
                        (
                        22
                        ,
                        85
                        ,
                        79
                        ,
                        24
                        ,
                        42
                        ,
                        27
                        ,
                        62
                        ,
                        40
                        ,
                        32
                        ,
                        47
                        ,
                        69
                        ,
                        55
                        ,
                        25
                        )
                     , then the relative order of P matches the substring 
                        u
                        =
                        (
                        24
                        ,
                        42
                        ,
                        27
                        ,
                        62
                        ,
                        40
                        ,
                        32
                        ,
                        47
                        )
                      of T, see Fig. 1
                     .

Several online [7,5,3,4] and one offline solution [2] have been proposed for order-preserving matching. Kubica et al. [4] and Kim et al. [3] presented solutions based on the Knuth–Morris–Pratt algorithm (KMP) [8]. Later, Cho et al. [5,6] gave a sublinear solution based on the bad character heuristic of the Boyer–Moore algorithm [9]. Almost at the same time, Belazzougui et al. [7] derived an optimal sublinear solution. We will present a new practical solution based on filtration. We form a modified pattern and use an algorithm for exact string matching as a filtration method. Our approach is simpler and in practice more efficient than earlier solutions. We transform the original pattern P into a binary string 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      expressing increases (1), equalities (0), and decreases (0) between subsequent pattern positions. Then we search for 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      in the analogously transformed text 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                     . For example, 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                        =
                        101001
                      corresponds to 
                        P
                        =
                        (
                        10
                        ,
                        22
                        ,
                        15
                        ,
                        30
                        ,
                        20
                        ,
                        18
                        ,
                        27
                        )
                      and 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                        =
                        100101001100
                      to T above. Each occurrence is a match candidate which is verified following the numerical order of the positions of the original pattern P. Note that in this approach any algorithm for exact string matching can be used as a filtration method. If the filtration algorithm is sublinear and the text is transformed on line, the total method is sublinear on average.

We made experiments with two sublinear string matching algorithms and two linear string matching algorithms as the filtering method. Our approach with sublinear filters was considerably faster than the algorithm by Cho et al. [5], which is the first sublinear solution of the problem.

The paper is organized as follows. Section 2 describes the previous solutions for order-preserving matching, Section 3 presents our solution based on filtration, Section 4 analyses the new approach, Section 5 presents and discusses the results of practical experiments, and Section 6 concludes the article.

In the first KMP approach presented by Kubica et al. [4], the fail function in the KMP algorithm is modified to compute the order-borders table. This can be achieved in linear time. The KMP algorithm is mutated such that it determines if the text contains substring with the same relative order as that of the pattern using the order-borders table. This computation can be done in linear time. Hence, the total time complexity of the method is linear.

The second KMP approach by Kim et al. [3] is based on the prefix representation. The prefix representation is based on finding the rank of each number in the prefix. The time complexity of the method is 
                        O
                        (
                        n
                        log
                        ⁡
                        m
                        )
                     . This approach is further optimized using the nearest neighbor representation to overcome the overhead involved in computing the rank function. The time complexity of the improved version is 
                        O
                        (
                        n
                        +
                        m
                        log
                        ⁡
                        m
                        )
                     .

The BMH approach by Cho et al. [5] is based on the bad character rule applied to q-grams, i.e. strings of q characters. A q-gram is treated as a single character in order to make shifts longer. In this way, a large amount of text can be skipped for long patterns, and the algorithm is sublinear on average. The standard version works in 
                        O
                        (
                        m
                        n
                        )
                      in the worst case. Later, Cho et al. [6] introduced a linear version, which has been combined with KMP in order to guarantee linear behavior in the worst case.

In Section 1 we gave an informal description of order-preserving matching. Let us define the problem formally.

Two strings 
                                 u
                                 =
                                 
                                    
                                       u
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       u
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       u
                                    
                                    
                                       m
                                    
                                 
                               and 
                                 v
                                 =
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       v
                                    
                                    
                                       m
                                    
                                 
                               of the same length over Σ are called order-isomorphic 
                              [3,4], written 
                                 u
                                 ≈
                                 v
                              , if
                                 
                                    
                                       
                                          
                                             
                                                u
                                             
                                             
                                                i
                                             
                                          
                                          ≤
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                          ⇔
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                          
                                          ≤
                                          
                                             
                                                v
                                             
                                             
                                                j
                                             
                                          
                                          
                                          for
                                          
                                          1
                                          ≤
                                          i
                                          ,
                                          j
                                          ≤
                                          m
                                          .
                                       
                                    
                                 
                               In the order-preserving pattern matching problem, the task is to find all the substrings of 
                                 T
                                 =
                                 
                                    
                                       t
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       t
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       t
                                    
                                    
                                       n
                                    
                                 
                               which are order-isomorphic with 
                                 P
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       p
                                    
                                    
                                       m
                                    
                                 
                              .

Our solution for order-preserving matching consists of two phases: filtration and verification. First the text is transformed to a bit string which is filtered with some exact string matching algorithm. In the second phase the match candidates are verified using a checking routine.

For filtration, the consecutive numbers in the pattern 
                                 P
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       p
                                    
                                    
                                       m
                                    
                                 
                               are compared pairwise in the preprocessing phase and the result is encoded as a modified pattern 
                                 
                                    
                                       P
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 
                                    
                                       b
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       b
                                    
                                    
                                       m
                                       −
                                       1
                                    
                                 
                               of binary numbers: 
                                 
                                    
                                       b
                                    
                                    
                                       i
                                    
                                 
                               is 1 if 
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 <
                                 
                                    
                                       p
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                               holds, otherwise 
                                 
                                    
                                       b
                                    
                                    
                                       i
                                    
                                 
                               is 0. In the search phase, some algorithm for exact string matching (let us call it A) is applied to filter out the text. When Algorithm A reads an alignment window of the original text, the text is encoded incrementally online in the same way as the pattern. Algorithm A is run as if the whole text would have been encoded. Because Algorithm A may recognize an occurrence of 
                                 
                                    
                                       P
                                    
                                    
                                       ′
                                    
                                 
                               which does not correspond to an actual match of P in T, each occurrence of 
                                 
                                    
                                       P
                                    
                                    
                                       ′
                                    
                                 
                               is only a match candidate which should be verified. It is clear that this filtration method cannot skip any occurrence of P in T.

During preprocessing the pattern, the numbers of the pattern 
                                 P
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                                 ⋯
                                 
                                    
                                       p
                                    
                                    
                                       m
                                    
                                 
                               are sorted. The result is an auxiliary table r: 
                                 
                                    
                                       p
                                    
                                    
                                       r
                                       [
                                       i
                                       ]
                                    
                                 
                                 ≤
                                 
                                    
                                       p
                                    
                                    
                                       r
                                       [
                                       j
                                       ]
                                    
                                 
                               holds for each pair 
                                 i
                                 <
                                 j
                               and 
                                 
                                    
                                       p
                                    
                                    
                                       r
                                       [
                                       1
                                       ]
                                    
                                 
                               is the smallest number in P. In addition, we need a binary vector E representing the equalities: 
                                 E
                                 [
                                 i
                                 ]
                                 =
                                 1
                               denotes that 
                                 
                                    
                                       p
                                    
                                    
                                       r
                                       [
                                       i
                                       ]
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       r
                                       [
                                       i
                                       +
                                       1
                                       ]
                                    
                                 
                               holds. The match candidates found by Algorithm A are traversed in accordance with the table r. If the candidate starts from 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                               in T, the first comparison is done between 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                       −
                                       1
                                       +
                                       r
                                       [
                                       1
                                       ]
                                    
                                 
                               and 
                                 
                                    
                                       t
                                    
                                    
                                       j
                                       −
                                       1
                                       +
                                       r
                                       [
                                       2
                                       ]
                                    
                                 
                              . There is a mismatch when
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      ]
                                                   
                                                
                                                >
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      +
                                                      1
                                                      ]
                                                   
                                                
                                                
                                                or
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      ]
                                                   
                                                
                                                =
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      +
                                                      1
                                                      ]
                                                   
                                                
                                                
                                                and
                                                
                                                E
                                                [
                                                i
                                                ]
                                                =
                                                0
                                                )
                                                
                                                or
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      ]
                                                   
                                                
                                                <
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      j
                                                      −
                                                      1
                                                      +
                                                      r
                                                      [
                                                      i
                                                      +
                                                      1
                                                      ]
                                                   
                                                
                                                
                                                and
                                                
                                                E
                                                [
                                                i
                                                ]
                                                =
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 
                               is satisfied. The candidate is discarded when a mismatch is encountered. Verification is efficient because sorting is done only once during preprocessing.

We use binary numbers in encoding. We also tried encoding of three numbers 0, 1, and 2 corresponding to ‘<’, ‘=’, and ‘>’, but the binary approach was faster in practice, because testing of one condition is faster than testing of two conditions. Also the frequency of nearby equalities is low in real data.

@&#ANALYSIS@&#

We will prove that our approach is sublinear in the average case, if the filtration algorithm is sublinear. Sublinearity means that on average all the characters in the text are not examined.

Let us assume that the numbers in P and T are integers and they are statistically independent of each other and the distribution of numbers is discrete uniform. Let 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      and 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                      be the transformed pattern and text. Let c be the count of the integer range (i.e. the alphabet size). The probability of one in a position of 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      or 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                      (as a result of a comparison) is 
                        p
                        =
                        (
                        
                           
                              c
                           
                           
                              2
                           
                        
                        /
                        2
                        −
                        c
                        /
                        2
                        )
                        /
                        
                           
                              c
                           
                           
                              2
                           
                        
                        =
                        (
                        c
                        −
                        1
                        )
                        /
                        2
                        c
                     , because there are 
                        
                           
                              c
                           
                           
                              2
                           
                        
                      integer pairs and c equalities. So the probability of a character match q is
                        
                           
                              
                                 
                                    
                                       
                                          
                                             p
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             (
                                             1
                                             −
                                             p
                                             )
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       2
                                       p
                                       (
                                       p
                                       −
                                       1
                                       )
                                       +
                                       1
                                       =
                                       1
                                       −
                                       
                                          
                                             c
                                             −
                                             1
                                          
                                          c
                                       
                                       ⋅
                                       
                                          
                                             c
                                             +
                                             1
                                          
                                          
                                             2
                                             c
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       =
                                    
                                    
                                       1
                                       −
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                
                                                   2
                                                
                                             
                                             −
                                             1
                                          
                                          
                                             2
                                             
                                                
                                                   c
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       =
                                       
                                          1
                                          2
                                       
                                       +
                                       
                                          1
                                          
                                             2
                                             
                                                
                                                   c
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        
                      Because adjacent positions in 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                        =
                        
                           
                              b
                           
                           
                              1
                           
                        
                        
                           
                              b
                           
                           
                              2
                           
                        
                        ⋯
                        
                           
                              b
                           
                           
                              m
                              −
                              1
                           
                        
                      and in 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                      are not independent, let us consider matching of a relaxed pattern 
                        
                           
                              P
                           
                           
                              ″
                           
                        
                        =
                        
                           
                              b
                           
                           
                              1
                           
                        
                        $
                        
                           
                              b
                           
                           
                              3
                           
                        
                        $
                        
                           
                              b
                           
                           
                              5
                           
                        
                        ⋯
                        $
                        
                           
                              b
                           
                           
                              s
                           
                        
                     , which contains every other character of 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      and where $ matches both 0 and 1 and s is 
                        2
                        ⌊
                        m
                        /
                        2
                        ⌋
                        −
                        1
                     . The probability of a match of 
                        
                           
                              P
                           
                           
                              ″
                           
                        
                      at a certain position of 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                      is smaller than 
                        
                           
                              q
                           
                           
                              (
                              m
                              −
                              1
                              )
                              /
                              2
                           
                        
                     , which approaches to zero, when m grows. This is true even for 
                        c
                        =
                        2
                     . The probability of a match of 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      (i.e. a match candidate of P) is smaller than the probability of a match of 
                        
                           
                              P
                           
                           
                              ″
                           
                        
                     . This means that the verification time approaches zero when m grows, and the filtration time dominates. If the filtration method is sublinear, the total algorithm is sublinear.

The preprocessing phase requires 
                        O
                        (
                        m
                        log
                        ⁡
                        m
                        )
                      time due to sorting of the pattern positions. The space requirement is 
                        O
                        (
                        m
                        )
                     .

In the worst case, the total algorithm requires 
                        O
                        (
                        n
                        m
                        )
                      time if, for example, 
                        
                           
                              P
                           
                           
                              ′
                           
                        
                      is 
                        
                           
                              1
                           
                           
                              m
                              −
                              1
                           
                        
                      and 
                        
                           
                              T
                           
                           
                              ′
                           
                        
                      is 
                        
                           
                              1
                           
                           
                              n
                              −
                              1
                           
                        
                     . If the filtration method is linear in the worst case, the total algorithm can be modified to work in linear time by combining a linear solution [4,3] L with it. When the distance of starting positions of subsequent match candidates is less than 
                        m
                        /
                        2
                     , next 2m positions are processed with L.

@&#EXPERIMENTS@&#

We tested four string matching algorithms as filtration methods for order-preserving matching. Two of them, SBNDM2 and SBNDM4 [10] are based on the Backward Nondeterministic DAWG Matching (BNDM) algorithm [1]. In BNDM, each alignment window is processed from right to left like in the Boyer–Moore algorithm [9] by simulating the nondeterministic automaton of the reversed pattern with bitparallelism. SBNDMq starts the processing of each alignment window by reading a q-gram. The third algorithm is Fast Shift-Or (FSO) [11]. We utilized a version of FSO coded by B. Ďurian [10]. FSO was selected because it is fast on short binary patterns [10]. The fourth algorithm is the KMP algorithm [8]; together with verification it was supposed to approximate the two earlier methods [3,4] based on KMP. Of the algorithms, SBNDM2 and SBNDM4 are sublinear, whereas FSO and KMP are linear.

The tests were run on Intel 2.70 GHz i7 processor with 16 GB of memory running Ubuntu 12.10. All the algorithms were implemented in C in the 64-bit mode and run in the testing framework of Hume and Sunday [12]. Our solution based on filtration was compared with the BMH approach by Cho et al. [5] (the authors generously let us use their implementation). Because the BMH approach was clearly faster than the KMP-based algorithm [3] and slightly faster than the linear version of the BMH approach in the tests [6], we tested only the first mentioned algorithm.

For testing we used three texts: a random text and two real texts, which were time series of the Dow Jones index and Helsinki temperatures. The random data contains 
                        1
                        ,
                        000
                        ,
                        000
                      random integers between 0 and 230. The Dow Jones data contains 
                        15
                        ,
                        248
                      integers pertaining to the daily values of the stock index in the years 1950–2011 and the Helsinki temperature data contains 6818 integers referring to the daily mean temperatures in Fahrenheit (multiplied by ten) in Helsinki in the years 1995–2005. From each text we picked randomly patterns of length 
                        5
                        ,
                        8
                        ,
                        10
                        ,
                        15
                        ,
                        20
                        ,
                        30
                     , and 50. Each set contains 1000 patterns for the random text and 200 patterns for the real texts. Table 1
                      shows the average execution times per pattern of all the algorithms. The unit is 10 milliseconds for real data and one second for random data. In addition, a graph on times for the Dow Jones data is shown in Fig. 2
                     . The real texts were tested with 180 repeated runs and the random text was tested with 60 repeated runs. In Table 1, S2OPM represents the algorithm based on SBNDM2 filtration, S4OPM represents the algorithm based on SBNDM4 filtration, BMOPM-q represents the BMH approach [5] for 
                        q
                        =
                        3
                        ,
                        4
                        ,
                        5
                     , KOPM represents the algorithm based on KMP filtration and FSO-OPM represents the algorithm based on Fast Shift-Or.

From Table 1, it can be seen that in case of real data, S4OPM is a clear winner for most tested values of m, and FSO-OPM is the fastest for 
                        m
                        =
                        5
                     . With all the three data sets, S2OPM is mostly slower than S4OPM but its execution time approaches that of S4OPM as the value of m increases. For 
                        m
                        =
                        50
                     , the execution times of S2OPM and S4OPM are almost equal. Relatively, S2OPM and S4OPM perform better on the real data than on the random data. In the case of Helsinki daily temperatures, the execution times of S2OPM and S4OPM are comparable. In the case of random data, S2OPM and S4OPM are the best for 
                        m
                        =
                        5
                      and FSO-OPM is the best for 
                        m
                        =
                        8
                        ,
                        10
                     .

We introduced a new practical solution based on filtration for order-preserving matching. Any exact string matching algorithm can be used as the filtration algorithm. In this paper, we utilized SBNDM2, SBNDM4, FSO, and KMP as the filtration method of our solution. The results of our practical experiments prove that the solutions based on SBNDM2 and SBNDM4 are faster than the earlier BMOPM algorithm. Moreover, the solution based on FSO is still faster for certain short pattern lengths. Research on filters and encodings for order-preserving matching is continuing. After submitting this paper, Chhabra et al. [13] improved filtering time with the SIMD technology. Chhabra et al. [14] applied the same encoding to approximate order-preserving matching. Cantone et al. [15] developed a more sophisticated encoding with a faster filter.

@&#REFERENCES@&#

