@&#MAIN-TITLE@&#Longest common substrings with k mismatches

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Two new algorithms for the longest common substring with k mismatches problem.


                        
                        
                           
                           A practical solution for arbitrary k which uses constant space.


                        
                        
                           
                           A theoretical solution for one mismatch which runs in quasilinear time.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Combinatorial problems

String algorithms

Hamming distance

Longest common substring

@&#ABSTRACT@&#


               
               
                  The longest common substring with k-mismatches problem is to find, given two strings 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , a longest substring 
                        
                           
                              A
                           
                           
                              1
                           
                        
                      of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              A
                           
                           
                              2
                           
                        
                      of 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      such that the Hamming distance between 
                        
                           
                              A
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              A
                           
                           
                              2
                           
                        
                      is ≤k. We introduce a practical 
                        O
                        (
                        n
                        m
                        )
                      time and 
                        O
                        (
                        1
                        )
                      space solution for this problem, where n and m are the lengths of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , respectively. This algorithm can also be used to compute the matching statistics with k-mismatches of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      in 
                        O
                        (
                        n
                        m
                        )
                      time and 
                        O
                        (
                        m
                        )
                      space. Moreover, we also present a theoretical solution for the 
                        k
                        =
                        1
                      case which runs in 
                        O
                        (
                        n
                        log
                        ⁡
                        m
                        )
                      time, assuming 
                        m
                        ≤
                        n
                     , and uses 
                        O
                        (
                        m
                        )
                      space, improving over the existing 
                        O
                        (
                        n
                        m
                        )
                      time and 
                        O
                        (
                        m
                        )
                      space bound of Babenko and Starikovskaya [1].
               
            

@&#INTRODUCTION@&#

In this paper we study the longest common substring (or factor) with k-mismatches problem (k-LCF for short
                        1
                     
                     
                        1
                        We use the k-LCF abbreviation as LCS usually refers to the Longest Common Subsequence problem.
                     ) which consists in finding the longest common substring of two strings 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , while allowing for at most k mismatches, i.e., the Hamming distance between the two substrings is ≤k. This problem is a generalization of the Longest Common Substring problem [2–4] and is similar to the threshold all-against-all problem defined by Gusfield [2] and to the local alignment problem of biological sequence analysis. In the threshold all-against-all problem the goal is to find all the pairs of substrings of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      such that the corresponding edit distance is less than a given number d. The difference in the k-LCF problem is that the distance used is the Hamming distance rather than the edit distance, and that we are interested in the pairs of substrings of maximal length only. In the local alignment problem, which can be solved in 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                      time using the Smith–Waterman algorithm [5], the goal is to compute a pair of substrings of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      such that the corresponding similarity, according to a suitable scoring function, is maximum over all the pairs of substrings. In particular, if the scoring function is such that the score of a match is 1, the score of a mismatch is 0 and gaps are not allowed, a solution of the local alignment problem is comparable to one of the k-LCF problem, with the difference that there is no bound on the number of mismatches.

Babenko and Starikovskaya [1] studied the case of 1 mismatch only and presented an algorithm for the 1-LCF problem which runs in 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                      time. A closely related problem is the one of computing the matching statistics with k mismatches. The matching statistics, introduced by Chang and Lawler [6] for the approximate string matching problem, is an array ms of 
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                      integers such that 
                        m
                        s
                        [
                        i
                        ]
                      is the length of the longest substring of 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      that starts at position i and matches exactly some substring of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                     , for 
                        i
                        =
                        0
                        ,
                        …
                        ,
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        −
                        1
                     . A natural generalization is obtained by allowing the matching to be approximate, with respect to the Hamming distance. Recently, Leimeister and Morgenstern [7] presented a greedy heuristic for the computation of the matching statistics with k mismatches, which runs in 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        k
                        ⋅
                        z
                        )
                      time, where z is the maximum number of occurrences in 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      of a string of maximal length which occurs in both 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     .

In this paper we present two novel contributions. Our first result is an efficient algorithm for the k-LCF problem which runs in time 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                      and only requires a constant amount of space. This algorithm can also be used to compute the matching statistics with k mismatches with no overhead in the time complexity, i.e., in 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                      time, and using 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                      space. Our second result is an algorithm for the 1-LCF problem, i.e., for the 
                        k
                        =
                        1
                      case. We show how to solve this instance in a more time efficient manner by using results from Crochemore et al. [8] for finding the longest generalized repeat(s) with one block of k adjacent don't care symbols. Assuming 
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        ≤
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                     , our algorithm takes time 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        log
                        ⁡
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                     , improving over the previous bound of 
                        O
                        (
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                        ⋅
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                        )
                     .

Let Σ be a finite alphabet of symbols and let 
                        
                           
                              Σ
                           
                           
                              ⁎
                           
                        
                      be the set of strings over Σ. Given a string 
                        S
                        ∈
                        
                           
                              Σ
                           
                           
                              ⁎
                           
                        
                     , we denote by 
                        |
                        S
                        |
                      the length of S and by 
                        S
                        [
                        i
                        ]
                      the i-th symbol of S, for 
                        0
                        ≤
                        i
                        <
                        |
                        S
                        |
                     . Given two strings S and 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                     , 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                      is a substring of S if there are indices 
                        0
                        ≤
                        i
                        ≤
                        j
                        <
                        |
                        S
                        |
                      such that 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        =
                        S
                        [
                        i
                        ]
                        .
                        .
                        .
                        S
                        [
                        j
                        ]
                     . If 
                        i
                        =
                        0
                      (
                        j
                        =
                        |
                        S
                        |
                        −
                        1
                     ) then 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                      is a prefix (suffix) of S. We denote by 
                        S
                        [
                        i
                        .
                        .
                        j
                        ]
                      the substring of S starting at position i and ending at position j. For 
                        i
                        >
                        j
                      we obtain the empty string ε. Finally, we denote by 
                        
                           
                              S
                           
                           
                              r
                           
                        
                        =
                        S
                        [
                        |
                        S
                        |
                        −
                        1
                        ]
                        S
                        [
                        |
                        S
                        |
                        −
                        2
                        ]
                        …
                        S
                        [
                        0
                        ]
                      the reverse of the string S.

The suffix tree 
                        T
                        (
                        S
                        )
                      of a string S is a rooted directed tree with 
                        |
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        |
                      leaves and edge labels over 
                        
                           
                              (
                              Σ
                              ∪
                              {
                              $
                              }
                              )
                           
                           
                              ⁎
                           
                        
                        ∖
                        {
                        ε
                        }
                     , where 
                        $
                        ∉
                        Σ
                      and 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        =
                        S
                        $
                     . Each internal node has at least two children and is such that the edge labels of the children have different first symbols. For each leaf i, the concatenation of the edge labels on the path from the root to leaf i is equal to 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        [
                        i
                        .
                        .
                        |
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        |
                        −
                        1
                        ]
                     . Assuming a constant size alphabet, the suffix tree can be built in 
                        O
                        (
                        |
                        S
                        |
                        )
                      time [2]. For any node u in 
                        T
                        (
                        S
                        )
                     , 
                        
                           depth
                        
                        (
                        u
                        )
                      denotes the length of the string labeling the path from the root to u. For any pair of nodes 
                        u
                        ,
                        v
                      in 
                        T
                        (
                        S
                        )
                     , 
                        
                           LCA
                        
                        (
                        u
                        ,
                        v
                        )
                      denotes the lowest common ancestor of u and v, i.e., the deepest node in 
                        T
                        (
                        S
                        )
                      that is ancestor of both u and v. The suffix tree can be preprocessed in 
                        O
                        (
                        |
                        S
                        |
                        )
                      time so as to answer LCA queries in constant time [9]. We denote by 
                        B
                        (
                        S
                        )
                      the binary suffix tree obtained by replacing each node u in 
                        T
                        (
                        S
                        )
                      with out-degree at least 2 with a binary tree with 
                        d
                        −
                        1
                      internal nodes (whose depth values are equal to 
                        
                           depth
                        
                        (
                        u
                        )
                     ) and 
                        d
                        −
                        2
                      internal edges, where the d leaves are the d children of u. The binary suffix tree can be built in 
                        O
                        (
                        |
                        S
                        |
                        )
                      time [8]. The generalized suffix tree 
                        T
                        (
                        
                           
                              S
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              S
                           
                           
                              2
                           
                        
                        )
                      of two strings 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      is the suffix tree built over 
                        
                           
                              S
                           
                           
                              ′
                           
                        
                        =
                        
                           
                              S
                           
                           
                              1
                           
                        
                        
                           
                              $
                           
                           
                              1
                           
                        
                        
                           
                              S
                           
                           
                              2
                           
                        
                        
                           
                              $
                           
                           
                              2
                           
                        
                     , where 
                        
                           
                              $
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              $
                           
                           
                              2
                           
                        
                        ∉
                        Σ
                     , such that the leaves are numbered with a pair (s-index) and for each leaf 
                        (
                        j
                        ,
                        l
                        )
                      the concatenation of the edge labels on the path from the root to the leaf is equal to 
                        
                           
                              S
                           
                           
                              j
                           
                        
                        [
                        l
                        .
                        .
                        |
                        
                           
                              S
                           
                           
                              j
                           
                        
                        |
                        −
                        1
                        ]
                        
                           
                              $
                           
                           
                              j
                           
                        
                     . The index of a leaf 
                        (
                        j
                        ,
                        l
                        )
                      is the starting position of 
                        
                           
                              S
                           
                           
                              j
                           
                        
                        [
                        l
                        .
                        .
                        |
                        
                           
                              S
                           
                           
                              j
                           
                        
                        |
                        −
                        1
                        ]
                        
                           
                              $
                           
                           
                              j
                           
                        
                      in 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        
                           
                              $
                           
                           
                              1
                           
                        
                        
                           
                              S
                           
                           
                              2
                           
                        
                        
                           
                              $
                           
                           
                              2
                           
                        
                     . We use the notation 
                        B
                        (
                        
                           
                              S
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              S
                           
                           
                              2
                           
                        
                        )
                      to denote the binary generalized suffix tree of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     .

Let 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      be two strings with 
                        n
                        =
                        |
                        
                           
                              S
                           
                           
                              1
                           
                        
                        |
                     , 
                        m
                        =
                        |
                        
                           
                              S
                           
                           
                              2
                           
                        
                        |
                     . W.l.o.g. we assume that 
                        n
                        ≥
                        m
                     . Given an integer k, let 
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                      be the length of the longest substring of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      ending at position i and j, respectively, such that the two substrings have Hamming distance at most k. Formally, 
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                      is equal to the largest integer 
                        l
                        ≤
                        min
                        ⁡
                        (
                        i
                        ,
                        j
                        )
                        +
                        1
                      such that
                        
                           
                              |
                              {
                              0
                              ≤
                              h
                              ≤
                              l
                              −
                              1
                              
                              |
                              
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                              [
                              i
                              −
                              h
                              ]
                              ≠
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                              [
                              j
                              −
                              h
                              ]
                              }
                              |
                              ≤
                              k
                              
                              ,
                           
                        
                      for 
                        0
                        ≤
                        i
                        <
                        n
                        ,
                        0
                        ≤
                        j
                        <
                        m
                     . The longest common substring with k-mismatches problem consists in, given two strings 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      and an integer k, finding the length of the longest substrings of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      with Hamming distance at most k, i.e., 
                        
                           
                              max
                           
                           
                              i
                              ,
                              j
                           
                        
                        ⁡
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                     .

In this section we present a practical algorithm for the k-LCF problem. By definition, 
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                      is also the length of the longest suffixes of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        0
                        .
                        .
                        i
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        0
                        .
                        .
                        j
                        ]
                      with Hamming distance at most k. Our algorithm computes all the values 
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                      based on this alternative formulation. The idea is to iterate over the ϕ matrix diagonal-wise and compute, for a fixed 
                        (
                        i
                        ,
                        j
                        )
                        ∈
                        {
                        (
                        0
                        ,
                        0
                        )
                        ,
                        (
                        0
                        ,
                        1
                        )
                        ,
                        …
                        ,
                        (
                        0
                        ,
                        m
                        −
                        1
                        )
                        }
                        ∪
                        {
                        (
                        1
                        ,
                        0
                        )
                        ,
                        (
                        2
                        ,
                        0
                        )
                        ,
                        …
                        ,
                        (
                        n
                        −
                        1
                        ,
                        0
                        )
                        }
                     , the values 
                        ϕ
                        (
                        i
                        +
                        p
                        ,
                        j
                        +
                        p
                        )
                     , for 
                        0
                        ≤
                        p
                        <
                        min
                        ⁡
                        (
                        n
                        −
                        i
                        ,
                        m
                        −
                        j
                        )
                     , i.e., the diagonal starting at 
                        (
                        i
                        ,
                        j
                        )
                     , in 
                        O
                        (
                        m
                        )
                      time. Let Q be an (empty) queue data structure and 
                        s
                        =
                        0
                     , for a given pair 
                        (
                        i
                        ,
                        j
                        )
                     . The algorithm iterates over p maintaining the invariant that 
                        p
                        −
                        s
                      is the length of the longest common suffix of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        .
                        .
                        i
                        +
                        p
                        −
                        1
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        .
                        .
                        j
                        +
                        p
                        −
                        1
                        ]
                      up to k-mismatches, i.e., 
                        p
                        −
                        s
                        =
                        ϕ
                        (
                        i
                        +
                        p
                        −
                        1
                        ,
                        j
                        +
                        p
                        −
                        1
                        )
                     , and that Q contains exactly the positions in 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      of the mismatches between 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        +
                        s
                        .
                        .
                        i
                        +
                        p
                        −
                        1
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        +
                        s
                        .
                        .
                        j
                        +
                        p
                        −
                        1
                        ]
                      with the order of elements in the queue matching their natural order.

At the beginning the invariant holds since Q is empty, 
                        p
                        −
                        s
                        =
                        0
                      and 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        +
                        s
                        .
                        .
                        i
                        +
                        p
                        −
                        1
                        ]
                        =
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        +
                        s
                        .
                        .
                        j
                        +
                        p
                        −
                        1
                        ]
                        =
                        ε
                     . Suppose that the invariant holds up to position p. If 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        +
                        p
                        ]
                        =
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        +
                        p
                        ]
                      then the invariant trivially holds also for 
                        p
                        +
                        1
                      with 
                        
                           
                              s
                           
                           
                              ′
                           
                        
                        =
                        s
                      and 
                        
                           
                              Q
                           
                           
                              ′
                           
                        
                        =
                        Q
                     . Otherwise, we have a mismatch between 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        +
                        p
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        +
                        p
                        ]
                     . If 
                        |
                        Q
                        |
                        <
                        k
                     , then the invariant also holds for 
                        p
                        +
                        1
                      with 
                        
                           
                              s
                           
                           
                              ′
                           
                        
                        =
                        s
                      and 
                        
                           
                              Q
                           
                           
                              ′
                           
                        
                      equal to Q after an 
                        
                           enqueue
                        
                        (
                        Q
                        ,
                        p
                        )
                      operation. Instead, if 
                        |
                        Q
                        |
                        =
                        k
                     , the pair of suffixes 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        +
                        r
                        .
                        .
                        i
                        +
                        p
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        +
                        r
                        .
                        .
                        j
                        +
                        p
                        ]
                     , for 
                        r
                        =
                        s
                        ,
                        …
                        ,
                        min
                        ⁡
                        Q
                     , match with 
                        k
                        +
                        1
                      mismatches and 
                        r
                        =
                        min
                        ⁡
                        Q
                        +
                        1
                      is the minimum position for which the corresponding suffixes match with k mismatches. Hence, in this case the invariant also holds for 
                        p
                        +
                        1
                      with 
                        
                           
                              s
                           
                           
                              ′
                           
                        
                        =
                        min
                        ⁡
                        Q
                        +
                        1
                      and 
                        
                           
                              Q
                           
                           
                              ′
                           
                        
                      equal to Q after a dequeue operation followed by an 
                        
                           enqueue
                        
                        (
                        Q
                        ,
                        p
                        )
                      operation.

The algorithm maintains the largest length found up to the current iteration and the starting positions of the corresponding substrings in 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , such that the position in 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      is minimal, in three integers ℓ, 
                        
                           
                              r
                           
                           
                              1
                           
                        
                     , and 
                        
                           
                              r
                           
                           
                              2
                           
                        
                     . Each time 
                        p
                        −
                        s
                        >
                        ℓ
                      it updates their values accordingly. The code of the algorithm is shown in Fig. 1
                     . The time complexity of one iteration of the algorithm is 
                        O
                        (
                        1
                        )
                      if the queue operations take constant time, which yields 
                        O
                        (
                        m
                        )
                      time for a fixed i and 
                        O
                        (
                        n
                        m
                        )
                      time in total. The space complexity is 
                        O
                        (
                        k
                        )
                     , as the queue contains at most k elements at any iteration.

For scanning one diagonal of ϕ, the algorithm needs time that is proportional to the length of the diagonal. This can be improved such that the time requirement becomes proportional to the number of mismatches along the diagonal, by using the well-known technique that performs LCA queries on the generalized suffix tree of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      to find, in constant time, how far the next mismatch is from the current one [10]. This gives an algorithm for the k-LCF problem that runs in time proportional to the number of pairs 
                        (
                        i
                        ,
                        j
                        )
                      such that 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        i
                        ]
                        ≠
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        j
                        ]
                     .

the algorithm can also be modified to use 
                                 O
                                 (
                                 1
                                 )
                               space at the price of a constant factor in the running time. We replace the queue with one integer q, encoding the number of mismatches (number of elements in the queue). The dequeue and enqueue operations then become 
                                 q
                                 ←
                                 q
                                 −
                                 1
                               and 
                                 q
                                 ←
                                 q
                                 +
                                 1
                              , respectively. The update of s requires the computation of 
                                 min
                                 ⁡
                                 Q
                                 +
                                 1
                              , which, by definition, is equal to the smallest position 
                                 
                                    
                                       s
                                    
                                    
                                       ′
                                    
                                 
                                 >
                                 s
                               such that 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                                 [
                                 i
                                 +
                                 
                                    
                                       s
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 1
                                 ]
                                 ≠
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                                 [
                                 j
                                 +
                                 
                                    
                                       s
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 1
                                 ]
                              . To this end, we simply scan 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                               from position 
                                 i
                                 +
                                 s
                               and 
                                 j
                                 +
                                 s
                              , respectively, until we find a mismatch. As each symbol of 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                               is looked up at most twice, the time complexity does not change. In practice, using an explicit queue is preferable, as it allows one to avoid rescanning the already scanned parts of the strings.

finally, we describe how to compute the matching statistics with k mismatches of 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                               with respect to 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                              . The matching statistics with k mismatches of 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                               w.r.t. 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               is an array 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                               of m integers such that 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 [
                                 i
                                 ]
                               is the length of the longest prefix of 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                                 [
                                 i
                                 .
                                 .
                                 m
                                 −
                                 1
                                 ]
                               that matches a substring of 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               with at most k mismatches, for 
                                 i
                                 =
                                 0
                                 ,
                                 …
                                 ,
                                 m
                                 −
                                 1
                              . Using the algorithm described above, the array 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                               can be computed in 
                                 O
                                 (
                                 n
                                 m
                                 )
                               time and 
                                 O
                                 (
                                 m
                                 )
                               space as follows: first, we initialize each slot of 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                               to 0; then, we run our algorithm on 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                    
                                       r
                                    
                                 
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                    
                                       r
                                    
                                 
                              , i.e., on the reverse of the strings 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                              , and for each computed cell 
                                 ϕ
                                 (
                                 i
                                 ,
                                 j
                                 )
                               we set 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 [
                                 m
                                 −
                                 1
                                 −
                                 j
                                 ]
                                 =
                                 max
                                 ⁡
                                 (
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 [
                                 m
                                 −
                                 1
                                 −
                                 j
                                 ]
                                 ,
                                 ϕ
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 )
                              . At the end of the procedure we thus have 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 [
                                 m
                                 −
                                 1
                                 −
                                 j
                                 ]
                                 =
                                 
                                    
                                       max
                                    
                                    
                                       i
                                    
                                 
                                 ⁡
                                 ϕ
                                 (
                                 i
                                 ,
                                 j
                                 )
                              , for 
                                 0
                                 ≤
                                 j
                                 <
                                 m
                              . The correctness of this procedure follows by observing that i) a suffix of 
                                 
                                    
                                       S
                                    
                                    
                                       r
                                    
                                 
                                 [
                                 0
                                 .
                                 .
                                 i
                                 ]
                               is the reverse of a prefix of 
                                 S
                                 [
                                 |
                                 S
                                 |
                                 −
                                 1
                                 −
                                 i
                                 .
                                 .
                                 |
                                 S
                                 |
                                 −
                                 1
                                 ]
                              , for any string S and 
                                 0
                                 ≤
                                 i
                                 <
                                 |
                                 S
                                 |
                              , and ii) 
                                 ϕ
                                 (
                                 i
                                 ,
                                 j
                                 )
                               is the length of the longest suffixes of 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                    
                                       r
                                    
                                 
                                 [
                                 0
                                 .
                                 .
                                 i
                                 ]
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                    
                                       r
                                    
                                 
                                 [
                                 0
                                 .
                                 .
                                 j
                                 ]
                               with Hamming distance at most k. Hence, 
                                 
                                    
                                       max
                                    
                                    
                                       i
                                    
                                 
                                 ⁡
                                 ϕ
                                 (
                                 i
                                 ,
                                 j
                                 )
                               is the length of the longest prefix of 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                                 [
                                 m
                                 −
                                 1
                                 −
                                 j
                                 .
                                 .
                                 m
                                 −
                                 1
                                 ]
                               that matches a substring of 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               with at most k mismatches.

Note that the ϕ matrix for 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                               immediately gives a dual matching statistics, where 
                                 m
                                 
                                    
                                       s
                                    
                                    
                                       k
                                    
                                 
                                 [
                                 i
                                 ]
                               is defined as the length of the longest suffix of 
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                                 [
                                 0
                                 .
                                 .
                                 i
                                 ]
                               that matches a substring of 
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                               with a most k mismatches. In practical applications this alternative matching statistics could be equally good.

In this section we describe an algorithm that solves the 1-LCF problem. We first introduce some necessary technical definitions. Given a string S, a pair of substrings 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        )
                        )
                      of S is a repeated pair if 
                        S
                        [
                        
                           
                              p
                           
                           
                              1
                           
                        
                        .
                        .
                        
                           
                              q
                           
                           
                              1
                           
                        
                        ]
                        =
                        S
                        [
                        
                           
                              p
                           
                           
                              2
                           
                        
                        .
                        .
                        
                           
                              q
                           
                           
                              2
                           
                        
                        ]
                     . A repeated pair 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        )
                        )
                      is left-maximal (right-maximal) if 
                        S
                        [
                        
                           
                              p
                           
                           
                              1
                           
                        
                        −
                        1
                        ]
                        ≠
                        S
                        [
                        
                           
                              p
                           
                           
                              2
                           
                        
                        −
                        1
                        ]
                      (
                        S
                        [
                        
                           
                              q
                           
                           
                              1
                           
                        
                        +
                        1
                        ]
                        ≠
                        S
                        [
                        
                           
                              q
                           
                           
                              2
                           
                        
                        +
                        1
                        ]
                     ). Given a string S, a repeat is a substring of S that corresponds to a repeated pair. A repeat w of S is left-maximal (right-maximal) if there exists a left-maximal (right-maximal) repeated pair 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        )
                        )
                      such that 
                        S
                        [
                        
                           
                              p
                           
                           
                              1
                           
                        
                        .
                        .
                        
                           
                              q
                           
                           
                              1
                           
                        
                        ]
                        =
                        S
                        [
                        
                           
                              p
                           
                           
                              2
                           
                        
                        .
                        .
                        
                           
                              q
                           
                           
                              2
                           
                        
                        ]
                        =
                        w
                     . Let ⁎ be the don't care symbol, i.e., a symbol that matches any symbol of Σ. A k-repeat of S is a string of the form 
                        u
                        
                           
                              ⁎
                           
                           
                              k
                           
                        
                        v
                      that matches more than one substring of S, where 
                        u
                        ,
                        v
                        ∈
                        
                           
                              Σ
                           
                           
                              ⁎
                           
                        
                      and 
                        k
                        >
                        0
                     . A longest k-repeat is a k-repeat of maximum length. A necessary condition for a k-repeat 
                        u
                        
                           
                              ⁎
                           
                           
                              k
                           
                        
                        v
                      to be longest is that, for each pair 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        )
                        )
                      of substrings matching the repeat, 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              p
                           
                           
                              1
                           
                        
                        +
                        |
                        u
                        |
                        −
                        1
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              p
                           
                           
                              2
                           
                        
                        +
                        |
                        u
                        |
                        −
                        1
                        )
                        )
                      is a left-maximal repeated pair and 
                        (
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        +
                        |
                        u
                        |
                        +
                        k
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        )
                        ,
                        (
                        
                           
                              p
                           
                           
                              2
                           
                        
                        +
                        |
                        u
                        |
                        +
                        k
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        )
                        )
                      is a right-maximal repeated pair.

The idea is to reduce the 1-LCF problem to the one of computing the longest 1-repeats of 
                        
                           
                              S
                           
                           
                              ¯
                           
                        
                        =
                        
                           
                              S
                           
                           
                              1
                           
                        
                        
                           
                              $
                           
                           
                              1
                           
                        
                        
                           
                              S
                           
                           
                              2
                           
                        
                        
                           
                              $
                           
                           
                              2
                           
                        
                      that occur in both 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , where 
                        
                           
                              $
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              $
                           
                           
                              2
                           
                        
                      are two symbols not in Σ. Let 
                        ℓ
                        =
                        
                           
                              max
                           
                           
                              i
                              ,
                              j
                           
                        
                        ⁡
                        ϕ
                        (
                        i
                        ,
                        j
                        )
                      for 
                        k
                        =
                        1
                     , and let 
                        
                           
                              i
                           
                           
                              ′
                           
                        
                        ,
                        
                           
                              j
                           
                           
                              ′
                           
                        
                      be such that 
                        ϕ
                        (
                        
                           
                              i
                           
                           
                              ′
                           
                        
                        ,
                        
                           
                              j
                           
                           
                              ′
                           
                        
                        )
                        =
                        ℓ
                     . Consider the strings 
                        
                           
                              A
                           
                           
                              1
                           
                        
                        =
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        
                           
                              i
                           
                           
                              ′
                           
                        
                        −
                        ℓ
                        +
                        1
                        .
                        .
                        
                           
                              i
                           
                           
                              ′
                           
                        
                        ]
                      and 
                        
                           
                              A
                           
                           
                              2
                           
                        
                        =
                        
                           
                              S
                           
                           
                              2
                           
                        
                        [
                        
                           
                              j
                           
                           
                              ′
                           
                        
                        −
                        ℓ
                        +
                        1
                        .
                        .
                        
                           
                              j
                           
                           
                              ′
                           
                        
                        ]
                     . It is not hard to see that the string 
                        
                           
                              A
                           
                           
                              1
                           
                        
                        [
                        0
                        .
                        .
                        p
                        −
                        1
                        ]
                        ⁎
                        
                           
                              A
                           
                           
                              1
                           
                        
                        [
                        p
                        +
                        1
                        .
                        .
                        ℓ
                        −
                        1
                        ]
                      is a longest 1-repeat of 
                        
                           
                              S
                           
                           
                              ¯
                           
                        
                      that occurs in both 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , where either 
                        
                           
                              A
                           
                           
                              1
                           
                        
                        =
                        
                           
                              A
                           
                           
                              2
                           
                        
                      and 
                        0
                        ≤
                        p
                        ≤
                        ℓ
                        −
                        1
                      or 
                        
                           
                              A
                           
                           
                              1
                           
                        
                        ≠
                        
                           
                              A
                           
                           
                              2
                           
                        
                      and p is the position corresponding to the single mismatch between 
                        
                           
                              A
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              A
                           
                           
                              2
                           
                        
                     .

To this end, we use a modified version of the algorithm all-longest-k-repeats by Crochemore et al. to find the longest k-repeats of a string [8]. The idea is to run this algorithm on the string 
                        
                           
                              S
                           
                           
                              ¯
                           
                        
                      with 
                        k
                        =
                        1
                     . With this input, the original algorithm reports all the longest 1-repeats of 
                        
                           
                              S
                           
                           
                              ¯
                           
                        
                     . To solve our problem we need to add the constraint that the 1-repeats must occur in both 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     . As the longest such repeats can be shorter than the unconstrained longest 1-repeats of 
                        
                           
                              S
                           
                           
                              ¯
                           
                        
                     , the all-longest-k-repeats algorithm must be modified accordingly.

The all-longest-k-repeats algorithm is structured in the following steps:
                        
                           1.
                           build the suffix tree 
                                 T
                                 (
                                 S
                                 )
                               of S and compute the ordering no of the leaves induced by a depth-first visit; build the binary suffix tree 
                                 B
                                 (
                                 
                                    
                                       S
                                    
                                    
                                       r
                                    
                                 
                                 )
                               of 
                                 
                                    
                                       S
                                    
                                    
                                       r
                                    
                                 
                               and associate to each leaf u with index i a list 
                                 
                                    
                                       A
                                    
                                    
                                       u
                                    
                                 
                               equal to 
                                 {
                                 
                                    no
                                 
                                 (
                                 
                                    
                                       i
                                    
                                    
                                       ¯
                                    
                                 
                                 )
                                 }
                              , if 
                                 i
                                 ≥
                                 k
                              , and to ∅ otherwise, where 
                                 
                                    
                                       i
                                    
                                    
                                       ¯
                                    
                                 
                                 =
                                 |
                                 S
                                 |
                                 −
                                 i
                                 +
                                 k
                              ; 
                                 γ
                                 ←
                                 0
                              
                           


                              for 
                              
                                 u
                                 ∈
                                 B
                                 (
                                 
                                    
                                       S
                                    
                                    
                                       r
                                    
                                 
                                 )
                               in depth-first order with children 
                                 
                                    
                                       u
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       u
                                    
                                    
                                       2
                                    
                                 
                               
                              do
                              
                                 
                                    (a)
                                    
                                       
                                          
                                             find-longest
                                          
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                A
                                             
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             depth
                                          
                                          (
                                          u
                                          )
                                          +
                                          k
                                          ,
                                          γ
                                          )
                                       
                                    


                                       
                                          
                                             
                                                A
                                             
                                             
                                                u
                                             
                                          
                                          ←
                                          
                                             merge
                                          
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                A
                                             
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                          )
                                       
                                    


                           Let 
                           
                              u
                              ,
                              v
                              ,
                              w
                            
                           be leaves in the suffix tree of S with corresponding depth-first ordering of leaves no. If 
                           
                              
                                 no
                              
                              (
                              u
                              )
                              <
                              
                                 no
                              
                              (
                              v
                              )
                              <
                              
                                 no
                              
                              (
                              w
                              )
                            
                           or 
                           
                              
                                 no
                              
                              (
                              w
                              )
                              <
                              
                                 no
                              
                              (
                              v
                              )
                              <
                              
                                 no
                              
                              (
                              u
                              )
                            
                           then 
                           
                              
                                 depth
                              
                              (
                              
                                 LCA
                              
                              (
                              u
                              ,
                              v
                              )
                              )
                              ≥
                              
                                 depth
                              
                              (
                              
                                 LCA
                              
                              (
                              u
                              ,
                              w
                              )
                              )
                           
                           .
                        

Let 
                        L
                        (
                        u
                        )
                      be the list containing the integer 
                        
                           
                              i
                           
                           
                              ¯
                           
                        
                      for each leaf with index i in the subtree of node u of 
                        B
                        (
                        
                           
                              S
                           
                           
                              r
                           
                        
                        )
                     . The idea is to iterate over all the left-maximal repeats of S using 
                        B
                        (
                        
                           
                              S
                           
                           
                              r
                           
                        
                        )
                      and for each pair 
                        (
                        
                           
                              p
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              p
                           
                           
                              2
                           
                        
                        )
                      of indexes in 
                        L
                        (
                        u
                        )
                      of such a repeat u compute the right-maximal repeat starting at position 
                        
                           
                              p
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              p
                           
                           
                              2
                           
                        
                      using an LCA query on 
                        T
                        (
                        S
                        )
                     . It turns out, by the above lemma, that, for a given index 
                        p
                        ∈
                        L
                        (
                        u
                        )
                     , it is enough to check the pairs 
                        (
                        p
                        ,
                        q
                        )
                      and 
                        (
                        p
                        ,
                        r
                        )
                      where q and r are the indexes of the closest leaves to leaf p in 
                        T
                        (
                        S
                        )
                     , with respect to the ordering no, such that 
                        q
                        ,
                        r
                        ∈
                        L
                        (
                        u
                        )
                     .

Our modification consists in the following: we replace 
                        T
                        (
                        S
                        )
                      with the generalized suffix tree of 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      and 
                        B
                        (
                        
                           
                              S
                           
                           
                              r
                           
                        
                        )
                      with the binary generalized suffix tree of 
                        
                           
                              S
                           
                           
                              1
                           
                           
                              r
                           
                        
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                           
                              r
                           
                        
                     . Let 
                        
                           
                              L
                           
                           
                              j
                           
                        
                        (
                        u
                        )
                      be a list containing the integer 
                        
                           
                              i
                           
                           
                              ¯
                           
                        
                     , for each leaf with s-index 
                        (
                        j
                        ,
                        l
                        )
                      and index i in the subtree of node u of 
                        B
                        (
                        
                           
                              S
                           
                           
                              1
                           
                           
                              r
                           
                        
                        ,
                        
                           
                              S
                           
                           
                              2
                           
                           
                              r
                           
                        
                        )
                     , provided that 
                        l
                        ≥
                        k
                     , for 
                        j
                        =
                        1
                        ,
                        2
                     . The condition 
                        l
                        ≥
                        k
                      ensures that the occurrence of u in 
                        
                           
                              S
                           
                           
                              j
                           
                        
                      ending at position 
                        |
                        
                           
                              S
                           
                           
                              j
                           
                        
                        |
                        −
                        1
                        −
                        l
                      can be extended by k don't care symbols to the right, as otherwise there can be no k-repeat with left part equal to the reverse of u label matching a prefix of 
                        
                           
                              S
                           
                           
                              j
                           
                        
                        [
                        |
                        
                           
                              S
                           
                           
                              j
                           
                        
                        |
                        −
                        1
                        −
                        l
                        −
                        
                           depth
                        
                        (
                        u
                        )
                        +
                        1
                        .
                        .
                        |
                        
                           
                              S
                           
                           
                              j
                           
                        
                        |
                        −
                        1
                        ]
                     . Our goal is to iterate over pairs in 
                        
                           
                              L
                           
                           
                              1
                           
                        
                        (
                        u
                        )
                        ×
                        
                           
                              L
                           
                           
                              2
                           
                        
                        (
                        u
                        )
                      only by computing, for a given index 
                        p
                        ∈
                        
                           
                              L
                           
                           
                              1
                           
                        
                        (
                        u
                        )
                     , the indexes q and r of the closest leaves to leaf p in 
                        T
                        (
                        
                           
                              S
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              S
                           
                           
                              2
                           
                        
                        )
                     , with respect to the ordering no, such that 
                        q
                        ,
                        r
                        ∈
                        
                           
                              L
                           
                           
                              2
                           
                        
                        (
                        u
                        )
                     , and vice versa if 
                        p
                        ∈
                        
                           
                              L
                           
                           
                              2
                           
                        
                        (
                        u
                        )
                     . To accomplish this, it is enough to associate to each leaf u of 
                        B
                        (
                        
                           
                              S
                           
                           
                              1
                           
                           
                              r
                           
                        
                        ,
                        
                           
                              S
                           
                           
                              2
                           
                           
                              r
                           
                        
                        )
                      with s-index 
                        (
                        j
                        ,
                        l
                        )
                      and index i two lists, 
                        
                           
                              A
                           
                           
                              u
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              A
                           
                           
                              u
                           
                           
                              2
                           
                        
                     : if 
                        l
                        <
                        k
                      the lists are empty; otherwise, if 
                        j
                        =
                        1
                      then 
                        
                           
                              A
                           
                           
                              u
                           
                           
                              1
                           
                        
                        =
                        {
                        
                           no
                        
                        (
                        
                           
                              i
                           
                           
                              ¯
                           
                        
                        )
                        }
                      and 
                        
                           
                              A
                           
                           
                              u
                           
                           
                              2
                           
                        
                        =
                        ∅
                     , and vice versa if 
                        j
                        =
                        2
                     . Then, we change the operations in the second step of the algorithm as follows:
                        
                           (a)
                           
                              
                                 
                                    find-longest
                                 
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             1
                                          
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    depth
                                 
                                 (
                                 u
                                 )
                                 +
                                 k
                                 ,
                                 γ
                                 )
                              
                           


                              
                                 
                                    find-longest
                                 
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             1
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    depth
                                 
                                 (
                                 u
                                 )
                                 +
                                 k
                                 ,
                                 γ
                                 )
                              
                           


                              
                                 
                                    
                                       A
                                    
                                    
                                       u
                                    
                                    
                                       1
                                    
                                 
                                 ←
                                 
                                    merge
                                 
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             1
                                          
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       1
                                    
                                 
                                 )
                              
                           


                              
                                 
                                    
                                       A
                                    
                                    
                                       u
                                    
                                    
                                       2
                                    
                                 
                                 ←
                                 
                                    merge
                                 
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             1
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       
                                          
                                             u
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 )
                              
                           

We now prove that the time complexity of steps a, b, c, and d is 
                        O
                        (
                        m
                        log
                        ⁡
                        (
                        n
                        /
                        m
                        )
                        )
                     , where 
                        m
                        =
                        min
                        ⁡
                        (
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    1
                                 
                              
                           
                        
                        |
                        ,
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    2
                                 
                              
                           
                        
                        |
                        )
                        ,
                        n
                        =
                        max
                        ⁡
                        (
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    1
                                 
                              
                           
                        
                        |
                        ,
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    2
                                 
                              
                           
                        
                        |
                        )
                     , i.e., there is only a constant overhead compared to the original algorithm. Suppose w.l.o.g. that 
                        m
                        =
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    1
                                 
                              
                           
                        
                        |
                        ,
                        n
                        =
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    2
                                 
                              
                           
                        
                        |
                      and let 
                        
                           
                              m
                           
                           
                              i
                           
                        
                        =
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    1
                                 
                              
                           
                           
                              i
                           
                        
                        |
                      and 
                        
                           
                              n
                           
                           
                              j
                           
                        
                        =
                        |
                        
                           
                              A
                           
                           
                              
                                 
                                    u
                                 
                                 
                                    2
                                 
                              
                           
                           
                              j
                           
                        
                        |
                     , for 
                        1
                        ≤
                        i
                        ,
                        j
                        ≤
                        2
                     . Note that 
                        m
                        ≥
                        
                           
                              m
                           
                           
                              1
                           
                        
                        +
                        
                           
                              m
                           
                           
                              2
                           
                        
                      and 
                        n
                        ≥
                        
                           
                              n
                           
                           
                              1
                           
                        
                        +
                        
                           
                              n
                           
                           
                              2
                           
                        
                     . Step a, b, c, or d takes i) 
                        O
                        (
                        
                           
                              m
                           
                           
                              i
                           
                        
                        log
                        ⁡
                        (
                        
                           
                              n
                           
                           
                              j
                           
                        
                        /
                        
                           
                              m
                           
                           
                              i
                           
                        
                        )
                        )
                        =
                        O
                        (
                        
                           
                              m
                           
                           
                              i
                           
                        
                        log
                        ⁡
                        (
                        n
                        /
                        
                           
                              m
                           
                           
                              i
                           
                        
                        )
                        )
                      time, if 
                        
                           
                              m
                           
                           
                              i
                           
                        
                        ≤
                        
                           
                              n
                           
                           
                              j
                           
                        
                     ; ii) 
                        O
                        (
                        
                           
                              n
                           
                           
                              j
                           
                        
                        log
                        ⁡
                        (
                        
                           
                              m
                           
                           
                              i
                           
                        
                        /
                        
                           
                              n
                           
                           
                              j
                           
                        
                        )
                        )
                        =
                        O
                        (
                        
                           
                              n
                           
                           
                              j
                           
                        
                        log
                        ⁡
                        (
                        n
                        /
                        
                           
                              n
                           
                           
                              j
                           
                        
                        )
                        )
                      time otherwise, where 
                        
                           
                              n
                           
                           
                              j
                           
                        
                        ≤
                        
                           
                              m
                           
                           
                              i
                           
                        
                     . We show that 
                        a
                        log
                        ⁡
                        (
                        n
                        /
                        a
                        )
                        ≤
                        m
                        log
                        ⁡
                        (
                        n
                        /
                        m
                        )
                      for any 
                        1
                        ≤
                        a
                        ≤
                        m
                     . This inequality can be written as 
                        
                           
                              f
                              (
                              m
                              )
                              −
                              f
                              (
                              a
                              )
                           
                           
                              m
                              −
                              a
                           
                        
                        ≤
                        log
                        ⁡
                        n
                      where 
                        f
                        (
                        x
                        )
                        =
                        x
                        log
                        ⁡
                        x
                     . We have 
                        
                           
                              f
                           
                           
                              ′
                           
                        
                        (
                        x
                        )
                        =
                        log
                        ⁡
                        x
                      and, by the mean value theorem, there exists 
                        c
                        ∈
                        (
                        a
                        ,
                        m
                        )
                      such that 
                        
                           
                              f
                              (
                              m
                              )
                              −
                              f
                              (
                              a
                              )
                           
                           
                              m
                              −
                              a
                           
                        
                        =
                        log
                        ⁡
                        c
                        ≤
                        log
                        ⁡
                        m
                        ≤
                        log
                        ⁡
                        n
                     .

The total time complexity of our algorithm for the 1-LCF problem is thus 
                        O
                        (
                        (
                        n
                        +
                        m
                        )
                        log
                        ⁡
                        (
                        n
                        +
                        m
                        )
                        )
                     . Assuming 
                        m
                        ≤
                        n
                     , we can reduce it to 
                        O
                        (
                        n
                        log
                        ⁡
                        m
                        )
                      by partitioning 
                        
                           
                              S
                           
                           
                              1
                           
                        
                      into overlapping substrings of length 2m such that the overlap between two consecutive substrings is of length m, and running the algorithm on each substring and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     . Formally, we run the algorithm on 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        [
                        m
                        ⋅
                        i
                        .
                        .
                        min
                        ⁡
                        (
                        m
                        ⋅
                        i
                        +
                        2
                        m
                        ,
                        n
                        )
                        −
                        1
                        ]
                      and 
                        
                           
                              S
                           
                           
                              2
                           
                        
                      and obtain a value 
                        
                           
                              γ
                           
                           
                              i
                           
                        
                     , for 
                        0
                        ≤
                        i
                        <
                        ⌈
                        n
                        /
                        m
                        ⌉
                     . Then, 
                        ℓ
                        =
                        
                           
                              max
                           
                           
                              i
                           
                        
                        ⁡
                        
                           
                              γ
                           
                           
                              i
                           
                        
                     . The time complexity of this algorithm is 
                        O
                        (
                        (
                        n
                        /
                        m
                        )
                        m
                        log
                        ⁡
                        m
                        )
                        =
                        O
                        (
                        n
                        log
                        ⁡
                        m
                        )
                     .

@&#ACKNOWLEDGEMENTS@&#

We thank the anonymous reviewers for helpful comments.

@&#REFERENCES@&#

