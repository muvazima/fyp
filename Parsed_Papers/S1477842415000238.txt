@&#MAIN-TITLE@&#A formal semantics of nested atomic sections with thread escape

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Semantics of languages with nested atomic sections and thread escape.


                        
                        
                           
                           A precise definition of atomicity and well-synchronisation on program traces.


                        
                        
                           
                           A mechanised proof that well-synchonisation implies strong atomicity.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Atomic sections

Well-synchronisation

Atomicity

Program traces

Formal semantics

Proof assistant

@&#ABSTRACT@&#


               
               
                  The multi-core trend is widening the gap between programming languages and hardware. Taking parallelism into account in the programs is necessary to improve performance. Unfortunately, current mainstream programming languages fail to provide suitable abstractions to do so. The most common pattern relies on the use of mutexes to ensure mutual exclusion between concurrent accesses to a shared memory. However, this model is error-prone and scales poorly by lack of modularity. Recent research proposes atomic sections as an alternative. The user simply delimits portions of code that should be free from interference. The responsibility for ensuring interference freedom is left either to the compiler or to the run-time system.
                  In order to provide enough modularity, it is necessary that both atomic sections could be nested and threads could be forked inside an atomic section. In this paper we focus on the semantics of programming languages providing these features. More precisely, without being tied to a specific programming language, we consider program traces satisfying some basic well-formedness conditions. Our main contribution is the precise definition of atomicity, well-synchronisation and the proof that the latter implies the strong form of the former. A formalisation of our results in the Coq proof assistant is described.
               
            

@&#INTRODUCTION@&#

The multi-core trend in architectures development is widening the gap between programming languages and hardware. Improving performances now come at the price of a deep software renewal because it cannot be done without taking parallelism on board. Unfortunately, current mainstream programming languages fail to provide suitable abstractions to do so. The most common pattern relies on the use of mutexes to ensure mutual exclusion between concurrent accesses to a shared memory. It is widely accepted that this model is error-prone and scales poorly by lack of modularity. In this context, the user is responsible for preserving some sequences of operations from interference. This is typically done by mapping the target (a collection of data) of such operations to a lock to be held when executing the sequence. Different mappings correspond to different choices of granularity, e.g. during a list update one can choose to protect the whole list or simply the updated item and its neighbourhood. A set of coarse-grained locks helps to keep the code simple, but in general leads to poor performances. On the opposite, fine grain locks lead to better performance but the complexity growth is inversely proportional. Despite an important effort of the community to help users in specifying such mappings, mainstream programming languages still do not offer support for doing so mainly because current proposals fail in handling programs in which the mapping changes dynamically. Quoting O׳Hearn et al. [1], ownership is in the eye of the asserter.

Recent research proposes atomic sections as an alternative. In this context, the user simply delimits portions of code that should be free from interference; the responsibility for ensuring interference freedom is left either to the compiler or to the run-time system. Proposals for implementing atomic sections fall in two categories, depending on the choice of an optimistic or pessimistic approach to concurrency. The former relies on transactions [2,3], a well established mechanism in database management systems. Intuitively, in this approach, sections are executed optimistically, assuming no interference, but cancelled if any interference occurs. For a discussion on issues raised by the implementation of transactions in a programming language, readers are referred to [4,5]. The latter relies on lock inference [6,7], sections are executed pessimistically, enforcing mutual exclusion between sections by means of locks. With [8] we consider that transactions are a mean, an implementation technique, to ensure atomicity. The same remark holds for lock inference and the two approaches could even be combined. For example, lock inference could be used to help a transaction-based system to deal with I/O.

At first glance, and independently of the underlying implementation, atomic sections seem simpler to learn compared to more classical synchronisation primitives [9]. However, it is not yet clear whether they can be efficiently implemented [10] and whether they are really simpler, considering formal semantics and reasoning about programs. Some systems allow the nesting of transactions [11,12] while others do not [2], thus leading to poor modularity. When nesting is possible one needs to define precisely the meaning of spawning threads within an atomic section. In [13], two primitives for thread creation are proposed: The first one delays the creation until the end of the section (if it is created inside), and the second one forces the thread to live entirely inside the transaction. In [6], nesting is allowed but the lock inference scheme prevents an atomic section inside another one to run before the enclosing section terminates when they access the same memory location. More importantly, one needs to define precisely the meaning of atomicity in this context.

In this paper we do not consider implementation issues but focus on the semantics of atomic sections. We consider a simple imperative language with fork/join parallelism and lexically scoped atomic sections. It supports the nesting of atomic sections, inner parallelism where threads are allowed to escape from surrounding sections, meaning that there is no synchronisation between the end of a section and the termination of threads started within this section. The semantics of the language is as permissive as possible and is not tied to any particular implementation. More precisely, we consider program traces satisfying some basic well-formedness conditions and, more importantly, satisfying the weak atomicity property, i.e there is no interference between concurrent sections. In this context, our contribution is the precise definition of atomicity, well-synchronisation and the proof that the latter implies the strong form of the former (up-to an equivalence relation over traces). A formalisation in Coq 
                     [14,15] of our results is available.

We first motivate our work with some examples using parallelism and nested atomic sections (Section 2). We expose the context of this work with some related work (Section 3). We then describe the semantics domains of our work including the characterisation of well-formed traces (Section 4). We present our notion of well-synchronised traces in Section 5. Section 6 is devoted to our notion of atomicity and to the proof sketch for the main result. In Section 7 we discuss the design choices for the formalisation in the Coq proof assistant and provide a matching between the definitions and results stated in the paper and their counterparts in Coq. We conclude and give future research directions in Section 8.

To motivate the need of parallelism inside atomic sections and nesting, let us see some examples of simple programs using such constructions. We need to consider an imperative language. It has the classical set of imperative instructions (loops, conditional, etc.), primitives for creation and synchronisation of threads (fork, join), and the possibility to delimit syntactically portion of code to protect with atomic section (atomic{ }). We expect this language to produce traces verifying the properties defined in the rest of the paper. We already defined a similar language with its operational semantics in [16] and proved such a result.

Let us see some examples of programs where parallelism inside atomic section and nesting are useful. For example, consider a shared array list that provides a resize operation. During the resize operation, the list needs to be isolated from the other threads. So an atomic section surrounds the process. However, in order that resizing is not a performance bottleneck, the copy must be done in parallel, where each thread copies a part of the array. That is an example of parallelism in atomic section.

Now suppose one wants to copy two arrays into a third one. These arrays are shared. So there must be an atomic section to protect the target array. Threads read the source arrays and write in the destination one. To read the array, threads must create an atomic section. So this section is nested in the first one.

This following program does this operation. The 5-size arrays a1 a2 are merged into to the 10-size array a thanks to the method merge. This method creates an atomic section in order to protect the array a, and spawns two threads in charge of the copy, thanks to the method copy. This method copies the content of b inside a, starting at the index k of the array a. These threads do not interfere with each other because each thread writes in its own portion of array a. However, it reads a shared array, so this reading must be protected by an atomic section. 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

@&#RELATED WORK@&#

Atomic sections have been the subject of many implementations, mainly using transactions, starting from only hardware based [17], to software based [2,18,19] or even a mix of both [20]. However in general, they did not allow parallelism (and so nesting) in atomic sections. Several papers try to improve these lacks.

Harris [21] proposed to improve composability of atomic sections by adding to them new constructions, like the possibility of specifying another atomic section in case of failure of the first one. But there is still no parallelism or nesting in atomic sections.

The need for nesting was expressed by Moss and Hosking, in [11], by pointing out the example of library use, but also by the fact that atomic sections are less monolithic, and thus lighter. However, inner parallelism is restricted to top level atomic sections (i.e. atomic sections that are not included in another atomic section). This restriction aims to ease the conflict detection and allows to optimise implementation.

The combination of nested parallelism and nested atomic sections was proposed by Agrawal et al. in [12]. They chose structural parallelism instead of pthread usually used, and thus they rely on a tree representation for the parallelism and atomic sections. Each inner atomic section must be terminated before the atomic section parent completes.

Some other works focus more on the proof of serialisability. In [22,23], they wanted to prove atomicity of transactional memory (without nesting). They are not tied to a specific language to be abstract, and their lemmas and definitions are defined on execution traces. However, it is more technical than our work, because they work with transactions and not atomic sections. Their proofs have the same structure than ours, involving the notions of equivalence and serial traces.

These works focus deal with a specific implementation of atomic sections. The next ones look over the semantics of atomic sections.

Jagannathan et al. gave operational semantics of a derived version of Featherweight Java with nested and multi-thread atomic sections, independent of any implementation in [24]. They allow nesting but each child atomic section must terminate before its parent. Their work on the proof of atomicity presents some similarities to ours. To prove the correctness of their work, they use program traces to abstract from the operational semantics, and show the serialisability, i.e. for any abort-free program, there must be a corresponding trace where atomic sections are executed serially.

In [13], Moore et al. pointed out common problems found in several implementations: the precise meaning of atomicity and unnecessary limitations of parallel nesting. To avoid the problem related to the unclear model of atomicity (weak or strong), their advice is to give a semantics with proofs on atomicity. They illustrate it through four languages, and one of them allows parallel nesting with two primitives for thread spawning. The first one spawns threads which must live entirely inside the parent section, and so can only create inner-sections, and the other one delays the spawning at the end of the parent section, and so these threads can only create sub-sections that live outside. We acknowledge the same fact about the unnecessary limitations, and we go further by letting threads escape from atomic sections.

In [25], Abadi et al. wanted also to face the problem associated with weak and strong atomicity, with the development of transactions based on the automatic mutual exclusion model. In their representation, only one atomic section can be executed at a time. They show that existing implementations of transactions can lead to surprising behaviour due to the weak semantics. They present the semantics of their language, and with some restrictions they can give the behaviour of strong atomicity but with a permissive implementation.

We consider a kernel imperative language with dynamic creation of threads communicating through shared memory. Synchronisation of concurrent accesses to this memory is ensured by means of atomic sections which can be nested and support inner-parallelism. These two properties are necessary to support calls to external library functions inside atomic sections without restrictions. Indeed these functions can also use atomic sections or parallelism. Threads forked within a section can escape from its scope, i.e. they may continue their executions after the section terminates. We argue that this asynchronous behaviour of threads, with respect to surrounding atomic sections, benefits to programs modularity. This choice contrasts with that of [13] where threads must either complete before the section may terminate, or run after termination of the section (depending on the choice of the primitive used for spawning the thread). We think that this kind of constraint is not necessary to define atomicity.

We base our study on partial program traces (Section 4.1) and abstract from program syntax by stating some well-formedness properties (Section 4.2). In particular, we assume that weak atomicity, i.e. non-interference of concurrent atomic sections, is ensured by the run-time system through some mutual exclusion mechanism. Because we consider inner-parallelism and thread-escape, the definitions of interference and concurrency between atomic sections require specific care. A program running in atomic section without interference means that it does not receive information which depends on the execution of the section. One must define precisely which threads and atomic sections should be considered as part of an atomic section.

We assume disjoint countable sets of memory locations, thread names and section names, elements of which are respectively noted ℓ, t and p, possibly with subscript. The set of values, elements of which are noted v, possibly with subscripts, contains at least memory locations, integers and thread names.


                        Actions, events and traces: We define the set of actions, elements of which are noted a, possibly with subscripts, as follows: 
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                       
                                          ∣
                                          τ
                                       
                                    
                                 
                              
                           
                        Intuitively, τ denotes an internal, non-observable, action. An action 
                           alloc
                           
                           ℓ
                           
                           n
                         denotes heap allocation of a block of size n at memory location ℓ and an action 
                           free
                           
                           ℓ
                         removes such a block from the heap. An action 
                           read
                           
                           ℓ
                           
                           n
                           
                           v
                         (resp. 
                           write
                           
                           ℓ
                           
                           n
                           
                           v
                        ) denotes a read (resp. write) access from (resp. to) the offset n from location ℓ and v is the read (resp. written) value. Actions 
                           fork
                           
                           t
                         and 
                           join
                           
                           t
                         respectively denote creation and join on a thread t. Finally, 
                           open
                           
                           p
                         and 
                           close
                           
                           p
                         respectively denote section opening and closing. Note that section names are purely decorative and have no operational contents, this will be formalised in well-formedness conditions in Section 4.2. Their sole purpose is to name occurrences of atomic sections occurring in traces. An event e is a pair of a thread name and an action, a trace s is a sequence of events. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     


                        Notations: We note 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                           
                              
                                 s
                              
                              
                                 2
                              
                           
                         the concatenation of partial traces (or traces for short) s
                        1 and s
                        2 where by abuse of notation e stands for 
                           ϵ
                           ·
                           e
                        . For i∈ 
                           N
                        , we define the partial function π
                        
                           i
                         by 
                           
                              
                                 π
                              
                              
                                 es
                              
                           
                           (
                           0
                           )
                           =
                           e
                         and 
                           
                              
                                 π
                              
                              
                                 es
                              
                           
                           (
                           n
                           +
                           1
                           )
                           =
                           
                              
                                 π
                              
                              
                                 s
                              
                           
                           (
                           n
                           )
                        . We respectively note 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 act
                              
                           
                           (
                           i
                           )
                         and 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 tid
                              
                           
                           (
                           i
                           )
                         the first and second projections over the event 
                           
                              
                                 π
                              
                              
                                 s
                              
                           
                           (
                           i
                           )
                        . We note 
                           e
                           ∈
                           s
                        , if there exists i such as 
                           
                              
                                 π
                              
                              
                                 s
                              
                           
                           (
                           i
                           )
                           =
                           e
                        , and by extension 
                           a
                           ∈
                           s
                         if 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 act
                              
                           
                           (
                           i
                           )
                           =
                           a
                        .


                        Definitions: To define precisely what should be considered as part of an atomic section, we introduce some auxiliary definitions. Given a trace s, the relations owner
                        
                           s
                         and father
                        
                           s
                         respectively relate a section to its owner thread and a thread to its father. The relation range
                        
                           s
                         denotes the range of a section. By convention, we state that a section p ranges up to the last position of a trace s if p is pending in s. For a well-formed trace s, as defined in Section 4.2, the relations owner
                        
                           s
                        , father
                        
                           s
                         and range
                        
                           s
                         will define partial functions. 
                           
                              
                                 
                                    
                                       owner
                                    
                                    
                                       s
                                    
                                 
                                 
                                 p
                                 
                                 t
                                 ≜
                                 (
                                 t
                                 ,
                                 open
                                 
                                 p
                                 )
                                 ∈
                                 s
                                 
                                 
                                    
                                       father
                                    
                                    
                                       s
                                    
                                 
                                 
                                 t
                                 
                                 
                                    
                                       t
                                    
                                    
                                       ′
                                    
                                 
                                 ≜
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 fork
                                 
                                 t
                                 )
                                 ∈
                                 s
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       i
                                       )
                                       =
                                       open
                                       
                                       p
                                       
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       j
                                       )
                                       =
                                       close
                                       
                                       p
                                    
                                    
                                       
                                          
                                             range
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       i
                                       )
                                       =
                                       open
                                       
                                       p
                                       
                                       close
                                       
                                       p
                                       ∉
                                       s
                                    
                                    
                                       
                                          
                                             range
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       (
                                       i
                                       ,
                                       |
                                       s
                                       |
                                       −
                                       1
                                       )
                                    
                                 
                              
                           
                        It is now possible to define precisely which threads and atomic sections should be considered as part of a section. Given a section p of a trace s, the relation 
                           
                              
                                 tribe
                              
                              
                                 s
                              
                           
                           
                           p
                         is defined as the least set of thread identifiers containing the owner of the section and threads forked as a side effect of executing the section (relation tribeChildren
                        
                           s
                        ). 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             tribeChildren
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             father
                                          
                                          
                                             s
                                          
                                       
                                       
                                       t
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    
                                    
                                       
                                          
                                             tribeChildren
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             owner
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    
                                    
                                       
                                          
                                             tribe
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    
                                 
                                 
                                 
                                    
                                       
                                          
                                             tribeChildren
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    
                                    
                                       
                                          
                                             tribe
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    
                                 
                              
                           
                        Intuitively, if t belongs to tribe
                        
                           sp
                         then the thread t is part of the computation of the atomic section p and thus should not be considered as an interfering thread. Our definition of atomicity in Section 6 will be based on this notion. In the same way, we define a relation over section names stating that an atomic section is part of the computation of another. We say that 
                           
                              
                                 p
                              
                              
                                 ′
                              
                           
                         is a subsection of p if 
                           
                              
                                 p
                              
                              
                                 ′
                              
                           
                           
                              
                                 ⋐
                              
                              
                                 s
                              
                           
                           p
                        , as defined below, holds: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                tribeChildren
                                             
                                             
                                                s
                                             
                                          
                                          
                                          p
                                          
                                          t
                                          
                                          
                                             
                                                owner
                                             
                                             
                                                s
                                             
                                          
                                          
                                          
                                             
                                                p
                                             
                                             
                                                ′
                                             
                                          
                                          
                                          t
                                       
                                       
                                          
                                             
                                                p
                                             
                                             
                                                ′
                                             
                                          
                                          
                                             
                                                ⋐
                                             
                                             
                                                s
                                             
                                          
                                          p
                                       
                                    
                                 
                                 
                                 
                                 
                                    
                                    
                                       p
                                       
                                          
                                             ⋐
                                          
                                          
                                             s
                                          
                                       
                                       p
                                    
                                 
                              
                           
                        Finally, two atomic sections are said to be concurrent if 
                           p
                           
                              
                                 ⌣
                              
                              
                                 s
                              
                           
                           
                              
                                 p
                              
                              
                                 ′
                              
                           
                        , as defined in (1), holds:
                           
                              (1)
                              
                                 p
                                 
                                 
                                    
                                       ⌣
                                    
                                    
                                       s
                                    
                                 
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 ≜
                                 p
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 ∧
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                    
                                       s
                                    
                                 
                                 p
                              
                           
                        
                     


                        Example: Let us see the previous definitions applied to the example in Fig. 1
                        . The white dots denote fork actions. The atomic sections are symbolised by rounded boxes. We suppose that “w” represents write actions on the same memory location. The other actions are labelled with a letter. Let s be the trace get from this example. The thread t
                        2 opens the section p
                        0 at the action e, and it closes it at the action i. We have 
                           
                              
                                 owner
                              
                              
                                 s
                              
                           
                           
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                           
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 father
                              
                              
                                 s
                              
                           
                           
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                        . The thread t
                        0 is created by t
                        2 while the section p
                        0 is active, so it is a child of the tribe of p
                        0 (
                           
                              
                                 tribeChildren
                              
                              
                                 s
                              
                           
                           
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                           
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                        ). The thread t
                        1 is also one of them because it is created by a child of the section. So the tribe of p
                        0 is made of t
                        2 (the owner), and 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                         (the children). We have 
                           
                              
                                 p
                              
                              
                                 2
                              
                           
                           
                              
                                 ⋐
                              
                              
                                 s
                              
                           
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                         because p
                        2 is created inside p
                        0 by the thread owner of p
                        0, and 
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                           
                              
                                 ⋐
                              
                              
                                 s
                              
                           
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                         because p
                        1 is created by a child of the tribe of p
                        0. Note here that p
                        1 runs outside p
                        0 thanks to thread escape. We also have 
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                           
                           
                              
                                 ⌣
                              
                              
                                 s
                              
                           
                           
                           
                              
                                 p
                              
                              
                                 3
                              
                           
                        .

In this section we state formally some well-formedness conditions over program traces. Those conditions can be seen as a specification for possible implementations of our language. They range from common sense conditions to design choices.

To formalise these conditions we use the following definitions: The predicate see
                        
                           s
                         which can be seen as an over-approximation of the information flow in s, and is defined as the transitive closure of (2); the relation ≺
                           s
                         on section names defined at (3):
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   i
                                                   <
                                                   j
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         tid
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                   =
                                                   t
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         tid
                                                      
                                                   
                                                   (
                                                   j
                                                   )
                                                   =
                                                   t
                                                
                                                
                                                   
                                                      
                                                         see
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   i
                                                   
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   i
                                                   <
                                                   j
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         act
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                   =
                                                   fork
                                                   
                                                   t
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         tid
                                                      
                                                   
                                                   (
                                                   j
                                                   )
                                                   =
                                                   t
                                                
                                                
                                                   
                                                      
                                                         see
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   i
                                                   
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   i
                                                   <
                                                   j
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         act
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                   =
                                                   write
                                                   
                                                   ℓ
                                                   
                                                   n
                                                   
                                                   v
                                                   
                                                   
                                                      
                                                         π
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         act
                                                      
                                                   
                                                   (
                                                   j
                                                   )
                                                   =
                                                   read
                                                   
                                                   ℓ
                                                   
                                                   n
                                                   
                                                   v
                                                
                                                
                                                   
                                                      
                                                         see
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   i
                                                   
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 p
                                 
                                    
                                       ≺
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 ≜
                                 ∃
                                 i
                                 ,
                                 j
                                 .
                                 i
                                 <
                                 j
                                 ∧
                                 
                                    
                                       π
                                    
                                    
                                       s
                                    
                                    
                                       act
                                    
                                 
                                 (
                                 i
                                 )
                                 =
                                 close
                                 
                                 p
                                 ∧
                                 
                                    
                                       π
                                    
                                    
                                       s
                                    
                                    
                                       act
                                    
                                 
                                 (
                                 j
                                 )
                                 =
                                 open
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                        A trace s is well-formed if it satisfies the conditions in Fig. 2
                         which are explained below:
                           
                              •
                              Condition 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          1
                                       
                                    
                                    )
                                  ensures that section and thread names respectively identify dynamic sections and threads. Conditions 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          2
                                       
                                    
                                    )
                                  and 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          3
                                       
                                    
                                    )
                                  state simple properties of section names. Each close action matches a previous open action which should be performed by the same thread. Moreover, each close action of a thread matches the last opened, but not yet closed, section opened by the same thread. As far as section names are concerned, those conditions impose no restrictions over the implementation as section names are purely decorative.

Conditions 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          4
                                       
                                    
                                    )
                                  and 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          5
                                       
                                    
                                    )
                                  state usual properties of fork/join instructions. The first one states that the actions done by a thread happen necessarily after the creation of the thread. The second one asserts that the creation of a thread and its actions are done before the synchronisation on this thread.

Condition 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          6
                                       
                                    
                                    )
                                  states that termination of a thread cannot be observed by another thread if the former has pending sections. An implementation can choose either to prevent termination of threads having pending sections or to force closing of such sections on termination. Condition 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          7
                                       
                                    
                                    )
                                  states that it is not possible for a thread to join another thread without having explicitly received its name. These conditions ensure that external threads will not interfere with an atomic section by observing termination of inner threads. These conditions match the intuition that atomic section should appear as taking zero-time and thus termination of threads within a section should not be observable before the section is closed. External threads must not see the termination of inner threads to avoid interferences. Non-interference could also be achieved by forbidding the opposite. We choose to make the inside of a section invisible from the outside, rather than make the outside invisible from the section.

Condition 
                                    (
                                    
                                       
                                          wf
                                       
                                       
                                          8
                                       
                                    
                                    )
                                  states that concurrent sections do not overlap.

A trivial result is that the subsection relation safely over-approximates overlapping of atomic sections in well-formed traces. Note that, in the absence of thread escape, the two notions would coincide. 
                           Lemma 1
                           
                              For every well-formed trace s, section p ranging from i to j in s and k such that 
                              
                                 i
                                 ≤
                                 k
                                 ≤
                                 j
                               
                              and 
                              
                                 
                                    
                                       π
                                    
                                    
                                       s
                                    
                                    
                                       act
                                    
                                 
                                 (
                                 k
                                 )
                                 =
                                 open
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                              , for some 
                              
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                              , we have 
                              
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       ⋐
                                    
                                    
                                       s
                                    
                                 
                                 p
                              .

By hypothesis and conditions 
                                 (
                                 
                                    
                                       wf
                                    
                                    
                                       1
                                    
                                 
                                 )
                               and 
                                 (
                                 
                                    
                                       wf
                                    
                                    
                                       2
                                    
                                 
                                 )
                               we have neither 
                                 p
                                 
                                    
                                       ⊀
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                               nor 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       ⊀
                                    
                                    
                                       s
                                    
                                 
                                 p
                              . From 
                                 (
                                 
                                    
                                       wf
                                    
                                    
                                       8
                                    
                                 
                                 )
                               it comes 
                                 p
                                 
                                    
                                       ⋐
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                               or 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       ⋐
                                    
                                    
                                       s
                                    
                                 
                                 p
                              . Suppose that p and 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                               are opened by distinct threads t and 
                                 
                                    
                                       t
                                    
                                    
                                       ′
                                    
                                 
                               (otherwise 
                                 i
                                 ≤
                                 k
                                 ≤
                                 j
                               entails the result by definition of ⋐
                                 s
                              ). We assume 
                                 p
                                 
                                    
                                       ⋐
                                    
                                    
                                       s
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                               and show the contradiction. By definition of ⋐
                                 s
                               it comes 
                                 
                                    
                                       tribeChildren
                                    
                                    
                                       s
                                    
                                 
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 
                                 t
                              . It is then immediate that 
                                 
                                    
                                       π
                                    
                                    
                                       s
                                    
                                    
                                       act
                                    
                                 
                                 (
                                 k
                                 )
                                 =
                                 open
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                               and 
                                 
                                    
                                       π
                                    
                                    
                                       s
                                    
                                    
                                       tid
                                    
                                 
                                 (
                                 i
                                 )
                                 =
                                 t
                               imply 
                                 k
                                 <
                                 i
                              , thus contradicting the hypothesis.□

An important aspect is to identify what kind of isolation is offered by atomic sections. Traditionally two kinds of atomicity can be distinguished [26]. In the weak form the atomic sections are protected only against other sections. It means that instructions outside sections can interfere with data accessed in atomic sections. In this case atomic sections only provide a weak form of protection. On the contrary, with strong atomicity, code inside an atomic section is totally protected both from code in other sections and code outside sections.

As stated in Section 4, we rely on the run-time system to ensure some weak-atomicity property: with condition 
                        (
                        
                           
                              wf
                           
                           
                              8
                           
                        
                        )
                      concurrent sections do not overlap. Traditionally, we define a notion of well-synchronisation which provides a sufficient condition for ensuring strong atomicity (as defined in Section 6). To do so we define the notion of conflict over actions by the relation 
                        ⋈
                      given in Fig. 3
                      and state that a trace is well-synchronised if a synchronisation occurs between any two events involving conflicting actions. Synchronisation between two events is defined by sw which is the least predicate defined by the transitive closure of rules in Fig. 3. There are four rules for sw, each requires that the two actions must be ordered. The rule 
                        
                           
                              sw
                           
                           
                              thread
                           
                        
                      states that two events done by the same thread are synchronised. The rule 
                        
                           
                              sw
                           
                           
                              fork
                           
                        
                      asserts that the creation of a thread is synchronised with the events done by this thread. The rule 
                        
                           
                              sw
                           
                           
                              join
                           
                        
                      specifies the synchronisation between the actions of a thread and the action join done on this thread. Finally, the rule 
                        
                           
                              sw
                           
                           
                              section
                           
                        
                      states the synchronisation between the closing and the opening of two concurrent sections.


                     Example: In the example of Fig. 1, we can observe ordered synchronised events. (d,e) corresponds to two events done by the same thread. (f,a) is the fork of a thread and one of its actions. (i,j) corresponds to the closing and opening of two concurrent sections. The two events of (d,a) are synchronised by transitivity. The two write actions are in conflict, but they are both in concurrent sections, and so synchronised.

Intuitively, we consider a high-level programming language in which well-synchronisation should not be seen as an additional programming constraint. Indeed, in such languages the user is not expected to deal with non-sequentially consistent executions and is responsible for writing data-race free programs. Moreover, thread names and memory locations are assumed to be values of opaque data-types. In particular, there must exist some communication (and thus some synchronisation in well-synchronised traces) between the allocation of a location (resp. the fork of a thread) and any access to that location (resp. join on that thread). Concerning thread names this is ensured by condition 
                        (
                        
                           
                              wf
                           
                           
                              7
                           
                        
                        )
                     . We do not impose an equivalent condition for memory locations here because it is useless to our purpose but in practice we will consider programs satisfying such a property.

Now we can define our property of well-synchronisation by requiring each conflicting action to be in synchronisation. 
                        Definition 1
                        A trace s is well-synchronised if for any conflicting actions a and 
                              
                                 
                                    a
                                 
                                 
                                    ′
                                 
                              
                            occurring respectively at position i and j in s such that 
                              i
                              <
                              j
                           , we have 
                              
                                 
                                    sw
                                 
                                 
                                    s
                                 
                              
                              
                              i
                              
                              j
                           .

The following lemma states that in well-synchronised traces information cannot flow without synchronisation. 
                        Lemma 2
                        
                           Let s be a well-synchronised trace. For all positions k and 
                           
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           , 
                              
                                 
                                    see
                                 
                                 
                                    s
                                 
                              
                              
                              k
                              
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              ⇒
                              
                                 
                                    sw
                                 
                                 
                                    s
                                 
                              
                              
                              k
                              
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           .

Immediate by induction on the proof of 
                              
                                 
                                    see
                                 
                                 
                                    s
                                 
                              
                              
                              k
                              
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           . □


                     Examples: We expect, in a trace both well-formed and well-synchronised, that a section is free from outside interference. This motivates well-formedness conditions 
                        (
                        
                           
                              wf
                           
                           
                              6
                           
                        
                        )
                      and 
                        (
                        
                           
                              wf
                           
                           
                              7
                           
                        
                        )
                     . Without these conditions, traces of Fig. 4
                      would be well-formed and well-synchronised traces but they have indeed a problem of interference. The black dots denote join actions, “w” and “r” respectively represent write and read operations on the same given memory location (and we assume this memory location is not used elsewhere inside section p). In both cases the read write operation interferes with the read action on this memory location inside section p. Without the 
                        join
                      action done by thread t
                     0, the two conflicting write operations would not be synchronised. Condition 
                        (
                        
                           
                              wf
                           
                           
                              6
                           
                        
                        )
                      forbids the 
                        join
                      in the first case, and condition 
                        (
                        
                           
                              wf
                           
                           
                              7
                           
                        
                        )
                      forbids it in the second case.

We can now relate our notions of section and synchronisation to express a property on tribes. The following proposition states that in well-synchronised traces members of a tribe cannot synchronise with non-members while the section is active. An immediate corollary is that in well-synchronised traces actions of members of a section cannot conflict with actions of non-members while the section is active. 
                        Proposition 1
                        
                           For every well-formed and well-synchronised trace s, section p ranging from i to j in s, and 
                           
                              k
                              ,
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                            
                           such that 
                           
                              i
                              ≤
                              k
                              ,
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              ≤
                              j
                            
                           and 
                           
                              
                                 
                                    sw
                                 
                                 
                                    s
                                 
                              
                              
                              k
                              
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                            
                           we have 
                           
                              
                                 
                                    tribe
                                 
                                 
                                    s
                                 
                              
                              
                              p
                              
                              t
                              ⇒
                              
                                 
                                    tribe
                                 
                                 
                                    s
                                 
                              
                              
                              p
                              
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                            
                           where 
                           
                              
                                 
                                    π
                                 
                                 
                                    s
                                 
                                 
                                    tid
                                 
                              
                              (
                              k
                              )
                              =
                              t
                            
                           and 
                           
                              
                                 
                                    π
                                 
                                 
                                    s
                                 
                                 
                                    tid
                                 
                              
                              (
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                           .

Let p be a section ranging from i to j in s and let 
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                            be such that 
                              i
                              ≤
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              ≤
                              j
                            and 
                              
                                 
                                    π
                                 
                                 
                                    s
                                 
                                 
                                    tid
                                 
                              
                              (
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                            for some 
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                           . We consider the property: 
                              
                                 
                                    
                                       
                                          
                                             P
                                             (
                                             
                                                
                                                   k
                                                
                                                
                                                   0
                                                
                                             
                                             )
                                          
                                          
                                             ≡
                                          
                                          
                                             ∀
                                             k
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                             .
                                          
                                          
                                             i
                                             ≤
                                             
                                                
                                                   k
                                                
                                                
                                                   0
                                                
                                             
                                             ≤
                                             j
                                             ∧
                                             i
                                             ≤
                                             k
                                             ≤
                                             j
                                             ∧
                                             
                                                
                                                   sw
                                                
                                                
                                                   s
                                                
                                             
                                             
                                             k
                                             
                                             
                                                
                                                   k
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                          
                                             ∧
                                             
                                                
                                                   π
                                                
                                                
                                                   s
                                                
                                                
                                                   tid
                                                
                                             
                                             (
                                             k
                                             )
                                             =
                                             t
                                             ∧
                                             
                                                
                                                   π
                                                
                                                
                                                   s
                                                
                                                
                                                   tid
                                                
                                             
                                             (
                                             
                                                
                                                   k
                                                
                                                
                                                   0
                                                
                                             
                                             )
                                             =
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                             ∧
                                          
                                       
                                       
                                          
                                          
                                          
                                          
                                             
                                                
                                                   tribe
                                                
                                                
                                                   s
                                                
                                             
                                             
                                             p
                                             
                                             t
                                             ⇒
                                             
                                                
                                                   tribe
                                                
                                                
                                                   s
                                                
                                             
                                             
                                             p
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           Now suppose that 
                              P
                              (
                              
                                 
                                    k
                                 
                                 
                                    0
                                 
                              
                              )
                            holds for all 
                              
                                 
                                    k
                                 
                                 
                                    0
                                 
                              
                              <
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           . We prove that 
                              P
                              (
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              )
                            holds by induction on the derivation of 
                              
                                 
                                    sw
                                 
                                 
                                    s
                                 
                              
                              
                              k
                              
                              
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                           .
                              
                                 •
                                 If 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             tid
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                     or 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       fork
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                     the result is immediate by definition of tribe.

Suppose that 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       =
                                       join
                                       (
                                       t
                                       )
                                    . By 
                                       (
                                       
                                          
                                             wf
                                          
                                          
                                             6
                                          
                                       
                                       )
                                     we have 
                                       
                                          
                                             tribeChildren
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       t
                                     and then, by definition of tribe, we can find some k
                                    0 and t
                                    0 such that 
                                       i
                                       <
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       <
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    , 
                                       
                                          
                                             tribe
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       
                                          
                                             t
                                          
                                          
                                             0
                                          
                                       
                                     and 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       )
                                       =
                                       fork
                                       (
                                       t
                                       )
                                    . By 
                                       (
                                       
                                          
                                             wf
                                          
                                          
                                             7
                                          
                                       
                                       )
                                     it comes 
                                       
                                          
                                             see
                                          
                                          
                                             s
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    . By definition of see, it is easy to check that 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       =
                                       join
                                       (
                                       t
                                       )
                                     implies that there exists some 
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                       <
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                     such that either 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             tid
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                       )
                                       =
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     or 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                       )
                                       =
                                       fork
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                     and either 
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       =
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                     or 
                                       
                                          
                                             see
                                          
                                          
                                             s
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                    . If 
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       =
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                     then the result is immediate. Otherwise, 
                                       P
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                       )
                                     holds by induction hypothesis and by Lemma 2 we have 
                                       
                                          
                                             sw
                                          
                                          
                                             s
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             0
                                          
                                       
                                       
                                       
                                          
                                             k
                                          
                                          
                                             1
                                          
                                       
                                    .By definition of tribe it comes 
                                       
                                          
                                             tribe
                                          
                                          
                                             s
                                          
                                       
                                       
                                       p
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    .

Suppose that 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       close
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                     and 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       =
                                       open
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             ″
                                          
                                       
                                       )
                                     for some 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     and 
                                       
                                          
                                             p
                                          
                                          
                                             ″
                                          
                                       
                                    . The result is immediate by Lemma 1.

The induction step is immediate by applying twice the induction hypothesis.□

In this section, we prove that well-formed and well-synchronised traces satisfy the strong atomicity property. More formally, we prove that well-synchronised traces are serialisable, i.e. any such trace is equivalent to a serial trace. A serial trace [27] is traditionally defined as a trace obtained by a program where atomic sections are executed serially i.e. without interleaving. This definition suits well without inner-parallelism. We can delay the execution of a forked thread inside the section, to let only the thread owner of the section run and use the classical definition of serialisability. We think that this is an unnecessary limitation of parallelism. An atomic section provides an isolation for a piece of program, and the threads created during the execution are a part of this program, and so they must be “allowed” to run. That is why we have to define our own notion of serialisability. To define the notion of serial trace, we must take care that sections support nesting, inner-parallelism and thread-escape.

This is exactly the purpose of the notion of tribe which captures the set of threads that should be allowed to run while a section is active. 
                        Definition 2
                        A trace s is serial if for every section p and for all positions i, j and k such that 
                              
                                 
                                    range
                                 
                                 
                                    s
                                 
                              
                              
                              p
                              
                              (
                              i
                              ,
                              j
                              )
                            and 
                              i
                              ≤
                              k
                              ≤
                              j
                            we have 
                              
                                 
                                    tribe
                                 
                                 
                                    s
                                 
                              
                              
                              p
                              
                              t
                            where 
                              
                                 
                                    π
                                 
                                 
                                    s
                                 
                                 
                                    tid
                                 
                              
                              (
                              k
                              )
                              =
                              t
                           .

A trace s is serialisable if there exists a serial trace 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            that is equivalent to s.

We now need to define formally what it means for two traces to be equivalent. Usually, traces are defined to be equivalent up to re-orderings preserving the order of conflicting actions, for a broader definition of conflicting actions than the one we use. For technical purpose, we consider a stronger definition of equivalence. 
                        Definition 4
                        Two traces s and 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            are equivalent, noted 
                              s
                              ≡
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                           , if there exists a bijection γ between positions of s and 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            such that 
                              
                                 
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           
                        


                           For every well-formed and well-synchronised trace s, and for every trace 
                           
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                           , if 
                           
                              s
                              ≡
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            
                           then 
                           
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            
                           is well-formed and well-synchronised.

The proof of well-synchronisation is done by examining the order between positions in the two traces and exploiting the properties of the bijection to show that these positions are still in synchronisation. The proof of well-formedness is done for each of the eight conditions, using properties of the bijection.□


                           Every well-formed and well-synchronised trace is serialisable.

The proof is by structural induction on s. The result is obvious for the empty trace. Suppose 
                              s
                              ·
                              (
                              t
                              ,
                              a
                              )
                            is a well-formed and well-synchronised trace. Then s is both well-formed and well-synchronised because these properties are prefix-closed. By induction hypothesis, there exists 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            such that 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                              ≡
                              s
                            and 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            is serial.

Then we prove that 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                              ·
                              (
                              t
                              ,
                              a
                              )
                              ≡
                              s
                              ·
                              (
                              t
                              ,
                              a
                              )
                           . The bijection used (noted γ) is the same as in 
                              s
                              ≡
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                            for all positions 
                              <
                              |
                              s
                              |
                            and 
                              γ
                              (
                              |
                              s
                              |
                              )
                              =
                              |
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                              |
                           . The proof of condition 
                              (
                              
                                 
                                    e
                                 
                                 
                                    1
                                 
                              
                              )
                            of equivalence is trivial. The trickiest part of condition 
                              (
                              
                                 
                                    e
                                 
                                 
                                    2
                                 
                              
                              )
                            is when we have 
                              
                                 
                                    sw
                                 
                                 
                                    s
                                    ·
                                    (
                                    t
                                    ,
                                    a
                                    )
                                 
                              
                              
                              i
                              
                              |
                              s
                              |
                            so we have to prove 
                              
                                 
                                    sw
                                 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                    ·
                                    (
                                    t
                                    ,
                                    a
                                    )
                                 
                              
                              
                              γ
                              (
                              i
                              )
                              
                              γ
                              (
                              |
                              s
                              |
                              )
                           . We know that 
                              
                                 
                                    π
                                 
                                 
                                    s
                                 
                              
                              (
                              i
                              )
                              =
                              
                                 
                                    π
                                 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              (
                              γ
                              (
                              i
                              )
                              )
                            and 
                              
                                 
                                    π
                                 
                                 
                                    s
                                    ·
                                    (
                                    t
                                    ,
                                    a
                                    )
                                 
                              
                              (
                              |
                              s
                              |
                              )
                              =
                              
                                 
                                    π
                                 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                    ·
                                    (
                                    t
                                    ,
                                    a
                                    )
                                 
                              
                              (
                              γ
                              (
                              |
                              s
                              |
                              )
                              )
                              =
                              (
                              t
                              ,
                              a
                              )
                           . By an induction on 
                              
                                 
                                    sw
                                 
                                 
                                    s
                                    ·
                                    (
                                    t
                                    ,
                                    a
                                    )
                                 
                              
                              
                              i
                              
                              |
                              s
                              |
                            we can conclude.

By Proposition 2, 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                              ·
                              (
                              t
                              ,
                              a
                              )
                            is well-formed and well-synchronised.

Now we show that 
                              
                                 
                                    s
                                 
                                 
                                    ′
                                 
                              
                              ·
                              (
                              t
                              ,
                              a
                              )
                            is serialisable.

We note 
                              
                                 
                                    excludes
                                 
                                 
                                    s
                                    ,
                                    p
                                 
                              
                              
                              t
                            when p is pending in s and 
                              ¬
                              
                                 
                                    tribe
                                 
                                 
                                    s
                                 
                              
                              
                              p
                              
                              t
                           . Assume p is the left-most section such that 
                              
                                 
                                    excludes
                                 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    p
                                 
                              
                              
                              t
                           .
                              
                                 •
                                 Suppose that no such section exists. Let the positions 
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    , the thread name 
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     and the section name 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     be such that 
                                       
                                          
                                             range
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    , 
                                       
                                          
                                             π
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                          
                                             tid
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     and 
                                       i
                                       ≤
                                       k
                                       ≤
                                       j
                                    . We want to prove that 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    . If 
                                       k
                                       <
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                     the result is immediate by the serialisability of 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                    . We suppose now that 
                                       k
                                       =
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                     (and then 
                                       t
                                       =
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    ). If 
                                       
                                          
                                             π
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       open
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     then k=i by 
                                       (
                                       
                                          
                                             wf
                                          
                                          
                                             1
                                          
                                       
                                       )
                                    , and then as the owner of the section 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                    , 
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     is in the tribe of 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                    . If 
                                       
                                          
                                             π
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       k
                                       )
                                       ≠
                                       open
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     then necessarily 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     is pending in 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                    . By assumption we have thus necessarily that 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     holds. As tribe is preserved by trace concatenation, 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    : The trace 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       ·
                                       (
                                       t
                                       ,
                                       a
                                       )
                                     is serial.

If section p exists, let i be such that 
                                       
                                          
                                             π
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                          
                                             act
                                          
                                       
                                       (
                                       i
                                       )
                                       =
                                       open
                                       
                                       p
                                    . We will reason using insertion which is useful to represent the shifting of an element in a trace. Given a non-empty trace 
                                       s
                                       ·
                                       e
                                    , we note 
                                       s
                                       
                                       
                                          
                                             ↰
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                       
                                       e
                                     the trace obtained by inserting e in s at position i
                                    0. A bijection γ is induced by the insertion:
                                       
                                          
                                             γ
                                             (
                                             k
                                             )
                                             =
                                             k
                                             
                                             if
                                             
                                             k
                                             <
                                             i
                                             ,
                                             
                                             γ
                                             (
                                             k
                                             )
                                             =
                                             k
                                             +
                                             1
                                             
                                             if
                                             
                                             i
                                             ≤
                                             k
                                             <
                                             |
                                             s
                                             |
                                             γ
                                             (
                                             |
                                             s
                                             |
                                             )
                                             =
                                             
                                                
                                                   i
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    Note γ keeps the relative order of positions lower than 
                                       |
                                       s
                                       |
                                    , and its inverse for positions different from i
                                    0. There are two important properties of insertion we use: 
                                       
                                          
                                             
                                                
                                                   
                                                
                                             
                                          
                                       
                                    Let us consider the trace 
                                       
                                          
                                             s
                                          
                                          
                                             ″
                                          
                                       
                                       =
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             ↰
                                          
                                          
                                             i
                                          
                                       
                                       
                                       (
                                       t
                                       ,
                                       a
                                       )
                                    . We now prove that 
                                       
                                          
                                             s
                                          
                                          
                                             ″
                                          
                                       
                                     is equivalent to 
                                       s
                                       ·
                                       (
                                       t
                                       ,
                                       a
                                       )
                                     and serial. To do so we need to use the two properties of insertion, so first we prove: 
                                       ∀
                                       k
                                       .
                                       
                                       i
                                       ≤
                                       k
                                       <
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                       ⇒
                                       ¬
                                       
                                          
                                             sw
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       k
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                    . Suppose 
                                       
                                          
                                             sw
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       k
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                     for a k such that 
                                       i
                                       ≤
                                       k
                                       <
                                       |
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                    . By serialisability of 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                     we know that 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       p
                                       
                                       
                                          
                                             t
                                          
                                          
                                             1
                                          
                                       
                                    , where 
                                       
                                          
                                             π
                                          
                                          
                                             s
                                          
                                          
                                             tid
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       
                                          
                                             t
                                          
                                          
                                             1
                                          
                                       
                                    , and 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       p
                                       
                                       
                                          
                                             t
                                          
                                          
                                             1
                                          
                                       
                                     by preservation of tribe by trace concatenation. By Proposition 1, we can conclude 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    . Because 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                       ·
                                       (
                                       t
                                       ,
                                       a
                                       )
                                     is well-formed we know that 
                                       a
                                       ≠
                                       open
                                       
                                       p
                                     and 
                                       a
                                       ≠
                                       fork
                                       
                                       t
                                    . By definition of tribe we obtain that 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       p
                                       
                                       t
                                     that contradicts assumption 
                                       ¬
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       p
                                       
                                       t
                                    .

By 
                                       (
                                       
                                          
                                             ins
                                          
                                          
                                             eq
                                          
                                       
                                       )
                                     and transitivity, we conclude 
                                       
                                          
                                             s
                                          
                                          
                                             ″
                                          
                                       
                                       ≡
                                       s
                                       ·
                                       (
                                       t
                                       ,
                                       a
                                       )
                                    .

For proving that 
                                       
                                          
                                             s
                                          
                                          
                                             ″
                                          
                                       
                                     is serial, let 
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                       
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                       k
                                     be positions, 
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                     a section name, 
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     a thread such that 
                                       
                                          
                                             range
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ″
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       (
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                    , 
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ≤
                                       k
                                       ≤
                                       
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                     and 
                                       
                                          
                                             π
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                          
                                             tid
                                          
                                       
                                       (
                                       k
                                       )
                                       =
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    . To prove 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ″
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     we first prove 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     by transposing the 
                                       
                                          
                                             range
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ″
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       (
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                     on 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                     and use the serialisability of 
                                       
                                          
                                             s
                                          
                                          
                                             ′
                                          
                                       
                                     to conclude. To do so prove that the relative positions of 
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                    , k and 
                                       
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                     are preserved by the inverse of the induced bijection γ, i.e. consider whether each position is equal to i or not: First prove that 
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ≠
                                       i
                                     and conclude for the four remaining cases using various well-formedness conditions. So 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     holds.

As tribe is preserved by trace concatenation, we have 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ′
                                                
                                             
                                             ·
                                             (
                                             t
                                             ,
                                             a
                                             )
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                     and by 
                                       (
                                       
                                          
                                             ins
                                          
                                          
                                             tribe
                                          
                                       
                                       )
                                    , we conclude 
                                       
                                          
                                             tribe
                                          
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ″
                                                
                                             
                                          
                                       
                                       
                                       
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                    . Therefore 
                                       
                                          
                                             s
                                          
                                          
                                             ″
                                          
                                       
                                     is serial.□

Pen and paper proofs for complex semantics are error-prone. This is thus safer to use a proof assistant (also called interactive prover) to formalise and prove the properties of such semantics. In this work we used Coq 
                     [14]. As its core it is based on the Curry–Howard correspondence that relates terms of a typed λ-calculus with proof trees of a logical system in natural deduction form. A type could be the statement of a property and a program could be a proof of a property. The calculus behind Coq is the calculus of (co)-inductive constructions, an extension of the initial Calculus of Constructions [28].

From a more practical side, Coq can be seen as a functional programming language, close to OCaml or Haskell but with a richer type system that allows to express logical properties. As a matter of fact, Coq is often used as follows: programs are developed in Coq and their properties are also proved in Coq. But it is also used to model semantics of programming languages and to prove their properties. Coq has also been used to prove mathematical theorems, for example the four-color theorem [29].

Writing proofs with an interactive theorem prover is longer because no routine or folklore results can be omitted in the proofs. However, confidence in the results is greater as there are no omissions and the proofs are checked by the prover. In the case of Coq, the only component of the system to be trusted is the type checker: a proof being a program and a logical statement being a type, checking that a proof is indeed a correct proof is type checking it against the statement/type. Coq being a rich language, there are always many ways to formalise a concept. In the development we try to find a balance between elegance of the modelling and simplicity of its use for further steps including proofs.

In this section we explain the choices we made when modelling the trace semantics and proving its properties in Coq. We give all the elements needed to read the statement of the main theorem. Then we explain the proof of this main theorem, using a set of tactics, designed to make the proof understandable even without running the proof script. Finally we also briefly explain how the development is organised and relate the Coq material with the definitions and results of the previous sections.

To understand this section, the reader must have basic notions of Coq. We refer to [30,31] for introductions to Coq and [15,32] for reference books.


                        Section 4 begins to define memory locations, section names, thread identifiers and values. The three first elements are defined as disjoint countable sets. To model that in Coq we define the following module type: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        where 
                           
                        .

In the remaining of the formalisation we assume having modules Ad (for memory addresses), TId (for thread identifiers) and SN (for section names) whose type is DecidableInfiniteSet. The property eq_dec is necessary to be able to have reasonings of the form: either these two values are equal or they are different. Indeed Coq is based on a constructive logic and we cannot reason using excluded middle. Instead of decidable equality we could have added the excluded middle axiom. This axiom could be added safely to Coq׳s logic. However as certain combinations of axioms make the logic incoherent, using an axiom that is not absolutely necessary hinders the modular nature of a development. That is why we prefer to prove that equality is decidable on the data structures we manipulate, or that a property is decidable when we need to reason by case on whether an instance of the property holds or not.

The infinite property is necessary to generate fresh names (for threads and sections), and un-allocated memory addresses using the following lemma: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

In the previous part, we assumed that values contain at least memory locations, numbers (data), and thread identifiers. In order to formalise that in Coq, we first define types (of the object language) that are associated to the values (of the object language), and we add a type for Boolean values. We relate these types of the object language to types of Coq by a function typeOfType that allows us to define a type for representing the values of our object language. All these definitions are given in several modules, for the sake of simplicity, we assume here we have only one module: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The next step is to defined actions, events and traces. The action type is an inductive type, where each constructor represents an action. It uses the address Ad.t, thread identifier TId.t, section name SN.t, and value Va.t types: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

From that, the type of events is defined as: 
                           Definition
                           
                           t
                           ≔
                           TId
                           .
                           t
                           ⁎
                           action
                         in a module Event. The type for traces is then 
                           Definition
                           
                           tr
                           ≔
                           list
                           
                           Event
                           .
                           t
                        . We must define an additional induction principle because the automatically generated principle is the one that matches the constructors: New elements are added to the beginning of the list. In the tr_ind induction principle, the inductive case considers that new elements are added at the end of the list.

In order to define the notion of well-formedness and well-synchronisation, it is first necessary to define various predicates on the data-types just defined.

Ownership and fatherhood are defined as 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        With respect to the definitions given we choose to state the membership of an event to a trace in the form 
                           ∃
                           i
                           ,
                           
                              
                                 π
                              
                              
                                 s
                              
                           
                           (
                           i
                           )
                           =
                           e
                         rather than 
                           e
                           ∈
                           s
                        . And actually we use 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 tid
                              
                           
                           (
                           i
                           )
                           =
                           t
                         and 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 act
                              
                           
                           (
                           i
                           )
                           =
                           a
                         rather than 
                           
                              
                                 π
                              
                              
                                 s
                              
                           
                           (
                           i
                           )
                           =
                           (
                           t
                           ,
                           a
                           )
                        . The Coq counterparts of 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 tid
                              
                           
                           (
                           i
                           )
                         and 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 act
                              
                           
                           (
                           i
                           )
                         are respectively threadId_of (pi i s) and action_of (pi i s). It was possible to use the In predicate of Coq to have definitions similar to the ones given in the first part of the paper. However, this would imply additional steps in the proofs to obtain statements such as 
                           
                              
                                 π
                              
                              
                                 s
                              
                              
                                 act
                              
                           
                           (
                           i
                           )
                           =
                           a
                        . There is therefore a trade-off between conciseness of predicate definitions and ease of use in proofs. A last detail on the functions used in these definitions: they are partial functions, because i may be an index out of the bounds of the list. Thus they return values of type option defined as 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        and the notation x==y stands for x=Some y.

The definition of range, tribeChildren and tribe are very close to their counterparts in Section 4. Most of the time, inferences systems are modelled in Coq as inductive definitions: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        Note the use of occursIn s a which simply states that there exists an event e containing a in the trace s.

Well-formedness is a predicate on traces defined as 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        It is basically a conjunction of the basic properties needed to insure well-formedness, but put in an inductive definition to ease its use in proofs. We do not detail all the properties but the first that is given as an English sentence in the first part, and wf_fork 
                        
                           (
                           
                              
                                 wf
                              
                              
                                 4
                              
                           
                           )
                         to show that the Coq versions are very close to the mathematical definitions: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The definition of well synchronised traces follows closely the definitions of the first part, 
                           ⋈
                         is modelled by conflict, the rules of Fig. 3 by sw, sw (defined as the transitive closure of the relation defined by the rules) by synchronizeWith, and Definition 1 by wellSynchronized: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

Finally, we need the definition of equivalence between two traces and the definition of atomicity for a trace. The latter is simple and is very close to Definition 2: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        Two traces are considered equivalent if there is a compatibility relation between them, i.e. a bijective relation which has the properties stated in Definition 4. We also use a notation in the Coq development: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

We now have all the elements needed to state the main theorem: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

In interactive proving systems, there are roughly two kinds of style for writing proofs: using a procedural language to write proof scripts, where tactics are used to transform the proof state (the goals, i.e. the statements remaining to be proved, their hypotheses, and the partially built proof terms), or using a declarative language that is very close to usual mathematical texts. It is easier to write proof scripts in the procedural style, and user specific tactics (usually the procedural language allows to write procedures that define new tactics) are very useful for automation. However proof scripts in this style are difficult to read, even if there are good practices that can be used within this style to improve readability, and almost impossible to understand without replaying the proof script in order to see the goals. Declarative proofs are much easier to read and understand even without executing them in a proof assistant. However they are longer to write, and often more verbose. There are proposals to mix the two styles [33], and Coq, among some proof assistants, offers both styles [34], even if the declarative proof style is not mature yet and has few users.

We also think that mixing the two styles allows to have more readable proofs still allowing to have automation. However, we take a very lightweight approach: we rely on Coq׳s procedural proof language features that help to structure proof scripts, and we design some tactics and tactic notations to write proofs in a declarative spirit. Moreover we use the usual procedural style whenever the proof details would have been omitted in a mathematical text.

We develop new tactics and tactic notations using only the Ltac language of Coq. It would be possible to improved these tactics, and provide additional ones, by developing a plugin (implemented in OCaml) for Coq. However this would no longer be a lightweight approach. We also are not advocating to use this style systematically, and in the whole development, we commit lightly to this style, mostly to help us remember quickly the main steps of a proof, but playing the proof script may still be needed to grasp the important details.

To show the advantages of the style, we wrote a version of the main theorem that strongly commits to it. We think the obtained proof script could be read on its own, without running it, provided our specific tactics, and some important Coq tactics, are informally explained. We begin with Coq׳s standard tactics:
                           
                              
                                 
                                    •
                                 
                              
                              While writing a proof in the procedural style, a tactic could generate several sub-goals from one goal. In the proof style we advocate, such a tactics should be always followed by “bullets”. Basically these could be understood as: for each sub-goal we start the proof by a symbol, such that the proof script displays a kind of itemised list of proofs. For example if in a proof, a tactic tac generates two sub-goals, the proof script should have the form 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 Bullet symbols include −, + and ⁎. Without thinking of the Coq goals, to read such a proof script we only need to know that tac is followed by a reasoning by case.


                                 
                                    induction
                                    
                                    t
                                  is a tactic that starts a proof by induction on the term t. It generates a sub-goal for each possible form of the inductive term t. When necessary, the sub-goal contains in hypothesis, the induction hypothesis. Optionally an alternative induction scheme ind could be specified 
                                    induction
                                    
                                    t
                                    
                                    using
                                    
                                    ind
                                 . In our style 
                                    induction
                                  should always be followed by bullets.


                                 
                                    case
                                    
                                    t
                                  is a tactic that is similar to 
                                    induction
                                  but without generation of the induction hypothesis. This is just a reasoning by case. In our style 
                                    case
                                  should always be followed by bullets.


                                 
                                    apply
                                  
                                 H is a tactic that tries to match the conclusion of the proposition named H and the goal. It generates sub-goals for each of the premises of H. It can be followed by 
                                    with
                                    
                                    
                                       
                                          t
                                       
                                       
                                          1
                                       
                                    
                                    …
                                    
                                       
                                          t
                                       
                                       
                                          n
                                       
                                    
                                 , to provide explicitly the n first arguments of 
                                    H
                                 .

In our style, 
                                    apply
                                  is often used in combination with the tactical 
                                    now
                                  
                                 tac that applies automatically simple tactics to solve the sub-goals that are generated by the tactic tac.

There are some cases that are not very complicated but not handled by 
                                    now
                                 . That is why we provide the tactical 
                                    conclude
                                    
                                    by
                                  
                                 tac which does the same that 
                                    now
                                  but using more powerful automation.

In our style, we make sure to provide in the context all the hypotheses (or hypotheses that quite straightforwardly imply these hypotheses) needed to apply a lemma 
                                    H
                                 .

In order to do so, we heavily rely on the 
                                    assert
                                  tactic of Coq. With 
                                    assert
                                    
                                    t
                                    
                                    as
                                    
                                    H
                                  we state that we want to prove t and add it in the context under the name 
                                    H
                                 . It can be optionally followed by 
                                    by
                                    
                                    tactic
                                  which gives the proof script necessary to prove t.

In our style we use main forms:
                                    
                                       ○
                                       
                                          
                                             assert
                                             
                                             t
                                             
                                             as
                                             
                                             H
                                             
                                             by
                                             
                                             tactics
                                           when tactics is short,


                                          
                                             assert
                                             
                                             t
                                             
                                             as
                                             
                                             H
                                             .
                                             
                                             {
                                             
                                             
                                                
                                                   tactic
                                                
                                                
                                                   1
                                                
                                             
                                             .
                                             …
                                             
                                                
                                                   tactic
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             
                                             }
                                           when the proof is longer. The {} is also a standard Coq way of structuring proofs. It indicates that what is inside is a proof of the first goal generated by the tactic that precedes it. In our style we only use it when there is only one goal.

In usual Coq proof scripts, the tactic 
                                    destruct
                                    
                                    t
                                    
                                    as
                                    …
                                  is often used. While being powerful, it does not make proof scripts easy to read. In the proof scripts that follows our style, we use it in only one case: when we want to decompose a value of a singleton inductive type into its components. As this tactics allows to name the components (after 
                                    as
                                 ) but not explicitly remind how this components are combined together, we use comments to explain that. Therefore in the proof script of the main theorem we have 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 Having a tactic such as decompose e 
                                 
                                    as
                                  
                                 (t,a) for example, would require to write a Coq plugin.


                                 
                                    inversion
                                  
                                 H can be used when H is the name of a term in the context whose type is an inductive type. For each constructor of the type (thus it could produce several sub-goals), it generates, if possible, the arguments for this constructor that are used to build H.

In our proof style we mainly use it to prove a statement that is included as an argument of a constructor in a hypothesis present in the context.


                                 
                                    ∃
                                    t
                                  is used when the goal is an existential quantification, it provides the witness t.


                                 
                                    contradiction
                                  concludes when there are both a proposition and its negation in the context.

One major drawback of Coq׳s tactics is that most of the tactics uses names of terms in the context rather than the terms themselves. One exception is 
                           assert
                        , and it is one of the reasons we use it a lot. There is also no standard tactic to remind what is the goal. Thus we provide:
                           
                              
                                 
                                    •
                                 
                              
                              
                                 
                                    prove
                                  
                                 t this tactic succeeds when the goal to prove is t. It makes the proof script much more readable, in particular we systematically use it in each of the bullets after an 
                                    induction
                                  or 
                                    case
                                 . When we want also to remind the hypotheses used to prove this goal we provide the form 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 This form is in particular used to explicitly state the induction hypothesis in the inductive cases of a proof by 
                                    induction
                                 .

Note that this form could also be used when the goal has the form 
                                    
                                       
                                          t
                                       
                                       
                                          1
                                       
                                    
                                    →
                                    ⋯
                                    →
                                    
                                       
                                          t
                                       
                                       
                                          n
                                       
                                    
                                    →
                                    t
                                 . In this case the terms t
                                 
                                    i
                                  are introduced in the context, with the names specified by 
                                    as
                                 .


                                 
                                    prove
                                  
                                 t should always be followed by a block {} that contains the proof of t.


                                 
                                    have
                                  
                                 t is used to remind one of the assumptions present in the context. t is the statement of the assumption, not its name. Optionally, the assumption may be renamed using the form 
                                    have
                                    
                                    t
                                    
                                    as
                                    
                                    H
                                 .

In usual Coq proof scripts, we mentioned that 
                                    destruct
                                  is often used. In particular when there is a hypothesis 
                                    H
                                    :
                                    ∃
                                    x
                                    :
                                    T
                                    .
                                    P
                                  in the context, to extract a witness w that as the property P that we name Hw we write: 
                                    destruct
                                    
                                    H
                                    
                                    as
                                    
                                    [
                                    w
                                    
                                    Hw
                                    ]
                                 . It is the same thing than decomposing a pair into its components. That is sensible since in Coq, H is a dependent pair: the first component is w, and the second a proof that w has property P. However, as the structure of H is not made visible in the proof script, this kind of tactic is difficult to read.

Therefore we provide the tactic: 
                                    witness
                                    
                                    t
                                    
                                    from
                                    
                                    H
                                  to extract a witness from an assumption, and often we use it in conjunction with 
                                    have
                                  it order to remind the property that holds for t. For example the proof of the main theorem contains 
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 Sometimes we do not use 
                                    have
                                  but instead we assert derived properties that are easily proved from the property of the witness.

In the following proof scripts, there are some tactics that have not been explained. The convention that if 
                           by
                         is followed by unexplained tactics, then it corresponds to omission of details in a mathematical proof. The statements of the lemmas (together with some definitions) applied in the proof are given in Appendix A. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

The formal development in Coq is available at: https://traclifo.univ-orleans.fr/PaPDAS/wiki/TransactionsInCoq
                     

In order to improve the readability and the reutilisability of definitions, Coq has a module system. There are two types of module. 
                           Module
                           
                           Type
                         acts as signature, and defines what is visible for the rest of the program. 
                           Module
                         defines the implementation. There are two ways for a module to instantiate a module type. A module M can instantiate a signature S, M:S, and then all the definitions that are in M and not in S will not be available. A module M can be compatible with a signature S, noted 
                           M
                           <
                           :
                           S
                         and the extra definitions will be visible for the rest of the program.

In the tables of Figs. 5 and 6
                        
                        , we give the matching between the definitions and lemmas in the paper and their counterparts in Coq. For each one we indicate its Coq name and the Coq file. All the files are in the Transactions directory of the archive.

There is about 12,000 lines of code including definitions, lemmas and their proofs. Proofs count for about 70% of the total size. In order to make this development more navigable, it has been divided into directories and files according to the following rules:
                           
                              •
                              Definitions are grouped together in a file naming with respect to the main notion these definitions concern. For example traces and the main predicates on them are defined in the file Trace.v.

Basics and auxiliary lemmas are in a file suffixed with _Basics, and in case of a large number of this lemmas, it could be divided into several files, for example Trace_Basics_tribe.v is about results on the tribes of a trace.

The main lemmas and theorems are in a file suffixed with _Theory. For example Lemma 1 is in the file Trace_Theory.v.


                                 Support contains some very general definitions and results, not specific to this development but nonetheless useful.


                                 Common contains material shared by the different parts of the full development such as the definition of types and values.


                                 Transactions contains the Coq formalisation of the previous sections. Inside this directory the notions having their specific set of files (and their dependencies) follows: 
                                    
                                       
                                          Trace
                                          ←
                                          Synchronisation
                                          ←
                                          Equivalence
                                          ←
                                          Insertion
                                          ←
                                          Atomicity
                                       
                                    
                                 
                              

In our study, we consider program traces of imperative languages with fork-join parallelism and lexically scoped atomic section which supports nesting and parallelism to provide a good modularity. This parallelism does not impose unnecessary synchronisation, thus threads can escape from surrounding sections. We design a semantics independent of any implementation. We precisely define well-formedness, that could be seen as a specification for the operational semantics of imperative languages with nested atomic sections and inner parallelism, as well as well-synchronisation and serialisability. We prove that all well-formed and well-synchronised traces are serialisable. We use the interactive theorem prover Coq to express our definitions and lemmas, and to check our proofs. In another paper [16], we design an operational semantics for a simple imperative language that produces only well-formed traces. This is evidence that the well-formedness conditions are indeed specification for language design.

This work is a part of a larger plan: we are building a verification compilation pass for our language with atomic sections towards a language without atomic sections but with locks. Our source language is the simple imperative language cited previously. Its semantics uses an abstract representation of nested atomic sections, a recursive structure where each level represents an atomic section. The target language has a concrete realisation of this structure, using records and locks. The compilation replaces atomic sections׳ calls, and adds extra code to maintain this data structure.

An additional pass would be to use static analysis (like in [35]) to improve our compilation.

@&#ACKNOWLEDGEMENTS@&#

Thomas Pinsard was supported by a PhD grant from the French ministry of higher education and research. This work was partly supported by ANR (France) and JST (Japan) (project PaPDAS “Parallel Program Development with Algorithmic Skeletons” JST 10102704 and ANR-2010-INTB-0205-02).


                     
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  


                     
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

@&#REFERENCES@&#

