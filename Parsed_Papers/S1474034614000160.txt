@&#MAIN-TITLE@&#Automatic clustering method for real-time construction simulation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This research aims to reduce the computational cost for overall collision checks in a virtual construction site.


                        
                        
                           
                           A computational method was developed specifically for clustering construction objects into larger surrounding boundary.


                        
                        
                           
                           Using surrounding boundary in place of the individual objects reduce the overall collision checks.


                        
                        
                           
                           A quality index was defined to evaluate the quality of clustering results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Clustering

Collision detection

Grouping

Virtual construction

@&#ABSTRACT@&#


               
               
                  Simulation of construction activities in a virtual environment can prevent constructability problems and increase efficiency and safety at the physical construction site. The computation for collision checks creates a bottleneck during these simulations. A typical construction simulation requires collision checks to be performed between all pairs among thousands or even millions of objects, and each of these checks must be completed within 1/10th or even 1/20th of a second to provide a smooth real-time simulation. Therefore, the reduction of computational cost is paramount. An effective and commonly used method is to cluster the objects into groups and use a larger surrounding boundary shape in place of the individual objects. This significantly reduces the computational effort required. However, clustering objects manually is usually time consuming and is difficult especially for large scenarios. In this paper, we develop an automatic clustering method, called the Propagation Clustering Method (PCM). PCM employs k-means clustering to iteratively cluster objects into multiple groups. A quality index is defined to evaluate the clustering results. Once the clustering results satisfy the predefined quality requirement, the group of objects is replaced by a rectangular box using the axis-aligned bounding box (AABB) algorithm. The rectangular box is then stored in a tree structure. To verify the feasibility of the proposed PCM, we defined three testing scenarios: a site with scattered objects, such as a small plant construction; a common construction site; and a large site with both common structures and scattered objects. Experimental results show that PCM is effective for automatically grouping objects in virtual construction scenarios. It can significantly reduce the effort required to prepare a construction simulation.
               
            

@&#INTRODUCTION@&#

Virtual construction enables simulation and visualization of the progress of construction activities. The testing and verification of a construction plan using computers has emerged as an important research area in the field of construction [1]. Through virtual construction simulation, engineers are able to access a detailed preview of the construction process, identify potential problems, and find effective solutions before the actual project begins. Virtual construction provides a low-cost sandbox environment for developing and testing various construction plans. Many successful studies have been presented to demonstrate the advantages and potentials of utilizing virtual construction [2–4].

As modern construction projects have become more complex and difficult to execute, there is a growing demand for virtual construction technology that can identify constructability problems in the early planning stage, and prevent delays at the real construction site; this demand is for more realism and a higher level of detail of construction simulation [6]. Kamat [5] developed Vitascope for operational-level simulation. Chi et al. [7] developed a crane simulator that simulates crane operation using a game engine. CMLabs [8], GlobalSim [9], Simlog [10] corporations developed training simulators with real-time physical behaviors and realistic rendering of scenes. They even simulated the sway of rigging objects with accuracy. These projects have demonstrated the effectiveness of integrating graphical technologies and physics engines for realistic and accurate crane simulation. Recent studies have integrated game engines into virtual construction [11–13], enabling fast-development and prototyping of construction simulation and also providing a rich interaction between users and the virtual construction scene. Methods proposed in recent studies, such as those of Hung and Kang [14], Yang et al. [15], allow users to control construction machines on the virtual site in order to identify constructability problems. This research has shown the potentials of real-time construction simulations. By simulating in detail the activities in the construction process such as cooperative crane lifts, engineers are able to find potential and unexpected problems before commencement of the project. Simulators also allow construction machine operators to rehearse various critical and high-risk tasks before or during the tasks themselves; this is expected to reduce fatal events and accidents caused by empirical misjudgments or insufficient considerations.

An important and critical part of real-time construction simulation is the collision detection between dynamical (e.g. construction machines) and static objects in a virtual construction site. Collision detection must be performed at all times to ensure safe operation during construction activities. At a real construction site, collisions between construction machines, lifting objects (in crane erection activities), and any other nearby objects may occur. By collision checking at each time step of the real-time simulation for a detailed construction process, engineers are able to ensure the safety of the construction plan, reduce additional costs, and prevent critical damage. Collision detection is also the critical part to perform automatic motion planning for construction machines such as cranes, which can help finding collision free and feasible paths to accomplish risky erection tasks [16,17].

The methods for collision detection have been developed over many years. Many research utilized hierarchical collision boundary trees to improve collision detection efficiency [18–22]. These methods focused on representation of a deformable or irregular 3-D model. Some researchers utilized graphics hardware to improve collision detection [23]. Recent research such as [24,25] has focused on efficient collision detection in soft bodies and cloth. Chang et al. [26] developed an algorithm which can speed up collision detection between statics rigid objects using bounding volume hierarchy which consists of an oriented bounding box (OBB) tree enhanced with bounding spheres. Other research such as Garca-Fernndez et al. [27] used a neural network approach to modeling crane collision, which is suitable for real-time simulations of environments where most of the objects have similar shape. Li et al. [28] presented a method called the sort moving boxes (SMBs) for large number of dynamical 2D/3D objects in a dynamic environment.

However, there is often over thousands of structural elements in a construction scene, which is the nature of construction site. The computational cost incurred in this process has been identified in several studies as a significant drawback [29–31]. The main problem is the polynomial increase in computational cost with the number of objects in a virtual construction site [32]. Besides, a construction machine, such as a tower crane, needs to be monitored and checked with all objects around simultaneously in order to ensure the safety and its clearance, especially when the working area is limited and narrow in a construction site. These all increase the difficulty and cost of the collision detection for real-time construction simulation. Although previous research [32] has developed methods for virtual construction to compute collisions more efficiently, these methods still struggle to deal with a large number of the objects, as well as objects with irregular shapes.

An ideal and effective method of reducing the number of collision checks is to group objects and replace them with larger bounding boxes, which is also a common trick used by game developers to manually define collision boundaries based on the original detailed 3-D models. In other words, two models are created: the detailed 3-D model, and the collision boundaries. The former is used for realistic rendering, and the latter for efficient collision checking. As construction simulations often involve a large number of structural elements, the generation of the collision boundaries becomes difficult and tedious. As the glowing development of building information model (BIM), these models may contain different level of details [33]; and the provided and conducted 3-D models of construction site are sometimes over-detailed for real-time construction site purposed such as crane erection simulation. Furthermore, the details of 3d retrieved model also change during the simulation period. Therefore, defining collision boundaries manually would require significant effort. An automated and efficient approach is needed to reduce the manual work involved.

The generation of the collision detection boundaries is a pre-processing procedure for real-time simulation and visualization. Fig. 1
                      shows the relationship between the generation of the collision boundaries and the real-time simulation pipeline. Appropriate boundaries are generated for real-time collision detection at each time step during simulation. To support real-time collision detection, we usually divide the model into groups of objects and generate collision detection boundaries around each of the groups. This reduces the number of detailed geometric features for the objects used in collision checking, significantly improving computational efficiency. However, the generation of ideal collision detection boundaries that accurately represent the physical structures of the objects as well as support real-time collision detection is not trivial. The challenges involved are summarized as follows:


                     Tradeoff between efficiency and accuracy: There is always a trade-off between efficiency and accuracy when computing collision boundaries. More detailed and complex collision boundaries depict the group of objects more accurately. However, the computational effort required for collision checks may also increase as a result. On the other hand, using a simplified collision detection boundary may speed up collision checking, but reduces accuracy. Therefore, it is important to have a systematic method for balancing computational efficiency and model accuracy.


                     Heuristic and tedious generation process: In practice, game developers usually generate collision boundaries using modeling software. They group objects based on simplified 3-D geometric primitives, such as spheres, rectangular boxes, and cones. This can reduce the computational cost of collision checks later. This simplified model is sometimes called a physics model. Game developers usually group objects based on their experience. To construct a suitable collision detection boundary, developers must tune the model by repeated modification and testing. Moreover, the scene and the objects at a construction site are very complex, and the number of elements may be over one thousand. As a result, the procedure is very time consuming, frustrating, and tedious.


                     Frequent boundary re-generation: Unlike computer games, a general and well-designed virtual construction simulation must support the varying requirements of different project phases. Thus, collision boundaries must be re-generated several times. For this, a fast re-generation algorithm is needed. Some simulations require a 4-D model (a 3-D model with a schedule [34]), where the model changes over time. Thus, developers need to overcome this challenge of frequent boundary re-generation.

To summarize, collision detection remains a significant challenge, especially for construction simulation. It is important to develop a computational method to generate boundaries automatically. Such a method would need to consider the nature of the construction simulation, balance computational efficiency and accuracy, and provide fast re-generation of boundaries to meet the requirements of construction management.

The goal of this paper is to develop an automatic method for generating boundaries that can replace the numerous construction objects. The boundaries must represent objects using simple geometric primitives, which would reduce the overall computational cost of collision checking. We develop an automatic clustering method as well as an index for verifying the clustering results. The method should meet the requirements of several types of projects, including projects with scattered objects or with a large number of clustered objects. The boundaries generated should strike a balance between efficiency and level of detail. The proposed method should be sufficiently simple to support existing physics engines and visualization frameworks. For developers, this automatic method should reduce the tedious work of generating boundaries manually.

@&#PROPOSED METHOD@&#

To appropriately classify objects and elements of a construction site into groups, which can appropriately reduce the cost of collision detection and also remain accuracy, we must consider the relationships between each object (i.e. position and dimension of object in this research). We developed a clustering method that can group objects for collision detection boundary generation, called Propagation Clustering Method (PCM). Clustering is a common and widely used method to classify a dataset into several clusters or groups by defined properties [35]. The proposed method involves two main steps: clustering and evaluation. This section describes the details of PCM, including the clustering and evaluation steps. A hierarchical boundary tree for collision detection is also introduced, in which the boundaries generated by PCM are stored.

First, the users import the 3-D model of a construction site, which includes information of vertices representing the geometry of each object in the model. An object is a structural element in the construction site, which can include a beam, a column, a floor, or a vessel. The AABB algorithm then converts each object into an object dataset for grouping. PCM is an iterative process, where each iteration executes both model clustering and quality evaluation. The model clustering procedure groups the objects based on their dimensions and position using the k-means clustering method [35]. The quality evaluation procedure then tests whether the clustering result meets the quality index criteria defined in this study, known as the Group Box Volume Ratio (GBVR). The model clustering procedures divide the input model into several object groups. These object groups are evaluated in the quality evaluation step. If the quality of the grouping result meets the requirements, the collision detection boundary is generated. If the quality requirement is not satisfied, the model will again undergo the first step. The model clustering procedure will re-cluster groups that do not satisfy the quality requirement. The clustering result of each iteration can also be used to construct a hierarchical boundary tree [36], which will be introduced later. Fig. 2
                         shows the workflow of the proposed PCM.

PCM continues subdividing groups using the model clustering method until the GBVR for each group is below a specified threshold, at which point the clustering process is complete. The specified threshold is called the Propagating Ratio in this paper. Model clustering utilizes the k-means clustering method to cluster the models. The k-means clustering method is a fast and simple method that roughly classifies input data based on distance. This method cannot guarantee the quality of each clustered group even as the number of clusters (the Propagating Clustering Number) is increased. Instead of increasing the number of clusters to achieve higher quality at the expense of generating unnecessary groups, PCM ensures that all clustered groups achieve the same quality level for a large number of elements and objects at a construction site. When the GBVR for all groups satisfies the propagating ratio, PCM clustering is complete. When clustering is complete, the number of groups stops increasing, and the clustering is convergent. The pseudo code of PCM is given in Table 1
                        .

To cluster the objects in a construction site, all objects must be represented in the same format. The position and the dimension of the object are the two major factors that can directly influence the quality of the generated group. Fig. 3
                         shows an example of clustered result consider different position and dimension of two objects. Fig. 3(a) and (b) shows the comparison of the group that two objects with different distance to each other. The generated group is larger that when the two objects are farer, which also has less quality that contains more free space in its boundaries. That means objects are closer to each other should be grouped together; In dimension property, Fig. 3(c) and (d) demonstrates the group that two objects have the same distance but different dimension. When the variation between objects dimension increase, it may increase the free space in its boundaries, which should be also considered in clustering process. Therefore in this research, we use these two characteristics as the properties for clustering. We convert each object into an axis-aligned bounding box (AABB) as shown in Fig. 4
                         
                        [19]. An axis-aligned bounding box is defined by six properties: x, y, and z for the position; and w, h, and l for the dimension of the box. We convert the construction scene into a list of bounding boxes, which then serve as the input data for the clustering procedure to determine which objects should be grouped together.

We represent a box using a data point g with six dimensions (
                           
                              x
                              ,
                              
                              y
                              ,
                              
                              z
                              ,
                              
                              w
                              ,
                              
                              h
                           
                        , and l). All boxes can be converted into points in a six-dimensional space; these points then become the input dataset G for clustering. We modified the most commonly used clustering method (the k-means clustering method) for our box classification. Given a set of n data points in a real d dimensional space, 
                           
                              
                                 
                                    R
                                 
                                 
                                    d
                                 
                              
                           
                        , and an integer k, the aim is to determine a set of k points (called centers) in 
                           
                              
                                 
                                    R
                                 
                                 
                                    d
                                 
                              
                           
                        , to minimize the mean squared distance from each data point to its nearest center. Table 2
                         shows the pseudo code of the k-means clustering method. Once the objects are classified and grouped, we can build an efficient collision detection boundary for collision checking.

Originally, the k-means method uses Euclidean distance [37] between two data points in deciding to which group that data point belongs. Each element in a data point has the same level of contribution to the distance. However, consider the example in Fig. 5
                        (a), where the aim is to cluster a scene with 1243 objects into three groups. Since the distance between dimensions has the same contribution as the distance between locations, the k-means method may give an unexpected and inaccurate collision detection boundary, as shown in Fig. 5(b). To achieve a more appropriate clustering result, we modified the distance function in the k-means method by adding weights to each element of the data point before clustering. The new distance calculation is shown in the equation below, where 
                           
                              
                                 
                                    w
                                 
                                 
                                    x
                                 
                              
                           
                         represents the weight coefficient of x, w
                        
                           y
                         represents the weight coefficient of y, and so on.
                           
                              (1)
                              
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             x
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             x
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       x
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             y
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             y
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       y
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             z
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             z
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       z
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             w
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             w
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       w
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             h
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             h
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       h
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             l
                                          
                                       
                                       -
                                       
                                          
                                             g
                                          
                                          
                                             2
                                             l
                                          
                                       
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ·
                                 
                                    
                                       w
                                    
                                    
                                       l
                                    
                                 
                              
                           
                        
                     

Increasing the weights of x and z will increase the degree of influence of the location in those planes in the overall distance calculation. After this modification, the clustering process gives a more useful result, as shown in Fig. 5(c), where the value of both 
                           
                              
                                 
                                    w
                                 
                                 
                                    x
                                 
                              
                           
                         and 
                           
                              
                                 
                                    w
                                 
                                 
                                    y
                                 
                              
                           
                         is 3. If we set all the weights of the dimensions to zero, the k-means method will cluster only according to the locations of the objects. The weight coefficients proposed in the current paper allows users to adjust and tune the clustering result, as the proposed method can cluster and group the objects. However, the quality of the clustering result is related to the geometry and the distribution of the elements in a construction site and building. These factors may need to be considered for each individual group in the clustering process, where each group has different features and requires a different set of the weight coefficients. The coefficient values also vary for different simulation purposes, which requires heuristic approaches to determine the parameters for different construction site and purposes.

The task of classifying these defined boxes into several groups according to their position and size can be regarded as a clustering problem. We represent a box by a data point with six dimensions (three for the position of the center of the box, and three for the size of the box). All boxes can then be transferred into a set of points in a six-dimensional space, to be used as input data for the clustering procedure.

To estimate the total volume of groups clustered by the proposed method, we can use the volume of the AABB boundaries. The smaller the volume of a box, the less is the collision-free space within it. The collision-free space is the space inside the bounding box that is not occupied by the objects. In Fig. 6
                        , the gray colored space represents the collision-free space in the group. More collision-free space corresponds to a lower cluster quality. However, it is difficult to accurately calculate the volume of collision-free space due to the complex shapes of objects in a construction site, and their tendency to overlap each other. Thus, an accurate volume calculation would have a high computation cost. In this study, we propose a simplified and fast measurement index, called the Box Volume Ratio (BVR), to determine the quality of the clustering. Eq. (2) shows the calculation for BVR, where 
                           
                              
                                 
                                    r
                                 
                                 
                                    bvr
                                 
                              
                           
                         is the calculated BVR, b is the AABB volume of the objects in the scene, and g is the AABB volume of the clustered groups.
                           
                              (2)
                              
                                 
                                    
                                       r
                                    
                                    
                                       bvr
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             k
                                          
                                       
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This method ignores the volume of overlapping parts in each box, making the computational cost of the calculation of the order 
                           
                              O
                              (
                              n
                              )
                           
                        . A larger BVR means there is more collision-free space within the collision detection boundary, and a smaller BVR means the collision detection boundary is better fitted to the actual shapes of the objects.

However, as the construction site model is usually very large, this index can only approximate the space occupied by the bounding box of the clustered group; it does not reflect the quality of the each clustered group’s collision detection boundary. To ensure that all the clustered groups of different sizes have the same level of accuracy, we must examine the quality of each individual group.

For this, we define the Group Box Volume Ratio (GBVR), which represents the quality of each group. The calculation of GBVR is given by Eq. (3), where 
                           
                              
                                 
                                    r
                                 
                                 
                                    bvr
                                 
                                 
                                    i
                                 
                              
                           
                         is the i-th GBVR and 
                           
                              
                                 
                                    b
                                 
                                 
                                    i
                                 
                              
                           
                         is the set of values representing the AABB volumes of objects in the i-th group.
                           
                              (3)
                              
                                 
                                    
                                       r
                                    
                                    
                                       bvr
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     

After each GBVR calculation, we can use the average GBVR value as an index to evaluate the quality of the clustered result. A higher average GBVR value suggests better clustering, while a lower average GBVR suggests that PCM converted a model into a simpler collision detection boundary.

We can use the PCM result as the boundary for collision checking. Fig. 7
                         shows the collision detection boundary generated by PCM for several iterations, where the propagating clustering number is set to 2. In each iteration, PCM checks whether all the generated groups meet the specified quality; it further clusters the groups that do not reach the requirement into sub-groups. As shown in Fig. 7, PCM generates two groups in the first iteration; in the second iteration, each group is clustered into two sub-groups, such that a total of four groups are generated, each of which are smaller than the groups in the first iteration; these newly generated sub-groups are kept and used for the following iteration. The user can generate more accurate collision detection boundaries by increasing the number of iterations, or boundaries for more computationally efficient collision detection by using fewer iterations. However, many critical erection project simulations require high accuracy and efficiency to provide users with a precise real-time simulation.

To develop an accurate and efficient collision detection strategy, we use the PCM method to construct a hierarchical collision detection boundary tree [36]. Fig. 8
                         shows an example of collision detection process between a sphere and a construction site. The figure shows 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           
                         being propagated by 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                        , where i is the number of generations. In a collision checking cycle, first the system checks whether the objects intersect with 
                           
                              
                                 
                                    S
                                 
                                 
                                    0
                                 
                              
                           
                        ; if so, the system will proceed to check its children, 
                           
                              
                                 
                                    S
                                 
                                 
                                    1
                                    ,
                                    0
                                 
                              
                              ,
                              
                              
                                 
                                    S
                                 
                                 
                                    1
                                    ,
                                    1
                                 
                              
                           
                        , and so on; otherwise the cycle is complete and the system will begin a new collision checking cycle at the next time interval. This collision checking policy significantly reduces the computational effort needed, yet still provides accurate collision boundary checking.

@&#IMPLEMENTATION@&#

To implement and test the proposed method, we used the Erection Director (ED) system, which is based on the work of [38]. ED was developed to simulate single and cooperative crane erections in a virtual construction site. The system can perform a smooth, realistic, physics-based construction simulation that allows users to control cranes and interact with the environment in real-time. It is developed on two major components, XNA and PhysX.

XNA is a framework based on DirectX generally used to develop PC and Xbox360 games [39]. It is used here as a rendering engine that supports various 3-D models, 2-D textures, and audio formats. All scenes in XNA are rendered using a graphics processing unit (GPU) shader. Using XNA, ED is able to efficiently process a complicated 3-D scene of a virtual construction site and render a realistic virtual world in real-time.

PhysX is a physics engine integrated into ED, used to simulate the dynamic motion of cranes as well as handle collision detection and response [40]. Users can define construction machines using joints and rigid bodies. Bounding shapes can also be assigned for performing collision detection. PhysX supports various bounding shapes including spheres, boxes, capsules, convexes, and shapes built by a triangle mesh. Additionally, PhysX provides hardware acceleration using the GPU of Nvidia graphics cards, and is able to provide real-time simulation due to its efficient solver and the high stability derived from the position-based dynamics method.

We implemented the proposed method as a plug-in module under ED called the PCM module. Fig. 9
                      shows the architecture of ED and the PCM module. Before a simulation begins, the developer must define the simulation environment, including the construction scene, construction machines, and the construction scenario. The system then generates the visual model for rendering, and the physics model for computing physical behaviors. The physics model contains the rigid body, joint definitions, and bounding shape. Without the PCM module, the bounding shapes of the physics model would have to be defined manually, which is tedious and un-systematic. The PCM module processes the visual model to construct the bounding shapes of physics models for collision detection. Fig. 10
                      shows the components of the PCM module.

In the PCM module, the two inputs provided by the user are the model and the clustering parameters. The first step of the generation process is to convert all the elements of the model into a bounding box dataset. Next, we use PCM to cluster the dataset into several model groups and a hierarchical boundary tree. The final step is to use the groups to generate the boundaries for collision checking. If the static collision detection boundary generator is used, the generated boundary is a static boundary, which collisions we check by direct inspection of the boundary. The dynamic collision detection boundary generator is used to generate the collision boundaries for the hierarchical boundary tree. Unlike the static boundary case, the collision detection process traverses the hierarchical boundary tree to retrieve the appropriate boundaries for collision detection. The user can choose to use either static or dynamic boundaries in the simulation.

In the PCM module, the two inputs provided by the user are the model and the clustering parameters. The first step of the generation process is to convert all the elements of the model into a bounding box dataset. Next, we use PCM to cluster the dataset into several model groups and a hierarchical boundary tree. The last step is to use the groups to generate the boundary for collision checking. If the static collision detection boundary generator is used to generate the collision boundary for model groups, the generated boundary is called a static boundary, which means we check for collisions by directly checking this boundary. The dynamic collision detection boundary generator is used to generate the collision boundary for the hierarchical boundary tree. Unlike the static boundary case, the collision detection process traverses the hierarchical boundary tree to retrieve the appropriate boundaries for collision detection. The user can choose to use either static or dynamic boundaries in the simulation.

In this paper, the PCM module uses AABB as the collision detection boundary for each clustered group to make the proposed method feasible. During the simulation, users can dynamically change and re-generate the collision detection boundaries according to specific requirements, such as for 4-D model applications.

To verify that the proposed method can automatically cluster a construction site model containing thousands of objects into groups and generate its corresponding collision boundaries, we tested the method with different types of construction site models. In the experiments, we tested PCM with different parameter values (that is, different propagating ratios and propagating clustering numbers) and compared these results with clustering results from the k-means method. Through these experiments, the efficiency and the effectiveness of PCM, and the computational efficiency of collision detection with the generated boundaries, can be evaluated and validated.

To test the proposed method, we used a site model of a real construction site, the Dalin oil refinery in Taiwan. We selected three different parts of the site model to compare the clustering results for the different types of site structures shown in Fig. 11
                        . Scenario 1 is a scattered and large-scale structure where dimensions of the objects are quite different. There are 3706 objects in this model. Scenario 2 is a common construction site structure: a steel structure mostly composed of columns, beams, and floors. It contains 4446 objects. Scenario 3 is a composite type construction site that contains a steel structure along with scattered cylindrical objects. There are 6871 objects in this model. All experiments were run on a mid-range laptop computer equipped with an Intel Core 2 Duo 2.13GHz processor, 3GB of RAM, and a GeForce 7950 display card.

To evaluate the proposed method, we tested the three scenarios using PCM, represented by 
                           
                              p
                              (
                              
                                 
                                    k
                                 
                                 
                                    prop
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    pr
                                 
                              
                              )
                           
                        , with different combinations of propagating cluster number 
                           
                              
                                 
                                    k
                                 
                                 
                                    prop
                                 
                              
                           
                         (ranging from 2 to 30) and propagating ratio 
                           
                              
                                 
                                    r
                                 
                                 
                                    pr
                                 
                              
                           
                         (ranging from 2 to 10). The results are shown in Figs. 12 and 13
                        
                        . The horizontal axis represents the propagating clustering number and the vertical axis represents the propagating ratio. The shading in the charts respectively represent the number of convergent groups in the clustering result and the corresponding convergent GBVR values. These two values are shown in grayscale, where white represents 3000 convergent groups in Fig. 12 and a convergent GBVR value of 5 in Fig. 13, and black represents zero convergent groups and zero convergent GBVR value. For example, the value of the point (10,5) in scenario 1 represents 222 convergent groups and 1.46 GBVR in Figs. 12 and 13, respectively. The process of PCM is convergent when no groups can be divided into sub-groups. The convergent group number and the convergent GBVR value are the number of groups and the average GBVR value for a convergent clustering process.

In scenario 1, we can see that the number of convergent groups is mostly less than 1000; for example, 
                           
                              p
                              (
                              2
                              ,
                              5
                              )
                           
                         gives 70 convergent groups and 2.59 as the convergent GBVR clustering value. Fig. 12 shows that the number of convergent groups increases when the propagating clustering number becomes larger. On the other hand, a larger propagating ratio will reduce the number of convergent groups. The number of convergent groups increases significantly when the propagating ratio is smaller than 4. However, the GBVR value decreases when the propagating clustering number is large and the propagating ratio is small. In scenario 2, the number of convergent groups is much larger than in scenarios 1 and 3. The value is always higher than 780. Compared to scenario 1, the distribution of the number of convergent groups for scenario 2 is flatter; the number of convergent groups does not increase sharply when the propagating ratio decreases. Similarly, the distribution of the convergent GBVR value is also flatter in scenario 2 than in scenario 1. For scenario 3, the distribution of the convergent GBVR value is similar to the results for scenarios 1 and 2. However, as scenario 3 is a composite scene composed of both scattered and uniform structures, the distribution of the number of convergent groups is a combination of the results of scenarios 1 and 2. The number of convergent groups increases sharply when the propagating ratio is below a certain threshold that is related to the propagating clustering number. Most of the convergent group sizes are more than 780. Similarly, the distribution of convergent GBVR values is similar to scenarios 1 and 2, however the flatness is between that seen in scenarios 1 and 2.

The clustering results validate the effectiveness of the proposed method, which is evidently successful at clustering a model with thousands of objects automatically. Figs. 12 and 13 show that PCM with a higher 
                           
                              
                                 
                                    k
                                 
                                 
                                    prop
                                 
                              
                           
                         and a lower 
                           
                              
                                 
                                    r
                                 
                                 
                                    pr
                                 
                              
                           
                         will generate a better result in terms of quality (lower convergent GBVR value), as well as more convergent groups. This is because a higher 
                           
                              
                                 
                                    k
                                 
                                 
                                    prop
                                 
                              
                           
                         leads PCM to generate more groups in each iteration of clustering. Even if only a few groups can fulfill the specified quality requirement, PCM will still cluster a model into the specified number of groups. However, PCM must generate more groups to reduce the collision-free space within a group to satisfy a lower propagating ratio. This decreases the efficiency of collision detection when the number of convergent groups is large, as the efficiency of the collision detection is mostly related to the number of collision boundaries. Thus, the tradeoff between quality and efficiency can be balanced using the PCM method. The test results in Figs. 12 and 13 show that the number of convergent groups increases sharply when the propagating ratio is lower than 4 and the propagating clustering number is larger than 3. However, the magnitude of the reduction in the convergent GBVR value becomes smaller, which implies that one must generate significantly more groups to reduce the convergent GBVR by an identical amount. Based on this experiment, the suggested values of PCM parameters, 
                           
                              
                                 
                                    k
                                 
                                 
                                    prop
                                 
                              
                           
                         and 
                           
                              
                                 
                                    r
                                 
                                 
                                    pr
                                 
                              
                           
                        , are 2 and 5, respectively; these values can provide appropriate clustering for the three kinds of models tested.

Another feature of the proposed PCM is that it provides a better clustering result in a scattered and large-scale site than in a uniform site. This is due to the fact that PCM generates more collision-free space when grouping long and perpendicular elements (which are characteristic of uniform structures such as steel structures with uniform beams and columns). Fig. 14
                         shows a sample model that will require a large number of groups to satisfy the clustering quality requirement. In this example, we have four beams to be clustered. If the four beams are grouped together as one group, the average GBVR value is 5.83. If we cluster the structure into two groups, the average GBVR value will not decrease as each group contains two perpendicular beams. Therefore, in order to reduce the average GBVR values, PCM must continuously cluster the model into more groups. In this example, four groups are needed to reduce the average GBVR value to 1. For the same reason, the number of convergent groups is much larger in scenario 2 than in other cases. The distribution of the number of convergent groups is flatter in scenario 2 because it needs the same number of convergent groups to satisfy a different propagating ratio. In the above examples, the convergent GBVR values are all set to 1 if the propagating ratio is specified as being smaller than 5.83.

In order to verify that PCM can appropriately cluster a site model into groups, as well as maintain consistent group quality, we also tested the three above cases using the k-means method and compared the results with PCM. There are usually thousands of objects in a construction site model. It is difficult to systematically and manually cluster objects into hundreds of groups that still remain accurate. The concept of using k-means clustering method directly to group objects is similar with grouping manually by a human however it is more efficient and can deal with thousands of objects within seconds. For the k-means method, we used different numbers of cluster groups from 2 to 1300. The results are shown in Fig. 15
                        (a–c), which compare the k-means method with PCM for scenarios 1, 2, and 3, respectively. The horizontal axis in the figures represents the number of convergent groups and the vertical axis represents the convergent GBVR.

In scenario 1, we can see that all the convergent GBVR values of PCM are less than 6. However, the k-means method needs at least 1200 groups to reach the convergent GBVR value of 6. In scenario 2, although the sizes of the PCM convergent groups are all larger than 700, the convergent GBVR values are all less than 4. The k-means method on the other hand, cannot perform clustering with convergent GBVR values smaller than 10, even with 1300 cluster groups. The uniform structure of scenario 2 also affects the k-means clustering result, as described in the previous section; each convergent GBVR value increases significantly. The convergent GBVR values of the k-means clustering result for scenario 3 are higher than those for scenarios 1 and 2 because the number of objects in scenario 3 is higher than in scenarios 1 and 2 by about 1000 and 2000 respectively. However, the number of objects does not affect the convergent GBVR value of PCM significantly; the convergent GBVR values of PCM are still much smaller than those from the k-means method. Another limitation of the k-means method is its inability to distinguish more than 1100 groups, even though the number of groups can exceed this number.

These results show that PCM is able to successfully cluster the site models containing thousands of objects with convergent GBVR values in the range 1.5–4. In contrast, clustering using the k-means method is less effective as PCM has the ability to retain the quality of each group’s collision detection boundary. It iteratively subdivides groups that do not satisfy the specified quality threshold until all groups satisfy the requirement.

We aim to validate the computational efficiency of the proposed method as well as its fast re-generation of collision boundaries, which together would affirm its suitability for various construction applications. For the tests of the proposed method with different combinations of propagating ratio and propagating clustering number outlined in Section 6.2, we recorded the computation time of each clustering procedure. Table 3
                         shows these results.

The results indicate that the computation time for PCM increases with the number of objects in the site model. The average times taken for computing the three scenarios are 2.89, 8.28, and 11.76s, respectively. The time increases because more computation time is required to calculate the bounding box volumes and the centroids of each cluster in k-means clustering, which is essentially an 
                           
                              O
                              (
                              n
                              )
                           
                         order calculation. However, the results also show that the computation time does not increase linearly because the site structure type also affects the computation time. For a uniform structure such as in scenario 2, more convergent groups are needed to satisfy the propagating ratio threshold than in the other cases. The average number of iterations for clustering convergence is approximately 7.83, 10.35, and 9.13 in the 3 scenarios, respectively.

The standard deviation of the computation time also increases when the number of objects increases. This is due to the influence of the number of objects on the quality of the k-means clustering result. Instead of finding an optimized solution, the k-means clustering is used to cluster objects in a very short time. The quality of the result can be very unpredictable especially when the number of objects is greater. This explains the increase in the standard deviations of the average computation times when the number of objects increases.

The PCM utilizes the k-means clustering method to cluster the objects, which is an 
                           
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    dk
                                    +
                                    1
                                 
                              
                              log
                              n
                              )
                           
                         heuristic algorithm [41]. The clustering result depends on the randomly determined initial centroids. It does not guarantee that all groups’ GBVRs can reach the required threshold. However, the computation test results show that the proposed method is efficient and fast; the clustering computations can be performed in less than 30s for a site model containing thousands of objects. The proposed method allows developers to set up a virtual construction scene for simulation in less time than with previous methods. They can tune and re-cluster the virtual setting according to their requirements, as well as adjust the level of detail of the collision boundaries in under 30s. Thus, the proposed method can significantly reduce the development cost of a real-time construction simulation.

In order to test the efficiency of the generated collision boundaries, we performed collision detection using the boundaries generated for each clustering experiment in Section 6.2. Collision detection is performed by checking whether a movable spherical boundary collides with objects in the construction site model. We used the AABB as the bounding shape of each clustered group. We first determined the computation time for collision detection with the boundaries generated by the original model (the AABB bounding shape was also used for each object in the model), and then compared this result with the computation time using the clustered groups. Each collision detection result is the calculated average value from 1000 test trials. The results are shown in Fig. 16
                        .

The collision detection computation times in scenarios 1, 2, and 3 using the original model were 1.04, 6.11, and 9.57ms respectively; evidently, these times depend directly on the number of objects. Fig. 16 shows the computation time of collision detection using PCM. The grayscale shading represents the computation time range from 0 to 3ms. The results show that PCM clustering reduces the computation time of collision detection to between 1/100th and 1/10th of that using the original model, while the convergent GBVR value between 1 and 4 (shown in Fig. 13) is still satisfied. The computation time is longer when the propagating clustering number is larger, and the computation time is shorter when the propagating ratio is greater. As the computation time largely depends on the number of boundaries, the computation time of collision detection for scenario 2 is greater than that for scenarios 1 and 3.

The results show that the collision boundaries generated by PCM are able to support a real-time simulation, as the computation time of collision detection is reduced significantly. However, the tradeoff between computational efficiency and quality is again clearly demonstrated in these results. If users require more accurate and detailed collision detection, a smaller propagating ratio and a larger propagating clustering number should be used at the expense of collision detection efficiency.

This experiment utilized the AABB bounding shape when clustering groups; this is a widely used and efficient method for collision detection. Some irregular concave shapes may influence the accuracy of the collision detection due to the additional wasted space in their collision boundaries. However, more accurate bounding shapes such as oriented bounding boxes (OBBs) will require additional time and cost in pre-processing, which may decrease the efficiency in setting up a fast simulation on site or during the construction task. Furthermore, OOB boundary increases little accuracy to symmetrical elements such as beam, column and cylinder vessel, which are common in a construction site. It also increases the dimension of data for clustering that contains three additional degrees in orientation. Therefore, for a more ideal collision boundary with both accuracy and efficiency, this paper has proposed a hierarchical collision detection boundary tree, which has the potential to meet accuracy and efficiency requirements.

In order to verify that the hierarchical collision detection boundary tree generated by PCM optimizes both accuracy and computational efficiency, we tested the tree generated for the three scenarios. The parameters 
                           
                              p
                              (
                              2
                              ,
                              5
                              )
                           
                         were used to generate each tree; for these parameters, the convergent GBVR value is adequate and the number of convergent groups is less than 1000. We used the AABB collision detection boundaries as the collision bounding shapes of each node in the tree, and a spherical collision detection boundary was moved through the entire scene to perform collision detection. The test results of the maximum computation time spent in collision detection for each scenario are shown in Table 4
                        .

The maximum computation time is usually when the collision checker collides with an object at the bottom of a branch that contains the most number of nodes, because the system must traverse the entire branch and perform collision detection at every node. We tested for different numbers of iterations as this influences the depth and branch number of the tree. In each case, the maximum computation time required is about 1/10th of the computation time using the original model, and depends on the number of objects in a model.

The results show that the maximum computation time decreases when the number of interactions increases. This implies that using a tree structure with greater depth can reduce the time spent unnecessarily checking objects that will not collide with the collision checker. The results confirm that the proposed method can generate a hierarchical collision detection boundary tree that optimizes both efficiency and accuracy. The tree enables real-time collision detection with accuracy comparable to the original model. Fig. 17
                         is a screenshot of the usage of the tree generated by PCM. The black boxes represent the nodes visited by the checker, and the red object is that with which the checker collides. We control the checker by translation along the x-axis towards the site. The screenshot was rendered at approximately 30 frames per second, which can be used in a real-time construction simulation.

The major contribution of this research is the development of a computationally efficient method for automatic collision detection boundary generation in virtual construction. The main contributions are summarized as follows:
                        
                           1.
                           PCM automates the clustering process: PCM can automatically cluster the objects in a model and group these objects based on their dimensions and position. Engineers save on the effort required to manually define and tune collision detection boundaries.

PCM allows for the re-generation of collision boundaries: PCM is fast and efficient, and can dynamically re-generate the collision detection boundary when the scene changes or is modified. This makes it easier to construct the collision detection boundaries for 4-D model applications.

PCM can generate collision boundaries with variable accuracy: PCM can generate collision boundaries with different levels of accuracy depending on the level of detail required in the simulation. Developers can easily adjust the balance between computational efficiency and the accuracy of the collision detection boundaries according to the requirements of the simulation.

PCM can be integrated with various collision checking methods: this study proposed a grouping method for generating the collision detection boundary; we used the AABB detection boundary to surround the clustered group. One may replace or combine this with other collision boundaries or strategies to improve collision accuracy and efficiency.

@&#CONCLUSION@&#

This paper presented a method, called the Propagation Clustering Method (PCM), for automatically generating the collision detection boundaries of a construction site model in real-time construction simulations. The proposed PCM uses a modified version of the k-means clustering method to cluster the objects in a construction site model into groups iteratively. Each object in a construction site model is represented by an AABB bounding shape as a six-dimensional data point. The method can thus classify the objects by their dimensions and positions. The weighted coefficients then allow users to adjust and tune the clustering result for different kinds of simulations. This research also defined an evaluation index for the clustered results by considering the volume of the generated collision detection boundaries and the objects’ AABBs. Developers can utilize the proposed method to generate appropriate collision detection boundaries quickly, and with different efficiencies and accuracies for different simulation purposes.

The generated results of this method are a set of simplified 3d models, which can be easily integrated with existing collision detection methods for a more accurate and lower computational cost. It can benefit and be applied to existing collision detection methods as a pre-processing procedure for a better performance. The proposed method can also generate a hierarchical collision detection boundary tree. By performing collision detection in the tree to different depths and levels of the detail, the hierarchical boundary tree can retain both efficiency and accuracy in collision detection.

To evaluate the feasibility of the proposed method, we conducted several experiments with three common types of the construction scenarios. The results showed that the proposed method groups objects automatically according to requirements. It can reduce the computational time of collision detection to 0.1–0.01 times of the computational time of using original model while also remain certain level of details and accuracy at the same time. This method performs object-based collision detection, and is hence suitable for construction applications. Future work will focus on development of heuristic approach to determine the appropriate values of weighted coefficients to increase the clustering result for different kinds of construction sites.

@&#REFERENCES@&#

