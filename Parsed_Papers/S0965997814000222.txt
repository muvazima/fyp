@&#MAIN-TITLE@&#Domain modeling as a basis for building a meshing tool software product line

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a systematic and iterative process for building a meshing tool software product line.


                        
                        
                           
                           The process builds a domain model that captures essential domain characteristics.


                        
                        
                           
                           The domain model is specified using a formal language.


                        
                        
                           
                           We validate the process by generating a SPL for tree stem deformation meshing tools.


                        
                        
                           
                           We present 3 meshing tools produced by a code generator built using this process.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Software product line

Meshing tools

Tree stem deformation

Domain analysis

Domain model

Code generator

@&#ABSTRACT@&#


               
               
                  Meshing tools are highly complex software for generating and managing geometrical discretizations. Due to their complexity, they have generally been developed by end users – physicists, forest engineers, mechanical engineers – with ad hoc methodologies and not by applying well established software engineering practices. Different meshing tools have been developed over the years, making them a good application domain for Software Product Lines (SPLs). This paper proposes building a domain model that captures the different domain characteristics such as features, goals, scenarios and a lexicon, and the relationships among them. The model is partly specified using a formal language. The domain model captures product commonalities and variabilities as well as the particular characteristics of different SPL products. The paper presents a rigorous process for building the domain model, where specific roles, activities and artifacts are identified. This process also clearly establishes consistency and completeness conditions. The usefulness of the model and the process are validated by using them to generate a software product line of Tree Stem Deformation (TSD) meshing tools. We also present Meshing Tool Generator, a software that follows the SPL approach for generating meshing tools belonging to the TSD SPL. We show how an end user can easily generate three different TSD meshing tools using Meshing Tool Generator.
               
            

@&#INTRODUCTION@&#

According to Northrop and Clements [1], a Software Product Line (SPL) is a set of software intensive systems that share a managed set of characteristics, and that satisfies the needs of a particular market segment or mission, being developed using a set of common core assets in a preestablished fashion. These core assets include the product line architecture, reusable software components, and domain models, among others. The ultimate purpose of a SPL is to provide a reuse infrastructure that allows achieving a high return on investment (ROI).

In a SPL we can identify two main technical stages: the domain engineering stage where reusable core assets are developed and maintained, and the application engineering stage where particular products are built by combining the already developed assets. Understanding and identifying common and variable aspects play a central role during the domain engineering stage. Commonalities are requirements that must hold for all SPL products, whereas variabilities are requirements that may or may not be present in a particular product, and as such define how SPL products may vary [2].

In the context of SPL, domain analysis is the first step within the domain engineering stage. It includes scoping and domain modeling. Scoping consists of defining which products are part of the SPL and which are not. Domain modeling is the process through which commonalities and variabilities are identified, captured and organized in a domain model with the purpose of characterizing the domain [3]. Domain modeling has been identified as one of the most important factors for the success of software reuse [4], and helps record and organize existing domain knowledge.

Meshing tools are sophisticated software due to the complexity of the concepts involved and the large number of interacting elements they manage. Given that meshing tools are used in a variety of different application domains, they may require slightly different functionalities, algorithms for implementing those functionalities, data representation, or format of the data used as input or output [5]. Also depending on the application domain, it may be required to have two, two and half, or three dimensional meshes, each one using different types of basic modeling elements. For example, Fig. 1
                      shows a surface triangulation (two and half dimensional mesh) that models the reticle shape of monkey kidney cells [6].

These tools have usually been developed with ad hoc methodologies [7,8], focusing on attributes such as performance and precision, and not necessarily focusing on maintainability or reuse, mainly because they have usually been developed by their final users and not by software engineers. By not having reuse in mind, every new tool needs to be developed almost from scratch even though it may involve algorithms already implemented and data structures already designed, many of them also used and tested. There have been some reuse efforts within the meshing tool community [9–12], but it is not yet a common practice. Consequently, a reuse framework is needed if the potential gains in productivity and quality SPL promises are to be achieved.

According to Smith and Chen [10], Bastarrica and Hitschfeld-Kahler [13], most mesh generators can be abstracted as: input information, calculate a domain discretization (mesh), refine and/or improve it, and finally output the results. These shared steps have been identified as commonalities among all members of a meshing tool SPL [14–16]. On the other hand, variabilities may be seen in two different ways: as including or excluding certain steps in a mesh processing, or as providing alternative implementations or algorithms for realizing the same chosen functionality. These options depend on the particular processing required and its characteristics (performance, memory use, amount and distribution of the mesh points, and scalability factors for managing complex domains, among others). According to Bosch [17], this is a clear revolutionary approach to SPL in the presence of already developed products, and therefore it is a promising opportunity.

The domain model is the basis for subsequent steps in the SPL development. It can be seen as a source of domain knowledge for newcomers to the meshing area or for people who are planning to develop a new meshing tool. Some authors have already approached building meshing tools with SPL concepts in mind [10,13,18,19], but to the best of our knowledge, none of them have focused on the domain model with a systematic process specially designed for this particular domain. Even though there are other methods for producing a domain model, we decided to customize our own model and process because none of them directly applies to the meshing tool domain. Some of them are general and need tailoring [2,20,21], others are domain specific and need adapting [22], and yet others are product oriented and need to rely on having many products already developed [23].

In this paper, we propose and formalize a domain model definition specially suited for meshing tools, as well as a rigorous process for building this model with the purpose of serving as a basis for rapidly building particular meshing tools within the SPL. The domain model integrates a lexicon, features, goals and scenarios as a means for capturing the domain characteristics, and also a series of relationships among these elements. We formalize the domain model definition using the Z specification language. We provide a process that identifies the domain expert and the domain analyst as the main stakeholders, defines the way the model elements are gathered and combined into a unified domain model, specifies the activities that each stakeholder must perform, and presents clear iteration and/or termination conditions based on model consistency and completeness. The application engineering phase of the SPL is addressed in the validation. To this end, we apply our approach by developing an actual domain model for a SPL for a particular meshing tool domain: the simulation of tree stem deformation, and generate particular meshing tools of this SPL. To this end, we have developed Meshing Tool Generator, a software tool based on the SPL approach for instantiating particular products.

The rest of the paper is organized as follows. In Section 2 we define the proposed process for building the domain model, identifying the main stakeholders involved and we formally define the domain model. Section 3 illustrates the use of the domain model for the Tree Stem Deformation (TSD) meshing tool SPL and how it is applied to building actual tools with the Meshing Tool Generator. Related work about both domain modeling methodologies in general and for developing meshing tools in particular are discussed in Section 4. Finally, Section 5 presents our conclusions and ongoing work.

We first present the process for building a domain model in Section 2.1 and then we formalize its elements and their relationships in Section 2.2.

Processes are defined by identifying roles, artifacts and activities. We identify the participant roles in the domain model construction process as the relevant stakeholders. The artifacts are those work products that need to be generated in order to complete the domain model. Finally, the activities are those that are carried out by the stakeholders in order to build the artifacts. In this section we describe each of these elements, and we include an activity diagram to depict the complete process.

Modeling complex domains is hard, so the people involved should have a clear idea about the role they should play. In any SPL, stakeholders can be classified into three groups [22]: business, domain, and product stakeholders, that can be characterized as follows for the meshing tool domain.
                              
                                 1.
                                 Business stakeholders: Customer, end user.

Domain stakeholders
                                       
                                          •
                                          Semiconductor modeling: Physicist, electrical engineer, computer scientist.

Tree stem deformation modeling: Forest engineer, mathematician, biologist, computer scientist.

Car design modeling: Physicist, mechanical engineer, computer scientist, mathematician.

Facial modeling: Computer scientist, film producer.

Atmospheric phenomena modeling: physicist, geophysicist, meteorologist, computer scientist.

Product stakeholders: Domain analyst, product manager, SPL architect, product architect, component designer, component developer, component integrator, product developer, product maintainer.

We define our domain model based on goals, scenarios and features, similar to Park et al. [24], but also considering scenarios composed by actions. We add a lexicon for describing the concepts within the domain so that the domain expert and the product stakeholders can have a common understanding of the concepts used. Fig. 2
                            summarizes the different parts of the domain model and their relationships.

The business goal states the purpose for developing products as part of a family. This goal is unique for the whole SPL, but there may be several particular goals. The set of goals identified as part of the domain model should fulfill the purpose of the business goal; however, checking if this relationship holds is out of the scope of this paper. We use natural language for stating goals since they are mainly provided by the domain expert in her/his own terms.

Scenarios are those actions performed by particular products while being executed. We use structured natural language to describe scenarios as a sequence of atomic actions similar to [21].

Features are those parameters, functionalities or data storage identified for the potential products in the SPL. Features may be either common to all products in the SPL (mandatory), optional or alternative. Features are generally inspired by components already developed and present in existing products as well as by concepts from the application domain. As is usual practice in SPL development, we document features using a feature model [25,26]. This model describes a tree-like structure and a series of constraints among the features.

The lexicon is, by definition, a natural language explanation of the concepts involved in the domain. We propose that at least all identified features should be described as part of the lexicon.

There have been several proposals for specifying a domain model, but very few processes for guiding the activities that need to be carried out in order to build this model. We propose a rigorous process for building the domain model and we specify it using a UML activity diagram, as shown in Fig. 3
                           .

The first activity to be carried out is Define Business Goal which is done by the domain expert. This goal helps delimit the scope of the SPL and gives it an explicit context.

Then, the domain expert and the domain analyst interact in order to identify and specify goals, scenarios, actions, features, and lexicon terms. These correspond to the Define Goals, Define Scenarios, Define Actions, Define Features and Define Lexicon activities, respectively. To do these activities, the domain expert and the domain analyst may consider a variety of sources of information as complementing the domain expert’s knowledge; among them we can find: available components developed within the domain, external information (e.g. emerging technologies within a domain, market information and literature) and/or systems information (e.g. system documentation and existent systems developed in the domain).

Once the first set of goals, scenarios, actions, features and lexicon is available, the domain expert and the domain analyst relate these model elements by executing the Define Relationships activity. The most important relationships are between goals and scenarios, between scenarios and features, and among features themselves.

Once these activities are done, the domain expert checks for completeness by analyzing if the model elements captured are enough for building all the expected products. Meanwhile, the domain analyst checks for consistency by verifying that the domain model satisfies all the consistency conditions. If any of these conditions (completeness or consistency) does not hold, then the process should iterate. Otherwise, the domain model is ready and we can proceed to the following step in the SPL development.

Our proposed domain model includes features, goals, scenarios and lexicon, along with the relationships among these elements. The lexicon defines the domain vocabulary, and allows a better and common understanding for all stakeholders involved in the domain [25]. Several other authors agree on the need of a lexicon in the development of the SPL [2,11,26,27].

The definitions of features, goals and scenarios are inspired by and adapted from Park et al. [24]. In the context of a product line, a goal is an objective of the business, organization or system that some stakeholder hopes to achieve with that product line. Scenarios capture real requirements by describing real situations or concrete behaviors in terms of actions. Thus, a scenario is generally composed of a sequence of one or more actions corresponding to user or system interactions with products in the product line. A scenario is a possible behavior limited to a set of interactions with the purpose of achieving some goals with a product of the product family. Consequently, goals can be achieved through the execution of scenarios. Features are characteristics and abstractions of product functionalities, parameters and data storage in a SPL visible for stakeholders, and thus they can be viewed as effects achieved by product behavior. As such, a feature is an attribute of a system that directly affects end users [26]. Product features are defined as part of the lexicon and are related to scenarios through actions, that is to say, features are required to implement actions.

It is possible to apply formal methods to the SPL. This idea is not new and has gained strength in recent years [28]. We use Z schemas to define the elements that belong to the domain model and the relationships among them, as well as the invariants in which they are involved.

Since features can be defined as mandatory (commonalities), or optional and/or alternative (variabilities), we define Feature as a name, a type, and a variability, as specified in the Feature schema.
                              
                                 
                                    
                                    
                                       
                                          
                                             TYPEF
                                             ∷=
                                             GroupedFeature ∣ SolitaryFeature ∣ RootFeature
                                          
                                       
                                       
                                          
                                             TYPEV
                                             ∷=
                                             Optional ∣ Mandatory
                                          
                                       
                                    
                                 
                              
                           
                        


                           GroupedFeature may be an AND Feature, an OR Feature or a XOR Feature [29].
                              
                                 
                              
                           
                        

We also consider GOAL, ACTION, and DESCRIPTION as primitive types, and we define SCENARIO as a sequence of ACTION.
                              
                                 
                                    
                                    
                                       
                                          [GOAL, ACTION, DESCRIPTION]
                                       
                                       
                                          
                                             SCENARIO
                                             ==seq ACTION
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                        

The schema DomainModel defines the elements that form part of the domain model. In this schema, the variables are Goals, Scenarios, Features, Actions and Lexicon. The schema also includes the relationships between goals and scenarios (By_Scenario [a]), and between scenarios and features (By_Feature [b]), both inspired by the work of Kaindl [30].

The invariants that any DomainModel must satisfy are those stated in the lower part of the schema. Among them we find the following: the identified actions are those derived from the defined scenarios [e]. The Lexicon includes the definition of some of the identified features [f], and there may be some other features that are not defined yet. Only those goals, scenarios and features that have been identified as part of the DomainModel can be related by the By_Scenario and By_Feature relationships [g,
                           h,
                           i,
                           j].

Domain Models not only include those elements that conform them, but also some constraints about these elements. The ConstrainedDomainModel restricts the DomainModel with the Requires [c] and Excludes [d] relationships that establish that two features must be both present in a product, or that cannot be together in a product, respectively. Both Requires and Excludes can only relate already identified Features [k,
                           l,
                           m,
                           n].
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                        

A consistent domain model is one that may be used as a basis for subsequent steps within the SPL development. Although we may temporarily have a transient inconsistent domain model, in the end it needs to be consistent. The ConsistentDomainModel schema refines the ConstrainedDomainModel schema by adding new constraints. It includes the ConstrainedDomainModel schema, and also includes the definition of another relationship (Attached [o]) between Actions and Features.
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                          
                                       
                                    
                                 
                              
                           
                        

Within a ConsistentDomainModel, all identified Features are described in the Lexicon [p], all identified Goals have a series of related Scenarios [q], all identified Scenarios contribute to a certain goal and may also be fulfilled with the set of identified Features [r]. Finally, all identified Actions are attached to at least one feature [s], and all Features are attached to at least one action [t]. These conditions are used for consistency checking, which is one of the termination conditions of the proposed process.

In this section, we apply the proposed process to building the domain model of a Tree Stem Deformation (TSD) meshing tool SPL. The purpose of these applications is mainly to model tree stems as particular cylinders whose surface, represented by a mesh composed of triangles, may grow or get deformed, as shown in Fig. 4
                     . However, their geometry is not restricted to cylindrical structures: these special kind of meshes may be used to model other domains as well, such as blood vessels that are deformed by blood pressure, or chemical refinery tubular networks that may be affected by temperature.

We first introduce the main domain concepts as part of the lexicon. Then, we focus on the business goal, and we define particular goals, some scenarios and features. Several features are then added to the lexicon. We illustrate the relationships among some goals, scenarios and features. We proceed with a second iteration mainly because the feature model was found to be incomplete and inconsistent. Then we advance further with the feature model, adding more features, defining them in the lexicon, and also relating them according to the Requires and Excludes constraints.

The relationships among goals, features and scenarios are stated in tables to simplify consistency checks. Only when the domain expert and the domain analyst intuitively think that the model is ready, they check the termination conditions. Thus, our domain analyst checks for domain model consistency using the constraints established in the ConsistentDomainModel schema, and the domain expert checks for completeness by determining if the candidate tools of the SPL could be built with the documented elements.

The radial growth of a tree stem occurs by the successive addition of cell layers. In this process, the auxin hormone plays an important role because it has been observed that it regulates the local radial growth rate of a tree stem: the higher the concentration in a specific point, the higher the tree growth at that point [31]. Forest et al. propose and validate a 3D auxin transport mathematical model which includes gravity dependence [31]. The mathematical model has been discretized for the finite element method and implemented in Femlab [32], but it still requires appropriate meshing tools to build the new surface mesh that represents the simulated radial growth. A high quality mesh for this purpose can be generated with different characteristics depending on the user’s needs, e.g., the stem geometry can be either generated from its medulla, from a simple cylinder or can be already available as an initial surface triangulation. Several processes can be applied to the initial mesh according to the simulation requirements: the mesh could be further refined or coarsened (derefined), or the mesh may need to be improved preserving the number of points, among others. All the meshing tools receive as input the geometry of the tree stem and optionally growing parameters (an auxin concentration, a growth direction and an offset for each mesh point), and generate as output a surface mesh that represents a stem tree surface. The tools should also allow visualizing a mesh, evaluating mesh quality and should include at least one of the processes mentioned above. The output mesh can be sent again to Femlab or stored for a posteriori analysis. By combining the different variabilities, different tools can be generated in order to fulfilling exactly the users’ needs. Furthermore, given that TSD modeling also requires algorithms that are useful for any mesh generation tool such as algorithms for mesh quality improvement, the meshing tools can be easily adapted to other similar problems.


                        Define Lexicon is one of the first activities of the domain modeling process, as stated in Fig. 3. The lexicon includes the definition of the terms that are identified as essential within the application domain. These definitions allow the stakeholders to understand the basic concepts and to share a common language while building and/or using a product.

In this section, we describe part of the vocabulary used for the TSD SPL domain model. Even though it is non-exhaustive, it helps understand the domain, and the knowledge it contains helps delimit the SPL scope.
                           
                              
                                 Tree stem deformation meshing tool: It is a piece of software for generating and managing meshes for tree stem deformation.


                                 Surface mesh: A surface mesh is a discretization of a domain geometry into simple cells. A surface mesh is composed of vertices (nodes) defined by points, edges defined by segments, and elements defined by triangles and/or quadrilaterals. An element represents the smallest discretization unit.


                                 Load mesh: It represents the task of loading the geometry of the tree stem. This geometry may be specified through an initial mesh, from a tree medulla or from a cylinder. Allowed input formats are the object file format (off), the Matlab format and/or the XYZU format, among others.


                                 Save mesh: It represents the task of storing the generated mesh in an specific format in order to use it as input for other programs. For example, a visualization tool such as GeomView or a finite element solver such as Femlab. Examples of output formats are: object file format (off) and the XYZU format, among others.


                                 Generate (initial) mesh: This step is applied only if a tree medulla or a cylinder is specified. In this case, the meshing tool takes a domain geometry as input and generates a discretization (mesh) that represents the given geometry as precisely as possible.


                                 Refinement criteria: These criteria control the number of points inserted in the mesh. Some common refinement criteria are the Maximum Edge Length (all mesh edges must have a length smaller or equal to a threshold value) and the Maximum Area (all mesh elements must have an area smaller or equal to a threshold value).


                                 Derefinement criteria: These are criteria that control the number of points deleted from the mesh. Some known derefinement criteria are the Minimum Edge Length (all mesh edges must have a length greater or equal to a threshold value) and the Minimum Area (all mesh elements must have an area greater or equal to a threshold value).


                                 Process mesh: The user of meshing tools usually specifies as input a domain geometry, some physical values associated to this geometry (e.g., hormone concentration), and some quality criteria, in order to obtain as output a mesh suitable for simulating some phenomena in this domain. In order to generate a suitable mesh, almost all meshing tools require one or more of the following algorithms:
                                    
                                       
                                          Refine: This process divides coarse elements into smaller ones according to certain refinement criteria. For example, if the Maximum Edge Length criterion is specified, the chosen algorithm divides (refines) all the elements whose longest edge is larger than the specified Maximum Edge Length value.


                                          Derefine: This process generates a coarse mesh from an overrefined mesh. Elements or edges that are too small are eliminated according to a specified derefinement criterion. An example of a derefinement criterion is Minimum Area, i.e., all elements that have an area smaller or equal to a threshold value are eliminated.


                                          Improve: This process improves the quality of the mesh without adding new points. For example, an algorithm to transform a mesh into a Delaunay mesh improves the Minimum Angle of all elements in the mesh.


                                          Deform the mesh: All previous algorithms work over fixed geometries, i.e., the shape of the domain does not change after applying any of these algorithms. However, the geometry in the TSD meshing tools may change as a consequence of growth. Different algorithms may be used to model deformations. For example, one algorithm moves geometry points until the first collision between mesh triangles is detected. Another algorithm moves all points a certain amount by correcting point trajectories if necessary.

The Define Goals activity is carried out simultaneously with other artifacts definition activities, as stated in Fig. 3. As a result of this activity, we have identified the business goal and a set of particular goals for this domain.

We can state the business goal, i.e., the goal for developing the meshing tool SPL, as follows:
                              
                                 •
                                 Developing a variety of surface meshing tools for tree stem deformation simulation with minimum effort.

This business goal emphasizes building meshing tools within a particular domain (tree stem deformation simulation) and with a particular purpose (with minimum effort).

Goals define what stakeholders want to achieve through the software product line. We have identified particular goals for the tree stem deformation simulation domain. Here we present three goals that implicitly describe both the context and the quality attributes of the SPL we would like to develop.
                              
                                 
                                    G1: Generation of quality surface meshes from simple tree stem geometries.


                                    G2: Generation and management of large scale meshes.


                                    G3: Evaluation, visualization and optimization of meshes.


                        Define Scenarios is followed by Define Actions for each scenario, as illustrated in Fig. 3. We here detail S1, a use scenario for the meshing tool SPL as well as their corresponding sequence of actions.
                           
                              
                                 S1
                              
                              Generate a quality Delaunay triangular surface mesh from a simple cylindrical geometry and simulate one growth step.
                                    
                                       
                                          A1: 
                                          Load the stem geometry specified in the Matlab format.


                                          A2: Apply the From cylinder mesh algorithm to generate the initial mesh.


                                          A3: 
                                          Visualize the mesh using Built-in graphical functionalities.


                                          A4: Evaluate the mesh using Display mesh information.


                                          A5: Select the threshold value for the Maximum face area of the refinement criterion.


                                          A6: Apply the Lepp-Delaunay algorithm while the Maximum face area of the refinement criterion is not fulfilled.


                                          A3: 
                                          Visualize the mesh using Built-in graphical functionalities.


                                          A7: Apply the Randomized algorithm for distributing hormone over the mesh.


                                          A8: Apply the Neighbor nodes algorithm.


                                          A3: 
                                          Visualize the mesh using Built-in graphical functionalities.


                                          A9: 
                                          Save the mesh in the Object file format.


                                          A10: 
                                          Visualize the mesh using Geomview.


                        Table 1
                         describes other scenarios as well, and Table 2
                         describes each action involved. Notice that identical actions that take part in different scenarios have the same identification.

The Define Features activity is carried out simultaneously with other artifacts definition activities, as shown in Fig. 3. Features are obtained both from the concepts defined as part of the lexicon and from those actions that are required for carrying out the identified scenarios. These features are organized according to a feature model, identifying commonalities and variabilities. While building this model, new features may also be identified and added to the model. Once the feature model is built, the Requires and Excludes relationships between features are established.


                           Fig. 5
                            shows the feature model for the tree stem meshing tool domain, following the characteristics of the Features defined in Section 2.2.1. Features Mesh, Load mesh, Save mesh, Visualize mesh, Display mesh information, and Process mesh are common to all meshing tools. Generate (initial) mesh, and Criterion are optional, i.e., they may be present or not in a particular meshing tool in this SPL. Features such as the Process mesh are formed by a group of alternate features: Refine mesh, Derefine mesh, Deform mesh, Improve mesh, and Distribute hormone. Either all of these features or any subset of them can be present in a particular tool. Finally, a meshing tool must work with input and output formats specified through Off, XYZU or Matlab which are alternate features of Load mesh and Save mesh. Similarly, either all of them or any subset of them can be present in a particular tool.

Feature models sometimes need additional constraints [25] or composition rules [26] that cannot be expressed only by single or grouped features in a plain feature diagram. These constraints may be modeled through Requires and Excludes relationships.


                           Table 3
                            shows some of the Requires relationships. For example, the Refine mesh algorithm requires a Refinement criterion, and vice versa. Similarly, the Derefine mesh algorithm requires a Derefinement criterion. Also, the Matlab format must be present in order to Generate mesh.

When constraints are taken into account, the number of different valid products that can be generated with this SPL is 80,199.
                              1
                              According to the Software Product Lines Online Tool (SPLOT) website, in http://www.splot-research.org.
                           
                           
                              1
                           
                        

After defining all elements contained in the domain model, the process illustrated in Fig. 3 states that the Define Relationships activity should be carried out to finish building the tentative domain model. Table 4
                         presents the relationships between goals and scenarios (By-Scenario relationship [a] in the DomainModel schema). The relationships between scenarios and features are presented in Table 1, which relates scenarios and actions, and Table 5
                        , which relates actions and features (By_Feature relationship [b] in the DomainModel schema).


                        Check Consistency is performed by checking all the conditions established in the ConsistentDomainModel in Section 2.2.2. We can see that all goals are achieved by at least one scenario, and that all scenarios contribute to the achievement of at least one goal, fulfilling condition [q] in ConsistentDomainModel.

By construction, the set of actions is the union of all actions required to fulfill the specified scenarios (condition [s]).


                        Table 5 (relationship Attached [o]) presents the relationships between actions and features. From the table, we find that the Built-in and Geomview features are required by several actions, and that they are not present in the feature model, thus violating condition [t]. Then, adding these features to the feature model is enough to ensure a consistent domain model. Fig. 6
                         shows how to extend the feature model so as to include these two features.

As shown in Fig. 3, the domain expert should check for completeness of the domain model. Thus, we asked our domain expert to identify those features in the domain model that are needed to build three particular meshing tools, a Basic TSD meshing tool, a Scalable TSD meshing tool and a Quality TSD meshing tool. We assume that these three tools are within the SPL scope, and as such it should be possible to build them with the elements identified as part of the domain model of this SPL. These three meshing tools are described in the following subsections, highlighting their features. Those features not present in the feature model shown in Figs. 5 and 6 are indicated by an attached *.

Product Basic TSD meshing tool is a meshing tool whose goal is to generate and deform tree stem meshes starting from simple geometry models. It can Refine and Derefine a Mesh, and also simulate and Visualize one growth step. The input geometry is Loaded using the Matlab format. The initial mesh is generated either by using the From cylinder or From medulla algorithms and stored in the Mesh and its components Node, Edge and Triangle. The amount of hormone associated to each node is computed by using the Randomized algorithm. The Deform Mesh process uses the Neighbor nodes algorithm. The quality of the mesh after one growth step is evaluated using the Display mesh information process, it refines the mesh using the Lepp-delaunay algorithm with the Maximum longest edge Refinement criterion and it derefines the mesh using the Edge collapse algorithm with Derefinement criterion Minimum longest edge. The mesh is visualized using either Built-in functionalities or Geomview. Meshes can be stored in the Off and XYZU formats.

Related scenarios are: S1, S3, and related goals are: G1, G3.

Product Scalable TSD meshing tool is a meshing tool whose goal is to manage and optimize large tree stem meshes generated by other tools so that they can be used by an external TSD simulator, such as the one implemented in Femlab. The input mesh is Loaded from the XYZU or Off formats and stored in the Mesh and its components Node, Edge and Triangle. If not specified in the input, the amount of hormone associated to each node is computed by using the Randomized algorithm. The Display mesh information process is used to evaluate the quality of the mesh before applying a refinement or derefinement algorithm. The Refine mesh process uses the Lepp-Delaunay algorithm with either the Maximum longest edge or Maximum face area Refinement criteria. The Derefine mesh process uses the Edge collapse algorithm. There are two realizations for the Derefinement criterion: Minimum longest edge and Minimum face area. The mesh is visualized either by using Built-in functionalities or Geomview. Meshes can be stored either in the Off or XYZU formats.

Related scenarios are: S2, S4, and related goals are: G2, G3.

Product Quality TSD meshing tool is a meshing tool whose goal is to deform tree stem meshes and improve mesh quality after one growth step. The initial tree stem mesh is generated by another tool and stored either in the Off or Comsol(*) formats. This product reads the mesh in these formats and uses Load mesh to initialize the Mesh and its components Node, Edge and Triangle. The amount of hormone associated to each node is computed using the Randomized algorithm. The Deform mesh process uses the Local consistency algorithm. The quality of the mesh after one growth step is evaluated using Display mesh information, the Improve process uses the Delaunay algorithm and the Derefine mesh process uses the Edge collapse algorithm with the Minimum face area Derefinement criterion. The mesh is visualized using Built-in functionalities, and is stored in the Off format.

The only related scenario is: S2, and the only related goal is: G3.

Since the previous analysis established that there is one feature with an * attached, we conclude that our domain model is not complete. Therefore, it is necessary to add the missing feature to ensure the completeness of the feature model and also probably adjust the scenarios and goals. This is shown in Fig. 7
                           .

According to the process described in Section 2.1, adding a new feature may require also adding new scenarios and goals, as the inclusion of new elements may affect the consistency of the domain model. Therefore, a new domain model construction process iteration is needed. The new feature Comsol can be included as part of the following action, and it can be substituted in any scenario where A11 (load from off format) appears.
                              
                                 
                                    A22: Load the mesh from the Comsol file format.

Even though reaching a domain model that is both complete and consistent may seem to be a laborious task, these conditions tell us where to focus our efforts. In the particular examples presented in the following section, both the completeness and consistency conditions were achieved.

In this section, we first present the MeshingToolGenerator, a software tool built based on the SPL approach for instantiating family member, and then we show how it is used for instantiating the tools described in Section 3.8.

The MeshingToolGenerator
                              2
                              MeshingToolGenerator can be downloaded from http://www.dcc.uchile.cl/∼prossel/meshingtoolgenerator/mt.htm.
                           
                           
                              2
                            
                           [33] allows configuring the feature model, choosing the particular values for the identified variabilities, and generating a particular meshing tool that includes only the code required to implement the specified features.

The MeshingToolGenerator takes the feature model as input and builds its user interface parametrically. Fig. 8
                           (a) shows the initial display where the user chooses the input and output formats and whether it is necessary to generate an initial mesh. In part (b), the options for mesh processing algorithms are chosen and the particular tool is finally generated.

In this section we show how to configure each product described in Section 3.8.1 using MeshingToolGenerator, and we show the resulting generated tool.


                           Basic TSD meshing tool. This tool was introduced in Section 3.8.1. Fig. 9
                            shows how to configure its features using MeshingToolGenerator. Fig. 10
                            shows the interface of the resulting meshing tool, which was built using the mesh generator.

The top part of Fig. 10 presents the application tool bar, showing its main functionalities. The first three buttons, New, Open and Save, are present due to the selection done in part (a) of Fig. 9. For example, button New is present because Generate mesh? was selected, and button Open is present because at least one of the input formats is selected in Load mesh. On the other hand, the following four buttons, Distribute hormone, Deform, Refine and Derefine, are included because of the selection done in Fig. 9(b). It can be noted that the Improve mesh option is not present in the tool bar because it was not selected in Fig. 9(b). Similarly, the Derefine button is present because the Derefine mesh option was selected. In order to show the refine algorithm and criterion selected, a dialog box related to the Refine mesh functionality is displayed. It can be seen that the only refinement algorithm available is Lepp-Delaunay, and the only available criterion is Maximum longest edge, also showing the placeholder for introducing its threshold.


                           Scalable TSD meshing tool. This tool was introduced in Section 3.8.2. Its main functionalities were selected using the mesh generator, as shown in Fig. 11
                           . In part (a) of the figure, we have selected some mesh formats, but we have not selected Generate mesh? for generating the initial mesh. In part (b), several processes and their corresponding algorithms have been selected. Fig. 12
                            shows the interface of the resulting meshing tool, built using the mesh generator.

The top of Fig. 12 shows the application tool bar. In this case, there is no New button because the Generate mesh? functionality was not selected in part (a) of Fig. 11. The dialog box displayed relative to the Derefine mesh option shows the criteria available for derefining the mesh. The name of the derefinement algorithm in use is not shown because, according to the feature model shown in Fig. 5, only the Edge collapse algorithm is present in this application.


                           Quality TSD meshing tool. Similarly, this tool’s functionalities are defined using MeshingToolGenerator as shown in Fig. 13
                           . Here, the Comsol format is selected in Load mesh; it was included as part of the feature model as a consequence of the domain model completeness evaluation. The Improve mesh?, Derefine mesh?, Distribute hormone? and Deform mesh? are selected. Fig. 14
                            shows the interface of the resulting meshing tool, built using the mesh generator.

The dialog box shown in Fig. 14 appears when the Open button is pressed to load a mesh. As the load formats selected in Fig. 13 are Off and Comsol, only these formats are available in the dialog box. Similarly, only the Off format is available as an option for the Save button.

@&#RELATED WORK@&#

In this section we discuss different techniques proposed for domain analysis in general, and for its application to meshing tools in particular, as well as other approaches that have been followed to build meshing tools.

Domain analysis is the process of identifying, collecting, organizing, and representing the relevant information in a domain, based upon the study of existing systems and their development histories, knowledge captured from domain experts, underlying theory, and emerging technology within the domain [26]. Although it is a general purpose process, it has been identified as one of the most appropriate forms of requirements engineering in the context of a SPL [25].

Coplien et al. [34] propose SCV (Scope, Commonalities and Variabilities), a method for conceptually addressing domain analysis within SPL. There are several notations and techniques proposed for realizing SCV such as FAST [2], PuLSE [20] and FORM [35]. These methods are useful for any application domain and they generally cover the whole domain engineering stage. All these methods propose well defined processes for building the domain model. Our approach goes a step further by formalizing the domain model definition and thus we are also able to precisely define iteration/termination conditions for our proposed process. Furthermore, we do not need to tailor the approach for the specific application domain because it is specifically created for the meshing tool domain.

Smith and Chen [19] have applied SCV to the meshing tool domain using FAST. Even though their approach is systematic, they do not take full advantage of the meshing tool domain characteristics because they apply a general DA method for scientific computing software [9,11]. For example, we have noticed that the binding time for variabilities in meshing tools is fixed: which features are included is always decided at product design time, and which particular implementation for each chosen feature is decided at compilation time. In this way, our documentation is more compact and the process is simpler because a default binding time is used. This default binding time allows us to make decisions at a higher level of abstraction, thus yielding simpler tools that would have better performance.

Kim et al. [21] propose a DA method based on goals and scenarios. It involves four information levels: business, service, interaction and internal, each of them refining the previous one. Due to the number of information levels, this method is appropriate for characterizing domains where the domain expert has little experience in software development. Meshing tool experts are usually involved in software development even though they are not always knowledgeable in software engineering, so we were able to simplify the domain model and the process for building it. Our model includes the business goal for the SPL and a single level where the complete model is defined. Park et al. [24] propose to use features, scenarios and goals for capturing the characteristics of the domain, as we do. However, since their approach is general for any domain, they use a method that involves three successive specification stages. We found that for our meshing tool domain, an iterative process and a model with two levels is enough. None of these methods, neither the one of Kim et al. [21] nor the one of Park et al. [24], define a clear termination condition.

Douta et al. [36] present an approach to commonality and variability analysis called CompAS, for the specific domain of computer assisted orthopedic surgery. This approach focuses on the analysis of the evolution of the domain to effectively determine which features should be included as common or variable. The method bases its source of information for building the domain model on publicly available literature (e.g. books, articles and standards). CompAS suggests that the domain analyst should regularly ask the domain expert for a correct, consistent and complete functional decomposition. We assign the domain expert a more relevant role as part of the process of building the domain model. However, we agree with Douta et al. [36] on the convenience of counting on a domain specific process.

Smith and Yu [12] provide a document-driven approach for generating a family of parallel meshing tools. The information used is similar to that included in our model, but the process presented is mainly a waterfall. Our process is iterative and the model is built incrementally so that feedback can be systematically incorporated.

Another approach is provided by Li et al. [37]. The authors present a specific requirements model for the scientific computing domain. This model-based approach allows eliciting requirements in a scientific computing project by modeling domain specific requirements elements and the associations between them. This model has two main advantages: the requirements are expressed through a model which has a higher level of abstraction than a textual requirements specification, and the abstractions and notations used by this model are domain specific. In spite of these advantages, the model has not been used in SPL, and its value in this context is unknown yet.

Finally, after analyzing the articles mentioned in the reviews of Alves et al. [38], Asadi et al. [39], Khurum and Gorschek [40], we can establish that, to the best of our knowledge, there are no domain analysis approaches for the meshing tool domain.

We presented a domain analysis process specially suited for the meshing tool domain, showing how its characteristics can be specified using a model based on lexicon, features, scenarios and goals. Our approach proposes a process with clear activities, roles and a clear termination condition, and a formalization of the model specified in a formal language. Consistency is defined among domain elements, and completeness is defined with respect to the products that are intended to be developed.

Defining a domain model that is complete for all potential meshing tools is impractical. The objective is to build a domain model that is complete enough to build a series of planned products. The domain model shown in this work may not be complete for certain tools, but it is easy to extend by adding particular scenarios and features, as was shown in Section 3.8.4. It should then be possible to build these new products with the added domain elements.

Although the feature model is the most formal part of our domain model, and the only one that can be automatically manipulated for generating tools, building a good feature model for complex domains is a non-trivial task. Domain experts tend to think in terms of goals and scenarios. Our model provides a framework and a process to guide the knowledge acquisition and recording in a natural way.

Having a completely formalized domain model, the natural next step is to develop a supporting tool that eases specification and enables analysis. Therefore, we are currently working on a tool for supporting the domain model construction as a plug-in for Eclipse.

In this paper we have shown the application of the model and the process to generate a software product line for Tree Stem Deformation (TSD) meshing tools. Furthermore, we have applied successfully a slightly different domain model process in the Emergency Management domain [41], where the purpose is the design of software tools for dealing with different kind of disasters.

We are also in the process of taking advantage of all the knowledge captured in the domain model as a basis for building a new family of meshing tools: tools for modeling face animation. These meshes are 2.5 D, have moving boundaries, and utilize several of the already defined input and output formats, as well as the mesh generation algorithms. Refinement and improvement algorithms have not been considered yet, but according to the model already built, a structure similar to that of Tree Stem Deformation can be followed. We are confident that, by applying the proposed process to building a SPL to this new domain, we will be able to generate these tools much easier and faster.

@&#ACKNOWLEDGMENTS@&#

The work of Nancy Hitschfeld-Kahler and Violeta Díaz has been partly funded by Fondecyt Project 1120495, Conicyt, Chile. The work of Pedro O. Rossel has been partially supported by Grant No. UCH 0109 from MECESUP, Chile. We would also thank the collaboration of Jaime San Martín, Fernando Padilla and Loic Forest in providing the requirements for the Tree Stem Deformation SPL.

@&#REFERENCES@&#

