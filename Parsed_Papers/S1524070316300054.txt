@&#MAIN-TITLE@&#Extracting feature lines from point clouds based on smooth shrink and iterative thinning

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An index SSI for measuring the degree of variation of the surface is proposed.


                        
                        
                           
                           A method for identifying potential feature points that are subordinate to different feature lines is present.


                        
                        
                           
                           Existing methods for thinning the potential feature points have been improved.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Point clouds

Feature line

Thinning

Surface variation

Curvature

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           Image, graphical abstract
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

The extraction of feature lines, as a basic operation in geometric model processing, can provide important information for the expression and understanding of 3-d models. Therefore, it has been widely applied in the visualisation [1], optimisation [2,3], and simplification [4–6] of geometric models, surface reconstruction [7], smoothing surfaces [8,9], and so on.

A feature line is the ordered connection of the feature points. Therefore, the primary step when extracting a feature line is to seek an index used for measuring the degree of variation of the surface to identify potential feature points from the whole point cloud. For this purpose, the principle component analysis(PCA) [10–13], curvature method [14–21] and M estimation [22–24] were proposed. However, the measurement of the surface variation of scattered point clouds has to be further discussed due to the lost topology, non-uniform sampling, and noise interference. Also, identified potential feature points require to be processed by the curve growing algorithm or the minimum spanning tree (MST), so as to obtain orderly connected feature lines. In this process, problems such as breakage and bifurcation of the feature lines induced by noise and non-uniform sampling must to be taken into account.

A new algorithm that can extract feature lines from the non-uniformly sampled point cloud containing noise is proposed in this research. Firstly, a new index, that is, the SSI for measuring the degree of variation of the surface is constructed based on the smooth shrinkage of the model, and then used to identify potential feature points from the whole point cloud. Afterwards, the growing algorithm is used to conduct regional segmentation of the potential feature points. Finally, the potential feature points of each region are subjected to independent iterative refinement using the bilateral filter algorithm based on curvature and distance. The feature points are then connected to form the feature lines. The main contributions in this paper are as follows: (1) a new index SSI for measuring the degree of variation of the surface is proposed. Due to its integral characteristics, SSI has favourable tolerance to noise. Meanwhile, by weighting the sampling density and restraining the shrinkage direction, SSI shows favourable adaptability to non- uniformly sampled point clouds. In addition, SSI is capable of expressing the concavity and convexity of the surface by calculating the angle between the shrink direction and the normal vector. (2) A method for identifying potential feature points that are subordinate to different feature lines is proposed. This method improves the distinction of ridge and valley lines by considering the spatial distance and the concavity and convexity of the surface while conducting regional segmentation on the potential feature points. Meanwhile, after regional segmentation, a greater radius of neighbourhood can be adopted to determine trends in curves, which is favourable for improving the stability while thinning the potential feature points later on. (3) Existing methods for thinning the potential feature points have been improved. While thinning the potential feature points, PCA is used to determine the curve direction and restrain the drift of potential feature points. In this way, problems such as breakage and the shrink in the endpoints of feature lines that frequently appear in traditional methods can be avoided.

The rest of the paper is arranged as follows: Section 2 reviews related work; the proposed SSI is introduced in Section 3; Section 4 describes the algorithm for extracting feature lines and its implementation; Section 5 verifies the proposed algorithm and compares it with other algorithms; and a summary of this research is presented in Section 6.

@&#RELATED WORK@&#

It is difficult to extract feature lines from scattered point clouds without connected topology. Many algorithms are proposed to solve this problem. Generally speaking, the entire process of extraction of feature lines can be divided into two parts: the identification of the potential feature points, and their connection.

Gumhold et al. [10] first introduced PCA for the extraction of feature lines: they used the eigenvalues obtained from PCA to construct an index named Surface Variation (SV), so as to identify the potential feature points. Then, the eigenvector from PCA is used to divide the potential feature points into the boundary points, edge points, and corners. Finally, the MST of the feature points is established to connect the feature points. By extending the aforementioned method, Pauly et al. [12,13] carried out multi-scale PCA on a point cloud by changing the number of neighbourhood points, which improves the adaptability of the algorithm to noisy point clouds. By using SV instead of the curvature, the aforementioned feature measurements can preferably represent the bending degree of the surface. However, SV can merely reflect the bending amplitude of the surface, but cannot represent the concavity and convexity, according to its positive or negative sign, just like that of the actual curvature. Therefore, the aforementioned methods cannot distinguish the spatially adjacent valley and ridge lines correctly.

To obtain the curvature of the point cloud according to the standard definition, surface fitting was introduced. Wang et al. [14] proposed an algorithm for extracting feature lines from the point cloud based on local reconstruction. This algorithm searches for the feature points by judging the number of surfaces to which a potential feature point is subordinate, and can preserve weak feature lines as much as possible while extracting significant features lines. However, this algorithm merely performs simple plane fitting for neighbourhood points, and thus is not applicable to the extraction of the feature lines generated by intersected bending surfaces. Pang et al. [15] calculated the curvature by fitting a local quadratic surface, and then acquired the strengthened feature points by projecting feature points onto the nearest potential feature lines. Although this method can extract both smooth and fine features, it is likely to give rise to a loss of information and the breakage of the extracted feature lines because the feature points require to be projected on the tangent plane for processing. The moving least-squares algorithm was used by Kim et al. [16–17] and Weber et al. [18] to estimate the curvature information of the point cloud. Kim acquired the neighbourhood information by calculating the local Voronoi map, and similar methods were also adopted by Quentin et al 
                        [19]. However, a Voronoi map is likely to be affected by any outliers. Daniels et al. [20] fitted surface using robust moving least-squares analysis, and then projected the potential feature points onto the intersecting lines of different surfaces to obtain the feature lines. As the moving least-squares surface is applied as a tool for curvature estimation in the aforementioned methods, these methods are endowed with limited speed of operation. Therefore, their use is slow when processing point clouds with large data sets and have poor processing effect on non-uniformly sampled point clouds. The fast Fourier transform was adopted to calculate the curvature of the point cloud by Enkhbayar et al 
                        [21]. Although, this method can be accelerated by parallel calculation, it has to establish local coordinate systems for each point in the point cloud using PCA and conducts the projection calculation in advance. These steps are time-consuming, and satisfying results cannot be obtained until the calculated results are filtered through a low pass filter.

Since measurement noise is inevitable in practical point clouds, methods based on statistical analysis were proposed to eliminate the influence of noise with large amplitude. Evangelos et al. [22] greatly improved the accuracy when estimating the curvature of noisy, non-uniformly sampled point cloud data using M estimation, but the time complexity is high. The multi-scale tensor voting was used by Min et al. [23] to calculate the degree of variation of the surface, which presents high efficiency and better adaptability to noise, but poor adaptability to non-uniformly sampled point clouds. Weber et al. [24] realised the extraction of the feature lines by clustering the Gauss maps of neighbourhood points. This algorithm exhibits favourable robustness, but cannot extract smooth feature lines because it is designed to extract sharp feature lines.

The connection of the feature points needs the potential feature points, so as to form orderly, connected feature lines. The line growing method is one of the methods used to connect feature points. For example, Enkhbayar et al. [21] firstly thinned the identified feature points, from which a seed point was found. Then, they added other feature points based on the seed point and the curve tendency to generate the integral feature lines. Kim et al. [17] used the Voronoi map to construct the connected topology, and realise the growth of the feature curve by taking the curvature direction into account. As another connection method, the integral method usually realises the connection of feature points by constructing the MST of the potential feature points. For instance, Pauly et al. [12] firstly established the undirected connection map for the potential feature points, and then calculated the weights of each side of the connection map based on the degree of variation of the surface and the distance to construct the MST. Finally, the orderly connected feature lines were generated after the short sides were removed. Demarsin et al. [11] firstly used the normal vector to conduct regional segmentation over the whole point cloud, and then constructed the MST for the boundary points of the region to extract the closed feature line. MST was used by Gerhard et al. [25] to construct the minimum spanning graph for the boundary points, from which the closed boundary lines were extracted.

Since feature lines are usually located in the place where the surface varies most significantly, a measurement index is therefore required to represent the degree of variation in the surface. In light of the processing requirements for practical scanning point clouds, this measurement index is supposed to be robust enough to noise and non-uniform sampling.

According to the definition, curvature directly reflects the variation of a surface. As for scattered point cloud data, the local point cloud data are required to be parameterised before fitting the parametric surface (quadratic or spline). Then, the curvature at the calculation point of the parametric surface is applied as the calculation result. Although, the curvature method shows favourable effects on the point cloud not containing noise, it exhibits lower precision to the practical scanning point cloud as it has to use the first and second differential of the parametric surface. An approximate calculation is another method of expressing the variation in the surface. Instead of calculating the curvature according to the standard definition, it approximately depicts the degree of variation of the surface using other indices. For example, the degree of variation of the normal vector of the neighbourhood points or SV is used to substitute the curvature on an approximate basis. Owing to the method uses the degree of variation of the normal vector to approximately substitute the curvature, essentially, it has to calculate the second differential of the surface. Therefore the result is greatly influenced by noise. Although, the method using SV can reduce the influence of noise on the calculation results through the weighting method, the calculation results lack significant physical meaning. As a result, it has difficulties in selecting appropriate thresholds to differentiate potential feature points in practical operation. Meanwhile, the aforementioned two methods can merely reflect the variation degree of the surface, but fail to express the concavity and convexity thereof according to the positive or negative sign of the value just like that of the Gaussian curvature. Moreover, the two methods fail to process non-uniform sampling, and therefore are hard to be directly applied in real scanning point clouds. Above all, it is necessary to find a new index to measure the degree of variation in the surface.

Compared to the differential operation used to calculate the curvature, the sum or average of the integral operation makes it exhibits stronger robustness to noises. As shown in (1), calculating the centre of gravity of local point cloud data is a typical integral operation. According to (1), if the noise contained in the point cloud is zero (on average), then the calculated centre of gravity 
                        
                           p
                           ¯
                        
                      of the neighbourhood point within the radius r of any arbitrary point p will not be influenced by noise.

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          p
                                          ¯
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             1
                                             n
                                          
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             (
                                             
                                                
                                                   p
                                                   i
                                                
                                                +
                                                
                                                   
                                                      ɛ
                                                   
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             1
                                             n
                                          
                                          
                                             (
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   p
                                                   i
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   
                                                      ɛ
                                                   
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             1
                                             n
                                          
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             p
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          s
                                          t
                                       
                                    
                                    
                                       :
                                    
                                    
                                       
                                          
                                             ∥
                                             
                                                
                                                   p
                                                   i
                                                
                                                −
                                                p
                                             
                                             ∥
                                          
                                          ≤
                                          r
                                       
                                    
                                 
                              
                           
                        
                     
                  

Obviously, if an index used for measuring the surface variation can be developed based on (1), then this index is expected to exhibit strong robustness to noise. Examining the formula again, it is seen that this formula can also perform Laplace smoothing on point clouds. As is well-known, Laplace smoothing can not only increase the smoothness of the point cloud data but also gives rise to volume shrinkage of the model (as a matter of fact, after an arbitrary point is processed by Laplace smoothing enough times, the model is supposed to shrink to a point eventually). Although this shrinkage introduces unexpected data errors in the smoothing of the point cloud; however, Fig. 1
                      shows that the shrinkage of the model is directly related to the sharpness of this point cloud. That is to say, the amount of shrinkage of the point cloud is small when Laplace smoothing is performed on the flat regions of the model, while the amplitude is large when Laplace smoothing is conducted on the sharp place. According to the analysis above, the shrinkage induced by smoothing can be used to construct an index for measuring the degree of variation of the surface δp
                     , as shown in (2).

                        
                           (2)
                           
                              
                                 
                                    δ
                                    p
                                 
                                 =
                                 
                                    ∥
                                    
                                       
                                          p
                                          ¯
                                       
                                       −
                                       
                                          
                                             
                                                p
                                             
                                             w
                                          
                                          ¯
                                       
                                    
                                    ∥
                                 
                              
                           
                        
                     
                  

As shown in (1), 
                        
                           p
                           ¯
                        
                      is the centre of gravity of the neighbourhood points of p, and 
                        
                           
                              
                                 p
                              
                              w
                           
                           ¯
                        
                      is that of the distance weighted centre of gravity of neighbourhood points of p, as indicated in (3):

                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                             
                                             w
                                          
                                          ¯
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   w
                                                   
                                                      d
                                                      i
                                                   
                                                
                                                
                                                   p
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                w
                                                
                                                   
                                                   
                                                      d
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          w
                                          
                                             
                                             
                                                d
                                                i
                                             
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          e
                                          
                                             −
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            ∥
                                                            
                                                               
                                                                  p
                                                                  i
                                                               
                                                               −
                                                               p
                                                            
                                                            ∥
                                                         
                                                         r
                                                      
                                                      )
                                                   
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Instead of depicting the degree of variation of the surface using 
                        
                           
                              ∥
                           
                           
                              
                                 p
                                 ¯
                              
                              −
                              p
                           
                           
                              ∥
                           
                        
                      directly, (2) replaces the original real coordinates of the point using the distance weighted centre of gravity for the purpose of improving the resistance of the index to noise: the calculation of 
                        
                           p
                           ¯
                        
                      for the point cloud containing zero-mean noise is entirely accurate, while the calculation results of 
                        
                           
                              
                                 p
                              
                              w
                           
                           ¯
                        
                      are also accurate as long as the number of neighbourhood points with the same distance is large enough under the condition of Gaussian distance weighting. Above all, the result calculated using (2) is hardly influenced by noise, and is a robust measurement index.

The practical scanning point cloud is always sampled non-uniformly. For example, when line structured light is used for scanning, the movement interval of the measuring device is usually far greater than the point cloud density under each perspective. As for surface structured light, the integration of multi-perspective measurement data is expected to reflect the variation of the point cloud density under the influence of overlapping and redundancy. To overcome the influence of the variation of sampling density, the method illustrated in (4) is used to weight each neighbourhood point, and the weight value wsi
                      is taken as the average distance between pi
                      and its five nearest neighbourhood points. This strategy can ensure that sparse and dense sampling places are endowed with large and small weights, respectively. By doing so, the lateral sliding caused by the variation in sampling density is overcome, so as to guarantee that shrinkage occurs along the normal vector to the local micro-tangent plane. To strengthen this tendency further, weighted PCA is conducted on the neighbourhood points based on the weight value of the distance in (3). In this way, the normal vector n
                     
                        p
                      of p is refined, and then the shrinkage is forced to occur along the normal vector, namely:

                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          p
                                          ¯
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   w
                                                   
                                                      s
                                                      i
                                                   
                                                
                                                
                                                   p
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                w
                                                
                                                   s
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                p
                                             
                                             w
                                          
                                          ¯
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   w
                                                   
                                                      d
                                                      i
                                                   
                                                
                                                
                                                   w
                                                   
                                                      s
                                                      i
                                                   
                                                
                                                
                                                   p
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   w
                                                   
                                                      
                                                      
                                                         d
                                                         i
                                                      
                                                   
                                                
                                                
                                                   w
                                                   
                                                      s
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          δ
                                          p
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          ∥
                                          
                                             
                                                (
                                                
                                                   
                                                      p
                                                      ¯
                                                   
                                                   −
                                                   
                                                      
                                                         
                                                            p
                                                         
                                                         w
                                                      
                                                      ¯
                                                   
                                                
                                                )
                                             
                                             ·
                                             
                                                n
                                                p
                                             
                                          
                                          ∥
                                       
                                    
                                 
                              
                           
                        
                     
                  

Furthermore, to endow the index with the ability to express the concavity and convexity of the surface, signs are added to (4), and their determination criterion is as follows: if the angle between the vector 
                        
                           
                              p
                              ¯
                           
                           
                              
                                 
                                    p
                                 
                                 w
                              
                              ¯
                           
                        
                      and the normal vector n
                     
                        p
                      is less than 90°, then the sign is taken as +1, otherwise it is −1. The calculation of the measurement index, with added signs, is given in (5):

                        
                           (5)
                           
                              
                                 
                                    δ
                                    p
                                 
                                 =
                                 sgn
                                 
                                    (
                                    
                                       
                                          n
                                          p
                                       
                                       ·
                                       
                                          p
                                          ¯
                                       
                                       
                                          
                                             
                                                p
                                             
                                             w
                                          
                                          ¯
                                       
                                    
                                    )
                                 
                                 
                                    ∥
                                    
                                       
                                          (
                                          
                                             
                                                p
                                                ¯
                                             
                                             −
                                             
                                                
                                                   
                                                      p
                                                   
                                                   w
                                                
                                                ¯
                                             
                                          
                                          )
                                       
                                       ·
                                       
                                          n
                                          p
                                       
                                    
                                    ∥
                                 
                              
                           
                        
                     
                  

The δp
                      in (5) can exhibit positive and negative changes and express the bending degree of the surface, and is called the smooth shrink index (SSI). Compared with the PCA, SSI is able to express the concavity and convexity of the surface, and endowed with all the characteristics of the curvature. Mean-while, it exhibits stronger adaptability to noises and non-uniform sampling compared with the curvature method. Furthermore, endowed with definite physical meaning, it is more realistic.


                     Figs. 2
                      and 3
                      show the SSI solved using Armadillo and Footprint models. Figs. 2(a) and 3(a) show the point cloud data processed by the uniform sampling algorithm proposed by the literature [26]. Figs. 2(b) and 3(b) show the solved SSI. The figures suggest that SSI can well reflect the fluctuations in point clouds obtained using uniform sampling and correctly distinguish the concavity and convexity of the surface. Figs. 2(c) and 3(c) show the effects of random noise after amplitudes of 25% and 50% of the average sampling distance are added into the original point cloud data. The SSI of the aforementioned noisy point clouds is solved as indicated in Figs. 2(d) and 3(d) and, as seen, the SSI performs well when filtering noise, and reflects the fluctuation of the surface. To verify the effect of SSI on a non-uniformly sampled point cloud, the neighbourhood points, at each point p, can be processed as follows: firstly, p is set as the origin of the coordinates, and its normal vector is taken as the local coordinate system for the positive direction of its x-axis; secondly, the neighbourhood points of p is projected to the plane of the local coordinate system XOY; finally, the neighbourhood points within four quadrants are stochastically taken as 100%, 40%, 70%, and 10% of the original value, respectively so as to simulate the performance of non-uniform sampling. Given that the x-, and y-axes of the aforementioned coordinate systems are stochastically selected, non-uniform sampling may occur in any direction along the normal vector. Thus, the performance of non-uniform sampling was simulated. In Figs. 2(e) and 3(e), the SSI obtained through non-uniform sampling on the neighbourhood points of point clouds, without added noise, is presented; while Figs. 2(f) and 3(f) show the solved SSI in the case with added noise. As shown, the accuracy of the SSI, as calculated, is not apparently influenced by the presence of noise and non-uniform sampling: the SSI can still distinguish the concavity and convexity of the surface, and represent local surface fluctuations.

The algorithm proposed in the research is shown in Fig. 4
                        . According to the algorithm, the input point cloud requires to be endowed with a normal vector. Otherwise, the normal vector is supposed to be calculated by fitting the local micro-tangent plane, followed by adjustment of the global direction, so that all the normal vectors are directed at the outside of the model surface. Once the aforementioned assumption is satisfied, this algorithm firstly calculates the SSI of each point in the point cloud, and then identifies the points with the absolute SSI value greater than the given threshold as the potential feature points. The identified potential feature points not only include the actual feature points but also their neighbourhood points due to the low-pass property of the SSI. In case the spatial distance between two feature lines is small, their potential feature points are expected to inter-mix, and thus the accuracy of the extraction of feature lines is affected. Therefore, the growing algorithm is used in this research to conduct regional segmentation of potential feature points. In the segmentation process, the distance between two adjacent points and the concavity and convexity of the surface are regarded as growth conditions. That is to say, both the distance and the sign consistency of SSI require to be satisfied during regional growth. After segmentation, the potential feature points in each region are independently subjected to iterative refinement using the bilateral filter based on distance and SSI to produce the final feature points. Meanwhile, in the process of iterative thinning, PCA is used to restrict the drift direction of the feature point, to avoid the shrinkage in the endpoints of the feature lines and the breakage of the feature lines caused by the non-uniformly sampled point cloud. After the aforementioned steps, the MST of the feature points is constructed and the feature points are connected to form feature lines.

The first step of this algorithm is to calculate the SSI of the point cloud. It is necessary to select an appropriate radius of neighbourhood during the calculation process: a small radius of the neighbourhood tends to have insufficient points being involved in the calculation, and cannot ensure the stability of the result. On the contrary, too large a radius of the neighbourhood is likely to group the points from the non-flat area into the neighbourhood of the point in flat areas, and thereby leads to closer SSI values for the two types of points and reduces the ability of the SSI to distinguish. As a matter of fact, the radius of the neighbourhood required in the calculation is related to the noise level and the sampling distance of the point cloud. The greater noise level or sampling distance a point cloud has, the greater the selected radius is supposed to be, and vice versa. Based on the above analysis, the following judgement about the selection criteria of the radius of the neighbourhood are obvious: (1) if the radius of neighbourhood is set as a multiple of the noise levelτ, then the robustness of the calculation results to noise can be guaranteed. (2) If the radius of the neighbourhood is set as a multiple of the average sampling distance
                              
                                 ρ
                                 ¯
                              
                           , then enough data points are expected to participate in the calculation, and thus the stability of the calculation results can be ensured. Above all, the calculation radius of SSI is set as 10 times the larger one between the sampling distance and the noise level in this research. The noise level in the model is estimated using the method proposed in this study [27] by using statistics relating to the error of the RASAC plane fitting.

After obtaining the SSI values of the point cloud, points with greater absolute SSI value than the given threshold are identified as potential feature points.

A point cloud dataset may contain multiple feature lines, which are possibly close to each other. Under such a situation the potential feature points subordinate to different feature lines identified in the former step may be mixed together, which gives rise to errors in the subsequent thinning process of the feature lines. For example, while thinning a piece of a feature line, the selected neighbourhood point may contain potential feature points of the feature line that is close to these feature lines in space, which therefore leads to failure of the thinning process. Therefore, it is necessary to segment the potential feature points before thinning, so as to have the potential feature points of each feature line grouped to a separate region. Another advantage of regional segmentation is that a greater radius of neighbourhood can be selected to identify the tendency of the feature line in the subsequent thinning process of potential feature points without worrying about the introduction of potential feature points of other feature lines into the neighbourhood. Furthermore, the drifting direction of the potential feature point is constrained in the thinning process, so that the stability of the extraction of the feature lines can be improved.

Regional segmentation is usually carried out by using the growing algorithm. To begin with, an empty growth list is generated, into which an arbitrary point selected from the point cloud is pushed. Afterwards, the header element of the growth list is taken out, and then the corresponding neighbourhood point is added to the growth list iteratively. The regional growth is finished when the growth list becomes empty. Given that point clouds are non-uniformly sampled, it is an optimal choice to select the radius based on local sampling density
ρ. The approach to determining the local sampling density of an arbitrary point p in a point cloud is described as follows: at first, a length 10 times greater than that of average sampling density 
                              
                                 ρ
                                 ¯
                              
                            is used as a radius to search neighborhood points; thereafter, the current point p is taken as the origin and its normal vector comprising six sectors divided on the basis of the local coordinate system plane XOY in the z-axis to search the neighborhood points further in each sector nearest to the current pointp; finally, the maximum distance is taken as the new local sampling density.

In general, two spatially close feature lines which are ridge and valley lines that appear in pairs. That is to say, the concavity and convexity of the surface of the region that the two lines belong to are different. Accordingly, the concavity and convexity of the surface can be restrained in the process of regional growth, that is, the points in the same region have to satisfy the spatial connectivity and the sign consistency of the SSI simultaneously. The regional segmentation process, with added restraints, is exhibited in Algorithm 1
                           .

Potential feature points are distributed around the real feature lines. Although they are linearly distributed from a large-scale perspective, they are disorderly when viewed locally. Therefore, potential feature points require to be thinned to strengthen the linearity and provide appropriate data for the connection of feature points.

The Laplace smoothing method is used in the research to thin the potential feature points. As shown in Fig. 5
                           (a), the neighbourhood points around the potential feature points nearby the boundary fail to fill the whole neighbourhood space. Therefore, these potential feature points are expected to deviate from the boundary after being processed by the standard Laplace smoothing. In this way, these potential feature points are thinned. The aforementioned strategy shows a favourable thinning effect on the uniformly distributed potential feature points (such asp). However, when it is applied to non-uniformly sampled potential feature points (such asq), the drifting direction of this point is not perpendicular to the actual feature line. Non- vertical drifting is expected to increase the distance between potential feature points after multiple iterations, which leads to the breakage of the feature line and thus affect the extraction accuracy of the feature lines.

To eliminate the influence of non-uniform sampling on the thinning of the feature lines, improvements were made to the Laplace smoothing method. Taking point q in Fig. 5(a) as an example, specific steps are shown in Figs. 5(b) and 5(c). Firstly, PCA is performed on the potential feature points within a given radius of neighborhood, and then the direction of the largest principal component direction is taken as the direction vector v
                           qof the feature lines. Afterwards, the drifting directions of potential feature points are restrained to occur merely along the vector obtained through the cross product of the feature line trend and normal vector at q, namely:

                              
                                 (5)
                                 
                                    
                                       
                                          
                                             q
                                          
                                          ′
                                       
                                       =
                                       q
                                       +
                                       sgn
                                       
                                          (
                                          
                                             
                                                q
                                                
                                                   q
                                                   ¯
                                                
                                             
                                             ·
                                             
                                                d
                                                q
                                             
                                          
                                          )
                                       
                                       ·
                                       
                                          ∥
                                          
                                             
                                                q
                                                
                                                   q
                                                   ¯
                                                
                                             
                                             ·
                                             
                                                d
                                                q
                                             
                                          
                                          ∥
                                       
                                       ·
                                       
                                          d
                                          q
                                       
                                    
                                 
                              
                           where,

                              
                                 
                                    d
                                    q
                                 
                                 =
                                 
                                    v
                                    q
                                 
                                 ×
                                 
                                    n
                                    q
                                 
                              
                           , 
                              sgn
                            is a sign function, with the value being the positive or negative sign of the variable.

Furthermore, the bilateral filter algorithm based on distance and SSI illustrated in (6) is used to obtain the centre of gravity of the pointq. The distance weight wd
                           is used to improve the stability while thinning the potential feature points, and the weight of SSI ws
                            enables the potential feature point with the greatest absolute value of SSI to have greater weight, which can accelerate the thinning speed of potential feature lines.

                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                q
                                                ¯
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                W
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      N
                                                      (
                                                      q
                                                      )
                                                   
                                                
                                                
                                                   
                                                      w
                                                      s
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            ∥
                                                         
                                                         
                                                            S
                                                            S
                                                            
                                                               I
                                                               i
                                                            
                                                         
                                                         
                                                            ∥
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      w
                                                      d
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            ∥
                                                         
                                                         
                                                            q
                                                            −
                                                            
                                                               q
                                                               i
                                                            
                                                         
                                                         
                                                            ∥
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      q
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             W
                                          
                                          
                                             =
                                          
                                          
                                             
                                                1
                                                /
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         N
                                                         (
                                                         q
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         w
                                                         s
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               ∥
                                                            
                                                            
                                                               S
                                                               S
                                                               
                                                                  I
                                                                  i
                                                               
                                                            
                                                            
                                                               ∥
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         w
                                                         d
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               ∥
                                                            
                                                            
                                                               q
                                                               −
                                                               
                                                                  q
                                                                  i
                                                               
                                                            
                                                            
                                                               ∥
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where qi
                            is a neighbourhood point of the potential feature point q.

Above all, the thinning process for the potential feature points is demonstrated in Algorithm 2
                           .

As Algorithm 2 is similar to the process involved in searching for a minimum using steepest descent method, its convergence can be ensured. As shown in Fig. 3, the point furthest from the potential feature point always tends to shift towards the centre thereof. The potential feature point can approach real feature lines at the fastest speed owing to the algorithm making the point drift in a direction vertical to the feature lines. Figs. 6
                            and 7
                            show the processes of conducting iterative thinning on feature points using Armadillo and Footprint models, respectively. As shown in the figures, the convergence is rapid: the potential feature points, which are distributed in an apparently linear way, can meet the convergence conditions after two to three iterations; meanwhile, all feature points can be thinned by within eight iterations.

This research realises the connection of the feature points by establishing the MST of the thinned potential feature points. What is worth noting is that the density of the thinned potential feature points may be far greater than the average sampling density of the point cloud, and the thinned potential feature points may have a non-uniform distribution. To ensure the correct construction of the MST, the thinned potential feature points are downward sampled, so as to generate feature points whose density is the same as 
                              
                                 ρ
                                 ¯
                              
                            the average sampling distance of the point cloud. After the re-sampling, five nearest neighbouring points around the feature point within each feature line are searched, and the square distance between neighbouring points is regarded as the connection weight to establish the undirected connection graph of the feature points. Finally, the Prim algorithm is used to generate the MST of this connection graph and generate a feature line. Meanwhile, the angle between the directions of each line segment in the MST and the calculated direction vector of feature lines in the thinning process are checked. If the angle is larger than the given threshold, the corresponding line segment is expected to be removed from the MST.

The proposed algorithm is coded in C++, and is tested on a computer with an Intel Core i7-4770 CPU and 3 Gigabytes of RAM. While implementing the algorithm, a kd-tree is adopted to accelerate the search of neighbourhood points and OpenMP is used to process the part where parallel operation can be performed (such as the calculation of SSI and the thinning of the potential feature points).

As shown in Fig. 8
                        , the algorithm is tested on the Venus model first. The Venus model contains abundant feature lines including the significant feature lines in the eyes and the fringe and gentle feature lines in the top of the head, which makes it an ideal dataset for verifying the validity of the algorithm. The first row in Fig. 8 illustrates the extraction process of the feature lines using SSI, and it is found that SSI can favourably reflect the fluctuations in the model surface. Meanwhile, the concavity and convexity of the surface are well differentiated (the red and the blue indicate the concave and the convex zones respectively). Also, the accuracy of SSI is not much influenced by zero-mean random noise after amplitudes of 25% and 50% of the average sampling distance are added into the original data, which suggests that SSI shows strong robustness to noise. For comparison, the quadratic surface fitting and the SV are used to measure the degree of variation in the model surface. The measurement results are exhibited in the second, and third, rows respectively. Since SV cannot distinguish the concavity and convexity, signs are added using the method put forward in this research for the convenience of comparison. As illustrated in the comparison, the three methods all can achieve satisfactory results when performed on point cloud data containing no noise. However, with the increase in noise amplitude, the accuracy of the quadratic surface fitting decreases rapidly. Although the aforementioned problem can be improved by increasing the radius of neighbourhood used for fitting, the larger radius of the neighbourhood is expected to eliminate the characteristics of the detailed section. On the other hand, although SV can resist noise to some extent, it is not endowed with characteristicsofsymbols and its distinguishing performance is not as good as that of the SSI method. Therefore, it is unable to depict micro-surface changes of the face of the Venus model. Besides, when selecting potential feature points, it is hard to find a similar threshold value which can be used to select, and precisely distinguish, the potential feature points for the forehead and vertex with its hairs. For instance, the feature points for the vertex with hairs cannot be extracted accurately if the accuracy for the feature points of the forehead with hairs is ensured; although decreasing the threshold can ensure the complete extraction of the feature lines on the vertex, the potential feature points of varying feature lines for the forehead with hairs tend to be mixed, which results in an extraction failure. In contrast, SSI can favourably reflect the details of the model under different noise levels. As indicated in Fig. 8(e), SSI can completely extract the potential feature points for the forehead and vertex with hairs with the same threshold value. This reveals that the SSI method is superior to SV in terms of its resolving power. The fourth column lists the results calculated using non-uniform neighbouring points in Section 3, this also shows the favourable adaptability of SSI. The sixth column indicates the final feature lines obtained by thinning the potential feature points in the fifth column. As observed in the comparison, the extracted SSI results are proved to be the most ideal no matter whether from the perspective of the quantity of the extracted feature lines, or the integrity of the extracted single feature line.


                        Figs. 9
                         and 10
                         show the results obtained by applying our algorithm to real scanning point clouds. As shown in Figs. 11
                        (a) and (b), owing to the data are obtained through the scanning by line structured light when the movement interval of the scanning device is far greater than the point density of a single scanning line, they present an obvious non-uniform sample on the whole. Meanwhile, measurement noise is inevitably contained in the data due to interference from environmental light, and so on. These factors impair feature line extraction. According to the calculations, the average sampling distance of the data and noise level are 0.07mm and 0.2mm respectively in Fig. 5, and 0.06mm and 0.15mm separately in Fig. 6. Since the noise amplitude is greater than the sampling distance, according to the rules described in Section 4.1, the radius of neighbourhood is taken as 10 times the noise level to calculate the SSI. As seen in the calculated SSI results, the influences of the noise and non-uniform sampling on the calculation of SSI have been eliminated and the calculation results reflect the fluctuations in the surface. Furthermore, the results in Fig. 9(b) also clearly represent France, resulting in a better display than in the original data. Figs. 9(c) and
10
(c) represent the identified potential feature points, whose threshold value is 1.5 times the average absolute value of SSI. The extracted feature lines are shown in Figs. 9(d) and
10
(d). As shown, the crest lines in the model are extracted perfectly, and accurately, despite the existence of noise and non-uniform sampling.


                        Figs. 12
                         and 13
                         show the results of extracting feature lines respectively from the Dragon model and Happy Buddha model using the proposed algorithm. The point cloud data from two models are chosen from the vertices of their corresponding meshes. Since there are many irregular triangles in the surfaces, the data exhibit apparently non-uniform sampling. Moreover, by adding random noise (which is 0.5 times greater than the average sampling distance) to the point cloud data, the obtained point cloud data and their partially enlarged figures are as seen in Figs. 12(a), (b),
13
(a), and (b). By using regional segmentation, potential feature points subordinated to different feature lines can be distinguished. Meanwhile, regional segmentation can also be used to judge the direction vector of the feature lines and restrict the drifting direction of the potential feature points. Therefore, the algorithm proposed here can avoid shrinkage at the endpoints of the feature lines (such as the feature lines in the scales of the Dragon and the eyes of the Happy Buddha). Meanwhile, this algorithm avoids the breakage of the feature lines caused by non-uniform sampling, and the extracted feature lines are more complete (such as the feature lines in the head of the Dragon model and the foundation of the Happy Buddha).


                        Figs. 12 and 13 also show the extracted results using other published methods [12, 21, 28]. Among them, [12] used SV to do multi-scale feature extraction. As SV performed worse than SSI in terms of resolving power, so it can only extract main feature lines in the models. In [21], they adopted an approach similar to the iterative thinning method used in this work, but, did not constrain the drift direction of points in their thinning process, which caused significant shrinkage at the endpoints of each feature line. Elsewhere [28], the potential feature points are filtered and projected, then, the feature lines are connected based on the observed growth pattern. In this process, it is hard to select the optimal threshold value to be filtered: too small a threshold value causes the feature lines to be filtered, as indicated in Fig. 12(f), while too big a threshold value causes points inside the potential feature to be filtered, which can cause bifurcations of the feature lines (Fig. 13(f)).


                        Table 1
                         lists statistics from each experiment. The noise with amplitude of 0.25 times the average sampling distance is added to the experiment for the Venus model. Meanwhile, the running time at each stage and the total running time of the algorithm are listed. The running times for calculating SV, quadratic surface fitting, and the thinning algorithm of the potential feature points proposed in study [21] under the same calculation neighbourhood are also illustrated for comparison. According to the statistics, the calculation time of the method using SSI is the shortest among all methods tested. While thinning the potential feature points, since the proposed algorithm needs to determine the curve direction, it spends a longer time than the method proposed in study [21]. However, consequently, the proposed algorithm improves the quantity and quality of the extracted feature lines.

To validate how much feature lines are affected by noise and non-uniform sampling, the mesh surface corresponding to the point cloud data shown in Figs. 12 and 13 was performed re-sampling in the experiments in an attempt to generate uniform sampling point cloud data without containing noise. The feature lines extracted based on abovementioned data are demonstrated in Fig. 14
                        . The comparison between Fig. 14 and Figs. 12, 13 shows that the algorithm proposed in this research is able to approximately achieve ideal effects of point clouds in the presences of noise and non-uniform sampling.

@&#CONCLUSIONS@&#

The SSI is proposed to combine with the improved Laplace smoothing and thinning methods to generate a simple, effective algorithm for extracting feature lines from noisy and non-uniform sampling point clouds. SSI can accurately express the concavity and convexity of the surface and adapt to noise and non-uniform sampling very well. Moreover, after being applied to the regional segmentation of potential feature points, SSI is proven to improve the distinguish ability of spatially close feature lines and determine the trends therein adopting a greater spatial neighbourhood. Meanwhile, it can also be used to accelerate iterative thinning in Laplace smoothing, so as to determine the drifting direction of the feature points. As demonstrated in the experiment based on clean, realistic scanning data, the algorithm proposed in this work can extract feature lines from the models perfectly under the condition of noises and non-uniform sampling.

As holes are a limiting form of non-uniform sampling for data clouds, our algorithm cannot extract holes delimited by boundary lines. Besides, although the distinguishing features of the algorithm in this research can be greatly improved by regional segmentation of potential feature points, the algorithm cannot distinguish the two intersected feature lines with consistent concavity and convexity. This will influence the determination of the strike for the feature lines at any intersection. Even though such a case has little influence on the convergence of the algorithm, the thinned feature lines may deviate from their real locations. Future work is expected to find a possible solution by finding an index which can distinguish, and deal with, those cases with intersecting feature lines.

@&#ACKNOWLEDGEMENTS@&#

This work is sponsored in part by grants from Youth Foundation of Jiangsu Provence (Grant No. BK20140892) and NUPTSF (Grant No. NY213038). The Happy Buddha and the Dragon data are from The Stanford 3D Scanning Repository. The Armadillo, Venus, Nasa and Toy Turtle data are from the AIM@ SHAPE Shape Repository.

@&#REFERENCES@&#

