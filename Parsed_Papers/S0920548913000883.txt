@&#MAIN-TITLE@&#PoEML: Modeling learning units through perspectives

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           PoEML modeling of learning units is arranged in several perspectives.


                        
                        
                           
                           Perspectives' separation supports reusability, adaptability and flexibility.


                        
                        
                           
                           Dependencies among perspectives have been minimized and identified.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

E-learning

Educational modeling language

Separation-of-concerns

Perspectives

Instructional design

@&#ABSTRACT@&#


               
               
                  This paper introduces an Educational Modeling Language (EML) to support the computational modeling of learning units. These computational models can be processed by suitable e-learning systems to support the authoring and delivering of learning experiences. Nevertheless, the modeling of learning units is a complex endeavor, involving issues of expressiveness, reusability, adaptability and flexibility. This paper proposes the Perspective-oriented EML to simplify this complexity. In PoEML, the model of a learning unit is not a single piece, as in current EMLs, but it is made up by several perspectives, where each perspective is focused on non-overlapping specific issues.
               
            

@&#INTRODUCTION@&#

Models have brought important benefits in many areas (e.g., architecture, industry, and geology). They enable users to tackle complex problems while reducing the required user effort. Basically, users can draw their attention on the main issues of a problem while abstracting from less important details, which reduces the cognitive load that needs to be applied. From a practical point of view, models can be oriented to the support of three main purposes [1]: design, communication and realization. During design, models can be used to represent, think, evaluate and manage the possible solutions to problems. During communication, models facilitate the interchange of ideas and solutions, especially when they have a graphical representation. Models can also be used as guidance during the realization of the entities they represent. Nowadays computational models, when used by appropriate applications, support these three purposes to a large extent.

The adoption of models has also been seen as an interesting solution in the e-learning domain. Several computational languages have been proposed to enable the creation of models of learning units. Some of the names used to refer these languages are Educational Modeling Languages (EMLs) [2,3] and Instructional Design Languages (IDLs) [4]. The main distinguishing idea underlying EMLs is to enable the expression of models of learning units independently from their level of aggregation and pedagogical approach. In this way, an ideal EML should enable to model a course about classical philosophy based on a collaborative learning approach, a problem-based session in medicine, a competency-based course to get the car-driver license, a software-engineering course with a project-based approach, etc. Currently, IMS Learning Design (IMS-LD) [5–7] is de-facto standard in computational EMLs. Since its publication in 2003 the adoption of EMLs as computational modeling languages has attracted the attention of many people. Nevertheless these languages have not been adopted to a large extent [8,9]. Current EMLs are very complex and not expressive enough (as shown in Section 2.4). In addition, they are not very useful as issues of reusability, adaptability and flexibility remain to be solved.

This paper introduces a new EML to simplify and enhance the modeling of learning units. The language is named as Perspective-oriented EML (PoEML) and it is based on a separation-of-concerns approach. The key underlying idea of PoEML is to separate the models of learning units in several perspectives, each perspective focusing on a particular set of non-overlapping issues from the whole model. In this way, the complexity of the models is separated in several parts and the modeling task can be tackled in a simpler and more structured way. This key idea is similar to the use of several plans to design buildings. The complete plan of a building has to include several plans, each one of them focused on specific issues: a Location Plan, a Site Plan, Architectural Sheets, Structural Plans, a Plumbing Plan, an Electrical Plan, etc. Basically, these plans of the building provide different perspectives and, in conjunction, they offer a whole picture of the complete building. Following this basic separation-of-concerns idea, PoEML approaches the modeling of learning units through several perspectives. Each perspective involves the modeling of a part of the whole learning unit in a way that is (almost) separated from the other perspectives. As a result, the proposed EML is able to extend the expressiveness of the language while its complexity can be controlled. In addition, as each perspective can be modified (almost) separately from other perspectives, the reuse, adaptation and flexibility of the models is facilitated.

The rest of the paper is organized as follows. The next section includes a general description about EMLs. Then, the PoEML proposal is introduced by describing its foundation and conceptual model. Following this introductory description, the language is shown step by step. Next, a demonstration example of the modeling of a learning unit through perspectives is included. Then, the results of a hands-on experience of the language with real teachers are described. The paper ends up with the main conclusions.

EMLs are the most important initiative up to date to support the modeling of learning units. This section introduces EMLs describing their foundation, goals and main features.

EMLs come from an important lack of pedagogical consideration in current e-learning systems [10]. From a practical point of view, existing e-learning systems are focused on supporting the development of a certain type of learning unit. One of the most common examples is page turning and single learner tracking (e.g., Blackboard). Nevertheless, such systems are not appropriate to support learning units of a type different from the one they are focused on. As a result, the support of learning units of different types requires several specific software systems. In addition, the use of different systems brings reusability, adaptability and flexibility problems, as usually it is not easy to change one system by another.

The main idea underlying EMLs is to support the modeling of learning units enabling the representation of the variety of pedagogical approaches. In this way, during design-time, an EML allows the creation of models of different kinds of learning units. Later, during run-time, the learning unit models are used to support the execution of an appropriate e-learning system, controlling and managing the learning unit enactment as it is specified in the model. In this way, this solution enables to use a single e-learning system to satisfy multiple learning needs.

This role of EMLs in education is similar to the role of modeling languages in other domains, such as the musical notation in music. The musical notation is used to represent compositions that later can be played by musicians. The musical notation can be used to represent different musical styles. In addition, a musician that can read the musical notation can also play compositions in accordance with different styles. Therefore, the key point is that EMLs and musical notation are both used as intermediary tools between the design-time and the run-time, facilitating the separation and integration of the two stages.

At the present time, EMLs have a similar basic structure focused on tasks (or activities
                           1
                        
                        
                           1
                           In general the terms “activity” and “task” are used interchangeably. Alain Wisner makes an important distinction between them [11]; “Tasks are what managers set—they are the prescribed work. Activity is what people actually do.”
                        ) and process specification [5] (see Fig. 1
                        ):
                           
                              •
                              The Task is the basic building block. Any learning unit is modeled as a set of Tasks. Each Task relates one or several Roles (e.g., learners and academic staff), with a certain work to be done and a certain Environment, containing the Resources and Tools available to perform such a task.

The Process is the “glue” among tasks, introduced to enable their control. There are several issues that can be considered in this control, being two of the more common ones:
                                    
                                       -
                                       The Control Flow which is used to indicate what tasks have to be worked out at each time. In Fig. 1 Act.2 can be performed after Act.1; Act.3 and Act.4 can be initiated when Act.2 is completed; and finally Act.5 can be initiated when both Act.3 and Act.4 have been completed.

The Data Flow which is used to indicate how and when data and contents have to be transferred among tasks and other elements (e.g., Environments, Tools).

The modeling of these issues is performed in different ways on each one of the existing EMLs. For example, the specification of the control flow is described using block structures in some languages (e.g., Plays and Acts in IMS-LD), while other languages use control connectors. Anyway they share most of the conceptualizations and the definition of Roles, Environments and Resources is recognized in all the languages.

During the last years, several EMLs have been proposed that differ on their orientation, structure or approach. Particularly, two of the main interests have been devoted to the linkage between Instructional Design and EMLs, and to the support of collaborative learning. Next some of the more relevant EML proposals are reviewed:
                           
                              •
                              
                                 OUNL-EML 
                                 [10]. It was the first language that received the name of EML, developed in the Open University of the Netherlands (OUNL). This language embodies most of the concepts that define these languages: activities, roles, environments, etc. Nevertheless, the definition of the control flow and data flow was not expressive enough.


                                 PALO 
                                 [12]. It was proposed in the Universidad Nacional de Educacion a Distancia (UNED) of Spain. It is especially devoted to model self-paced learning through a process-based approach. In this way it shares the focus on tasks and processes with EMLs. The study of this proposal is interesting to view the transition from content-structured proposals, such as SCORM [13], to EMLs.


                                 IMS-LD 
                                 [5]. It was developed by the IMS consortium taking as foundation the OUNL-EML and integrating other IMS specifications, such as: Meta-data, Content Packaging, Question and Test Interoperability, etc. A key concern on the development of this specification was its complexity. To address this problem, the specification was proposed in three levels of compatibility (Levels A, B and C). Each level of compatibility offers a different level of expressiveness in relation with the kind of behaviors that can be supported. Basically, these three levels involve: Level A—predefined behavior; Level B—conditioned behavior in accordance with the value of data elements; Level C—event-based behavior in accordance with the appearance of events.


                                 CPM 
                                 [14]. It involves an UML [15] profile for cooperative Problem-Based Learning (PBL) scenarios. The focus of this proposal was mainly the high-level (not executable) design of learning units, taking into account issues such as learners' grouping and management. There are other similar proposals also based on UML, such as CoUML [16], where UML is also extended focused on the modeling of collaborative learning units.


                                 CSCL-script formalization 
                                 [17]. This language introduces some new elements to facilitate the modeling of Computer-Supported Collaborative Learning (CSCL) scripts [18]. Basically, the new elements enable the capture of events produced during the execution of the learning unit and to perform actions. This functionality gives more expressiveness in relation with the support of collaborative learning units, but it also introduces more complexity.


                                 E2ML 
                                 [19]. This is a graphical language proposed from an instructional design point of view. Its main purpose is to facilitate the modeling of learning units by offering clear diagrams for final users. It does not produce any executable code.


                                 MISA/MOT 
                                 [20]. This proposal is based on the concept of “instructional engineering.” It is also a graphical language where instructional design ideas and concepts are taken into account. The generated models are not executable, although a mapping to IMS-LD has been proposed to enable the use of the graphical elements of MISA/MOT to create and produce IMS-LD models.

In some cases the proposed EMLs do not support the computational enactment, but they are just focused on design and communication. IMS-LD supports the computational execution of models and several design-time and run-time applications are available. E2ML and MISA/MOT are oriented to perform instructional design, as they consider learning goal description. CPM and CSCL-script formalization are particularly oriented to enable enhanced descriptions of collaborative learning units.

In addition to these languages, there are some other proposals related with EMLs, but they have not achieved an appropriate maturity or they have not been developed as modeling languages. Some of the more important ones are: LAMS [21], a Learning Management System (LMS) inspired by IMS-LD and based on the process approach; Xedu [22], an EML devoted to analyze the development costs of software systems to support EMLs; COW [23], a workflow-inspired language; Active Document [24], a LMS and a language based on the description of activities and processes focused on the support of chemical experiments for learning; and LDL [25], an EML focused on the interchanges of artifacts (e.g., data elements, messages) that can be produced among participants in tasks.

A main conclusion of the review about EMLs is the existence of expressiveness and complexity problems [8,9]. On the one hand, existing EMLs are not expressive enough to cover the variety of pedagogic approaches. IMS-LD is the most mature EML, but several initiatives have identified expresiveness deficiencies and new languages have been proposed to solve them [26,27,21] in relation with collaborative learning, PBL, instructional design, etc. On the other hand, the authors of IMS-LD themselves have recognized (from the beginning) its complexity [28,8], and although it was published with three levels it has not been adopted to a large extent.

Existing EMLs also involve problems of reusability, adaptability and flexibility [8]. Firstly, it is very important to facilitate the reuse of models of learning units by final users, as they may be reused completely or partially. Secondly, models should not be rigid, but they should include variations to adapt themselves to the particular features of the context or persons involved (e.g., the previous qualifications of learners). Finally, learning units need to be changed dynamically in unexpected ways depending on their development. At this point it is important that models be flexible enough to allow such changes without requiring too much effort. These three issues need to be solved in order to facilitate their adoption by e-learning users [29,30].

This section introduces conceptually a new EML that enhances the expressiveness of existing EMLs while controlling the complexity and observing capabilities such as reusability, adaptability and flexibility. In conjunction, these requirements seem clearly opposite. To tackle with this contradiction a separation-of-concerns approach has been adopted. Basically, the modeling of educational units is not addressed as an all-or-nothing task, as in existing EMLs, but the learning units are observed from several perspectives that are modeled separately (but not independently). Following this approach the new EML has been named Perspective-oriented EML (PoEML).

The key strategy for the development of PoEML has been the separation-of-concerns principle. Separation-of-concerns is a long-standing idea that simply means that a large problem is easier to manage and solve if it can be broken down into parts and each part can be approached separately. It is an important design approach in many areas, such as software design [31], used to facilitate the understanding, design and management of complex systems. In addition, UML [32] is a modeling language for software engineering where different diagrams are proposed to model different issues: use cases, analysis, design, etc.

Another important principle of PoEML is the Activity Theory 
                        [33]. This theory has been used to analyze the issues involved in learning units and to identify an appropriate separation-of-concerns [34]. The Activity Theory is a meta-theory about activities and their constituent components [35]. Considering that any learning unit can be described as a set of tasks (activities during the run-time), the Expanded Mediation Model conceived in this theory provides an interesting framework to identify a suitable separation-of-concerns (see Fig. 2
                        ). The core of this model is that any activity involves a subject playing a role acting on an object to achieve a certain goal. The connection between the subject and the object is influenced by the environment and the community where the activity is performed. In other words, the work on the activity depends on the environment and the community. The environment contains the tools and resources that can be used by the subject to act on the object. The community puts the stress on the social context where the subject operates, involving the influence of two new issues: rules and division of labor. The rules component highlights the fact that within a community, subjects are bound to rules and regulations that affect the way they interact in the activity, including also the interaction with the environment and its elements. The division of labor refers to the breaking down of the goal into sub-goals and the distribution of responsibilities among the available subjects. As a result new subsidiary activities (sub-activities) are produced.

The Activity Theory has guided us in the separation-of-concerns in learning units towards the identification of 13 perspectives. Fig. 2 shows how several perspectives are located in relation to the Expanded Mediation Model. These perspectives can be modeled using the PoEML packages (see Section 4). At this point our assumption has been that as collaborative learning involves the performance of collaborative activities, and collaborative activities can be fully analyzed using the Activity Theory Expanded Mediation Model, then if we were able to model all the elements identified by Activity Theory we would provide a good support to collaborative learning approaches. Particularly, we found that existing EMLs did not recognize all the elements involved in the Activity Theory and therefore we conclude that their expressiveness could be enhanced.

The PoEML conceptual model describes the main concepts of the language and the relations between them. From a conceptual point of view PoEML is mainly characterized by two important elements: the definition of a new task concept and the adoption of a hierarchical structure. In addition, there is one root element with special components.

As other EMLs PoEML is a process-based language. Nevertheless, the task concept has a significative distinguished element and therefore it is given a special name: the Educational Scenario (ES). An ES involves two key features:
                              
                                 •
                                 An ES can include one or several Goals recognized as first-class entities. In existing EMLs goals are represented just as a textual description that informs participants about what they have to do at each task. In PoEML a Goal includes its own identifier, description, input and output parameters and control information to determine its state during execution. Existing EMLs also enable to represent these parameters and control information, although it is not included as part of the goals, but in the relations between tasks and interleaved with the specification of the learning unit structure; making it very difficult and complex to change the control related with the goals of a learning unit without changing its structure.

An ES can include not just elements (namely: Goals, Roles, Environments, and Data Elements), but also specifications related to its control. Particularly, an ES includes specifications that support the modeling of the issues such as assignment of permissions to participants, notification of events, invocation of operations, order among Sub-ESs and temporal planning of Sub-ESs. In addition, this is performed in a constrained way as the controls involved in these specifications can only affect the elements included in the same ES.

In this way, the ES provides a completely encapsulated model that facilitates a separation-of-concerns approach to the modeling of learning units. On the one hand, an ES does not make reference to any issue outside of its own contained elements. On the other hand, each one of these elements and specifications is considered at a different perspective. In practice, the model of an ES is made up by the (sub-)models of its Goals, Roles, Environments, Data Elements and specifications of Authorization, Awareness, Interaction, Order and Temporal. In addition, all these elements and specifications are modeled as first-class entities, each one of them involving its own unique identifier, sub-elements and control information. This model is completely different from the theatrical model adopted on IMS-LD, where several concerns are modeled in an overlapping way.


                           Fig. 3
                            illustrates this ES concept. It shows how an ES can include several elements: Goals (at least 1), Roles, Environments, Data Elements and Causal Descriptions; and specifications: Awareness, Authorization, Interaction, Order and Temporal. Notice that Goals, Roles and Environments can also include Data Elements.

The previous conceptual view is completed by considering the hierarchical aggregation of ESs to model learning units. Basically, any model of learning unit is made up by several ESs that are aggregated in a hierarchical way. The hierarchical aggregation of ESs indicates that a certain ES (parent-ES) can be made up by several ESs (sub-ESs or children-ESs).

In addition to the hierarchical structure, a learning unit can require the establishment of relations between Goals, Roles, Data Elements, sub-ESs and Environments of different ESs that are described as Flows:
                              
                                 1.
                                 The Functional Flow involves the relations that can be established among Goals included in ESs. These relations can be of two different types:
                                       
                                          •
                                          Completion relations. They can be used to indicate what conditions over the state of some Goals have to be satisfied in order to complete a certain Goal (generally this Goal is contained in a parent-ES and the other Goals are in its sub-ESs). For example, to obtain the car driving license it is required to pass the theoretical test and succeed on the practical exam.

Attempt relations. These relations can be used to indicate what conditions over the state of some Goals have to be satisfied to enable the attempt of other Goal (generally all these Goals are contained in sub-ESs of the same parent-ES). For example, the practical exam can be attempted when the theoretical test has been passed.

The Participants Flow involves the relations that can be established among Roles included in different ESs. They are used to represent the assignment/transfer of participants to/among Roles. For example, the assignment of learners to a Role “team,” made up by four learners.

The Data Flow involves the relations that can be established among Data Elements, indicating the transfer of data among them. For example: the grade obtained in the assessment of a questionnaire has to be transferred to the next ES and also maintained in the transcript of the learner.

The Control Flow involves the relations that can be established between the sub-ESs of a certain ES. Basically, this flow indicates what sub-ES can be done at a certain moment. It can be determined in two different ways:
                                       
                                          • In relation with the state of availability of other ESs. The state of availability of an ES usually depends on the state of achievement of its contained Goal(s). For example, when the learner passes the theoretical exam, the examination ES is closed and the practices assigned are opened.
                                                2
                                             
                                             
                                                2
                                                Notice that instances of ESs are opened and closed, meanwhile instances of Goals can be attempted, passed and failed.
                                             
                                          

• In accordance with a temporal planning. For example, the presentation of the subject is going to be produced on March 11 at 5pm. Another example, the final exam has to be performed in less than 1h.

There is not any Environment Flow as the contents of the Environments cannot be transferred, but it is possible to establish relations between Environments. For example, the lab used to perform the final practice exam has to be the same lab where the learners performed all the practices.

We would like to stress that the modeling of each one of these issues can be performed using a different PoEML package (see next section) producing as a result a specific (sub-)model. In addition, this modeling is done in a structured way, as the relations have to be established among elements included in the same ES or in its sub-ESs.

There is an important relation between the Control Flow and the Functional Flow. The Control Flow indicates when an ES can be accessed and when it is closed. Similarly, the Functional Flow indicates when a Goal can be attempted and when it is satisfied or failed. This distinction between Control and Functional flow (and between ESs and Goals) is not found in existing EMLs. On the contrary in PoEML this separation is clearly established bringing a lot of flexibility.

This hierarchical structure is represented in Fig. 4
                           . There is as a main block, representing the Root-ES, that contains two blocks representing sub-ESs: ES A and ES B. In addition, ES A contains three further sub-ESs: ES A.1, ES A.2 and ES A.3. The figure shows this structural arrangement and the relations established between its contained Goals, Roles and Data Elements. It is quite clear that to show all these issues in a single picture is more confusing that to show them in several non-overlapping perspectives.

To complete this conceptual model it is necessary to introduce the concept of Root-ES. The Root-ES represents the global learning unit as it aggregates all the other elements, including the sub-ESs. It can include the same elements than any other ES. In addition, as it represents the global learning unit, it can also include further elements that capture the connections of the learning unit with the “outside world”. This outside world is composed by real resources, tools, participants, environments and organizations that exist outside of the learning unit. For example, a learning unit model should enable indicating that a certain PDF document has to be used. The connections between these external elements and the model of the learning unit are established in the Root-ES and they can be referenced from any sub-ES of the Root-ES, independently of its depth level in the hierarchical structure of ESs. The specification of tools and organizations involves special features and it is performed in specific perspectives.

In this way, from a conceptual point of view, an ES is an encapsulated entity including all the elements that build it up and the specifications that define its structure and behavior. Furthermore, a Root-ES is a hierarchical and structured model that can represent any piece of learning at different levels of aggregation, from simple lessons to complete curricula, and that includes all the connections with the “outside world” required to perform its enactment.

PoEML is organized in 13 packages corresponding with the 13 perspectives in which the concerns involved in learning units have been separated. Each one of the packages is focused on supporting the modeling of the elements and issues considered in the corresponding perspective. This section describes PoEML package by package.

The Structural Package is devoted to model ESs and its aggregation into hierarchies. This hierarchical structure represents the skeleton of any learning unit, which can be complemented with specifications (performed with the other packages) introducing further details. Models of learning units are provided as a set of hierarchical aggregated ESs, each ES containing:
                           
                              •
                              Other ESs. They can be used to break down a certain ES (parent-ES) into several parts (sub-ESs or children-ESs). Each one of the sub-ESs is an ES in itself and therefore it can include all the elements described in this list.

Goals. At least one Goal has to be included in each ES to indicate what has to be done. Goals can be modeled using the Functional Package (see Section 4.2).

Roles. They indicate who has to be involved in the ES and in which function. No specific participants are modeled. Roles can be modeled using the Participant Package (see Section 4.3).

Environments. They are locations (physical or virtual) containing resources. The Environments and their resources can be used by the participants to work on the ES. Environments can be modeled using the Environment Package (see Section 4.4).

Variables. They are Data Elements used to maintain control information related with the ES. Variables can be modeled using the Data Package (see Section 4.5).

Authorization Specifications. They are used to indicate the assignment of permissions to Roles. Authorization Specifications can be modeled using the Authorization Package (see Section 4.8).

Awareness Specifications. They are used to indicate how to process the events produced during the enactment of the learning unit and who has to be informed of relevant events. Awareness Specifications can be modeled using the Awareness Package (see Section 4.9).

Interaction Specifications. They are used to indicate the invocation of operations in an automatic or semi-automatic way. Interaction Specifications can be modeled using the Interaction Package (see Section 4.10).

Order Specifications. They are used to indicate the order in which the sub-ESs of an ES have to be performed. Order Specifications can be modeled using the Order Package (see Section 4.11).

Temporal Specifications. They are used to indicate temporal indications and constraints about the start and finish times of the sub-ESs of this ES. Temporal Specifications can be modeled using the Temporal Package (see Section 4.12).

Causal Descriptions. They are used to describe the ES providing information about its rationale, purpose, strategy, context, etc. Causal Descriptions can be modeled using the Causal Package (see Section 4.13).

It is possible to include several items of each type. Regarding the elements, these items can be modified with an instance number. For example, if an ES includes two learners, it can be modeled as just one Role learner and a number of instances two. Similarly, it is possible to include activation expressions to determine if each one of the included specifications has to be used or not during enactment. For example, a cooking course includes one order specification and one temporal specification. The temporal specification is used if the learners experience the course face to face. The order specification is used if the learners experience the course by the Web. This can be modeled by relating each specification to opposite activation expressions.

The following code is an excerpt of the XML Schema Definition of the PoEML ES_type. It can be observed how the different elements and specifications are represented as different entities in the schema, each one of them including its own type definition. Eventually, any ES is made up by a combination of these elements and specifications that can be included in any number. In addition, it is possible to indicate the number of instances of each element and the activation of each specification.
                           
                              <
                                 xs:complexType name = “ES_Type”>
                                 
                                    
                                       <
                                          xs:complexContent
                                          >
                                             
                                                <
                                                   xs:extension base = “poeml:Instance_Element_Type”
                                                   >
                                                      
                                                         <
                                                            xs:sequence
                                                            >
                                                               
                                                                  <
                                                                     xs:element name = “Components”>
                                                                     
                                                                        
                                                                           <
                                                                              xs:complexType
                                                                              >
                                                                                 
                                                                                    <
                                                                                       xs:sequence
                                                                                       >
                                                                                          
                                                                                             <
                                                                                                xs:element name = “Goal” type = “poeml:Goal_Type” maxOccurs = “unbounded”>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                                </xs:element
                                                                                                >

<
                                                                                                xs:element name=“Role” type = “poeml:Role_Type” minOccurs = “0” maxOccurs
                                                                                                
                                                                                                =“unbounded”>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                                         </xs:element
                                                                                                         >

<
                                                                                                xs:element name = “Environment” type = “poeml:Env ironment_Type”…
                                                                                                >
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                                         </xs:element
                                                                                                         >

<
                                                                                                xs:element name = “Variable” type = “poeml:DataEl ement_Type”… >
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                                </xs:element
                                                                                                >

<
                                                                                                xs:element name = “CausalDescription” type = “poe ml:CausalDescription_Type …”>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                                         </xs:element
                                                                                                         >

<
                                                                                                xs:element name = “Authorization_Specification” type = “poeml:AuthorizationSpecification_ Type” …/>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      

<
                                                                                                xs:element name = “Awareness_Specification” type = “poeml:AwarenessSpecification_Type” …/>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      

<
                                                                                                xs:element name = “Interaction_Specification” type = “poeml:InteractionSpecification_Type” …/>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      

<
                                                                                                xs:element name = “Order_Specification” type = “ poeml:OrderSpecification_Type” …/>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      

<
                                                                                                xs:element name = “Temporal_Specification” type = “poeml:TemporalSpecification_Type” …/>
                                                                                                
                                                                                                   
                                                                                                      
                                                                                                         …
                                                                                                      


                                                                                       </xs:sequence
                                                                                       >


                                                                              </xs:complexType
                                                                              >


                                                                     </xs:element
                                                                     >

<
                                                                     xs:element ref = “poeml:ES”/>
                                                                  


                                                            </xs:sequence
                                                            >


                                                   </xs:extension
                                                   >


                                          </xs:complexContent
                                          >


                                 </xs:complexType
                                 >

The Functional Perspective is about the Goals that have to be attained in a learning unit. The Goals included in an ES specify the work that has to be performed by the participants on it. For example, a Goal can be “to produce a basic transistor circuit” or “to evaluate the learners.” These Goals are different from learning goals that refer to a desired knowledge, skill, or capability. Taking into account this focus, the Functional Package is used to model Goals and relations among Goals. In PoEML a Goal can include the following elements:
                           
                              •
                              A name and a verbatim description to inform participants about what they have to do.

Input Parameters and Output Parameters. They are Data Elements used to indicate the data provided to perform the Goal and the data that has to be produced to satisfy it, respectively. For example: “A document including specifications of a problem to be solved”, “The qualification obtained by a learner in an evaluation.” These parameters are characterized in accordance with the Data Element of the Data Package (see Section 4.5).

Input Constraints and Output Constraints. The Input Constraints enable control when a Goal can be attempted. For example: “The software tool that supports the design of microprocessors must be available,” “The learner must have obtained a qualification greater than five in a previous questionnaire.” On the other hand, Output Constraints enable to control when a Goal has been satisfied. For example: “The document containing the microprocessor design has been delivered.”

Attempt connections. They can be established among the Goals of the sub-ESs of a certain ES. They enable control of the attempt of a Goal in accordance with the state of other Goal(s). For example, the Goal “performing the lab practice” cannot be attempted in case the Goal “viewing the solution to the lab practice” has been satisfied.

Completion connections. They can be established between the Goals of the sub-ESs and a Goal of the corresponding parent-ES. They enable controling the accomplishment of the Goal of the parent-ES in accordance with the satisfaction of the Goals of the sub-ESs. For example, the Goal“To examine the learners” has the following possible specializations: “To take a written examination”; “To take an oral examination”; “To take a portfolio examination”; etc. In case any one of the specializations is satisfied the general Goal is satisfied. Another example, a practice has as a Goal “to develop a software application.” This Goal is broken down into the following Sub-Goals: “to perform the analysis”; “to design a solution”; “to program the design”; and “to perform tests.” All these Sub-Goals have to be accomplished to satisfy the general Goal.

The Participant Package is used to model Roles and the transfer of participants between Roles. At different with existing EMLs, in PoEML every ES needs to declare its own Roles. In addition, the way in which Roles are populated (namely, participants are assigned to Roles) is by taking participants from the parent-ES Roles. There is just one exception, the Roles of the Root-ES are populated with external participants or with the members of an organizational structure. A Role can be modeled through the specification of the following elements:
                           
                              •
                              A name and a verbatim description to inform about the purpose and function of the Role.

Properties. They are Data Elements used to indicate the data that has to be associated with the Role. The value of the Properties during the execution will correspond with the particular participant assigned to the Role. Some examples of Properties associated with a Role: personal data as name, surname, address; previous knowledge, etc. These Properties are specified using the Data Package (see Section 4.5).

Sub-roles. The definition of groups is supported by the aggregation of Roles, creating composed Roles. For example a project team is made up by the following Roles: one leader, three developers, one tester and one supervisor.

Connections with the Roles included in sub-ESs. These connections specify how the participants assigned to the Roles of a parent-ES are transferred to the Roles of the sub-ESs. There are four different kinds of Role transfer connectors: (i) selection connectors to take several participants from a larger set; (ii) election connectors to take exactly one participant from a larger set; (iii) relation connectors to constraint possible selections/elections to the results of previous ones; and (iv) assignment connectors to distinguish between forced assignment and voluntary assignment.

The Environment Package is used to model Environments. Environments can be defined in an abstract or concrete way. In other words, it is possible to describe the general features that have to be provided by the Environment or to refer to an existing Environment. PoEML also distinguishes between virtual or physical environments. An Environment can be modeled through the specification of the following elements:
                           
                              •
                              A name and a verbatim description to identify and inform about the Environment.

The virtual or physical nature of the Environment.

The location in case it is an existing Environment. It can be a reference to an Environment included in a previous ES.

Sub-environments. An Environment can be made up by other Environments. For example: “A laboratory room is made up by a working environment and a test environment.”

Artifacts. They are Data Elements used to include documents and information in the Environment. These Artifacts are characterized using Data Elements in the Data Package (see Section 4.5). Some examples: “A document explaining a concept”, “A variable indicating the grade obtained in a questionnaire.”

Tools. They are applications or services that provide a certain functionality. The specification of these Tools is considered in the Tool package (see Section 4.6).

In addition, this package also identifies the Class element. This element is used to support the classification of the resources included in an ES. Each resource can be assigned to one Class. For example: “Resources for expert learners and resources for novice learners”. The use of the Class element facilitates the control of the resources, as they can be managed in conjunction through the Class they belong to.

The Data Package is used to model Data Elements and the transfer of data among them. A Data Element is an entity used to maintain information that may be included in ESs, Goals, Roles and Environments to model Variables, Parameters, Properties and Artifacts respectively. They can have different data types: boolean, integer, real, date, string, file, record, URI, etc. A Data Element can be modeled through the specification of the following elements:
                           
                              •
                              A name and a textual description to identify and inform about the Data Element itself.

A reference to an external source where the content of the Data Element has to been taken from or delivered to. This element can be used to transfer information to or from the external context.

A default content for the Data Element.

Connections with other Data Elements. These connections cam be used to indicate how the contents of this Data Element have to be transferred to other Data Elements. These connections can be established in three different ways:
                                    
                                       -
                                       By reference. A Data Element establishes a link with other Data Element and they have the same content, always.

By copy. A Data Element takes the content of other Data Element at a certain time. The Copy can be synchronous (it is produced when the sink Data Element is created) or asynchronous (it is produced at a specific time).

By Transformation. It involves the operation of the contents. Some operation types are: Boolean (e.g., >,<,=,<>, AND, OR), Arithmetic (e.g. ,+,−,∗,/), string processing (e.g. sub-string, delete).

The Tool concept is used to represent the applications and services that can be used in a learning unit (e.g., simulators, editors, communication services, collaboration services). Tools can be fixed during the design-time, establishing that a specific item has to be used; or they can be described in an abstract way, enabling their dynamic binding just before or during run-time. In other words, Tools provided by different vendors that satisfy the required functionality can be used. Users participating in an ES can access and use those Tools contained in the Environments included in the ES.

The Tool package enables to model Tools in the root-ES. The modeling of Tools involves the following four types of issues:
                           
                              •
                              Features. General functional and non-functional features.

The Permissions that have to be supported by the Tool in order to enable their assignment to final participants.

The Events that have to be provided by the Tool in order to enable their capture and processing.

The Operations that have to be supported by the Tool in order to enable their automatic or semi-automatic invocation.

Notice how the last three issues are directly related with the Authorization, Awareness and Interaction perspectives (see Sections 4.8, 4.9 and 4.10). The specification of these characteristics of Tools is a requirement to enable their use in the modeling of such specifications.

This perspective refers to the required organizational structure of the participants involved in the learning unit. This information can be used to constrain the behavior of other perspectives. For example, the assignment of a teacher to an evaluation activity may depend on her/his position in the organizational structure.

The Organizational Package is used to model organizational structures. They involve the specification of the following issues:
                           
                              •
                              Organizational Positions. They are used to specify functions and responsibilities assigned to a certain person. For example, the dean.

Organizational Units. They are used to specify functions and responsibilities assigned to several persons. For example, the professor and assistants involved in a certain subject.

Organizational Structure. They are made up by organizational units, positions and other organizational structures. For example, a department in a university.

Authorization involves participants' rights to access Environments, Data Elements and Tools. For example, a simulator may provide two different permissions: “expert” and “novice”. Teachers may be assigned the “expert” permission while learners are assigned “novice”.

The Authorization Package is used to model Authorization Specifications, establishing the assignment of Permissions to participants. A Permission is an entity used to grant access to certain functionalities. These specifications involve three key issues that have to be arranged appropriately:
                           
                              •
                              Permission sources. Permissions are provided by the Tools included in the Environments and by some PoEML elements (e.g., Goals have attempt and completion permissions). The Permissions provided by a certain Tool have to be explicitly modeled in the Tool package.

Permission operators. There is just one permission operator to create aggregations of Permissions.

Permission sinks They are the persons that are assigned the Permissions.

This package and the next two ones (Awareness and Interaction) are key to model collaborative learning units. This kind of learning units can be conceived in many different ways and these packages enable them. In addition, the modeling in these three packages is considered in a very similar way, involving sources, operators and sinks.

Awareness refers to the processing of run-time information (events) and the notification of relevant events to participants interested on them. For example, in many learning units it is very important that teachers are aware of learners' actions. Nevertheless, as important as this is, it is not to overload the teacher with excessive information. Therefore, awareness involves giving the right participant the appropriate information and avoiding information overload. To accomplish this, awareness should be focused, customized, and temporally constrained [36].

The Awareness Package is used to model Awareness Specifications, establishing the capture, processing and notification of Events. Events are entities used to indicate a certain occurrence. They include some parameters to maintain relevant information associated with such occurrence. These specifications involve three key issues:
                           
                              •
                              Event sources. Events are provided by the Tools included in the Environments and by some PoEML elements (e.g., Tasks generate init and finish events). The Events provided by a certain tool have to be explicitly modeled in the Tool package.

Event operators. Events can be processed using several kinds of operators: filters, aggregations and correlations. The processing of Events with these operators takes into account their parameters.

Event sinks. There are two kinds of receptors for processed events: a person (such as a teacher interested on the events produced by learners); and an interaction specification, as explained in the following section.

The Interaction Perspective is about the performance of automatic or semi-automatic Operations in Tools. An Operation is a functionality that can be invoked in a Tool, involving input and output parameters. Many of the controls required to support collaboration among a group of participants involve the invocation of operations in collaborative tools at certain time points or as result of Events. This perspective involves the mechanisms required to support the invocation of Operations.

The Interaction Package is used to model Interaction Specifications, establishing the invocation of Operations in an automatic or semi-automatic way. These specifications involve three key issues:
                           
                              •
                              Operation sources. Operations are provided by the Tools included in the Environments and by some PoEML elements (e.g., environments have operations to add and remove Data Elements). The Operations provided by a certain Tool have to be explicitly modeled in the Tool package. In addition, all the elements of PoEML also provide some default Operations. For example, Data Elements include an Operation to reset their content.

Operation operators. Operations can be combined using the following operators: sequence, parallel, if-then-else and loop. The combination of Operations also requires the management of the input and output parameters. In other way, it is necessary to indicate the Data Flow of these parameters. This can be performed with the Data Package.

Operation sinks. Operations can be invoked on two difference ways: (i) under the occurrence of a certain Event, detected with an Awareness Specification; and (ii) under the decision of a certain participant. Therefore, the receptors of these Interaction Specifications are Awareness Specifications or participants.

The Order Perspective is about the relative order in which ESs can be accessed. It indicates whether they can be accessed in sequence or in parallel, to set synchronization points among several ESs performed in parallel, etc.

The Order Package is used to model Order Specifications. Each ES can include one or several Order Specifications indicating the order in which its sub-ESs can be accessed. Such specifications can use the following connectors among sub-ESs:
                           
                              •
                              Sequence. It describes a point where an ES can be accessed when the previous ES has been closed.

Unordered Sequence. It describes a situation where several ESs can be accessed in sequence, but with no predefined order in which they must be performed. The order is decided during the execution.

Parallel Split. It specifies a point where several ESs can be accessed and performed in parallel.

Loop. It specifies a point where a return to an already finished ES can be produced if required.

Merge. It specifies a point where several ESs that were being performed in parallel converge. Each time one of the ESs is closed a new instance of the next ES is created and opened.

Synchronization. It specifies a point where several ESs that were being performed in parallel converge. To open the next ES, all parallel ESs must be closed.

The Temporal Perspective is about temporal constrains associated with initiation and finish of ESs. An example of temporal constraint would be to indicate that a lab practice must be initiated by 14:00 and that it has to be finished in 2h.

The Temporal Package is used to model Temporal Specifications. Each ES can include one or several Temporal Specifications indicating the time at which its Sub-ESs can be done, namely when they are opened and closed. As conflicts can appear between the Order and Temporal specifications it is possible to indicate the priority of each one of them. Temporal specifications are modeled through the use of operators associated with actions such as the start, finish or duration of ESs. The operators that can be used are the following ones:
                           
                              •
                              Equality. It is used to specify that action A has to be performed just when another action B is produced.

Hard-Before. It is used to specify that action A has to be performed before another action B is produced. If action B is produced and A has not yet been produced then action A is forced to be performed.

Soft-Before. It is used to specify than action A can be performed before another action B is produced. If action B is produced and A has not been produced yet then action A cannot be performed.

After. It is used to specify that an action A can be performed after action B is produced.

The Causal Perspective involves the description of the elements and relationships included in the models of learning units. This data is not used to execute the models, but to inform interested users (e.g., designers, teachers) about the purpose of the whole model or about some particular issue.

The Causal Package is used to model Causal Descriptions. Each element and specification included in a model can include its own Causal Descriptions. These descriptions can be simple verbatim descriptions or more complex structures, such as meta-data records with ontological descriptions.

To support the use of PoEML an XML binding and a graphical representation have been produced [37]. The XML schema is devoted to produce models as XML documents, facilitating their interchange among software tools. The graphical representations are devoted to facilitate the understanding by human beings, supporting the design and communication between teachers, designers and any other person interested in the models. It is important to mention that both the XML documents and the graphical representation are also arranged in accordance with the 13 perspectives.

We have also developed a graphical authoring tool named JPoEML. This tool enables the composition of PoEML models using the graphical notation and generates automatically XML documents in accordance with the XML schema. Fig. 5
                      shows the main user interface of the JPoEML tool.

Using JPoEML we have created models of learning units in accordance with different pedagogical approaches. This section introduces the model of a learning unit based on a Competency-Based Learning (CBL) approach. This learning unit has been taken from the IMS-LD Best Practice Document and Implementation Guide [38] (pages 75–89). Therefore, a comparison between the modeling in PoEML and in IMS-LD is performed.

In the CBL approach, students increase their competency level with respect to particular competencies by carrying out study tasks of increasing complexity, starting from a baseline level. Students work through a collection of study tasks until they have acquired the desired level (e.g., with respect to a degree program). This example is a course on Public Administration where students need to acquire two competencies: advising and anticipating. The traditional version of the course asked students to read a book and take a master exam for each competency. In the example, the course is delivered through Internet.

Three actors are involved in the example: the student, the tutor and the examiner. For each competency (e.g., advising and anticipating), the student has to carry out a sequence of activities, each being conditional for the next:
                        
                           1.
                           
                              Preparation. The student receives all kind of background information, like cases and hints information about the course and chooses whether or not he/she wants to study the course with examples (this is a way of personalization of the course).


                              Practice and tests. The student has to perform a practice activity and a test activity for each one of the competencies. She/he can attempt these activities in any order. The student is allowed repeated realization of practice activities, but she/he can take each of the test activities only once. The results of such activities should be reported to the tutor.


                              Supervision. The tutor has to supervise the work of the student. Furthermore, after sending in a practice activity report, the student has to be given feedback from the tutor; and after sending a test activity report, the student receives an assessment from the tutor.


                              Grading. After the student has been assessed on the two test activities (corresponding with each one of the competencies), he/she may request the examiner for a grade. The test grades provided by the tutor are sent to the examiner, who gives the final grade to the student.

The modeling of this learning unit in PoEML does not require all the PoEML packages, but only the following ones:
                        
                           •
                           The Structural Package to model the structure of the learning unit, recognizing the ESs that made up the main structure.

The Functional Package to model the Goals that have to be attained at each ES and the relationships among them.

The Participant Package to model the involved Roles at each ES and the transfer of participants among the Roles of the ESs.

The Environment Package to model the Environments and resources available to perform the work considered at each ES.

The Data Package to model the Data Elements required for each of the ESs, Goals, Roles and Environments, and the transfer of contents among such Data Elements.


                        Fig. 6
                         shows the graphical representation of the structural sub-model. This representation is mainly performed using a tree structure. It is also used a frame based representation which is shown on the right side. Each ES includes the corresponding Goals, Roles, Environments, sub-ESs and Specifications. In addition, in the Root-ES there is a Expression which simply represents a point where a certain value has to be calculated.

In addition to this graphical representation there are data associated with each one of the elements that is not represented. These data are information such as the description of the element, the input and output parameters of goals, the number of instances, etc. In JPoEML this information is shown and can be edited using a form based panel situated in the bottom-right area (see Fig. 5).

The Root-ES is named Competency-Based Learning and it contains three sub-ESs, corresponding with each of the main parts of the course (Preparation, Practice and Testing and Grade), three Roles (Learner, Tutor and Examiner), and a single Goal, demanding the performance of the activities (sub-ESs) proposed.

Despite it is not represented graphically, the sub-ES Practice and Test is defined as a multi-instance ES. In this case it has two instances corresponding to the competencies advising and anticipating. During execution, each one of these two instances contains different instances of each one of the elements included: Goals, Roles, Environments, etc.

The Root-ES also includes an expression Availability Examples. This expression is introduced to take into account whether or not the course should include examples.

The Practice and Testing ES is made up by two sub-ESs: a Learner Activity ES and a Tutor Activity ES. Each one of these ESs has its corresponding working Environments and Goals. The Learner Activity ES includes an authorization specification named Examples Authorization that is activated in accordance with the expression Availability Examples, determining if the learner is going to have access to the examples or not.


                        Fig. 7
                         shows the representation of the functional sub-model. This representation is performed using a graphical structure based on frames, where each frame represents a particular ES. The several ESs are hierarchically aggregated and they contain just their corresponding Goals. In addition, completeness and attempt relationships among Goals are also depicted.

In the figure the two instances of the Practice and Testing ES are shown through a double lined frame with an indication of the number of instances inside parentheses. Notice that during run-time, there will be two instances of the Goal To Perform the Activities of this ES. Therefore, the completeness and attempt relations of this Goal with the other ones have to be checked for both instances.

The completion relations are established from the Goals of Sub-ESs towards the Goals of ESs, represented graphically from botton to top. They indicate what is really needed to do in the course. In this way, these relations are of type AND indicating that in order to satisfy a Goal it is required that the related Goals achieve a certain state (by default: “satisfied”). Notice that in order to complete the Goal in the Practice and Testing ES it is only required to complete the Goals To Perform the Test and To Provide Assessment. The other two Goals (To Do the Practice and To Provide Feedback) do not have any influence.

The attempt relations are established among Goals included in sub-ESs of a same parent-ES, represented graphically in a horizontal disposition. In this example these relations are positive, representing that to allow the attempt of a Goal it is needed that a previous goal has achieved a certain state (by default: satisfied).

The representation of this sub-model is also performed following the frames scheme. Each frame represents an ES, including inside detailed information about the involved Roles. How the transfer of participants among Roles in different ESs has to be performed is also represented (cf. Fig. 8
                        ).

As in the functional sub-model, the Practice and Testing ES would be represented with a double line frame. This indicates that several instances of the ES have to be created, specifically two instances. Each of these instances contains different instances of each of the Roles involved: learner and teacher.

Each ES includes explicitly its involved Roles. This feature facilitates the reuse of any ES, independently of its aggregation level in the ESs hierarchy, because the Roles are locally defined. As a consequence, it is required to show the transfer of participants from the Roles of the parent-ES to the Roles of its sub-ESs.

Since the requirements of this learning unit are not very demanding in relation with the participants' transfer, there is only one connector: the FIFO assignment. This connector is used to indicate that the participants of the Role in the parent-ES have to be transferred to the Role in the sub-ES in accordance with the order in which they were assigned to the Role in the parent-ES. We could also have horizontal relations between Roles to indicate constraints in the assignments (e.g., two Roles in different ESs cannot be performed by the same person).

Similar to the previous sub-models, the PoEML graphical representation of this sub-model is also performed in accordance with a frame structure. In this case each ES frame includes the environments where the resources and tools provided for the work in the ES would be located. These graphical sub-models also include the representation of the tools included in each Environment and relations between Environments.

The data sub-model is used to specify the Data Elements included in the ESs, Goals, Roles and Environments, and the transfer of contents among these Data Elements. The graphical representation of these sub-models is not performed in a single diagram because it would be very complex. On the contrary, JPoEML enables to represent graphically the data sub-model by focusing on pairs of sub-ESs.

In the CBL course, the data model is very important to represent the data transfer among the several Goals involved. For example, the results obtained in the tests have to be delivered to the tutors, and the grades assigned by the tutors have to be delivered to the examiner. Fig. 9
                         shows the data transfer from the output parameters of the Goals To Do the Practice and To Perform the Test to the input parameters of the Goals To Provide Feedback and To Provide Assessment, respectively. In both cases, the data elements are defined as type record, namely: data elements made up by other data elements. In addition, these data transfers are modeled as synchronous copies. Therefore, the data transfer is going to be produced just in the moment when the Goals that provide the data are completed. The figure also shows the input parameters and output parameters of the Goals not involved in the transfer. For example, the Goal To Perform the Test includes a Data Element Questions containing the questions of the test. The actual value of these questions is taken form an external source (e.g., a text file).

@&#DISCUSSION@&#

The critical point in the model of this CBL learning unit is to support the variability of the Practice and Testing activity. It is possible to perform first the advising activities and then the anticipating activities (advising-then-anticipating), or vice versa (anticipating-then-advising). The modeling of this behavior with IMS-LD is performed by considering all the possible routes, in this case two. In this way, it seems an appropriate solution. Nevertheless, this solution includes a scalability problem, as all the possible routes have to be considered. With 2 competencies the number of routes is 2 (result of 2!), for 3 competencies, it is needed to model 6 routes (3!), and for 4 competencies 24 (4!). Obviously, the modeling of learning units in such manner is not an appropriate solution. On the contrary, the modeling performed with PoEML does not have this scalability problem. New competencies can be added to the CBL course very simply, just changing the number of instances of the Practice and Testing sub-ES and assigning the appropriate values to the new instances of elements, namely: input parameters of the new Goal instances. In this way the PoEML model is more flexible and scalable than the IMS-LD one.

In addition, PoEML brings important improvements to expressiveness, extensibility and usability. In this example PoEML enables modeling the assignment of participants to Roles, something that cannot be specified using IMS-LD. Furthermore, the modeling through perspectives enables to extend the model by involving new sub-models in a easy way. For example, if we need to establish some ordering among activities we just have to include an Order Specification, without modifying anything else. The separation into perspectives also provides a simple representation of the whole model, contributing to a better understanding and facilitating the use of the models by human beings. Basically, it is provided a separation-of-concerns that enables us to draw the attention on the involved issues step by step. In addition, this example also shows how this approach contributes to the reusability, adaptation and flexibility of the models, as long as changes in the sub-model of a certain perspective can be carried out without affecting to other sub-models or, more precisely, affecting them in a controlled way.

PoEML is not simply a modeling language. In addition, PoEML models can be enacted by appropriate software (e.g., a Learning Management System). Therefore, PoEML includes a large number of elements devoted to support such an enactment. These elements are important for the execution, but they are not essential for the understanding of the main issues involved in the modeling of learning units. More specifically, this paper is focused on PoEML, but many details of the language have not been described for the sake of understanding. Similarly, the evaluation of the language needs to distinguish between the modeling that can be performed by a common teacher, and the executable-modeling that can be produced by taking full use of PoEML.

Taking into account the purpose of this paper, we have realized an evaluation of PoEML focused on the modeling methodology. This methodology is characterized by the adoption of a separation-of-concerns approach, through perspectives, and the modeling by refinement. In other words, the models of learning units are created by working on the different perspectives separately, step by step. In addition, the model is not created in a single step, but the progressive specification of the elements is facilitated. This development methodology is supported by the JPoEML graphical authoring tool.

We have conducted an experience of PoEML involving eight teachers of the Universidade de Vigo. They did not have any previous knowledge about the language, so we provided them a two-hour tutorial about PoEML and the JPoEML tool. Then, they were asked to produce a model of some of their courses in PoEML. The types of courses they tried to model were quite heterogeneous: traditional theoretical courses with several lectures and one final exam, engineering courses involving theory and practice tasks, problem-based learning activities, etc. The general results were very good and, with a certain help, all the teachers were able to create their models.

We asked these teachers to fill in a survey about their experience with PoEML and their suggestions. In the following, some of more interesting questions are described together with the results:
                        
                           •
                           
                              Have you had some previous experience with EMLs? Only two of the teachers have listened previously about IMS-LD, but they have not created any model of learning unit using it. Therefore they did not have any previous experience.


                              Do you find the PoEML perspectives appropriate to model learning units? 75% of the teachers felt the modeling approach was very appropriate. Just two of the teachers felt overloaded by the 13 perspectives. We consider that it was because they did not need to use many of the packages.


                              Do you have created the models following in successive refinements? Almost all the teachers indicated that they had produced the models in this way. They felt this was very practical, as they can modify and change the elements when they need to do it.


                              Do you understand the models created by other teachers? Almost 60% of the answers indicated that they were able to do it using just the models. The rest of the answers indicated that additional information was required.


                              Do you have identified some issue that cannot be modeled using PoEML? Here we did not receive any affirmative answer.


                              Do you thing the information provided at the beginning of this experience has been enough? Half of the answers demanded more information in order to create the models. Some of these answers recognized that they have understood the issues explained, but they feel that they need more information in order to produce more detailed models.

In order to provide a comprehensible validation of PoEML we should enact models of learning units and carry out experiences with real teachers and learners. We are working towards this goal. Nevertheless, this first experience with the authoring of models is valuable from the point of view of the separation-of-concerns approach and methodology. Finally, development of models of learning units may involve several stages: (i) authoring by “generic” teachers and instructional designers; (ii) edition by “technical” programmers to generate an executable model; (iii) enactment of models. The good news about PoEML is that it supports this workflow. In addition, if we are able to develop suitable authoring tools that can be used by “generic” teachers and automate the generation of PoEML code we could get rid of “technical” programmers. Here the problem is not at the automatic generation of PoEML code, but at the provision of understandable design metaphors in authoring tools.

@&#CONCLUSIONS@&#

PoEML is proposed as a new approach towards the modeling for learning units through perspectives. The adoption of models provides a number of advantages in any discipline, involving design, communication and realization purposes. Nevertheless, the achievement of appropriate models and languages to create them is not a simple issue. The work presented in this paper is an attempt to contribute to this effort in the e-learning domain.

The main approach adopted in PoEML is the separation-of-concerns. As in other engineering disciplines, the management of complexity is a key point to facilitate the solution of problems and the separation-of-concerns is a well-known technique to deal with it. This strategy enables us to draw the attention on one concern at each time, while abstracting from the others. Therefore, PoEML is not provided as a single set of elements, but is made up by several sub-languages (packages). In the learning domain there are some proposals that follow this separation-of-concerns approach, such as [39], where learning units are considered through several orthogonal aspects. Anyway, as far as we know, PoEML is the first attempt that takes the separation-of-concerns as driven development principle. Previous efforts in EMLs did not pay much attention to this separation-of-concerns approach. IMS-LD has been a main promoter on the adoption of EMLs and its developers recognized a complexity problem. Subsequent proposals were mainly interested on the expressive capacity to support certain pedagogical approaches (mainly collaborative learning).

The first results on PoEML show that it is a very expressive and relatively simple language. The development of PoEML has taken into account the expressive needs of many different approaches, mainly those based on collaborative learning. This is justified because this kind of learning unit is not well supported by current e-learning systems. This focus and the results obtained from hands-on experiences show that the language has a large expressive power. Nevertheless, a main feature of the language is its relative simplicity. Despite its expressive power, as each perspective is focused on a particular issue, the complexity of the language is distributed among the several packages and the designer can draw his/her attention on each one of them. This brings a lot of clarity to the models. In addition, the separation into perspectives also enables changing the model in one perspective without affecting to other perspectives or affecting them in a controlled way.

Finally, we would like to stress that the separation-of-concerns approach is not just reflected in the language, but it has also enabled the development of a specific modeling methodology and supporting tools. We have already developed the JPoEML graphical authoring tool and currently we are working in an engine to enact models of learning units. These methodology and tools adopt a step-by-step approach, facilitating the understanding of users and the development of systems. We need to work on this methodology and tools but the results of the first experiences are favorable and this can be a first step towards a greater adoption of EMLs in the daily e-learning practices.

@&#ACKNOWLEDGMENTS@&#

This research has been co-funded by the Galician Regional Government under project CN 2012/259 “Research Networks: TELGalicia” and by the Spanish Ministry of Science and Innovation under grant “Methodologies, Architectures and Standards for adaptive and accessible e-learning (Adapt2Learn)” (TIN2010-21735-C02-01).

@&#REFERENCES@&#

