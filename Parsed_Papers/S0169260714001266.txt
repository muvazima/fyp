@&#MAIN-TITLE@&#Epileptic seizure detection in EEGs signals using a fast weighted horizontal visibility algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Developing a fast algorithm for constructing a network from a time series in linear time.


                        
                        
                           
                           Discriminating between healthy and seizure EEG signals with 100% accuracy with only two features.


                        
                        
                           
                           Extracted features from a time series is faster and more robust to against noise than those based on FFT.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Epilepsy

Computational complexity

Weighted horizontal visibility graph

Mean degree

Mean strength

@&#ABSTRACT@&#


               
               
                  This paper proposes a fast weighted horizontal visibility graph constructing algorithm (FWHVA) to identify seizure from EEG signals. The performance of the FWHVA is evaluated by comparing with Fast Fourier Transform (FFT) and sample entropy (SampEn) method. Two noise-robustness graph features based on the FWHVA, mean degree and mean strength, are investigated using two chaos signals and five groups of EEG signals. Experimental results show that feature extraction using the FWHVA is faster than that of SampEn and FFT. And mean strength feature associated with ictal EEG is significant higher than that of healthy and inter-ictal EEGs. In addition, an 100% classification accuracy for identifying seizure from healthy shows that the features based on the FWHVA are more promising than the frequency features based on FFT and entropy indices based on SampEn for time series classification.
               
            

@&#INTRODUCTION@&#

The feature extraction is an essential procedure to classify time series, especially EEG signals [1]. There are two main methods to extract features from a given time series: linear and nonlinear methods. Conventional linear methods are based on frequency domain [2,3] or time domain [4]. Fast Fourier Transform (FFT) has been widely applied in time series analysis, especially for epileptic EEG signal classification. The power spectral density (PSD) feature [5,6] based on FFT can be characterized a time series efficiency. However, frequency domain is not robust enough to represent inter-ictal epileptic signals because the raw EEGs are chaos and nonlinear [7].

Other features extraction techniques are based on nonlinear methods. Correlation dimension features from ictal signals [8,9] are smaller than those from inter-ictal EEG signals. Cumulants features [10] are considered to identify the ictal EEGs. A series of entropies [11–15] are widely applied in epileptic EEG detection. High order spectra features [16,17] are applied for ictal EEG classification. Largest Lyapunov exponent [9] from healthy EEG signals are larger than those of inter-ictal signals. Recurrence plot features [18,19] are also employed to identify ictal signals. Tang et al. [20] analyzed visibility graphs (VGs) from higher band frequencies of seizure EEGs and showed that the performance of the VGs based approach is better than that of the simple entropy method. Zhu et al. [21] also implemented VG based features to identify the ictal EEGs from healthy EEGs with 100% accuracy. However, many nonlinear feature extraction algorithms are slower than a FFT method, which makes them hard to be implemented in real time applications.

This paper presents a fast weighted horizontal visibility algorithm (FWHVA) to classify epileptic EEG signals in linear complexity and high accuracy. Similar as the PSD features based on FFT from frequency domain, strength and degree features are investigated based on the FWHVA from graph domain. Two chaos signals with added white noise are also applied to evaluate the robustness and computing speed with features from the FWHVA, FFT and SampeEn. Five groups of EEG signals: two groups of normal EEGs, two categories of inter-ictal EEG signals and one type of ictal EEGs are used to investigate the classifying performance with the features extracted from graph domain, frequency domain and time domain separately.

The remaining of the paper is organized as follows: the experimental data and methods are briefed in the next section. The FWHVA method is illustrated in Section 3. Section 4 investigates the computing speed and robustness of noise. The performances of the FWHVA are applied to identify epileptic EEGs in Section 5. The discussions of the advantages and disadvantages of the proposed method are illustrated in Section 6. Finally, the conclusions are drawn in Section 7.

This paper uses epileptic EEG database which was obtained from http://www.meb.uni-onn.de/epileptologie/science/physik/eegdata.html. The datasets were described by Anndrzejak et al. [8]. The EEG data were digitized in 173.61 samples per second, obtained from a 12-bit A/D converter. The band-pass filter settings were at 0.53–40Hz. The whole EEG dataset consists of five groups of data sets (denoted set A–E) and each group contains 100 recordings. Sets A and B were recorded from five healthy volunteers with eyes opened and eyes closed, respectively. Sets C and D were recorded from five epileptic patients during seizure-free intervals from the opposite hemisphere of the brain and within the epileptogenic zone, respectively. Set E only contains the seizure activity EEGs. Sample recordings of five class EEG signals are shown in Fig. 1
                     .

The automatic epileptic EEG detection method is shown in Fig. 2
                     . This is a two-stage classification procedure. The first stage is feature extraction, which maps a raw EEG signal into a WHVG. Two features, the mean degree and mean strength, are obtained from each graph at this stage. The second stage is the classification, which uses the K-NN classifier to identify the seizures from extracted features.

A horizontal visibility graph (HVG) is a type of a complex network which was proposed by Luque et al. [22]. Normally, a time series 
                           
                              
                                 
                                    {
                                    
                                       x
                                       i
                                    
                                    }
                                 
                                 
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    )
                                 
                              
                           
                         is mapped into a graph G(V, E), where a time point x
                        
                           i
                         is mapped into a node 
                           
                              
                                 v
                                 i
                              
                              ∈
                              V
                           
                        . The relation between any two points (x
                        
                           i
                        , x
                        
                           j
                        ) are represented as an edge e
                        
                           ij
                        
                        ∈
                        E and the value is defined as
                           
                              (1)
                              
                                 
                                    
                                       e
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      
                                                         x
                                                         k
                                                      
                                                      <
                                                      
                                                         x
                                                         i
                                                      
                                                      ∧
                                                      
                                                         x
                                                         k
                                                      
                                                      <
                                                      
                                                         x
                                                         j
                                                      
                                                       
                                                      ∀
                                                      k
                                                      ∈
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ∧
                                                      i
                                                      <
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where e
                        
                           ij
                        
                        =0 implies that the edge does not exist, otherwise it does. Fig. 2 shows a HVG associated with a time series, which was recorded from subject S0002.

The first 12 values in Fig. 3(a) are Y
                        =(340, 353, 400, 470, 538, 590, 611, 629, 649, 693, 759, 837). The first node in Fig. 3(b) is associated with the first value of Y in Fig. 3(a). The second node is corresponded to the value of 353, and so on.

In a complex network, the node degree is one of the basic characteristics of graphs. The degree d
                        
                           i
                         of node v
                        
                           i
                         is the number of edges from v
                        
                           i
                        . For example, in Fig. 3(b), d
                        1
                        =1 and d
                        2
                        =2. It is noted that the degrees of nodes from 2 to 12 in Fig. 3(b) are all at 2.
                           Example 1
                           Let Y
                              1
                              =(340, 353, 400, 470, 538), Y
                              2
                              =(340, 340, 342, 341, 340), the degree sequences of their HVGs associated with both Y
                              1 and Y
                              2 are the same (1, 2, 2, 2, 1), respectively.

A HVG is a subgraph of visibility graphs (VGs) first proposed by Lucas Lacasa et al. [23]. Shao [24] analyzed heartbeat interval signals with VGs. Tang et al. [20] and Zhu et al. [21] studied the epileptic EEGs with VGs, respectively. Zhu et al. [25] also studied sleep EEG signals using VGs. However, HVG based methods have not yet been applied to analyze and classify epileptic EEGs. Example 1 shows that HVGs cannot be used to distinguish between monotonic (consistently increasing or decreasing) time series and a constant time series. In fact, EEGs at ictal state include a lot of spike waves as shown in Fig. 1(e). Therefore, it is necessary to introduce improved graph features to enhance the performance of identifying spike waves.

This section introduces a weighted graph to discriminate the difference between monotonic increase (or decrease) time series and constant time series as shown in Example 1. A weighted horizontal visibility graph associated with a time series 
                           
                              
                                 
                                    {
                                    
                                       x
                                       i
                                    
                                    }
                                 
                                 
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    )
                                 
                              
                           
                         is denoted as G(V, E, W). The weight w
                        
                           ij
                         of edge e
                        
                           ij
                         between nodes v
                        
                           i
                         and v
                        
                           j
                         is defined as follows:
                           
                              (2)
                              
                                 
                                    
                                       w
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            (
                                                            
                                                               x
                                                               i
                                                            
                                                            −
                                                            
                                                               x
                                                               j
                                                            
                                                            )
                                                            (
                                                            i
                                                            −
                                                            j
                                                            )
                                                         
                                                      
                                                      +
                                                      1
                                                   
                                                
                                                
                                                   
                                                      
                                                         e
                                                         
                                                            i
                                                            j
                                                         
                                                      
                                                         
                                                      exists
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

A weighted graph is characterized with the concept of strength. A strength of node v
                        
                           i
                         is defined as follows:
                           
                              (3)
                              
                                 
                                    
                                       s
                                       i
                                    
                                    =
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          w
                                          
                                             i
                                             j
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        
                     

This parameter can be used to distinguish a monotonic increase (or decrease) time series from a constant time series.
                           Example 2
                           Let us consider the two time series in Example 1 again. Y
                              1
                              =(340, 353, 400, 470, 538) and the strength sequence of the WHVG associated with Y
                              1 is (14, 62, 119, 140, 69). The strength sequence of the WHVG associated with Y
                              2 is (1, 4, 5, 4, 2). It is obvious that the two strength sequences are different.

There are many measuring parameters in complex networks, such as clustering coefficient and average path [26]. The mean degree of a graph with n nodes is defined as:
                           
                              (4)
                              
                                 
                                    
                                       d
                                       ¯
                                    
                                    =
                                    
                                       1
                                       n
                                    
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          d
                                          i
                                       
                                    
                                 
                              
                           
                        
                     

Degree distribution (DD) is another linear complexity feature of graphs, which is a probability that a node has a degree of k. It is obtained by counting the number of nodes having degree k divided by the total number of nodes. This study uses p(k) to denote the DD of degree k of a HVG.

For weighted graphs, according to Barrat et al. [27], the measuring properties of weighted complex networks are mean strength, weighted clustering coefficient, etc. The mean strength of a graph having n nodes is defined as
                           
                              (5)
                              
                                 
                                    
                                       s
                                       ¯
                                    
                                    =
                                    
                                       1
                                       n
                                    
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          s
                                          i
                                       
                                    
                                 
                              
                           
                        
                     

Based on graph theoretical analysis, the computation complexities of finding a clustering coefficient, counting triangles [28], and the average shortest path [29] are O(n
                        2), which is low efficient when it is applied in real time applications. In this paper, mean degree and mean strength are considered because the computational complexities of calculating mean degree and mean strength are linear.

Given a time series 
                           
                              
                                 
                                    {
                                    
                                       x
                                       i
                                    
                                    }
                                 
                                 
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    )
                                 
                              
                           
                        , it can get the frequency domain features 
                           
                              
                                 
                                    {
                                    X
                                    (
                                    
                                       ω
                                       j
                                    
                                    )
                                    }
                                 
                                 
                                    (
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    N
                                    )
                                 
                              
                           
                         by Fast Fourier Transform (FFT), where N
                        ≥
                        n is the power of 2. In general, two features are widely studied in EEG signal processing. The first one is the peak frequency, which is defined as
                           
                              (6)
                              
                                 
                                    
                                       f
                                       p
                                    
                                    =
                                    {
                                    
                                       w
                                       i
                                    
                                    |
                                    X
                                    (
                                    
                                       w
                                       i
                                    
                                    )
                                    =
                                    max
                                    (
                                    X
                                    (
                                    
                                       ω
                                       
                                          j
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          n
                                       
                                    
                                    )
                                    )
                                    }
                                 
                              
                           
                        
                     

The second is power spectral density (PSD), which defines the energy distribution of a signal over the time-frequency domain. It refers to the amount of power per unit frequency as a function of frequency. Different algorithms are used for the estimation of the PSD. A simple method is calculated by using the equation below:
                           
                              (7)
                              
                                 
                                    
                                       P
                                       θ
                                    
                                    =
                                    
                                       1
                                       N
                                    
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       N
                                    
                                    
                                       |
                                       X
                                       (
                                       
                                          ω
                                          i
                                       
                                       )
                                       |
                                    
                                 
                              
                           
                        
                     

This study uses the peak frequency between 4 and 40Hz (denoted as f
                        
                           p
                        ) and the mean PSD over frequency band 0.5–40 (denoted as P
                        
                           θ
                        ) to compare with the mean strength over all degrees. The PSD algorithm is calculated by the R package SeeWave [30].

Entropy is used to measure the complexity of a time series. It has been widely applied to EEG signal processing. Sample Entropy was proposed by Richman and Moorman [31]. Bai et al. [11] used approximate entropy (AE) and sample entropy to analyze epileptic EEG signals and found that sample entropy is more suitable for identifying seizures than approximate entropy. A SampEn algorithm used in this study to estimate the sample entropy is available from Physione website (http://www.physionet.org/physiotools/sampen/). The algorithm of SampEn has three input parameters, (1) m: the embedded dimension, (2) r: the similarity criterion, (3) n: the length of a time series 
                           
                              
                                 
                                    {
                                    
                                       x
                                       i
                                    
                                    }
                                 
                                 
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    )
                                 
                              
                           
                        . In this study, two SE features (S
                        
                           e1: m
                        =2, r
                        =0.15, and S
                        
                           e2: m
                        =2, r
                        =0.2) of each epoch of EEG signals are extracted.

A K-nearest neighbor (K-NN) classifiers is commonly used in epileptic EEG signal processing because it is known to be very sensitive to the curse-of-dimensionality [32]. However, a K-NN classifier can achieve a good performance when the dimension of features is low [32]. The dimension of extracted features in this study is just two. A K-NN classifier is therefore applied to compare the performances of the features using SampEn, HVG and WHVG.

The K-NN algorithm is a traditional pattern recognition method [33], which is a statistical supervised classification. The main idea is that given a new test data t, the algorithm obtains the K nearest neighbors from the training set Y based on the distance between t and Y. The distance used in this study is neighbor Euclidean distance as shown in Eq. (8)
                        
                           
                              (8)
                              
                                 
                                    d
                                    s
                                    t
                                    (
                                    
                                       x
                                       t
                                    
                                    ,
                                    y
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      y
                                                      i
                                                   
                                                   −
                                                   
                                                      x
                                                      t
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The most dominating class amongst these K neighbors is assigned as the class of t. In this study, the K-NN algorithm is implemented by R package FNN (http://cran.r-project.org/web/packages/FNN/index.html), where K is 3.

In order to evaluate the performances of the proposed algorithm in this paper, the accuracy (AC), sensitivity (SE), and specificity (SP) are assessed for the EEG classification. These parameters are defined below:
                           
                              (9)
                              
                                 
                                    SE
                                    =
                                    
                                       
                                          TP
                                       
                                       
                                          TP
                                          +
                                          FN
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    SP
                                    =
                                    
                                       
                                          TN
                                       
                                       
                                          TN
                                          +
                                          FP
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    AC
                                    =
                                    
                                       
                                          TN
                                          +
                                          TP
                                       
                                       
                                          TN
                                          +
                                          FN
                                          +
                                          TP
                                          +
                                          FP
                                       
                                    
                                 
                              
                           
                        where TP=correctly classified seizure EEG, TN=correctly identified non-seizures EEG, FP=falsely identified ictal EEG and FN=falsely recognized non-seizure EEG.

To implement Eq. (1), the iterative implementation algorithm is shown in Algorithm I.
                        Algorithm I
                        HVA


                        
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             input: x[1…n]
                                          
                                       
                                       
                                          
                                             output: HVG(V,E)
                                          
                                       
                                       
                                          
                                             
                                          
                                       
                                       
                                          
                                             1.
                                          
                                          
                                             for (i
                                             
                                             =
                                             
                                             2; i
                                             
                                             <
                                             
                                             n; i++)
                                          
                                       
                                       
                                          
                                             2.
                                          
                                          
                                             
                                             for (j
                                             
                                             =
                                             
                                             1; j
                                             
                                             <
                                             
                                             i; j++)
                                          
                                       
                                       
                                          
                                             3.
                                          
                                          
                                             
                                             
                                             flag
                                             
                                             =
                                             
                                             True;
                                          
                                       
                                       
                                          
                                             4.
                                          
                                          
                                             
                                             
                                             for (k
                                             
                                             =
                                             
                                             j
                                             
                                             +
                                             
                                             1; k
                                             
                                             <
                                             
                                             i&flag; k++)
                                          
                                       
                                       
                                          
                                             5.
                                          
                                          
                                             
                                             
                                             
                                             if x[k] stratify conditions of equation (1) then flag
                                             
                                             =
                                             
                                             False
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             
                                             end if
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             next for
                                          
                                       
                                       
                                          
                                             6.
                                          
                                          
                                             
                                             
                                             if (Flag) V[i] and V[j] are connected
                                          
                                       
                                       
                                          
                                          
                                             
                                             next for
                                          
                                       
                                       
                                          
                                          
                                             next for
                                          
                                       
                                    
                                 
                              
                           
                        


                     Algorithm I looks simple. However it needs to iterate three variables (i, j and k), which means that the worst computing time to obtain a degree sequence of a HVG for a time series with n data points is O(n
                     3). Thus Algorithm I is hard to be applied to real time applications. For instance, Xia et al. [34] showed that the computing time of constructing a HVG increased from 0.04s to 2.28s when the input size of data points increased from 1000 to 8000.

To improve the constructing time, firstly the k in Eq. (1) should be eliminated. The idea is based on Eq. (12),
                        
                           (12)
                           
                              
                                 
                                    e
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   
                                                      x
                                                      i
                                                   
                                                   >
                                                   max
                                                   (
                                                   x
                                                   [
                                                   (
                                                   j
                                                   +
                                                   1
                                                   )
                                                   ⋯
                                                   (
                                                   i
                                                   −
                                                   1
                                                   )
                                                   ]
                                                   )
                                                    
                                                   1
                                                   <
                                                   j
                                                   <
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   i
                                                   =
                                                   j
                                                   +
                                                   1
                                                    
                                                   j
                                                   >
                                                   0
                                                
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Logically Eq. (12) is similar as Eq. (1) but remove the iterative loop of k. When condition i
                     =
                     j
                     +1 is satisfied, points x[j] and x[i] (x[j
                     +1]) are always visible according to the definition of HVG, and edge between v[j] and v[i] (v[j
                     +1]) exists, that is e
                     
                        ij
                     
                     =1.

Secondly, to minimize the iteration j in Algorithm I, only the maximal value among x[1…i
                     −1] needs to be considered. A vector SortList is used to store maximal values of x[1…i
                     −1]. Following Eqs. (2) and (12), this study implement an improve HVG constructing algorithm and named FWHVA algorithm as below:
                        Algorithm II
                        FWHVA


                        
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             input: x[1…n]
                                          
                                       
                                       
                                          
                                             output: WHVG(V,E,W)
                                          
                                       
                                       
                                          
                                             
                                          
                                       
                                       
                                          
                                             1.
                                          
                                          
                                             SortList.push(1);
                                          
                                       
                                       
                                          
                                             2.
                                          
                                          
                                             for (i
                                             
                                             =
                                             
                                             2; i
                                             
                                             <
                                             
                                             n; i++)
                                          
                                       
                                       
                                          
                                          
                                             
                                             V[i] and V[i
                                             −
                                             1] are connected
                                          
                                       
                                       
                                          
                                             4.
                                          
                                          
                                             
                                             W[i]
                                             
                                             =
                                             ǀx[i]
                                             −
                                             x[i
                                             −
                                             1]ǀ
                                             +
                                             
                                             1
                                          
                                       
                                       
                                          
                                             5.
                                          
                                          
                                             
                                             if (x[i]
                                             
                                             >=
                                             
                                             x[i
                                             −
                                             1]) then
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             do
                                          
                                       
                                       
                                          
                                             6.
                                          
                                          
                                             
                                             
                                             
                                             j
                                             
                                             =
                                             
                                             SortList.pop()
                                          
                                       
                                       
                                          
                                             7.
                                          
                                          
                                             
                                             
                                             
                                             if (j!
                                             
                                             =
                                             
                                             i
                                             −
                                             1) then
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             
                                             
                                             V[i] and V[j] are connected
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             
                                             
                                             W[i]
                                             
                                             =
                                             ǀ(x[i]
                                             −
                                             x[j])*(i
                                             −
                                             j)ǀ
                                             +
                                             
                                             1
                                          
                                       
                                       
                                          
                                          
                                             
                                             
                                             
                                             end if
                                          
                                       
                                       
                                          
                                             10.
                                          
                                          
                                             
                                             while(!SortList.empty() and x[j]
                                             
                                             <
                                             
                                             x[i])
                                          
                                       
                                       
                                          
                                             11.
                                          
                                          
                                             
                                             if x[j]
                                             
                                             >
                                             
                                             x[i] SortList.push(j) end if
                                          
                                       
                                       
                                          
                                          
                                             end if
                                          
                                       
                                       
                                          
                                             12.
                                          
                                          
                                             SortList.push(i);
                                          
                                       
                                       
                                          
                                          
                                             next for
                                          
                                       
                                    
                                 
                              
                           
                        

The FWHVA algorithm uses two loops, while the execution time of the inner repeat (line 4) is equal to the average depth of the stack. An algorithm based on HVG developed in our previous study [25] was similar as this one, but it did not include the weighted portion. Gutin et al. [35] has shown the worst case of the numbers of edges in a HVG as follows.
                        Lemma 1
                        
                           [35]: The maximum number of edges in a HVG on n
                           >2 vertices is 2n
                           −3, which represents the time series in the form of X
                           ={…;8;6;4;2;1;3;5;6;7;9;…} or X
                           ={…;9;7;5;3;1;2;4;6;8;…}.

Because a WHVG is a subset of a HVG, the average number of edges is the same as HVG. Now let us consider the computational complexity of the FWHVA algorithm.
                        Lemma 2
                        The complexity of constructing a FWHVA is O(n).

It is clear that the worst case is decided by the execution time of a loop at line 10 of Algorithm II: FWHVA, when a WHVG has the maximum number of edges. According to Lemma 1, the average execution time of each node of a HVG is at most 2. It implies that the executing time at line 5 is less than 2*(2n
                           −3). Therefore, the time complexity is O(n). Since SortList at line 12 is n at most, the space complexity is also O(n).□

To verify Lemma 2 in Section 4, the proposed FWVHA and SampEn are implemented in C program language, while the FFT, PSD and statistical analysis are implemented by R package SeeWave [30]. The experiments include two parts: (a) analysing and classifying two chaos signals with added noise based on the mean degree, mean strength, PSD and a sample entropy index; (b) evaluating the computing time of FWHVA by comparing with HVA, PSD and SampEn.

The stability and noise-robustness of the proposed method are two important factors in pattern classification. Two chaos signals: Hénon map, and Logistic map, are used to evaluate the performance. The Hénon map is defined in Eq. (13).
                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         x
                                                         
                                                            k
                                                            +
                                                            1
                                                         
                                                      
                                                      =
                                                      1.4
                                                      −
                                                      
                                                         x
                                                         k
                                                         2
                                                      
                                                      +
                                                      0.3
                                                      
                                                         u
                                                         i
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         y
                                                         
                                                            k
                                                            +
                                                            1
                                                         
                                                      
                                                      =
                                                      1.4
                                                      −
                                                      (
                                                      C
                                                      
                                                         x
                                                         k
                                                      
                                                      +
                                                      (
                                                      1
                                                      −
                                                      C
                                                      )
                                                      
                                                         y
                                                         k
                                                      
                                                      )
                                                      
                                                         y
                                                         k
                                                      
                                                      +
                                                      B
                                                      
                                                         v
                                                         k
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         u
                                                         
                                                            k
                                                            +
                                                            1
                                                         
                                                      
                                                      =
                                                      
                                                         x
                                                         k
                                                      
                                                      ,
                                                      
                                                         v
                                                         
                                                            k
                                                            +
                                                            1
                                                         
                                                      
                                                      =
                                                      
                                                         y
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

While the Logistic map uses following Eq. (14)
                        
                           
                              (14)
                              
                                 
                                    
                                       x
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    =
                                    a
                                    
                                       x
                                       t
                                    
                                    (
                                    1
                                    −
                                    
                                       x
                                       t
                                    
                                    )
                                 
                              
                           
                        
                     

The same amount of Gaussian white noise (GWN) are added to the above both chaos signals to evaluate the performance of the robustness against noise. Because the aim of this study is to classify EEG signals, and the duration of the epileptic EEG signals are limited from 1s [36] to 5s [19,37], the size of these chaos signals is 1024. The parameters in Eqs. (13) and (14) are assigned as a
                        =4, B
                        =0.3, C
                        =0.2. 20 test-runs are conducted in the experiments with initial values u
                        0, v
                        0, x
                        0 and y
                        0 randomly assigned between (0,1).


                        Fig. 4
                         illustrates six features: mean degree 
                           
                              d
                              ¯
                           
                        , degree distribution of degree two (p(2)), mean strength 
                           
                              s
                              ¯
                           
                        , sample entropy S
                        
                           e1, peak frequency F
                        
                           p
                         and mean PSD 
                           
                              
                                 
                                    
                                       P
                                       θ
                                    
                                 
                                 ¯
                              
                           
                         extracted from two chaos signals with added white noise.

It is found that 
                           
                              d
                              ¯
                           
                         of the HVGs (Fig. 4(a)) and the F
                        
                           p
                         from frequency domain (Fig. 4(d)) are sensitive to the initial values of Chaos signals, while p(2), 
                           
                              s
                              ¯
                           
                        , S
                        
                           e1 and 
                           
                              
                                 
                                    
                                       P
                                       θ
                                    
                                 
                                 ¯
                              
                           
                         are kept steady against the initial values. It is observed that 
                           
                              s
                              ¯
                           
                         is more robust than p(2), S
                        
                           e1 and 
                           
                              
                                 
                                    
                                       P
                                       θ
                                    
                                 
                                 ¯
                              
                           
                         base on the distances between chaos signals and the chaos signals with noise. Therefore, 
                           
                              s
                              ¯
                           
                         is more robust against noise than other features.

This section is to compare computation speed among the HVA, SampEn, PSD and FWHVA methods. All algorithms are run on a 3.20GHz Intel@Xeon W5580 CPU processor machine with 24G RAM. The operating system is Windows 7.0 64 bits.

The average execution time for the four algorithms: HVA, SampEn, PSD and FWHVA are shown in Fig. 5
                        . The execution times of the HVA and SampEn raise rapidly when the size of input data n increases, while the execution time of the FWHVA exhibits a slower growth rate than that of PSD. The ratio of the execution times between SampEn and the FWHVA is 76 times when n
                        =4000, and it is more than 3.8 times faster than PSD when n
                        =4000.

To evaluate the performance of the extracted features for pattern classification in Section 3, three parts of experiments are included: (1) analysing and classifying epileptic EEGs based on the mean degrees of the HVGs; (2) analysing and classifying epileptic EEGs based on 
                        
                           d
                           ¯
                        
                      and 
                        
                           s
                           ¯
                        
                      of the WHVG; (3) classifying the EEGs using FWHVA, SampEn and PSD methods with the same EEG segment size; (4) classifying the EEGs using HVGs, SampEn and PSD methods with different sizes of EEG segments.

For experiments (1) and (2), each EEG recording is divided into four equal epochs and each epoch contains 1024 data points. For experiments (3) and (4), every EEG recording is separated into 23, 8, 4, 2, and 1 equal epochs, and each epoch has 173, 512, 1024, 2048 and 4096 data points, respectively. The 10-fold cross validation is used to demonstrate the mean accuracy of 10 times K-NN classification. The whole set are divided into 10-subsets, one of the 10 subsets is used as test, and the other subsets are put together to conduct a training set.

In order to evaluate the performances of the different features, 
                           
                              d
                              ¯
                           
                         of HVG is tested and compared with S
                        
                           e1 (m
                        =2, r
                        =0.15) and F
                        
                           p
                         of peak frequency 4–40Hz in this section. 
                           
                              d
                              ¯
                           
                        , S
                        
                           e1 and F
                        
                           p
                         are extracted from a 1024-point segment of an EEG signal, respectively. Table 1
                         shows that the statistical results of these three features.


                        Fig. 6
                         shows the results of 
                           
                              d
                              ¯
                           
                         of from HVGs associated with the five groups of epileptic EEG signals. It is found that 
                           
                              d
                              ¯
                           
                         of the HVGs associated with the ictal EEG (set E) is the highest among those from other EEGs. 
                           
                              d
                              ¯
                           
                         of the HVGs associated with set D is the lowest, and that of healthy EEG (set A) is in the middle level.

This section investigates the statistical differences using WHVGs. Table 2
                         shows that the statistical results of the three features: 
                           
                              s
                              ¯
                           
                         of the WHVGs, S
                        
                           e2 of SampEn and P
                        
                           θ
                         of the PSD.


                        Fig. 7
                         shows the mean strength among the five sets of epileptic EEG datasets. Comparing to Fig. 6, the mean strength of the WHVGs associated with set E has the highest value, while 
                           
                              s
                              ¯
                           
                         of the WHVGs associated with set A is the lowest, and these associated with sets B and D are in the middle. Figs. 6 and 7 indicate that the perforamnce of 
                           
                              s
                              ¯
                           
                         of the WHVGs could not be represented by 
                           
                              d
                              ¯
                           
                         of the HVGs.

To evaluate the performance, a K-NN classifier is used to distinguish the seizure EEG from the other sets of EEG data. Firstly, one single feature is used to conduct the classification, where odd numbers of epochs are in the training set and the others are in the testing set. The results are shown in Table 3
                        .

Secondly, the performances of identifying seizure EEGs are evaluated with the same groups of two dimensional features: 
                           
                              d
                              ¯
                           
                         and 
                           
                              s
                              ¯
                           
                         of from WHVGs, two sample entropy features: S
                        
                           e1 and S
                        
                           e2, and two frequency domain features: F
                        
                           p
                         
                        and P
                        
                           θ
                         separately. The results are illustrated in Table 4
                        .

The classification accuracy with 
                           
                              d
                              ¯
                           
                         and 
                           
                              s
                              ¯
                           
                         features in Table 4 are higher than those with S
                        
                           e1 and S
                        
                           e2 and those based on F
                        
                           p
                         and P
                        
                           θ
                         when classifying set E from sets A, C, and D, respectively. Comparing to Table 3, the classification accuracy of classifying using 
                           
                              
                                 d
                                 ¯
                              
                           
                         and 
                           
                              s
                              ¯
                           
                         in Table 4 increases significantly (p
                        =0.04), while the accuracy of agreement with S
                        
                           e1 and S
                        
                           e2 has no significant difference (p
                        =0.11). Therefore, 
                           
                              
                                 d
                                 ¯
                              
                           
                         and 
                           
                              s
                              ¯
                           
                         from the WHVGs are much better features for the EEG signals classification than sample entropy features or the clustering technique extracted features.

In this section, the classification accuracies for identifying set E from set A and from set (A, B, C, D) with the K-NN classifier are evaluated using five different sizes of an epoch. Each epoch contains 173, 512, 1024, 2048 and 4096 data points, respectively. The extracted features based on the WHVG and SampEn are forwarded to a K-NN classifier to conduct the classification, respectively. The average accuracies using five different lengths of odd epochs using 10-fold cross-validation by the K-NN classifier are listed in Table 5
                        .

@&#DISCUSSION@&#

It is observed that 
                           
                              d
                              ¯
                           
                         of HVGs associated with chaos signals in Fig. 4 and associated with epileptic EEG signals in Table 1 are close to 4. These results agree with those reported by Luque et al. [38] that the mean degree of HVG associated with a periodic time series (period is T) satisfies the following equation.
                           
                              (15)
                              
                                 
                                    
                                       d
                                       ¯
                                    
                                    =
                                    4
                                    
                                       
                                          1
                                          −
                                          
                                             1
                                             
                                                2
                                                T
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Eq. (15) implies that 
                           
                              d
                              ¯
                           
                         is converged to four if input signal is infinite. However, based on Table 1 and Fig. 6, the HVGs with 1024 points of inter-ictal EEGs satisfy 
                           
                              
                                 d
                                 ¯
                              
                              <
                              3.9
                           
                         and 
                           
                              
                                 d
                                 ¯
                              
                              <
                              3.72
                           
                        , respectively. In contrast, 
                           
                              
                                 d
                                 ¯
                              
                              >
                              3.95
                           
                         from two chaos signals with added noise are shown in Fig. 4. These phenomena agree with the results reported by Pritchard et al. [7] that the inter-ictal EEGs are not low-dimensional chaos. Certainly, the deviation 
                           
                              
                                 d
                                 ¯
                              
                              <
                              3.9
                           
                         of HVGs associated with EEG signals is due to the finite size fluctuation associated to the length of time series.

From physiological point of view, the linear complexity features based on 
                           
                              d
                              ¯
                           
                         and 
                           
                              s
                              ¯
                           
                         present that EEG signals during seizures are more chaotic. The results are also consistent with the results reported by Hu et al. [39].

Moreover. Fig. 4 shows that the probability of degree 2 associated with 4096 points logistic map (u
                        =4) is consistent with the Eq. (19) in [40] which proved that p(2)=1/3 when input signal is long enough, the p(2) of mixed noise logistic map (u
                        =4) is less 0.35, which show a better noise robustness than mean degree. Thus the degree distributions can enhance robust and performances than the mean degree of HVGs.

This study uses the FWHVA method to extract 
                           
                              d
                              ¯
                           
                         and 
                           
                              s
                              ¯
                           
                         from the WHVG for detecting seizures. Compared with the FFT and entropy methods, this method has the following advantages: (1) it is a simple and fast calculation method, faster than FFT as shown in Section 3; (2) it is suitable for applications for classifying a short term time series, especially EEG signals, such as epileptic EEGs and sleep EEGs [25]. Because the strength feature is more suitable for identifying spike-waves, the epileptic diagnosis can be more efficient by the FWHVA on these types of EEGs; (3) the strength feature is better to characterize the epileptic EEGs than the PSD as shown in Fig. 7 and Table 4; (4) the mean strength feature extracted by the FWHVA is more robust to against Gaussian white noise as shown in Fig. 4; (5) the WHVGs can map EEG recordings onto a different set of edges (by defining different weights and relations). Therefore, thousands of parameters can be deduced from the graph features, such as mean and probability distributions of nodes or edges. It is relatively easier to obtain those key features to identify seizure or inter-ictal EEGs, as shown in Section 5.3. While other nonlinear methods, such as sample entropies, cannot extract significant features by just changing their parameters.

The proposed algorithm only requires one parameter, the input signals, which is not affected by the sampling frequency. In other words, it is independent from the frequency domain. Unlike the FFT algorithm, the window size should be the power of 2, while the FWHVA algorithm has no limit for the length of input data or window size. Therefore, the algorithm is more robust and easy to be applied to any size of data. Similarly as frequency can be divided into different sub-frequency bands, the WHVGs can enhance robust and performance by applying other graph features, such as variance of degree distributions.

Unfortunately, this method is not suitable for long-term time series, especially using 
                           
                              
                                 d
                                 ¯
                              
                           
                         feature, due to periodic limitations in Eq. (15). For example, the classification accuracy between set (A, B, C, D) and set E by using 
                           
                              d
                              ¯
                           
                         and 
                           
                              s
                              ¯
                           
                         features is less 3.6% for 4096 per segment, but it is 1.8% larger for a 173 data point segment compared with F
                        
                           p
                         and P
                        
                           θ
                        , as shown in Table 5. Thus, a further study is needed to investigate other graph features for long-term signals.

As shown in Fig. 2, there are two stages in EEG classification. The computation times for set A and set E with five different epoch sizes are presented in Table 6
                        . The size of the input data in classification stage in Fig. 2 is the number of features, while that in stage 1 is the EEG samples. Therefore, stage 1 introduces the bottleneck of the computation for EEG signals classification due to the long size of recordings. The FWHVA algorithm is a significantly important factor of the speed when faster classifiers are applied in classifying EEGs, such as K-NN classifier.

From clinical point of view, the size of a segment of epileptic EEG signals is less than 5s [19,37]. In fact, Barlow [36] suggested that better segment period is 1s. In addition, when the epoch size is 173 (1s) as shown in Tables 5 and 6, the classification performance with features based on the WHVGs is 8.9% higher than those based on the SamEn and 1.5 higher than the PSD, while the speed of the FWHVA is faster than those PSD or SampEn. Therefore, the FWHVA is an efficient tool for real time epileptic EEG signal processing.

The classification accuracies for the epileptic EEG database from different literature are presented in Table 7
                        .

According to Table 7, the accuracy of classification between sets A and E is 0.4% different from the best result by Srinivasan et al. [2] based on frequency domain, while sets D and E is 0.6% different from the best result by Siuly et al. [41]. For sets (A, B, C, D) and E, the classification accuracy is more close to clinic needs, it is a just little less compared with the PSD method.

However, our proposed method uses just two dimension features, and the speed is much faster than the PSD. In fact, according to Table 3, the classification accuracy between focal inter-ictal EEGs and ictal EEGs with the HVG feature 
                           
                              d
                              ¯
                           
                         is higher than those from the peak frequency features F
                        
                           p
                         and SampEn feature S
                        
                           e1. The 92.0% classifying accuracy on set D and set E only with one feature 
                           
                              d
                              ¯
                           
                         is higher than the 83.13% accuracy with one permutation entropy feature and a SVM by Nicoletta and Julius [12]. There are many methods to identify seizure on these EEG database [14]. However, using just two features, the classification accuracy of our proposed method is the highest so far.

@&#CONCLUSIONS@&#

There are three main conclusions in this paper. Firstly, two novel features: 
                        
                           d
                           ¯
                        
                      and 
                        
                           s
                           ¯
                        
                      from WHVGs are proposed to identify ictal EEGs from healthy EEGs with 100% accuracy when a segment EEG has 2048 or 4096 data points. 
                        
                           d
                           ¯
                        
                      and 
                        
                           s
                           ¯
                        
                      from ictal EEGs are found to be significantly higher than those of healthy and inter-ictal EEG, which explains that ictal EEGs are more chaotic. Secondly, 
                        
                           s
                           ¯
                        
                      of graph domain is more robust to noise than PSD of frequency domain and sample entropies of time domain, the former is also more stable for the initial value of chaos signals than the latter two features. Lastly, a fast weighted horizontal visibility graph constructing algorithm for HVG is provided and named as FWHVA. Compared with the sample entropy and FFT, the computational efficiency of the FWHVA is 76 times faster than that of the sample entropy and is 3.8 times faster than that of the FFT when the size of signals is more than 4000 data points. In addition, this study can also be applied to other time series analysis.

@&#REFERENCES@&#

