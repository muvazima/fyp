@&#MAIN-TITLE@&#Skill-based framework for optimal software project selection and resource allocation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a conceptual skill-based framework to capture resource allocation in software development projects.


                        
                        
                           
                           We build a corresponding mathematical model for resource allocation and project selection at the level of software skills.


                        
                        
                           
                           We develop a meta-heuristic to solve this problem which overcomes the computational complexity of the proposed formulation.


                        
                        
                           
                           The proposed framework and the corresponding model are applied to the case of Lebanon.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Resource allocation

Project selection

Software development

Software skills

Meta-heuristic

@&#ABSTRACT@&#


               
               
                  This paper presents a conceptual framework and a mathematical formulation for software resource allocation and project selection at the level of software skills. First, we introduce a skill-based framework that considers universities, software companies, and potential projects of a country. Based on this framework, we formulate a linear integer program PMax which determines the selection of projects and the allocation of human resources that maximize profit for a certain company. We show that PMax is NP-complete. Therefore, we devise a meta-heuristic, called Tabu Select and Greedily Allocate (TSGA), to overcome the computational complexities. When compared to PMax running on CPLEX, TSGA performs 15 times faster with an accuracy of 98% on small to large size problems where CPLEX converges. On larger problems where CPLEX does not return an answer, TSGA computes a feasible solution in the order of minutes.
                  For demonstration, the proposed skill-based framework and the corresponding mathematical model are applied to Lebanon by performing two surveys on the Lebanese software industry and academia. The case study shows that the proposed framework and mathematical model can be used in practice to improve project selection and resource allocation decisions in software companies.
               
            

@&#INTRODUCTION@&#

The project management literature generously addressed resource allocation in general (Brucker, Drexl, Mohring, Neumann, & Pesch, 1999; Herroelen & Leus, 2005; Herroelen, Reyck, & Demeulemeester, 1998; Oezdamar & Ulusoy, 1995) and project portfolio selection (Archer & Ghasemzadeh, 1999; Meade, 2002) as two separate problems. However, there is great room for suggesting models that solve the two interdependent problems simultaneously. In particular, the authors in Gutjahr, Katzensteiner, Reiter, Stummer, and Denk (2010), Yoshimuraa, Fujimia, Izuia, and Nishiwakia (2006) present models to solve the two problems one after the other assuming that the profitability of a chosen portfolio of projects is totally independent from the resources allocated on each one of them. We argue that in reality, the cost of the development of a project highly depends on the human workforce that works on it (Acuna, Juristo, & Moreno, 2006).

Additionally, software specific studies concerning project selection and resource allocation are still scarce (Otero, Centeno, Ruiz-Torres, & Otero, 2009). The problem of resource allocation in software project development is a unique challenge due to specific characteristics of software projects and software developers (Kan, 1994). The work of Acuna et al. (2006) finds that human resource allocation on software projects is generally left to the judgment of experts such as software team leaders and project managers. Although judgments are educated guesses that work in practice, however, managers lack mathematical tools to develop and assess project schedules and associated human resource allocation (Padberg, 2001). In particular, Plekhanova (1999) and Otero et al. (2009) observe that project managers map each software task to one skill when allocating human resources to tasks. Otero suggests that tasks should be mapped to several skills (Otero et al., 2009). Ngo-The maps a task into a set of skills and optimally allocates resources in release planning (Ngo-The & Ruhe, 2009).

In this paper, we propose a skill-based framework (SBF) that considers software projects, software companies and software related academia at the level of basic skills. That is, skills are the common thread that cuts across these three domains and are therefore at the center of our proposed framework. Educational processes, represented by universities, generate skills and form software development human resources that can be categorized into talent classes. Each talent class: S
                     ↦
                     L is characterized as a map from skills S to a strength level L
                     ={none,
                     weak,
                     average,
                     good,
                     excellent}. We characterize software projects by collective strength levels of required skills. The required skills and their associated levels are based on expert estimations where experts are project managers and software team leaders. We denote by potential projects those projects that can be developed in a given country. The process of developing software requires skills. Companies in a given country select from a set of potential projects. Each company then allocates its human resources in the form of capita per talent class to develop the selected projects. The company does the selection and allocation with maximum profit as a target. Companies in turn enrich their human resources via (1) strengthening existing skills and (2) producing skills that are not covered in current curricula. We assume that skills produced during development work will eventually make it into curricula due to the interaction between the industry and the academia. We refine our skill set S to include the skills produced by the industry S
                     
                        I
                      and assume none as the strength level for fresh graduates in such skills.

Based on the above framework, we build an integer linear program to optimally select a portfolio of projects and allocate resources (i.e. talents) to them such that the allocated talents satisfy the skills required by the selected projects. PMax differs from previous project selection and resource allocation methods (Gutjahr et al., 2010; Yoshimuraa et al., 2006) in that it treats the resource allocation and project selection as a single problem and presents an integer linear program to solve it. PMax also provides a more realistic cost estimation formula as it considers a company to pay all its talents regardless of whether a talent is allocated or not. Additionally, PMax differs from existing models (Gutjahr et al., 2010; Otero et al., 2009; Yoshimuraa et al., 2006) in that it introduces the concept of critical skills. A critical skill j for a project p is a skill with a minimum level of expertise Θ[p][j], where at least one allocated talent must possess to satisfaction a strength in j
                     ⩾
                     Θ[p][j], while other skills can be satisfied by strength levels of several talents.

In this paper, we make several contributions to the software management and operations research literature.
                        
                           •
                           We present SBF, a skill-based framework, to formalize the relationship between the software academia, the software industry of a given country and the potential projects at the level of skills. We formulate project selection and resource allocation as a mathematical program, PMax, which allows for critical skills and estimates cost more accurately.

We introduce TSGA, a Tabu-based meta-heuristic, to overcome the computational complexity of PMax since PMax is shown to be NP-complete. We compare the performance of TSGA to CPLEX. TSGA performs 15 times faster than CPLEX and reaches an optimal solution 64% of the time. On average, the profit value obtained from TSGA is 98% of the optimal profit obtained by CPLEX.

We conduct surveys covering the Lebanese software industry and academia to demonstrate how SBF can be implemented.

@&#LITERATURE REVIEW@&#

The paper draws upon various streams of research form project management, analyses of skills and competencies required for software product development, and software estimation models and techniques. From the project management literature, we only focus on the literature that combines project portfolio selection, activity scheduling, and resource allocation. Although relevant, the voluminous literature on resource constrained project scheduling problem, including multi-project and multi-mode versions, will be ignored. Additionally, since our mathematical model is built on a new skill-based framework, we also review literature describing various skills and competencies required in a software development environment. Finally, since our proposed model requires the estimation of various input parameters relating to cost and duration of development activities, we also discuss these various software estimation techniques in this section.


                        Gutjahr et al. (2010) present a mixed integer non-linear programming model for project selection and resource allocation while focusing on increasing the competences of the staff through experience. They decomposed the problem by applying a meta heuristic for project selection and then a greedy priority based heuristic for project scheduling and staffing. The main problem resides in the assumption that the cost of development of a certain project is assumed to be given independently of the resources that the model allocates on it. PMax differs by incorporating the cost of the allocated resources in the calculation of the project development cost.


                        Yoshimuraa et al. (2006) tackle the problems of project selection and resource allocation. They start by selecting the portfolio of projects that maximizes profit. Then they allocate a project leader for each project to end up with allocating the other human resources. In this paper, we consider that project selection and resource allocation are two interdependent problems that should be solved together.


                        Otero et al. (2009) presented a method that associates a set of required skills with each software task for the completion of the task. The method assigns available human resources to complete the required tasks. Otero’s work addresses the situation when the available resources fall short of covering the required skills and minimizes the learning time based on rhetorical relations between missing and available skills. PMax differs in that it maximizes profit, extends skills to projects instead of tasks, and considers project selection concurrently with resource allocation.


                        Xiao et al. (2009) consider the time and cost optimization problem in project scheduling and present a near optimal genetic algorithm. Ngo-The and Ruhe (2009) consider the release planning problem in software development. They present an optimal allocation of resources that maximizes the value gained from the released features. Their solution does not isolate software release planning from resource allocation across several releases to solve the problem globally. They first compute an optimal solution for a relaxed version of the problem, which they use with a genetic algorithm to compute a near optimal solution for the original problem.

Finally, Barreto et al. present a project manager with utility functions to form a team that fits desired needs using constraint satisfaction approach. The desired needs could optimize several aspects such as expense, performance, or size (Barreto, de O. Barros, & Werner, 2008).

There are two main approaches to software development effort estimation: judgment-based methods using group consensus techniques, and model-based methods using formal mathematical models (Boehm, Abts, & Chulani, 2000). Expert judgment techniques involve consulting with a group of software cost estimation experts to use their past experiences and arrive at an estimate (or to a consensus) for the cost and duration of the proposed project (Jorgensen, 2005). Formal models, on the other hand, are designed to provide some mathematical equations to perform effort estimation. These mathematical models could be based on rules-of-thumb, historical data, and analogies, and use inputs such as lines of code, number of functions to perform, and other cost drivers such as language, design methodology, skill-levels, risk assessments. The algorithmic methods have been largely studied and there are a lot of models that have been developed, such as COCOMO models, the Putnam model, and function points based models (Boehm et al., 2000). No one method is necessarily better or worse than the other; in fact, their strengths and weaknesses are often complimentary to each other (Jorgensen, Boehm, & Rifkin, 2009). Jorgensen shows that formal models have been somewhat erratic, and do not provide higher accuracy than expert judgment (Jorgensen & Shepperd, 2007). Expert judgment-based estimation approaches are, by far, the most common used approaches by the software industry (Jorgensen & Shepperd, 2007). There is no substantial evidence in favor of the use of estimation models. There are even situations where expert estimates are expected to be more accurate than formal estimation models (Jorgensen, 2004). We adopt this point of view and rely on experts to populate the different parameters of PMax while keeping in mind the best practices for expert estimations (Jorgensen, 2004).

Several researchers studied the software skill sets available in the industry to understand the software development dynamics. Andre, Baldoquin, and Acuna (2011) and Colomo-Palacios, Tovar-Caro, Crespo, and Gomez-Berbis (2010) defined several software development job positions and associated each position with a set of required skills. The positions are ordered in a hierarchical fashion, and a number of human resources with the needed skills are mapped to the positions to form a team. This set of skills includes technical skills, as well as a communication and team management skills.


                        Acuna and Juristo (2004) consider the positions as roles and push the mapping of positions to skills further. They consider psychological traits suitable for playing the role and compute a correspondence between software development roles and a likelihood of needed personality features. Trigo et al. (2010) investigate the most important software skills according to Chief Information Officers (CIO) in Spanish and Portuguese software companies. They consider 10 high level skills and they conclude that the most important skills are business knowledge and help desk/user support (Trigo et al., 2010). In our skill-based framework, we differ from Colomo-Palacios and Trigo in that we compute a granular set of detailed software related skills based on the study of the academia. In particular, we compute at least an order of magnitude larger skills set, where the skills are well defined formally in terms of course objectives and syllabi.


                        Lethbridge (2000) and Kitchenham, Budgen, Brereton, and Woodall (2005) try to determine the relevance of software skills taught at academia to the industry needs. They categorize skills into software engineering, scientific and general business and arts skills. They survey software graduates about the importance of their skills. The results reveal that programming languages are the most important skills that are rightfully well taught at universities while mathematical skills in general are taught more in depth than what the developers actually needed at work. We follow the same framework to generate software skills based on academia but we address CIOs of software companies to collect information about the employees of the companies. We refine our skill set based on the feedback of the CIOs. Intuitively, this provides a better management perspective of the value of skills. We also determine the importance of skills by analyzing the needs of the software projects developed in a certain country. We compare our findings for the Lebanese case with Lethbridge and Kitchenham in the results section.

SBF is a novel framework that considers software projects, software companies and software related academia at the level of basic skills. SBF analyses universities and their curricula, software companies and their human resources, and potential software projects and their requirements in terms of skills. SBF considers the union of the skills taught at universities, strengthened informally at work, produced at work, and required in potential projects as the base skill set.

SBF partitions university graduates and current human resources into talent classes. Each talent class is defined by a talent class strength vector that determines the strength of a talent in all skills. SBF represents the companies as talent class cardinality vectors where an entry in a vector represents the number of human resources in a talent class. Software project requirements are expressed in terms of required skills and strength in required skills.


                     Fig. 1
                      shows how universities’ students build strength in targeted skills. A university offers software curricula that teach several courses. Each course has specific outcomes that either develop existing software skills or teach completely new ones to students. In SBF, we consider all software courses from local universities to compile a list of all covered software related skills.

Developers working in local companies are likely the graduates of local universities, thus they possess a subset of the global skills taught in the country. In addition, two developers might possess a certain skill but with different strength levels. This might be due to different educational tracks or due to different work experiences. Thus, each developer possesses strength values in the compiled list of skills that reflect his/her proficiency.

We classify developers into several talent classes reflecting their skills and experiences. Developers belonging to the same talent class possess the same strengths in all the skills. For example, all developers belonging to talent class A possess a strength of 5 in the human computer interaction (HCI) skill and a strength of 4 in the object oriented programming (OOP) skill. Developers from the same talent class have the same compensation rate.

On the other hand, the analysis of project requirements determines skills and strength levels in those skills that are required for a successful completion of the projects. As shown in the right side of Fig. 1, SBF maps each required skill per project to a required strength level. The team working on a project must possess the required strength level in all required skills to be eligible to work on the project and complete within the set deadline. For example, if project “Navigate” requires strength of 10 in HCI and 7 in OOP, then a team of two developers from talent class A can work on it.

Academic programs are composed of a hierarchy of courses. Some courses are required and others are left as electives. Each course has a syllabus detailing its learning outcomes. We map a learning outcome to one or more software skills. The term hosting course of a set of skills denotes the course that teaches those skills. Students acquire a different strength level in each software related skill depending on several parameters.
                           
                              •
                              The choice of elective courses that the student takes indicates the skills he/she possesses.

Additionally, the performance of a student in a course, denoted by perf, is directly related to the strength in the skills that the course teaches.

For a given skill, and a given course that hosts this skill, the number of courses that consider the hosting course as a prerequisite, denoted by prereq, is indicative of how much the skills taught in the hosting course are fundamental.

Skills are more fundamental if they are required in several courses. Intuitively, this means the skills are further sharpened through repetition.

Skills in courses with higher depth in the prerequisites graph are given higher weights because they represent advanced courses taught at advanced stages. The depth of a hosting course corresponds to its position in the prerequisites graph and is a good indicator of the level of the unique skills it introduces.

We propose to compute the strength of a student in a given skill as follows.
                           
                              (1)
                              
                                 strength
                                 =
                                 perf
                                 ×
                                 (
                                 1
                                 +
                                 prereq
                                 )
                                 ×
                                 depth
                              
                           
                        Eq. (1) describes the strength of a human resource in a skill as a product of performance, frequency of the skill in the curriculum and the introduction level of the skill. The performance of a student perf ranges over either passing (1), good (2), or excellent (3). We do not consider weak students as we assume they do not make it into the software development market.

The industry survey determines the performance of existing human resources. The survey also ranks the existing human resources based on experience. We compute the strength of skills for existing human resources using Eq. (1) where perf represents performance, depth represents rank, and prereq represents original skills at hiring.

In SBF we compute the strength as in Eq. (1) and normalize the strength value over the range 0 to H, where H represents the highest normalized strength in a given skill.

SBF computes several representative talent classes to partition the talents generated by given universities. We considered two groups of students in each software-related academic program. In the first group, students take only the mandatory courses and select not to take software related elective courses. In the second group, students take the mandatory courses and all the software electives. In each group of students there are excellent students, good students and average students. This results in a total of six talent classes for each program where the first extreme represents the average students with only mandatory software related courses, and the other extreme represents the excellent students with all software related courses.

We assume that the rest of the students who do not belong to one of the two groups, fall between them in one of the six talent classes.

Given J skills, and K talent classes, we define 
                           M
                         to be the talent classes K
                        ×
                        J matrix such that 
                           M
                        [k][j]∈[0,
                        H] represents the strength of a developer from talent class k in skill j, where 1⩽
                        k
                        ⩽
                        K, 1⩽
                        j
                        ⩽
                        J. We represent a software company as a set of available human resources assumed all to be software developers. The human resources of a company are mapped to the set of talent classes. For each company, we define the resources vector 
                           n
                         of size K such that 
                           n
                        [k] is the number of software developers belonging to talent class k.

Similarly, each company is assumed to pay salaries for its developers in accordance with the strengths they possess. Therefore, we define the cost vector 
                           c
                         of size K such that 
                           c
                        [k] represents the money that the company pays per unit time for a software developer belonging to talent class k.

A software project with an associated revenue price is defined by a set of requirement specifications communicated by the client. The technical specifications detail the skills required to complete the project, and also fix delivery deadlines. In SBF, we rely on experts to formulate technical requirements into required skills with required strength vectors of size J. We introduce the nominal total strength matrix 
                           W
                        , where P is the number of projects to consider, such that 
                           W
                        [p][j] represents the strength that project p (1⩽
                        p
                        ⩽
                        P) requires in skill j.

In addition, SBF considers important skills by requiring that for each important skill, at least one member of the development team must have more than a required minimum. For this reason, we introduce a critical skills requirements Θ matrix. The value Θ[p][j]∈[0,
                        H] indicates that project p requires that at least one developer in the development team allocated on p must possess strength in j greater than or equal to Θ[p][j]. This allows our framework to define some expertise requirements in skills depending on project needs.

The vector 
                           d
                         of size P represents the deadlines of the projects such that 
                           d
                        [p] indicates how many yearly quarters are available at time 0 before the deadline of p. The development team respects the deadline of project p by finishing working on p before 
                           d
                        [p]. Additionally, experts can estimate the nominal duration 
                           δ
                        [p] that the development team needs to complete a given project p. We denote by that the nominal duration vector 
                           δ
                        . Finally, vector 
                           π
                         of size P is the revenue vector where 
                           π
                        [p] is the revenue that project p generates.

Given P potential software projects and a set of available software developers distributed over K software talent classes, our objective is to select the portfolio of projects that maximizes profit and allocates resources optimally amongst them so that all selected projects are successfully completed before their deadlines. Let T
                     =
                     max(
                        d
                     [1],…,
                     
                        d
                     [p],…,
                     
                        d
                     [P]) denote the planning horizon, i.e. the last deadline of the set of projects. We use yearly quarters as discrete time steps such that the allocation of resources occurs at each quarter, i.e. resources may be re-allocated quarterly.


                     Table 1
                      presents a list of symbols used throughout this paper. The resource allocation matrix 
                        A
                      denotes the resources allocated to projects throughout the quarters. 
                        A
                     [t] is a matrix of size P
                     ×
                     K, i.e. each 
                        A
                     [t][p][k] is one element of 
                        A
                     [t] that denotes the number of developers from talent class k working on project p during quarter t,1⩽
                     t
                     ⩽
                     T. Matrix 
                        B
                      denotes the total allocated strength matrix such that
                        
                           (2)
                           
                              ∀
                              t
                              ,
                              B
                              [
                              t
                              ]
                              =
                              A
                              [
                              t
                              ]
                              .
                              M
                           
                        
                     The binary indicator vector 
                        γ
                      of size P denotes the selected projects, such that 
                        γ
                     [p] is 1 if project p is selected and 0 otherwise. The binary selection matrix 
                        S
                      denotes projects selected per quarter. The entry 
                        S
                     [p][t] is 1 if resources were allocated to project p in quarter t and 0 otherwise.

Our objective is to maximize profit with available resources. Our decision variables are the entries of the 
                        A
                      matrix. We also present the variables in 
                        S
                      and 
                        γ
                     , that are computable from 
                        A
                     , as decision variables to make the problem linear and we constrain them to 
                        A
                     . The total revenue R
                     =
                     
                        γ
                     . 
                        π
                      is the revenue associated with the set of the selected and completed projects.

The binary indicator vector 
                        b
                      of size T denotes the busy quarters, i.e., 
                        b
                     [t] is 1 if the resources were allocated in quarter t and 0 otherwise.

The total cost of development is defined as 
                        
                           ζ
                           =
                           c
                           ·
                           n
                           ·
                           
                              
                                 ∑
                              
                              
                                 t
                                 =
                                 1
                              
                              
                                 T
                              
                           
                           b
                           [
                           t
                           ]
                        
                      and is calculated as the sum of the costs of each quarter. We assume that all employees receive salaries whether they are allocated to work on a project or not. The cost is added to the total cost if the company is working on at least one project during a chosen quarter. Thus the profit Q becomes:
                        
                           (3)
                           
                              Q
                              =
                              γ
                              ·
                              π
                              -
                              ζ
                           
                        
                     Constraint (C1) ensures that projects selected for work during a certain quarter have enough allocated resources in terms of total strengths. We compute an integer linear constraint without logic operations Li-1 that is equivalent to (C1). For each 〈p,
                     t〉 pair, When 
                        S
                     [p][t]=0, (C1) is satisfied. Similarly, so is ∀j.
                        B
                     [t][p][j]⩾0 from (Li-1) because 
                        B
                     [t][p][j] is always greater than or equal to 0. When 
                        S
                     [p][t]=1, (C1) and (Li-1) both get simplified to 
                        B
                     [t][p][j]−
                     
                        W
                     [p][j]⩾0. This proves the equivalence between (C1) and its integer linear form (Li-1).
                        
                           (C1)
                           
                              ∀
                              p
                              ,
                              t
                              ·
                              (
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              1
                              )
                              ⇒
                              (
                              ∀
                              j
                              ·
                              B
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              j
                              ]
                              ⩾
                              W
                              [
                              p
                              ]
                              [
                              j
                              ]
                              )
                           
                        
                     
                     
                        
                           (Li-1)
                           
                              ∀
                              p
                              ,
                              t
                              ,
                              j
                              ·
                              B
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              j
                              ]
                              -
                              (
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              j
                              ]
                              )
                              ⩾
                              0
                           
                        
                     Constraint (C2) ensures that projects not selected for work during a quarter have no resources allocated to them. We do not provide a linear form of constraint (C2) because we show in Theorem 1 that (C2) is redundant at optimality.
                        
                           (C2)
                           
                              ∀
                              p
                              ,
                              t
                              ·
                              (
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              0
                              )
                              ⇒
                              (
                              ∀
                              k
                              ,
                              A
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              =
                              0
                              )
                           
                        
                     Constraint (C3) guarantees that when a project is selected, it is actually completed. That is the number of quarters allocated to work on the project is at least equal to the number of nominal quarters needed to complete the project. We compute (Li-3) as an integer linear constraint version of (C3) in a similar manner to (Li-1). When 
                        γ
                     [p]=1, the bodies of the quantifiers in (C3) and (Li-3) are both reduced to 
                        
                           
                              
                                 ∑
                              
                              
                                 t
                                 =
                                 1
                              
                              
                                 T
                              
                           
                           (
                           S
                           [
                           p
                           ]
                           [
                           t
                           ]
                           )
                           ⩾
                           δ
                           [
                           p
                           ]
                        
                     . When 
                        γ
                     [p]=0, (C3) and (Li-3) are satisfied since T
                     ⩾
                     
                        δ
                     [p] and 
                        
                           
                              
                                 ∑
                              
                              
                                 t
                                 =
                                 1
                              
                              
                                 T
                              
                           
                           (
                           S
                           [
                           p
                           ]
                           [
                           t
                           ]
                           )
                           ⩾
                           0
                        
                     .
                        
                           (C3)
                           
                              ∀
                              p
                              ·
                              (
                              γ
                              [
                              p
                              ]
                              =
                              1
                              )
                              ⇒
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         t
                                                         =
                                                         1
                                                      
                                                      
                                                         T
                                                      
                                                   
                                                
                                                S
                                                [
                                                p
                                                ]
                                                [
                                                t
                                                ]
                                             
                                          
                                       
                                       ⩾
                                       δ
                                       [
                                       p
                                       ]
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (Li-3)
                           
                              ∀
                              p
                              ·
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       t
                                       =
                                       1
                                    
                                    
                                       T
                                    
                                 
                              
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              +
                              (
                              T
                              ×
                              (
                              1
                              -
                              γ
                              [
                              p
                              ]
                              )
                              )
                              ⩾
                              δ
                              [
                              p
                              ]
                           
                        
                     Constraint (C4) guarantees that we do not work on projects that are not selected. We do not provide a linear form for (C4) because we show in Theorem 1 that it is redundant at optimality. Constraint (C5) ensures that allocated resources do not exceed available resources.
                        
                           (C4)
                           
                              ∀
                              p
                              ·
                              (
                              γ
                              [
                              p
                              ]
                              =
                              0
                              )
                              ⇒
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                t
                                                =
                                                1
                                             
                                             
                                                T
                                             
                                          
                                       
                                       [
                                       S
                                       [
                                       p
                                       ]
                                       [
                                       t
                                       ]
                                       =
                                       0
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (C5)
                           
                              ∀
                              k
                              ,
                              t
                              ·
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       =
                                       1
                                    
                                    
                                       P
                                    
                                 
                              
                              A
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              ⩽
                              n
                              [
                              k
                              ]
                           
                        
                     Constraint (C6) ensures that a project has no resources allocated to it after its deadline. Constraint (C7) guarantees that the allocated talents for a project contain at least one talent that satisfies the critical skills required to complete the project.
                        
                           (C6)
                           
                              ∀
                              p
                              ,
                              t
                              ∈
                              [
                              d
                              [
                              p
                              ]
                              ,
                              T
                              ]
                              ·
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              0
                           
                        
                     
                     
                        
                           (C7)
                           
                              ∀
                              p
                              ,
                              j
                              ,
                              t
                              ·
                              (
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              1
                              ∧
                              Θ
                              [
                              p
                              ]
                              [
                              j
                              ]
                              >
                              0
                              )
                              ⇒
                              
                                 
                                    
                                       ∃
                                       k
                                       ·
                                       A
                                       [
                                       t
                                       ]
                                       [
                                       p
                                       ]
                                       [
                                       k
                                       ]
                                       >
                                       0
                                       ∧
                                       M
                                       [
                                       k
                                       ]
                                       [
                                       j
                                       ]
                                       ⩾
                                       Θ
                                       [
                                       p
                                       ]
                                       [
                                       j
                                       ]
                                    
                                 
                              
                           
                        
                     In order to write (C7) as a set of integer linear constraints, we introduce a new four dimensional matrix of binary decision variables 
                        f
                     . (C7) is equivalent to the following four integer linear constraints.
                        
                           (Li-7-1)
                           
                              ∀
                              p
                              ,
                              k
                              ,
                              j
                              ,
                              t
                              ·
                              A
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              +
                              f
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              [
                              j
                              ]
                              -
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              ⩾
                              0
                           
                        
                     
                     
                        
                           (Li-7-2)
                           
                              ∀
                              p
                              ,
                              k
                              ,
                              j
                              ,
                              t
                              ·
                              M
                              [
                              k
                              ]
                              [
                              j
                              ]
                              +
                              (
                              f
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              [
                              j
                              ]
                              -
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              )
                              ×
                              Θ
                              [
                              p
                              ]
                              [
                              j
                              ]
                              ⩾
                              0
                           
                        
                     
                     
                        
                           (Li-7-3)
                           
                              ∀
                              p
                              ,
                              j
                              ,
                              t
                              ·
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       =
                                       1
                                    
                                    
                                       K
                                    
                                 
                              
                              f
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              [
                              j
                              ]
                              ⩽
                              K
                              -
                              1
                           
                        
                     
                     
                        
                           (Li-7-4)
                           
                              ∀
                              p
                              ,
                              k
                              ,
                              j
                              ,
                              t
                              ·
                              f
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              [
                              j
                              ]
                              ∈
                              {
                              0
                              ,
                              1
                              }
                           
                        
                     Constraints (C8) and (C9) enforce the relation between the busy vector and the project selection matrix. In particular, if for a quarter a company is not busy, then it has no projects selected in that quarter. Otherwise, it has at least one project selected.
                        
                           (C8)
                           
                              ∀
                              t
                              ·
                              (
                              b
                              [
                              t
                              ]
                              =
                              0
                              )
                              ⇒
                              (
                              ∀
                              p
                              ·
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              0
                              )
                           
                        
                     
                     
                        
                           (C9)
                           
                              ∀
                              t
                              ·
                              (
                              b
                              [
                              t
                              ]
                              =
                              1
                              )
                              ⇒
                              (
                              ∃
                              p
                              ·
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              =
                              1
                              )
                           
                        
                     The integer linear form of (C8) is (Li-8). There is no need to present the linear form of (C9) as shown in Theorem 1. When 
                        b
                     [t]=0, (C8) is equivalent to ∀p
                     ·
                     
                        S
                     [p][t]=0, and (Li-8) is reduced to 
                        
                           ∀
                           t
                           ·
                           
                              
                                 ∑
                              
                              
                                 p
                                 =
                                 1
                              
                              
                                 P
                              
                           
                           S
                           [
                           p
                           ]
                           [
                           t
                           ]
                           ⩽
                           0
                        
                     . Given that 
                        S
                     [p][t]⩾0, then (Li-8) is equivalent to 
                        
                           
                              
                                 ∑
                              
                              
                                 p
                                 =
                                 1
                              
                              
                                 P
                              
                           
                           S
                           [
                           p
                           ]
                           [
                           t
                           ]
                           =
                           0
                        
                      and thus equivalent to (C8). When 
                        b
                     [t]=1, (C8) is satisfied. Similarly (Li-8) is satisfied since 
                        
                           P
                           ⩾
                           
                              
                                 ∑
                              
                              
                                 p
                                 =
                                 1
                              
                              
                                 P
                              
                           
                           S
                           [
                           p
                           ]
                           [
                           t
                           ]
                        
                     .
                        
                           (Li-8)
                           
                              ∀
                              t
                              ·
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       =
                                       1
                                    
                                    
                                       P
                                    
                                 
                              
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              -
                              (
                              b
                              [
                              t
                              ]
                              ×
                              P
                              )
                              ⩽
                              0
                           
                        
                     Constraint (C10) dictates the types of all the decision variables.
                        
                           (C10)
                           
                              ∀
                              t
                              ,
                              ∀
                              p
                              ,
                              ∀
                              k
                              ·
                              A
                              [
                              t
                              ]
                              [
                              p
                              ]
                              [
                              k
                              ]
                              ∈
                              N
                              ,
                              S
                              [
                              p
                              ]
                              [
                              t
                              ]
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              γ
                              [
                              p
                              ]
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              b
                              [
                              t
                              ]
                              ∈
                              {
                              0
                              ,
                              1
                              }
                           
                        
                     Our objective is to select a portfolio of projects that the company can complete successfully with maximum profit Q and minimum effort subject to constraints (C1)–(C10). Note that effort 
                        
                           E
                           =
                           
                              
                                 ∑
                              
                              
                                 t
                                 =
                                 1
                              
                              
                                 T
                              
                           
                           
                              
                                 ∑
                              
                              
                                 p
                                 =
                                 1
                              
                              
                                 P
                              
                           
                           A
                           [
                           t
                           ]
                           [
                           p
                           ]
                           ·
                           c
                        
                      is different from the cost ζ since cost considers the cost of employees for each quarter while effort ignores the cost of an employee in quarters where he is not allocated to a project. Thus, we formulate the objective function as shown in Eq. (4) where ε is a very small positive number.
                        
                           (4)
                           
                              OF
                              =
                              γ
                              ·
                              π
                              -
                              ζ
                              -
                              ε
                              ·
                              E
                           
                        
                     Constraints (C2), (C4), and (C9) are subsumed by the optimization as proven in Theorem 1 below, and consequently we relax our problem and solve for
                        
                           (PMax)
                           
                              
                                 
                                    
                                       max
                                    
                                    
                                       C
                                       1
                                       ,
                                       C
                                       3
                                       ,
                                       C
                                       5
                                       -
                                       C
                                       8
                                       ,
                                       C
                                       10
                                    
                                 
                              
                              
                              γ
                              ·
                              π
                              -
                              ζ
                              -
                              ε
                              ·
                              E
                           
                        
                     
                     
                        Theorem 1
                        
                           Let System1 be PMax and let E1 be the set of solutions to System1. Let System2 be max
                           
                              C1-C10
                            
                           
                              (4)
                            
                           and let E2 be the set of solutions to System2. We have E1
                           
                           =
                           
                           E2.
                        

Intuitively, maximizing profit guarantees (C9) and minimizing effort guarantees (C2) and (C4), however the formal proof for Theorem 1 is found in the Appendix available online.
                        1
                        
                           http://webfea.fea.aub.edu.lb/fadi/dkwk/doku.php?id=pmax.
                     
                     
                        1
                     
                  

We argue that PMax is NP-complete by reducing the knapsack (KP) problem to an instance of PMax.

Let the number of skills J
                     =1, all the potential projects 1⩽
                     p
                     ⩽
                     P have duration 
                        δ
                     [p]=1, and let the deadline 
                        d
                     [p]=1. Let the number of talent classes K
                     =1 indicating that 
                        M
                      has only one entry 
                        M
                     [1][1] that we set to 1. Let 
                        c
                     [1]=0 (i.e. resources are available for free). This special instance of PMax can be written as
                        
                           (5)
                           
                              
                                 
                                    
                                       max
                                    
                                    
                                       γ
                                    
                                 
                              
                              (
                              γ
                              ·
                              π
                              )
                           
                        
                     subject to
                        
                           (6)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       =
                                       1
                                    
                                    
                                       P
                                    
                                 
                              
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              1
                              ]
                              ⩽
                              n
                              [
                              1
                              ]
                           
                        
                     and where
                        
                           (7)
                           
                              ∀
                              p
                              ,
                              A
                              [
                              1
                              ]
                              [
                              p
                              ]
                              [
                              1
                              ]
                              =
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              1
                              ]
                           
                        
                     
                  

This is a 0–1 KP problem where 
                        W
                     [p][1] is the weight of project p, 
                        π
                     [p] is its value and 
                        n
                     [1] is the capacity of the knapsack. Any solution to this problem is a solution to the KP problem. Given that KP is NP-complete (Garey & Johnson, 1990), we conclude that PMax has no deterministically polynomial algorithm as long as there is no such a known algorithm for any of the NP-complete problems. Let the number of skills J
                     =2, all the potential projects 1⩽
                     p
                     ⩽
                     P have duration 
                        δ
                     [p]=1, and let the deadline 
                        d
                     [p]=1. Let the number of talent classes K
                     =2. Let M[1][1]=
                     M[2][2]=1 and M[1][2]=
                     M[2][1]=0. Let 
                        c
                     [1]=
                     
                        c
                     [2]=0 (i.e. resources are available for free). This instance of PMax can be written as
                        
                           (8)
                           
                              
                                 
                                    
                                       max
                                    
                                    
                                       γ
                                    
                                 
                              
                              (
                              γ
                              ·
                              π
                              )
                           
                        
                     subject to
                        
                           (9)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       =
                                       1
                                    
                                    
                                       P
                                    
                                 
                              
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              1
                              ]
                              ⩽
                              n
                              [
                              1
                              ]
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       =
                                       1
                                    
                                    
                                       P
                                    
                                 
                              
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              2
                              ]
                              ⩽
                              n
                              [
                              2
                              ]
                           
                        
                     and where
                        
                           (11)
                           
                              ∀
                              p
                              ,
                              A
                              [
                              1
                              ]
                              [
                              p
                              ]
                              [
                              1
                              ]
                              =
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              1
                              ]
                           
                        
                     
                     
                        
                           (12)
                           
                              ∀
                              p
                              ,
                              A
                              [
                              1
                              ]
                              [
                              p
                              ]
                              [
                              2
                              ]
                              =
                              γ
                              [
                              p
                              ]
                              ×
                              W
                              [
                              p
                              ]
                              [
                              2
                              ]
                           
                        
                     This is a two dimensional KP problem. Therefore, PMax has no known fully polynomial time approximation scheme (FPTAS) (Kellerer, Pferschy, & Pisinger, 2004).

Given the complexity of PMax, solving medium and large size problems optimally is practically infeasible. The memory and run-time requirements can vary tremendously depending on the inherent complexity and the structure of the problem.

Problems of the real case size of J
                     =197, K
                     =12, P
                     =35 (as shown later in Section 7) and with a relatively small number of developers (in the order of tens) are sometimes infeasible if run on an 8gigabyte quad-core machine using CPLEX. This behavior is justified by the NP-complete characteristic of the problem. For this reason, we devise Tabu Select and Greedily Allocate (TSGA), a method that implements a greedy allocation of resources on a set of chosen projects for completion then performs Tabu iterations on the project selection vector to improve on company profit.

Tabu Select (TSel) is an application of the Tabu Search meta-heuristic on the selection of projects problem. As introduced by Glover (1989), Glover (1990), Tabu search takes a feasible solution, a set of constraints, an objective function, a set of aspiration criteria, and a set of stopping conditions. TSel explores the neighborhood space of the feasible solution beyond local optimality to improve on the value of the objective function. This means that TSel allows intermediate worse objective values in the hope of improving again later. Given a feasible solution of the problem, Tabu search considers it as its current configuration then it investigates the neighboring candidate solutions. The candidate solution that has the best objective and that does not break any Tabu conditions is then considered as the new configuration. Tabu moves are only allowed if the aspiration criteria are met. Meanwhile, TSel keeps track of the solution that generated the best objective so far. The algorithm terminates when the stopping conditions are satisfied.

We make use of TSel to determine the most profitable binary project selection vector 
                           γ
                        
                        ∗, thus a configuration is an instance of 
                           γ
                        . We define a move to a neighboring solution as a single bit flip in the configuration vector. The candidate moves are all the possible one-bit flips of the configuration vector resulting in candidate 
                           γ
                         vectors. A Tabu list maintains all visited 
                           γ
                         configuration and restricts revisiting it unless the aspiration criterion is met.

For Tabu Select, we define two aspiration criteria. We allow to designate a Tabu candidate move as a new configuration only when one of the following two events happens: (1) The profit associated with this move is higher than the best profit reached so far. (2) All candidate 
                           γ
                         vectors are Tabu.

TSel terminates if one of the following stopping conditions takes place:
                           
                              •
                              If the number of iterations (maxIterNum) is exceeded without improving the best stored solution,

When the allowed run time (maxRunTime) is exceeded,

When all the candidate moves are Tabu for the maxTabuConfNum consecutive iteration.

It is generally advisable that the initial feasible solution is computationally easy to generate and of good quality (Glover, 1989). Initially, TSel filters the infeasible projects. A project is feasible if its required strength in each of the J skills does not exceed the combined strength of the company resources in that skill and if its critical requirements are available in the company resources. For each feasible project p, quarterVal[p] represents an estimation of the quarterly profit associated with p. The value quarterVal[p] is equivalent to the revenue of p per quarter of development reduced by an estimate of the cost of the allocated resources on p.
                              
                                 (13)
                                 
                                    quarterVal
                                    [
                                    p
                                    ]
                                    =
                                    
                                       
                                          π
                                          [
                                          p
                                          ]
                                       
                                       
                                          δ
                                          [
                                          p
                                          ]
                                       
                                    
                                    -
                                    quarterCost
                                    [
                                    p
                                    ]
                                 
                              
                           
                        

To estimate quarterCost[p], we determine first the skill j
                           
                              m
                            that maximizes 
                              W
                           [p][j] over all skills. We assume that dividing 
                              W
                           [p][j
                           
                              m
                           ] by the average developer strength in j
                           
                              m
                            gives us an estimation of the number of developers that will work on p. We then multiply this estimation of the number of developers by the average salary (averageC) of a developer in the company in question.
                              
                                 (14)
                                 
                                    quarterCost
                                    [
                                    p
                                    ]
                                    =
                                    
                                       
                                          W
                                          [
                                          p
                                          ]
                                          [
                                          
                                             
                                                j
                                             
                                             
                                                m
                                             
                                          
                                          ]
                                       
                                       
                                          averageStr
                                          [
                                          
                                             
                                                j
                                             
                                             
                                                m
                                             
                                          
                                          ]
                                       
                                    
                                    ×
                                    averageC
                                 
                              
                           Feasible projects are added to the vector of feasible projects feasibleProj ordered by the decreasing order of quarterVal.

During any phase of the solution, TSGA maintains a matrix 
                              F
                            of unallocated resources such that 
                              F
                           [t][k] indicates the number of unallocated developers belonging to class k during quarter t.
                              
                                 (15)
                                 
                                    F
                                    [
                                    t
                                    ]
                                    [
                                    k
                                    ]
                                    =
                                    n
                                    [
                                    k
                                    ]
                                    -
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             p
                                             =
                                             1
                                          
                                          
                                             P
                                          
                                       
                                    
                                    A
                                    [
                                    t
                                    ]
                                    [
                                    p
                                    ]
                                    [
                                    k
                                    ]
                                 
                              
                           At startup, no allocations are yet made, thus ∀t, ∀k, 
                              F
                           [t][k]=
                           n[k]. After selecting a project p, Greedily Allocate (GAlloc) checks if p is feasible given the matrix 
                              F
                           . If p is feasible, GAlloc allocates resources for p and modifies 
                              F
                            removing the newly allocated resources on p. We generate the initial feasible solution 
                              γ
                           
                           
                              i
                            according to the following:
                              
                                 1.
                                 Start with 
                                       γ
                                    
                                    
                                       i
                                    
                                    =
                                    
                                       0
                                    
                                 

Select the next p belonging to feasibleProj
                                 

If Greedily Allocate (GAlloc) can allocate resources for p, then let 
                                       γ
                                    
                                    
                                       i
                                    [p]=1

Goto 2

The initial project selection vector 
                              γ
                           
                           
                              i
                            and the associated initial allocation matrix 
                              A
                           
                           
                              i
                            are then fed to the Tabu Select iterations. We note here that if 
                              γ
                           
                           
                              i
                           
                           =
                           
                              0
                           , then no project is feasible and thus there is no reason to continue and perform the iterations.

The goal of TSel iterations is to move from one configuration to the other aiming at improving the objective value. Algorithm 1 describes the iteration process. The decision variables 
                              γ
                           
                           ∗ and 
                              A
                           
                           ∗ with the associated profit Q
                           ∗ denote the best answer that Tabu Select has reached at any point in time.

Initially, the best answer reached is the answer obtained from the initial solution. Therefore 
                              γ
                           
                           ∗
                           =
                           
                              γ
                           
                           
                              i
                           , 
                              A
                           
                           ∗
                           =
                           
                              A
                           
                           
                              i
                            and Q
                           ∗ is the profit associated with 
                              γ
                           
                           
                              i
                            and 
                              A
                           
                           
                              i
                            and is calculated as indicated in Eq. (3).

For each configuration vector 
                              γ
                           
                           
                              c
                           , generateMutations () generates the associated list of possible neighboring solutions. Each neighboring (candidate) solution 
                              γ
                           
                           
                              can
                            differs by one bit from 
                              γ
                           
                           
                              c
                           
                           ·
                           
                              γ
                           
                           
                              can
                            either adds an additional project to be completed or deselects a previously selected project. In the latter case, freeResources () frees the allocated resources on the earlier selected project by removing them from 
                              A
                            and adding them to 
                              F
                           .

In case 
                              γ
                           
                           
                              can
                            adds an additional project, GAlloc () either succeeds in allocating resources for the additional project and returns true, or fails and returns false. The list of feasible neighboring solutions are stored in candidatesMap.

If the best neighboring solution has a profit above Q
                           ∗, then it becomes the next configuration and {Q
                           ∗,
                           
                              γ
                           
                           ∗,
                           
                              A
                           
                           ∗} are updated accordingly. Otherwise, the neighboring solution that is not contained in the tabuList and that has the highest profit Q is then the next configuration. If no such neighboring solution is found, then one of the Tabu neighbors is chosen at random to be the next configuration by the choice () function.

Any chosen configuration that does not belong to tabuList is added to this list. Iterations continue until one of the stopping criteria is met. At the beginning of each iteration, 
                              F
                            is reset to represent the non-allocated resources in 
                              A
                           . The function resetF () resets 
                              F
                            according to Eq. (15).
                              Algorithm 1
                              (
                                    γ
                                 
                                 ∗,
                                 
                                    A
                                 
                                 ∗,
                                 Q
                                 ∗) TSI (
                                    γ
                                 
                                 
                                    i
                                 ,
                                 
                                    A
                                 
                                 
                                    i
                                 )// returns (
                                    γ
                                 
                                 ∗,
                                 
                                    A
                                 
                                 ∗,
                                 Q
                                 ∗) 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   1: 
                                                      γ
                                                   
                                                   ∗
                                                   =
                                                   
                                                      γ
                                                   
                                                   
                                                      i
                                                   , 
                                                      A
                                                   
                                                   ∗
                                                   =
                                                   
                                                      A
                                                   
                                                   
                                                      i
                                                   , Q
                                                   ∗
                                                   =
                                                   Q(
                                                      γ
                                                   
                                                   
                                                      i
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      i
                                                   ), 
                                                      γ
                                                   
                                                   
                                                      c
                                                   
                                                   =
                                                   
                                                      γ
                                                   
                                                   
                                                      i
                                                   , 
                                                      A
                                                   
                                                   
                                                      c
                                                   
                                                   =
                                                   
                                                      A
                                                   
                                                   
                                                      i
                                                    
                                                   //initialization
                                             
                                             
                                                
                                                   2: iterNum
                                                   =1, tabuConfNum
                                                   =0, tabuList
                                                   ={}
                                             
                                             
                                                
                                                   3: StartTimer (runTime)
                                             
                                             
                                                
                                                   4:
                                             
                                             
                                                
                                                   5: while (iterNum
                                                   <
                                                   maxIterNum && tabuConfNum
                                                   <
                                                   maxTabuConfNum) do
                                                
                                             
                                             
                                                
                                                   6:  
                                                   candidatesMap.clear (), tabuCandidatesMap.clear ()
                                             
                                             
                                                
                                                   7:  
                                                   list
                                                   
                                                      γ
                                                   
                                                   
                                                      can
                                                   
                                                   =generateMutations (
                                                      γ
                                                   
                                                   
                                                      c
                                                   ) // generate vectors one-bit different from 
                                                      γ
                                                   
                                                   
                                                      c
                                                   
                                                
                                             
                                             
                                                
                                                   8:  
                                                   for (
                                                      γ
                                                   
                                                   
                                                      can
                                                   
                                                   ∈
                                                   list
                                                   
                                                      γ
                                                   
                                                   
                                                      can
                                                   ) do
                                                
                                             
                                             
                                                
                                                   9:  
                                                   if (runTime
                                                   >
                                                   maxRunTime) then
                                                
                                             
                                             
                                                10: 
                                                    
                                                   return (
                                                      γ
                                                   
                                                   ∗,
                                                   
                                                      A
                                                   
                                                   ∗,
                                                   Q
                                                   ∗)
                                             
                                             
                                                11:  
                                                   end if
                                                
                                             
                                             
                                                12:  
                                                   
                                                      A
                                                   
                                                   =
                                                   
                                                      A
                                                   
                                                   
                                                      c
                                                   
                                                
                                             
                                             
                                                13:  
                                                   
                                                      F
                                                   
                                                   =resetF (
                                                      n
                                                   ,
                                                   
                                                      A
                                                   )
                                             
                                             
                                                14:  
                                                   p
                                                   =indexOfNonZeroElement (
                                                      γ
                                                   
                                                   
                                                      can
                                                   
                                                   −
                                                   
                                                      γ
                                                   
                                                   
                                                      c
                                                   )
                                             
                                             
                                                15:  
                                                   if ((
                                                      γ
                                                   
                                                   
                                                      can
                                                   
                                                   −
                                                   
                                                      γ
                                                   
                                                   
                                                      c
                                                   )[p]==−1) then 
                                                   // if the mutation removes a project
                                             
                                             
                                                16:  
                                                    freeResources (p) // move resources of p from 
                                                      A
                                                    to 
                                                      F
                                                   
                                                
                                             
                                             
                                                17:  
                                                   else if (
                                                      
                                                         ≠
                                                         g
                                                      
                                                    GAlloc (p,
                                                   
                                                      A
                                                   )) then 
                                                    // GAlloc succeeds and mutation adds a project
                                             
                                             
                                                18: 
                                                    
                                                   continue
                                                
                                             
                                             
                                                19:  
                                                   end if
                                                
                                             
                                             
                                                20:
                                             
                                             
                                                21:  
                                                   Q
                                                   
                                                      can
                                                   
                                                   =
                                                   Q(
                                                      γ
                                                   
                                                   
                                                      can
                                                   ,
                                                      A
                                                   )
                                             
                                             
                                                22:  
                                                   candidatesMap.insert ({Q
                                                   
                                                      can
                                                   ,
                                                   
                                                      γ
                                                   
                                                   
                                                      can
                                                   ,
                                                   
                                                      A
                                                   })
                                             
                                             
                                                23:  
                                                   end for
                                                
                                             
                                             
                                                24:
                                             
                                             
                                                25:  
                                                   while (candidatesMap.isEmpty ()==false) do
                                                
                                             
                                             
                                                26:  {Q
                                                   
                                                      best
                                                   ,
                                                   
                                                      γ
                                                   
                                                   
                                                      best
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      best
                                                   }=max
                                                      Q
                                                   
                                                   candidatesMap
                                                
                                             
                                             
                                                27:  
                                                   if (Q
                                                   
                                                      best
                                                   
                                                   >
                                                   Q
                                                   ∗) then
                                                
                                             
                                             
                                                28: 
                                                    {Q
                                                   ∗,
                                                   
                                                      γ
                                                   
                                                   ∗,
                                                   
                                                      A
                                                   
                                                   ∗}={Q
                                                   
                                                      best
                                                   ,
                                                   
                                                      γ
                                                   
                                                   
                                                      best
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      best
                                                   }
                                             
                                             
                                                29:  
                                                    
                                                   break
                                                
                                             
                                             
                                                30:  
                                                   end if
                                                
                                             
                                             
                                                31:  
                                                   if (
                                                      γ
                                                   
                                                   
                                                      best
                                                   
                                                   ∈
                                                   tabuList) then
                                                
                                             
                                             
                                                32: 
                                                    
                                                   candidatesMap.remove ({Q
                                                   
                                                      best
                                                   ,
                                                   
                                                      γ
                                                   
                                                   
                                                      best
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      best
                                                   })
                                             
                                             
                                                33: 
                                                    
                                                   tabuCandidatesMap.add ({
                                                      γ
                                                   
                                                   
                                                      best
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      best
                                                   })
                                             
                                             
                                                34:  
                                                   end if
                                                
                                             
                                             
                                                35:  
                                                   end while
                                                
                                             
                                             
                                                36:
                                             
                                             
                                                37:  
                                                   if (candidatesMap.isEmpty ()) then
                                                
                                             
                                             
                                                38:  {
                                                      γ
                                                   
                                                   
                                                      c
                                                   ,
                                                   
                                                      A
                                                   
                                                   
                                                      c
                                                   } = choice (tabuCandidatesMap)
                                             
                                             
                                                39:  
                                                   tabuConfNum
                                                   =
                                                   tabuConfNum
                                                   +1
                                             
                                             
                                                40:  
                                                   else
                                                
                                             
                                             
                                                41:  
                                                   
                                                      γ
                                                   
                                                   
                                                      c
                                                   
                                                   =
                                                   
                                                      γ
                                                   
                                                   
                                                      best
                                                   , 
                                                      A
                                                   
                                                   
                                                      c
                                                   
                                                   =
                                                   
                                                      A
                                                   
                                                   
                                                      best
                                                   
                                                
                                             
                                             
                                                42:  
                                                   tabuConfNum
                                                   =0
                                             
                                             
                                                43:  
                                                   end if
                                                
                                             
                                             
                                                44:  
                                                   iterNum
                                                   =
                                                   iterNum
                                                   +1
                                             
                                             
                                                45: end while
                                                
                                             
                                             
                                                46:
                                             
                                             
                                                47: return (
                                                      γ
                                                   
                                                   ∗,
                                                   
                                                      A
                                                   
                                                   ∗,
                                                   Q
                                                   ∗)
                                             
                                          
                                       
                                    
                                 
                              

Greedily Allocate is called on Line 17 of Algorithm 1 to decide whether a project p should be added to the list of chosen projects. GAlloc starts by populating the vector of candidate quarters 
                           q
                         that includes the quarters during which p can be worked at. A quarter earlier than 
                           d
                        [p] is added to 
                           q
                         if the combined strength of the unallocated resources in it is at least equal to the strength that p requires for all J skills and if the unallocated resources satisfy the critical skills requirements for p. If the size of 
                           q
                         is at least 
                           δ
                        [p], then p is feasible. The complexity of the feasibility check of project p is therefore O(
                           δ
                        [p]×
                        J
                        ×
                        K).

GAlloc calculates for each quarter t from 
                           q
                         the money value MVal[t] of the resources already allocated during t. GAlloc selects 
                           δ
                        [p] quarters from 
                           q
                         starting with the quarters with the highest MVal. Ties between two quarters are broken by choosing the one closer to the deadline 
                           d
                        [p] first. By selecting quarters with highest MVal, GAlloc tries to maximize a quarter usage by allocating as much resources as possible during it before switching to less occupied quarters.

This process has implications on the cost of development since allocating resources for an additional project during a previously non-busy quarter (with MVal
                        =0) adds to the total cost of human resources and makes the company pay salaries for all its developers during that quarter. Breaking ties by choosing quarters closer to the deadline tries to free early quarters for other potential projects with closer deadlines.

For the 
                           δ
                        [p] chosen quarters for working on p, GAlloc allocates all the unallocated resources on p. Then it removes one resource at a time without breaking feasibility conditions starting from the talent class that has the highest salary and moving towards the least costly ones. The allocation process has therefore a polynomial complexity of O(
                           δ
                        [p]×
                        K
                        ×max (
                           n
                        )). Therefore, as a whole Greedily Allocate has a polynomial complexity.

We evaluate our skill-based framework and apply it on the Lebanese academia and software industry. We perform two surveys, one for the academia and one for the software companies, following the guidelines presented in Section 3 to populate the parameters of PMax.

In Lebanon, there is one public university and 31 licensed private universities as per the Lebanese Ministry of Education (2012). We conducted surveys on nine universities that have the highest enrollment rates in Lebanon.
                           2
                           The universities are in no specific order: the Lebanese University (LU), the American University of Beirut (AUB), the Saint Joseph University (USJ), the Lebanese American University (LAU), the Beirut Arab University (BAU), the Notre Dame University (NDU), the Hariri Canadian University (HCU), the Lebanese International University (LIU), and the Haigazian University (HU).
                        
                        
                           2
                         Each academic institution offers one or more software related programs. We note the distinction between bachelors of engineering (Computer Engineering, Electrical Engineering) and bachelors of science (Computer Science, Information Technology). We study the academic programs offered as indicated in Section 3 and we generate a list of software skills and a set of talent classes.

According to Dal Hitti, the general manager of the Association of the Lebanese Software Industry (ALSI), there are 103 software companies in Lebanon. Half of them are of very small size comprising of 5 employees on average. A quarter of them are composed of 25–30 employees, 22% have an average size of 80 employees and the remaining 3% are companies above 100 employees each (Hitti, 2011).

We contacted 35 software companies and 11 completed the interview based industry survey.
                           3
                           It is worth noting that there are 103 software development companies in Lebanon and 11 of them agreed to complete the survey, i.e. 10.6% of the total number.
                        
                        
                           3
                         For each company, we parametrized the vectors 
                           n
                         and 
                           c
                        . Then each CIO provided us with detailed information about a project that the company completed. This information was used to populate the vectors 
                           d
                        , 
                           δ
                         and 
                           π
                         and the matrix 
                           W
                        . We ended up with 11 projects. Survey data is available online
                           1
                        .

We generalized and extended the set of projects collected from the surveys by aggregating the required skills and the revenue and formed a total of 35 projects that represent the Lebanese industry. In particular, for each project p, we generated a bounding range of two projects p
                        1 and p
                        2 where p
                        1 required less skills and returned higher revenue and p
                        2 required more skills and returned less revenue. We also generated two virtual projects to model the projects that the Lebanese industry might attract. One constituted an upper bound on revenue with associated maximum skills requirements, and the other reflected minimum overhead with freelance web development skills working for one yearly quarter. The revenue associated with the latter is set to a small value that reflects market conditions. From the academic survey we were able to identify a comprehensive and granular skill set and a set of sample talent classes that are dispatched into the technical workforce from the academia in Lebanon. The skill set contains 197 skills which cover software and software related skills taught in Lebanese academia. We rank these skills based on need and availability and we report the most important ones in the online Appendix 
                        1.

We classified these skills into 39 categories as displayed in Table 2
                        . They range from core software development to math and electrical engineering. The sample set of talent classes contains 12 classes, 6 for engineering majors, and 6 for science degrees. The talent classes range from taking the bare minimum set of required core courses to taking all the software elective courses. The 11 surveyed companies employ 310 employees, from which 241 are technical employees working in software development.

@&#RESULTS@&#

For the 11 surveyed companies, we run PMax to determine the optimal project selection vector 
                           γ
                         and the optimal resource allocation matrix 
                           A
                        . PMax provides us with the best performance of the companies with their maximal profit. Table 3
                         shows the cost and the selected projects for each one of the 11 companies after running PMax on them in the “Cost (PMax)” and “Selected projects” columns respectively.

Column “Difference in cost” estimates the savings resulting from PMAX had the company decided to operate on the selected projects without the advice of PMAX. We can see that even when the optimal portfolio for several companies is the same (as is the case for companies 1, 4 and 5 for instance), the associated cost might be different. This is a direct implication of the difference in human resource allocation between the different companies which directly affects the development costs.

@&#DISCUSSION@&#

We conducted a second industrial survey where we summarized the results of PMAX for the eleven companies. The first question in the survey queried the representatives on the feasibility of the distribution of skills across selected projects as suggested by PMAX.

The second question queried about the feasibility of the schedule. The third question asked for a ranking of synergistic factors that support or obstruct the results but that are not included in the parameters of PMAX. Finally, the fourth and fifth question asked about technical and know how skills existing in industry that are not covered or cannot be categorized under technical and know how skills acquired at academy.

We passed the survey to representatives from the eleven companies. Two of them replied. We also passed the survey with additional descriptions of the companies to eight software development professionals working in the industry at senior and managerial positions and four of them replied.

All respondents agreed that the results of PMAX are feasible and insightful in terms of allocating talent classes based on the distribution of skills required by the project. They also agreed that the schedules proposed by PMAX were feasible. Informally they expressed their interest in using PMAX once it is developed into an easy to use tool.

They listed and ranked several factors that they think are essential to the success of the strategy and most of them were first concerned with the availability of such projects in the market currently open for the Lebanese companies. Their second important concern was the feasibility of investment in developing the projects. A minority was concerned with the logistics to run several big projects at once in a Lebanese company.

Several of them listed “shipping software” as a technical skill that is not covered in academic training, next in importance they listed “knowledge of specialized development platforms”. They also listed “testing and quality control”, “handling error and exceptional cases” and “handling engineering trade-offs” as skills that are not covered in academic training. In retrospect, we found out that those skills were listed as outcomes and objectives in several advanced technical courses we have surveyed in our academic survey in one form or another.

On know-how and non-technical skills the majority complained about team work. The other complaints were related to risk assessment and experience in client interface. Again, these skills are listed in one form or another in advanced courses we have surveyed in our academic survey. We understand the complaints in the validation surveys as complaints on the strength level in these skills which does not affect the validity of our model. The validation survey and the tables are available online
                           1
                        .

We also interviewed a selected group of CIOs to validate the results and reflect on the proposed analysis framework. The CIOs thought that they would make use of the model described in this work if it is transformed into an easy to use tool and if it is extended to provide dynamic measures of profit estimations. Concerning the list of 197 software related skills, CIOs thought that additional software skills might come from sources different from academia and thus they think they must be incorporated in the analysis. Additionally, they spelled the importance of non-technical skills in the evaluation and classification of employees. One CIO gave us access to the evaluation sheet of employees at his company and we found out that 13 skills are common between his evaluation form and our skill list. In addition, he uses other meta skills that map into sets of skills in our case. The evaluation sheet contained further non-technical skills that we do not consider in our analysis.

We ran PMax and TSGA, on a 64-bit machine with 8gigabyte of memory and a quad-core CPU clocked at 2.8gigahertz. The problems from the Lebanese industry were relatively small. The number of talent classes K was limited to 12, the number of project P was set to 35 and the number of developers in a single company ranged between 6 and 60.

Given these sizes, PMax, when run on CPLEX, required between 15 and 533second to determine 
                        A
                      and 
                        γ
                      with an average time of 75second. Some problems exhausted 5gigabyte of RAM to run into completion. The problems are available online1.

After carefully tuning the parameters of TSGA, we set maxIterNum
                     =1000×
                     size(feasibleProj), maxTabuConfNum
                     =
                     size(feasibleProj) and maxRunTime
                     =600seconds. Additionally, We do not put any constraint on the size of the tabuList knowing that the memory needs of TSGA are very modest and almost limited to this list. We then run the same 11 problems using TSGA. We get an optimal solution for 10 of the problems and a 99.75% of the optimal profit on the last one. The run time of TSGA is on average 90% smaller than the CPLEX run time.

To compare the actual performance of TSGA versus PMax, we generated 100 problems with relatively the same size of the Lebanese industry. We kept the same talent classes derived from the Lebanese cases and generated 35 random projects (P
                     =35). We also generated for each problem a random number of talents that we constrained to be less than 100. Then we distributed the talents over the 12 talent classes.

We ran both PMax and TSGA on the 100 generated problems. PMax ran into completion for 99 out of the 100 problems. [12] For one of the problems, and after a run time of 26,800second, PMax exhausted all the RAM before exiting. For the other 99 problems, Table 4
                      summarizes the performances of PMax and TSGA.

TSGA performed almost 15 times faster than PMax and generated on average a profit valued at 98% of the optimal profit. Additionally, for the 99 comparative problems, TSGA reached the exact optimal solution 64 times and the worst profit that it found was 19% below the optimal solution. We can see that PMax sometimes needs a considerable amount of time (96minute) to run into completion while the worst TSGA runtime was 68second. The results show that TSGA is performing well for small size problems when compared to PMax.

For industries larger than the Lebanese industry, benchmarking TSGA against PMax is not possible because PMax will exhaust memory and runtime resources before returning an optimal solution.

We generate larger problems that mimic industries larger than the Lebanese industry to check how the performance of TSGA varies with problem sizes. We present problems with increments of the number of projects available P and the total number of talents N, then we run both TSGA and PMax on the generated problems.


                        Table 5
                         shows that when PMax returns a solution, TSGA maintains its performance presented in Section 8. CPLEX exhausts memory resources without generating any feasible solution for problems where P
                        ⩾100 and N
                        ⩾280. TSGA runtime is still very reasonable and exits on functional stop conditions other than the 10minute maxRunTime allowed for it. The largest two problems we simulated maintained 2551 and 2235 γ configurations in the Tabu list and were solved in 2651 and 2235 iterations that took 28.32 and 32.65second respectively. The detailed results are found online.

When Tabu search is used, it is advisable that the initial solution is quickly computable and of good quality. A better initial solution implies a better overall problem solution in general (Hasle, Lie, Quak, & for industriell og teknisk forskning ved Norges tekniske hogskole, 2007). For TSGA, the initial solution is very quickly generated. After running the 100 benchmarking simulations, the average time for generating the initial solution is 0.02second. At the same time, on average, the objective value of the profit obtained from the initial solution is 78% of the optimal objective found by CPLEX as shown in Table 6
                        . This high value indicates that the heuristic for generating the initial solution and that includes calling Greedily Allocate is performing well.

@&#CONCLUSION@&#

In this paper, we proposed a skill-based representation of a country over four analysis domains: universities, companies, talents and projects. We showed how we can determine the software skills that a country produces by analyzing the academic programs of its different universities. We then presented a formal methodology for ranking the strength of graduating students in the different software skills.

We also introduced PMax, a project selection and a resource allocation integer linear program that determines the optimal portfolio of projects for a certain company and allocates resources optimally among them.

We studied the complexity of PMax and we found them to be NP-complete. For this reason, we introduced a meta-heuristic based algorithm (TSGA) to outcome the difficulties of using PMax.

We showed how our methodology can be applied by performing two surveys on the Lebanese software industry and academia. We generated a list comprising of 197 software-related skills taught in Lebanon and we compiled the most and the least needed ones in the Lebanese industry. We collected real data about Lebanese companies and software projects developed internally and we ran PMax. We then evaluated the performance of TSGA comparing it to PMax and we concluded that TSGA is running 15 times faster than PMax with 98% accuracy. We showed that as opposed to PMax, TSGA can scale easily when the size of the problems increases.

In practice, our methodology relies on expert opinions to formalize technical software project requirements into skill strength requirements. It also relies on an up-to-date inventory of human resources represented in terms of strengths in skills. This is common practice in software companies where every employee is required to update his/her Curricular Vitae according to a preset template. It will be beneficial if in future work, an established model-based estimation method (for software development cost) is used to validate the expert opinions. In future work, we will consider a dynamic model that allows for skill growth based on resource allocation. If a resource x is allocated on a project p requiring skill s for a period t. At the end of t, the strength of x in s should increase and x might now belong to a different talent class with a higher cost. In general, we hypothesize that an increase in skill strength will increase the cost of the labor force, but at a greater benefit of allowing the company to bid for more challenging and rewarding projects.

@&#ACKNOWLEDGMENTS@&#

The authors would like to acknowledge the financial support of the Lebanese national council for scientific research (LNCSR) and Dar Al Handasah Endowment Fund for Research in Engineering. The authors would also like to thank the CIOs of the Lebanese companies that completed the surveys in particular Mr. Dal Hette and Mr. Sami Slim.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2013.09.035.


                     
                        
                           Supplementary data 1
                           
                        
                     
                  

@&#REFERENCES@&#

