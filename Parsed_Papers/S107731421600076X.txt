@&#MAIN-TITLE@&#A real-time Human-Robot Interaction system based on gestures for assistive scenarios

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a multi-robot human interaction system with two robots and a depth sensor.


                        
                        
                           
                           It includes a static and dynamic gestures recognition module.


                        
                        
                           
                           The set of gestures is described using arm/body and facial/head features.


                        
                        
                           
                           Interactive disambiguation for floor and object detection based on pointed location.


                        
                        
                           
                           Tested with several real users as well as with an offline test setting.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Gesture recognition

Human Robot Interaction

Dynamic Time Warping

Pointing location estimation

@&#ABSTRACT@&#


               
               
                  Natural and intuitive human interaction with robotic systems is a key point to develop robots assisting people in an easy and effective way. In this paper, a Human Robot Interaction (HRI) system able to recognize gestures usually employed in human non-verbal communication is introduced, and an in-depth study of its usability is performed. The system deals with dynamic gestures such as waving or nodding which are recognized using a Dynamic Time Warping approach based on gesture specific features computed from depth maps. A static gesture consisting in pointing at an object is also recognized. The pointed location is then estimated in order to detect candidate objects the user may refer to. When the pointed object is unclear for the robot, a disambiguation procedure by means of either a verbal or gestural dialogue is performed. This skill would lead to the robot picking an object in behalf of the user, which could present difficulties to do it by itself. The overall system — which is composed by a NAO and Wifibot robots, a KinectTM v2 sensor and two laptops — is firstly evaluated in a structured lab setup. Then, a broad set of user tests has been completed, which allows to assess correct performance in terms of recognition rates, easiness of use and response times.
               
            

@&#INTRODUCTION@&#

Autonomous robots are making their way into human inhabited environments such as homes and workplaces: for entertainment, helping users in their domestic activities of daily living, or helping disabled people in personal care or basic activities, which would improve their autonomy and quality of life.

In order to deploy such robotic systems inhabiting unstructured social spaces, robots should be endowed with some communication skills so that users can interact with them just as they would intuitively do, eventually considering a minimal training. Besides, given that a great part of the human communication is carried out by means of non-verbal channels [1,2], skills like gesture recognition and human behavior analysis reveal to be very useful for this kind of robotic systems, which would include viewing and understanding their surroundings and the humans that inhabit them.

Gesture recognition is an active field of research in Computer Vision that benefits from many machine learning algorithms, such as temporal warping [3–5], Hidden Markov Models (HMMs), Support Vector Machines (SVMs) [6], random forest classifiers [7] and deep learning [8], just to mention a few of them. Moreover, gesture recognition personalization techniques have also been proposed in [9] to adapt the system to a given user. Studies in Human Computer Interaction (HCI) and more specifically Human Robot Interaction (HRI) take advantage of this field. Hence, many recent contributions [10–14] consider KinectTM-like sensors to recognize gestures given the discriminative information provided by multi-modal RGB-Depth data. A KinectTM based application is introduced in [15] for taking order service of an elderly care robot. Static body posture is analyzed by an assistive robot in [16] to detect whether the user is open towards the robot interaction or not. Communicative gestures are contrasted from daily living activities in [17] for an intuitive human robot interaction. A novice user can generate his/her gesture library in a semi-supervised way in [18], which are then recognized using a non-parametric stochastic segmentation algorithm. In [19], the user can define specific gestures that mean some message in a human-robot dialogue, and in [20] a framework to define user gestures to control a robot is presented. Deep neural networks are used in [21] to recognize gestures in real time by considering only RGB information. Pointing gestures, similar to the one we propose in this paper, have been studied mostly focusing in hand gestures [22], using the hand orientation and face pose [23]. The pointing direction is estimated in [24,25] using gaze and finger orientation, and deictic gesture interactions that people use to refer to objects in the environment are studied in [26]. Related pointing interactions have also been used for robot guidance [27].

In this work we introduce a real time Human Robot Interaction (HRI) system whose objective is to allow user communication with the robot in an easy, natural and intuitive gesture-based fashion. The experimental setup is composed by a humanoid robot (Aldebaran’s NAO) and a wheeled platform (Wifibot) that carries the NAO humanoid and a KinectTM sensor. In this set-up, the multi-robot system is able to recognize static and dynamic gestures from humans based on geometric features extracted from biometric information and dynamic programming techniques. From the gesture understanding of a deictic visual indication of the user, robots can assist him/her in tasks such as picking up an object from the floor and bringing it to the user. In order to validate the system and extract robust conclusions of the interactive behavior, the proposed system has been tested in offline experiments, reporting high recognition rates, as well as with an extensive set of user tests in which 67 people assessed its performance.

The remainder of the paper is organized as follows: Section 2 introduces the methods used for gesture recognition and Human Robot Interaction. Section 3 presents the experimental results including the offline and user tests and, finally, Section 4 concludes the paper.

With the aim to study gestural communication for HRI, a robotic system has been developed able to understand four different gestures so a human user can interact with it: wave (hand is raised and moved left and right), pointing at (with an outstretched arm), head shake (for expressing disagreement) and nod (head gesture for agreement).

The overall robotic system involves several elements: an Aldebaran’s NAO robot, a small size humanoid robot which is very suitable to interact with human users; a Microsoft’s KinectTM v2 sensor to get RGB-Depth visual data from the environment and track the user; and, given that the vision sensor exceeds NAO’s robot capabilities (in size and computing performance), a Nexter Robotics’ Wifibot wheeled platform is used to carry the sensor as well as the NAO, easing its navigation and precision at long ranges.

In fact, the proposed robotic system takes inspiration from the DARPA Robotics Challenge 2015
                        1
                     
                     
                        1
                        
                           theroboticschallenge.org
                        
                      in which a humanoid robot should drive a car towards an interest place and exit the car in order to finish its work by foot. In a similar way, the wheeled robot was added to the system in order to carry the sensor along with the little humanoid, which should also exit it to complete its task by walking. This multi-robot setup allows the NAO to use the information from the Kinect’sTM v2 sensor and eases its navigation. And for its side, the NAO is the one in charge of directly interacting with the user, also being able to act on the environment, for instance, by grasping objects. The overall setup is shown in Fig. 1
                     , with the NAO seated on the Wifibot. The setup also includes a laptop with an Intel i5 processor to deal with KinectTM’s data and another Intel Core 2 Duo laptop, which sends commands to the robots using the Robot Operating System (ROS)
                        2
                     
                     
                        2
                        
                           ros.org
                        
                      
                     [28]. The depth maps are processed using the Point Clouds Library (PCL)
                        3
                     
                     
                        3
                        
                           pointclouds.org
                        
                      
                     [29], and body tracking information is obtained using the KinectTM v2 SDK.

The system has been programmed as an interactive application, and tested with several users of different ages and not related with the robotics world (see Section 3.2).

This section explains the methods used to perform the gesture recognition and image understanding. Given that the application of the system is to enhance the interaction between a human user and a robot, the defined gestures should be as natural for the user as possible, avoiding user training or learning of a specific set of gestures. Instead, the robot should understand gestures as a human would understand another human’s gestures, and should reply to that visual stimulus in real time.

The considered set of human gestures has been divided into two categories, depending on the amount of movement involved in their execution:

                           
                              •
                              Static gestures are those in which the user places his/her limbs in a specific position and stands for a while, without any dynamics or movement involved. In this case, the transmitted information is obtained through the static pose configuration. Pointing at an object is an example of static gesture.

Dynamic gestures are, in contrast, those in which the movement is the main gesture’s feature. The transmitted information comes from the type of movement as well as its execution velocity. It may also contain a particular pose for a limb during the movement. Examples of dynamic gestures are a wave to salute someone or a gesture with the hand to ask someone to approach to the user’s location.

Four different gestures have been included in the designed system to interact with the robot, being three of them dynamic and the remaining one static. The dynamic gestures are the wave, the nod and a facial negation gesture. The static one is the pointing at an object. Both categories are tackled using different approaches. Next we describe the extracted features, the gesture recognition methods and how the gesture’s semantic information is extracted.

Gesture recognition is performed based on some features extracted from the user body information obtained from depth maps. For the included arm gestures or any possible new gestures involving more body parts, skeletal data is obtained from depth images of the KinectTM sensor using the KinectTM SDK v2.0.

Given that a limb gesture such as the wave does not depend on the position of other parts of the body such as the legs, the rest of the body is not taken into consideration when the recognition is performed. So, rather than directly using the joint coordinates of the whole body, as in [4,30], our proposed method only takes into account the involved limbs from which some distinctive features are extracted. This approach allows the system to recognize gestures any time the skeletal data is properly tracked from the sensor, including situations such as sitting (for instance a person in a wheelchair), as well as standing up or crouching.

The application is able to recognize four gestures: the pointing at, the wave, the nod and the head negation. The point at gesture’s features on the skeleton are displayed in Fig. 2
                           a. They can be described as:

                              
                                 •
                                 
                                    δp
                                    , the Euclidean distance between the hand and hip joints of the same body part. This feature discriminates between the pointing position and the resting one in which the arms may be outstretched at the sides of the body but not pointing at a place.


                                    θp
                                    , the elbow joint angle, defined as the angle between the vector from the elbow joint to the shoulder one and the vector from the elbow to the hand joint. It defines when the arm is outstretched.


                                    ρp
                                    , the position of the hand joint.

Given the presented setup and the overall structure of the robotic system, the above features only accounts for large pointing gestures (with the full arm extended), as the ones one would use to point at something laying on the ground.

The features and dynamics for the wave gesture are shown in Fig. 2b. They are defined as:

                              
                                 •
                                 
                                    δw
                                    , the Euclidean distance between neck and hand joints. Although it was not necessary in order to perform the tests with the current set of gestures, this measure could be normalized by dividing it by the longitude of the arm to have a standardized value in the range [0, 1] to handle body variations.


                                    θw
                                    , the elbow joint angle, as defined in the point at gesture.

The elbow angle used in the features above does not require from normalization as it is not affected by different body heights.

The orientation of the face provided by the sensor is used to describe the nod gesture (vertical movement of the head) and the negation one (horizontal movement of the head). The three usual angular axes — pitch, roll and yaw — are used but instead of taking the absolute values, its derivatives are employed as frame features, 
                              
                                 
                                    Δ
                                 
                                 
                                    O
                                    
                                       i
                                       ,
                                       a
                                    
                                 
                                 =
                                 
                                    O
                                    
                                       i
                                       ,
                                       a
                                    
                                 
                                 −
                                 
                                    O
                                    
                                       i
                                       −
                                       1
                                       ,
                                       a
                                    
                                 
                                 ,
                              
                            where O
                           
                              i, a
                            is the orientation in degrees of the face in the frame i according to the a axis. Moreover, one out of F frames is used to compute the features to filter noisy orientation estimations, and the values are thresholded to a given value D in order to end up with a sequence of directional changes. More formally, the feature of a frame i for the axis a, f
                           
                              i, a
                           , is computed as:

                              
                                 (1)
                                 
                                    
                                       
                                          f
                                          
                                             i
                                             ,
                                             a
                                          
                                       
                                       =
                                       
                                          (
                                          |
                                          
                                             Δ
                                          
                                       
                                       
                                          O
                                          
                                             i
                                             ,
                                             a
                                          
                                       
                                       
                                          |
                                          ≥
                                          D
                                          )
                                       
                                       ·
                                       s
                                       i
                                       g
                                       n
                                       
                                          (
                                          
                                             Δ
                                          
                                          
                                             O
                                             
                                                i
                                                ,
                                                a
                                             
                                          
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                           Fig. 3
                            depicts the facial gestures.

A Dynamic Time Warping (DTW) [31] approach is used to detect the dynamic gestures. The DTW algorithm matches two temporal sequences finding the minimum alignment cost between them. One sequence is the reference gesture model of the gesture g, 
                              
                                 
                                    R
                                    g
                                 
                                 =
                                 
                                    {
                                    
                                       r
                                       1
                                    
                                    ,
                                    ⋯
                                    ,
                                    
                                       r
                                       m
                                    
                                    }
                                 
                                 ,
                              
                            and the other is the input stream 
                              
                                 S
                                 =
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    s
                                    ∞
                                 
                                 }
                                 ,
                              
                            where r
                           
                              i
                            and s
                           
                              i
                            are feature vectors. Features will depend on the gesture to be recognized: for the wave, 
                              
                                 
                                    r
                                    i
                                 
                                 =
                                 
                                    {
                                    
                                       δ
                                       
                                          i
                                       
                                       w
                                    
                                    ,
                                    
                                       θ
                                       
                                          i
                                       
                                       w
                                    
                                    }
                                 
                              
                            and 
                              
                                 
                                    r
                                    i
                                 
                                 =
                                 
                                    {
                                    
                                       f
                                       
                                          i
                                          ,
                                          p
                                          i
                                          t
                                          c
                                          h
                                       
                                    
                                    ,
                                    
                                       f
                                       
                                          i
                                          ,
                                          r
                                          o
                                          l
                                          l
                                       
                                    
                                    ,
                                    
                                       f
                                       
                                          i
                                          ,
                                          y
                                          a
                                          w
                                       
                                    
                                    }
                                 
                              
                            for the facial gestures. Both sequences are aligned by means of the computation of a m × n dynamic programming matrix M, where n is the length of the temporal window being used to discretize the infinite time, as data keeps entering the system while no gesture has been identified. Provided that gesture spotting is not needed, the minimum value for n is two.

Each element m
                           
                              i, j
                            ∈ M represents the distance between the subsequences 
                              
                                 {
                                 
                                    r
                                    1
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    r
                                    i
                                 
                                 }
                              
                            and 
                              
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    s
                                    j
                                 
                                 }
                                 ,
                              
                            so it is computed as:

                              
                                 (2)
                                 
                                    
                                       
                                          m
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       =
                                       d
                                       
                                          (
                                          
                                             r
                                             i
                                          
                                          ,
                                          
                                             s
                                             j
                                          
                                          )
                                       
                                       +
                                       m
                                       i
                                       n
                                       
                                          (
                                          
                                             m
                                             
                                                i
                                                ,
                                                j
                                                −
                                                1
                                             
                                          
                                          ,
                                          
                                             m
                                             
                                                i
                                                −
                                                1
                                                ,
                                                j
                                             
                                          
                                          ,
                                          
                                             m
                                             
                                                i
                                                −
                                                1
                                                ,
                                                j
                                                −
                                                1
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where d( ·, ·) is a distance metric of choice. Different distance metrics can be used in our implementation. For instance, the Hamming distance:

                              
                                 (3)
                                 
                                    
                                       
                                          d
                                          H
                                       
                                       
                                          (
                                          
                                             r
                                             i
                                          
                                          ,
                                          
                                             s
                                             j
                                          
                                          )
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             =
                                             0
                                          
                                          o
                                       
                                       
                                          {
                                          
                                             r
                                             i
                                             k
                                          
                                          ≠
                                          
                                             s
                                             j
                                             k
                                          
                                          }
                                       
                                       ,
                                    
                                 
                              
                           with o being the number of features of the gesture, is used for the facial gestures case. The weighted L1 distance is employed for the case of the wave gesture, computed as:

                              
                                 (4)
                                 
                                    
                                       
                                          d
                                          
                                             L
                                             1
                                          
                                       
                                       
                                          (
                                          
                                             r
                                             i
                                          
                                          ,
                                          
                                             s
                                             j
                                          
                                          )
                                       
                                       =
                                       
                                          ∑
                                          
                                             k
                                             =
                                             0
                                          
                                          o
                                       
                                       
                                          
                                             α
                                             k
                                          
                                          
                                             |
                                             
                                                r
                                                i
                                                k
                                             
                                             −
                                             
                                                s
                                                j
                                                k
                                             
                                             |
                                          
                                       
                                       ,
                                    
                                 
                              
                           with αk
                            a positive weighting constant.

A gesture g will be considered as recognized if a subsequence of the input data stream S is similar enough to the reference sequence R
                           
                              g
                           :

                              
                                 (5)
                                 
                                    
                                       
                                          m
                                          
                                             m
                                             ,
                                             k
                                          
                                       
                                       ≤
                                       
                                          μ
                                          g
                                       
                                       ,
                                       
                                       ∀
                                       k
                                       ,
                                    
                                 
                              
                           where μg
                            is obtained using a training method for each gesture g, detailed in Section 3.1.1.

In order to assure the fulfillment of the real time constraint, the DTW is executed in a multi-threaded way in which the different gestures are spread between different threads that run the gesture recognition method simultaneously, stopping in case one of the methods finds a gesture in the input sequence.

In case of the need of properly segmenting the gesture in a begin-end manner, such as for validation purposes, the warping path can be found to locate the beginning of a gestural sequence. This warping path:

                              
                                 (6)
                                 
                                    
                                       W
                                       =
                                       {
                                       
                                          w
                                          1
                                       
                                       ,
                                       ⋯
                                       ,
                                       
                                          w
                                          T
                                       
                                       }
                                       ,
                                    
                                 
                              
                           with 
                              
                                 m
                                 a
                                 x
                                 (
                                 m
                                 ,
                                 n
                                 )
                                 ≤
                                 T
                                 <
                                 m
                                 +
                                 n
                                 +
                                 1
                                 ,
                              
                            is a matrix of pairs of indexes of contiguous elements in the matrix M that define a mapping between the reference gesture R
                           
                              g
                            and a subsequence of the input sequence S, subject to the following constraints:

                              
                                 •
                                 
                                    
                                       
                                          
                                             w
                                             1
                                          
                                          =
                                          
                                             (
                                             1
                                             ,
                                             j
                                             )
                                          
                                       
                                     and 
                                       
                                          
                                             w
                                             t
                                          
                                          =
                                          
                                             (
                                             m
                                             ,
                                             
                                                j
                                                ′
                                             
                                             )
                                          
                                       
                                    .

for 
                                       
                                          
                                             w
                                             
                                                t
                                                −
                                                1
                                             
                                          
                                          =
                                          
                                             (
                                             
                                                a
                                                ′
                                             
                                             ,
                                             
                                                b
                                                ′
                                             
                                             )
                                          
                                       
                                     and 
                                       
                                          
                                             w
                                             t
                                          
                                          =
                                          
                                             (
                                             a
                                             ,
                                             b
                                             )
                                          
                                       
                                     then 
                                       
                                          a
                                          −
                                          
                                             a
                                             ′
                                          
                                          ≤
                                          1
                                       
                                     and 
                                       
                                          b
                                          −
                                          
                                             b
                                             ′
                                          
                                          ≤
                                          1
                                       
                                    .

The warping path W that minimizes the warping cost:

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             C
                                             w
                                          
                                          
                                             (
                                             M
                                             )
                                          
                                          =
                                          
                                             min
                                             
                                                w
                                                ∈
                                                W
                                             
                                          
                                          
                                             {
                                             
                                                1
                                                T
                                             
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         t
                                                         =
                                                         1
                                                      
                                                      T
                                                   
                                                   
                                                      M
                                                      
                                                         w
                                                         t
                                                      
                                                   
                                                
                                             
                                             }
                                          
                                          ,
                                       
                                    
                                 
                              
                           can be found for the matrix M by backtracking of the minimum path from m
                           
                              m, j
                           , to m
                           1, k
                           , being k the starting point of the segmented gesture and j the ending of it.

A static approach has been selected for static gesture recognition, in the sense that a gesture is considered as recognized when features are within certain values for a given number of contiguous frames and small movement is involved. The number of frames and the feature thresholds are obtained through a similar training method as for the dynamic case.

In our case, the pointing gesture is recognized when, for a certain number of frames F, the elbow angle is greater than a threshold Tea
                            indicating the arm is outstretched and the distance between the hand and the hip is greater than a certain distance Td
                            meaning that the arm is not in the resting position. Moreover, the hand coordinates are used in order to check the constraint that the position is hold still and not moving. That is, a gesture is recognized if the following constraints are held during Fp
                            frames:

                              
                                 (8)
                                 
                                    
                                       
                                          δ
                                          
                                             i
                                          
                                          p
                                       
                                       >
                                       
                                          T
                                          d
                                       
                                       ,
                                       
                                       
                                          θ
                                          
                                             i
                                          
                                          p
                                       
                                       >
                                       
                                          T
                                          
                                             e
                                             a
                                          
                                       
                                       ,
                                       
                                       
                                          d
                                          E
                                       
                                       
                                          (
                                          
                                             ρ
                                             
                                                i
                                             
                                             p
                                          
                                          ,
                                          
                                             ρ
                                             
                                                i
                                                −
                                                1
                                             
                                             p
                                          
                                          )
                                       
                                       ≈
                                       0
                                       ,
                                    
                                 
                              
                           where dE
                            represents the Euclidean distance.

The system runs the static gesture recognition in parallel with the dynamic one, in a multi-threaded way.

Once a pointing gesture has been recognized, some information needs to be extracted from it in order to perform its associated task and help the user. The main information that this deictic gesture gives is the pointed location, which is the region of the surrounding space that has some elements of interest for the user. To estimate it, a floor plane description, the pointing direction and some coordinates belonging to the ground are needed.

First of all, the arm position has to be obtained in order to know the pointing direction. To do so, the arm joints of the last ten frames of the gesture are averaged to obtain the mean direction and avoid tracking errors. Then, the coordinates of the hand joint H and the elbow joint E are used to get the pointing direction as the 
                              
                                 
                                    
                                       E
                                       H
                                    
                                    →
                                 
                                 =
                                 H
                                 −
                                 E
                              
                            vector. Even though the KinectTM v2 sensor provides information about the hand tip joint, the direction provided by the elbow to hand vector proved to be more precise than the hand to hand tip one in preliminary tests.

The ground plane is extracted using the plane estimation method of the PCL library [32]. A depth image of the KinectTM is obtained and converted to a point cloud, the planes of which are segmented using a Random Sample Consensus (RANSAC) method [33]. Those planes that have a similar orthogonal vector to a reference calibrated plane are used as floor planes. The reference plane is automatically obtained at system start up by segmenting all the planes in the depth image and keeping the parameters of the plane whose orthogonal vector is the same as the vertical axis (y axis) of the sensor. In case the camera is not in a parallel position with the ground or no plane is found which fulfills this condition, the reference plane is obtained from the user who has to click three points of the ground in the graphical interface, from which the plane is estimated. Then, the ground point coordinates are obtained by picking one element from the floor cloud.

Therefore, let Pf
                            be the ground point and 
                              
                                 
                                    
                                       N
                                       →
                                    
                                    f
                                 
                                 =
                                 
                                    (
                                    A
                                    ,
                                    B
                                    ,
                                    C
                                    )
                                 
                              
                            the orthogonal vector of the floor plane 
                              
                                 
                                    π
                                    f
                                 
                                 =
                                 A
                                 x
                                 +
                                 B
                                 y
                                 +
                                 C
                                 z
                                 +
                                 D
                                 =
                                 0
                                 ,
                              
                            the pointed point Pp
                            can be obtained by:

                              
                                 (9)
                                 
                                    
                                       
                                          P
                                          p
                                       
                                       =
                                       H
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   P
                                                   f
                                                
                                                −
                                                H
                                                )
                                             
                                             ·
                                             
                                                
                                                   N
                                                   →
                                                
                                                f
                                             
                                          
                                          
                                             
                                                
                                                   E
                                                   H
                                                
                                                →
                                             
                                             ·
                                             
                                                
                                                   N
                                                   →
                                                
                                                f
                                             
                                          
                                       
                                       ·
                                       
                                          
                                             E
                                             H
                                          
                                          →
                                       
                                       .
                                    
                                 
                              
                           An example of the pointing location estimation is shown in Fig. 4
                           a.

After some tests with users, we observed that the bones were correctly tracked by the KinectTM sensor but not precisely enough to get an accurate pointing direction. This was more clear when the pointing gesture was performed with the hand in front of the body. Also, the users tended to actually point farther than the objects’ location, and the real pointed line did not intersect with the objects, as it can be observed in Fig. 4b. In order to deal with this imprecision, we corrected the pointing position just by slightly translating the pointed location backwards.

Similar to what humans do as a response to a pointing gesture, we want that the robots look at the surroundings of the estimated pointed location to detect possible objects that the user is referring to. Notice that in our case we do not care about recognizing the actual objects but rather detecting their presence.

This is performed by first extracting the set of points X from the scene point cloud in which each x
                           
                              i
                            ∈ X is selected such that its Euclidean distance dE
                            to the pointed point is smaller than a certain value r, dE
                           (x
                           
                              i
                           , Pp
                           ) ≤ r, being X a spherical point cloud of radius r and centered in the pointed point Pp
                           . After the extraction of the floor plane, 
                              
                                 Z
                                 =
                                 X
                                 ∖
                                 {
                                 
                                    x
                                    i
                                 
                                 
                                 |
                                 
                                 
                                    x
                                    i
                                 
                                 ∈
                                 
                                    π
                                    f
                                 
                                 }
                                 ,
                              
                            all the objects should be isolated and a clustering algorithm is applied to the sub point cloud Z in order to join all the points of the same objects in a smaller point cloud per each object. The clustering algorithm that has been used is the Euclidean Cluster Extraction method [32], which starts the clustering by picking a point z
                           
                              i
                            ∈ Z and joining to it all its neighbors z
                           
                              j
                            ∈ Z such that dE
                           (z
                           
                              i
                           , z
                           
                              j
                           ) < dth
                           , being dth
                            a user defined threshold. The process is repeated for all of these neighbors until no more points are found, in which case a cluster Ci
                            is obtained. The remaining points of the cloud Z are processed in the same way to get the other object clusters. Once the objects are found, its centroid point is computed as the mean coordinates of all the points of the cluster, 
                              
                                 
                                    
                                       1
                                       
                                          
                                             |
                                          
                                          
                                             C
                                             i
                                          
                                          
                                             |
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          z
                                          ∈
                                          
                                             C
                                             i
                                          
                                       
                                    
                                    z
                                    ,
                                 
                              
                            and then each cluster’s convex hull is reconstructed in order to compute its area. This allows the system to get a notion of its position in the space and size (see Fig. 4a).

However, it may be the case in which the pointed location is not clearly near a single object, so there is a doubt on which was the referred one. When this situation arises, a spoken disambiguation process is started in which the robot asks the user about the object. To do so, the robot may ask if the person was pointing at the biggest object if the objects are clearly of different sizes, otherwise it asks about its relative position, for instance asking a question like “is it the object at your right?”. The user can respond to the question with a yes or no utterance, recognized using NAO’s built in speech recognition software, or by performing the equivalent facial gestures, and the robot will know which was the referred object if there were only two of them, or it may ask another question in case there were three dubious objects in sight. A flowchart of the disambiguation process is included in the supplementary material.

The gesture recognition makes the robotic system able to understand some human gestures. But, the human user must be able to recognize what is the robot doing for the interaction to be successful and pleasant. In our case, this means that the robots must work together in order to fulfill the task and respond to the user in an appropriate way. For instance, the Wifibot is able to perform a more precise navigation, whereas the NAO is ideal to interact and speak to the user as well as to act on the environment. This means that the answer of the system to a visual stimuli made by the person has to be expected for them, thus being a natural response to the gesture. Fig. 5
                         shows the flow of the application in a normal use case. The application has been programmed using a state machine paradigm to control the workflow. Details of the implemented state machines are shown in the supplementary material.

For the wave gesture, the expected response would be waving back to the user, performing a similar gesture to the one made by him/her and maybe performing some utterance. In the case of the pointing gesture, the robot has to approach the pointed location and analyze which objects are present, trying to deduce which object was the user referring to. Notice that there is no need that the user points to a place which is in the field of view of the sensor, being it possible to point at some objects which are farther away which will also make the robot go to the pointed location to check for objects.

Once the object is known and has been disambiguated in case of doubt, the NAO goes down the Wifibot (Fig. 6) and approaches the object, which is then shown to the user performing a gesture with the hand and the head to expose that it understood the object correctly, as it can be seen in Fig. 7
                        . Note that this could be extended to grasp the object and bring it to the user.

@&#EXPERIMENTAL RESULTS@&#

In order to evaluate the designed system, several experiments were carried out, including offline evaluation of the methods and online evaluation of the whole system with an extensive set of user tests.

The gesture recognition methods were evaluated in an offline setting in order to validate the performance of the methods and tune a set of parameter values. Hence, a small data set “HuPBA sequences” was generated and labeled. It includes 30 sequences of 6 different users (5 sequences per user) in which each of them performs the four gestures that the system is able to recognize, as well as another arbitrary gesture of their choice; all of them performed in a random order. The gesture models used in the dynamic gesture recognition module were specifically recorded for this purpose from one user performing the gesture in an ideal way. This ideal way was taken from the observations of the recorded sequences, and also taking into account observation of other gesture based systems and quotidian interaction with people. This model subject is not part of the subjects in the data set.

In order to evaluate the system, two metrics usually used in this domain have been adopted: the Jaccard index (also known as overlap) and defined as 
                           
                              J
                              
                                 (
                                 A
                                 ,
                                 B
                                 )
                              
                              =
                              
                                 
                                    |
                                    A
                                    ∩
                                    B
                                    |
                                 
                                 
                                    |
                                    A
                                    ∪
                                    B
                                    |
                                 
                              
                              ,
                           
                         and the F1 score, which is computed as 
                           
                              F
                              
                                 1
                                 
                                    s
                                    c
                                    o
                                    r
                                    e
                                 
                              
                              =
                              
                                 
                                    2
                                    T
                                    P
                                 
                                 
                                    2
                                    T
                                    P
                                    +
                                    F
                                    P
                                    +
                                    F
                                    N
                                 
                              
                           
                        .

In order to compute the performance measure, a Leave-One-Subject-Out cross validation (LOSOCV) technique has been used. In it, a subject of the data set is left out and a grid search is performed in order to tune the best parameters for the different methods and gestures of the system. Then, those parameters are used with the sequences of the left out user and the performance metrics are obtained. This procedure is repeated with all the subjects and their results are averaged for every subject and sequence in order to obtain the final score.

To carry out the parameters tuning, an interval of values for each of them is tested against the set of recordings, keeping those which perform better. The interval of parameters that has been used and tested includes the DTW thresholds μwave
                            ∈ [6.75, 9.5], considering equally distributed values with step 0.25, 
                              
                                 
                                    μ
                                    
                                       n
                                       o
                                       d
                                    
                                 
                                 =
                                 
                                    μ
                                    
                                       n
                                       e
                                       g
                                       a
                                       t
                                       e
                                    
                                 
                                 ∈
                                 
                                    [
                                    4.5
                                    ,
                                    20
                                    ]
                                 
                              
                            with step 0.5. The distance weights for the wave gesture were α ∈ [0.1, 0.55] with step 0.05. The facial gesture’s parameters tested were orientation derivative threshold D ∈ [5, 30] with step 5 and number of frames between samples F ∈ [1, 20] with increments of 1 unit. For the static gestures, the thresholds and number of frames were Td
                            ∈ [0.1, 0.45] with step 0.5 and Tea
                            ∈ [2.0, 2.55] with a stepping of 0.05. Those ranges were chosen empirically by performing some initial tests using some sequences which included variations in the gestures, recorded for this purpose.


                           Fig. 8
                            shows the obtained results with the standard deviation of the different users. Fig. 8a plots the results for the F1 measure with different overlap thresholds to decide which amount of overlapping is enough to be considered a TP. Meanwhile, Fig. 8b shows the results using the Jaccard index measure with different number of “Do not care” frames.

As it can be observed, the wave and the point at gestures are the ones which have better recognition rates, being the point at slightly better according to the Jaccard index. As for the facial gestures, the nodding presents a better performance than the negation in both measures. The facial gestures present a worse performance due to the fact that many users perform the gestures very subtly and with different lengths that vary in a considerable way in terms of orientation. It also gets hampered by the distance from the user to the camera as the orientation values are more subtle the farther the user is. Even though, we get a LOSOCV F1 score of 0.6 ± 0.61 (mean ± standard deviation of the LOSO subjects) for the nod gesture and 0.61 ± 0.15 for the negation one with an overlap threshold of 0.4, which have resulted to be acceptable to get a natural interaction in the real time system.

Focusing on the Jaccard index plot from Fig. 8b, it can be observed that the best mean performance is obtained when 7 “Do Not Care” frames are used, reaching a 0.65 ± 0.07 of overlap. The use of “Do Not Care” frames to compute the Jaccard index makes sense in natural interaction applications because the goal is not to segment the gesture at frame level but to detect the gesture itself, despite which frame the detection started or ended. The use of 7 frames (the three previous to the beginning, the beginning frame and the three after it) is enough to solve any temporal difference between the detection and the labeled data.

In order to evaluate the system’s performance, it was tested with different users in a real scenario. Their opinion was collected and use easiness was considered according to the need of external intervention from our part for the communication.

The test users were selected from different age groups and education backgrounds, who might have never seen a humanoid robot before, to analyze their behavior and check the task fulfillment. The tests took place in different environments, trying to keep users in known and comfortable scenarios, including two high schools, a community center and an elderly social association. A total of 67 users participated in the experiments.

The screenplay for the tests is as follows: the user stands in front of the robotic system and two or three objects are placed on the ground, around three meters far. The user first waves to the robot, then points at an object of their election, answering with a facial gesture if the robot asks a question to disambiguate. Otherwise, the users were asked to perform some facial gestures at the end of the test. The procedure was usually repeated twice by each user, and they had to fill in a questionnaire about the experience at the end. A video showing an execution example of the system is included as supplementary material.

The objects were two milk bottles and a cookie box, and the gesture recognition parameters were obtained by using the training mechanism previously explained, but this time all the “HuPBA sequences” were used for the tuning of the parameters. As for the object cluster extraction, a radius of 55 centimeters around the pointed location was used, which was a suitable value for the used objects. Fig. 9
                         shows some of the users performing the tests in the different environments.

This section highlights some interesting results which were obtained from users’ questionnaire after the test. Results are analyzed in three age groups. Fig. 10
                            shows some bar plots of the most relevant questions, aggregated by age group. Table 1
                            includes some of the answers to numerical questions in the questionnaires.

In summary, users aged from 9 to 86 years, average being 34.8 ± 23.98. They have been divided into three groups: 9 to 34, 35 to 60 and 61 to 86 years, being the youngest user of the last group aged 71. The gender was quite balanced, being 55% of the users males, as seen in Fig. 10a. Moreover, they had zero or very small previous contact with any kind of robots.

The wave gesture was agreed to be natural by most of the users, in all the age groups, even though some users had problems to reproduce it and needed some explanation as they would have waved in another way. The response they obtained from the robot was the one they would expect and was considered quick enough, which means that the robot acted in a natural way and they did not need help to understand the response it gave, as seen in Fig. 10b, c and in Table 1. The results for the point at gesture are quite similar, being it natural and quite fast with equivalent results in the different age groups, even though some users expected the robot to do something with the objects such as grasping or opening a bottle (Fig. 10d, e). Moreover, most of the users thought the pointing time was enough but a 35% of the users felt it was too much time (although some of them kept pointing at the object once the robot said the gesture was already recognized), as shown in Fig. 10f. As for NAO’s response, the robot missed the right object in a very few cases, but they thought it clearly showed which object the robot understood without ambiguities, as seen in Table 1.

The facial gestures were not performed by all the users, but again most of them felt comfortable doing them, being the nod too exaggerated for some of them. In fact, 46% of the people from the youngest group that made the nod gesture felt it was unnatural or too exaggerated, as shown in Fig. 10g. The negate gesture had similar response (see Fig. 10h). In general, facial gestures presented a disadvantage with long haired people in which the hair covered the face while performing them (specially in the negation case), which implied that the face tracker lost the face and the gesture was not recognized. The 88% of the users thought that it was easy to answer the yes/no questions to the system.

Finally, the overall interaction was felt quite natural, as seen in Table 1, and not too much users felt frustration due to the system misunderstanding of gestures, as it can be seen in Fig. 10i. Some users did not know what was the robot doing at some moment of the test as shown in Fig. 10j, but most of these cases were due to the language difficulty, as the robot spoke in English
                              4
                           
                           
                              4
                              Most of the user’s mother tongue was either Spanish or Catalan.
                           . Hence, the 36% of the users did not speak English and they needed external support and translation. The 92% the users stated that they enjoyed the test (100% of the elderly group did), and a vast majority of the users thought that applications of this kind can be useful to assist people in household environments, specially the elder ones or those with reduced mobility, as depicted in Fig. 10l. Moreover, almost all of them thought it was easy to communicate a task in a gesture manner, as Fig. 10k shows. In the last question they were asked about possible gesture additions to the system. The most interesting responses include gestures to call it to come back, start, stop or indicate the NAO to sit again on the Wifibot.

In order to obtain objective evaluation metrics, 30 additional tests performed by six users (five gestures per user) were conducted. The response times of the different gestures along with recognition rates, as well as the execution times of the object detection module were extracted from them. Tables 2
                         and3
                         show the obtained results.

As it can be seen, the response times in Table 2, which span from the end of the gesture to the start of the robot response, are quite suitable for a natural interaction, being all the gestures answered in less than two seconds in average. As for the object detection, comprising the time between the order from the robot to segment objects and the response from the Wifibot’s laptop, which is computed in less than a second.

Looking at the recognition rates, the best recognized gesture was the point at one. The negation gesture was the one with the lowest recognition rates, as it was the case of the offline results, mainly because the face not being well tracked when the face is sidewards the camera.

The system also shows high recognition rates for the object detection even though there were some errors, which are detailed in Table 3.

@&#CONCLUSIONS@&#

In this work, we presented a multi-robot system designed to interact with human users in a real time gesture based manner. The system is a proof of concept that shows how important is the interaction phase in order to be able to assist users with special needs, such as elderly or handicapped people. Consequently, they could interact with the robot in the way they are used to do with other human beings, and the robot can use the information provided by the users to help them. For instance, the robot could pick something up from the floor without the need of actually recognizing the object but just knowing that the person referred it with a deictic gesture.

We included a gesture recognition method based on the KinectTM v2 sensor which takes into account dynamic gestures, recognized by a DTW using specific features from the face and the body, and static gestures such as deictic ones to refer to something present in the environment.

The multi-robot system is shown as an effective way of combining efforts with specialized robots, one to carry the weight of the sensor and the computing power with a precise navigation, and the other able to speak and interact in a natural way with the user. Their collaboration in performing the tasks leads to the success of the system and the interaction.

Furthermore, an extensive set of user tests was carried out with 67 users who had little contact with robots and that were able to perform the tests with minimal external indications, resulting in a natural interaction for them in most of the cases. Offline tests also showed high recognition rates performing real time gesture detection and spotting in a specifically recorded data set.

Nevertheless, different elements of the system such as the detection of the pointing direction could be improved as future work. For instance, the use of a more accurate hand pose estimator like the ones proposed in [34–36] may allow the direction of the finger to be used to obtain the pointing direction, probably resulting in a more precise location estimation. The facial gestures are another element which could be highly improved, first by trying to use a better facial tracker which can properly handle side views (which clearly affect the detection of the negation gesture), but also by exploring or adding other kind of features.

@&#ACKNOWLEDGMENTS@&#

We would like to thank La Garriga’s town council, youth center and Ràdio Silenci for their help in the user test communication and organization, as well as to the following entities, associations and people located in La Garriga: the Associació de Gent Gran l’Esplai de l’EspaiCaixa, “La Torre del Fanal” community center, Institut Vil·la Romana, Escola Sant Lluís Gonçaga, and Pujol-Buckles family for allowing us to perform the tests in their facilities. Special thanks also to Dr. Marta Díaz for her guidelines in the user test analyses, to Joan Guasch and Josep Maria Canal for their help in the Wifibot adaptations, and to Víctor Vílchez for proofreading. This work has been partially supported by the Spanish Ministry of Economy and Competitiveness, through the projects TIN 2012-38416-C03-01 and TIN2013-43478-P. The research fellow Gerard Canal thanks the funding through a grant issued by the Catalunya — La Pedrera Foundation.

Supplementary material associated with this article can be found, in the online version, at 10.1016/j.cviu.2016.03.004.


                     
                        
                           Supplementary Data S1
                           
                              Supplementary Raw Research Data. This is open data under the CC BY license http://creativecommons.org/licenses/by/4.0/
                              
                           
                           
                        
                     
                  

@&#REFERENCES@&#

