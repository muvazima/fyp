@&#MAIN-TITLE@&#Branch-and-price for staff rostering: An efficient implementation using generic programming and nested column generation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We describe a nested column generation algorithm for staff rostering.


                        
                        
                           
                           We show how generic programming can be used within a column generation implementation.


                        
                        
                           
                           Our resulting system is faster and more flexible than traditional systems.


                        
                        
                           
                           We can obtain good solutions to practical staff rostering problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

OR in manpower planning

Generic programming

Branch-and-price

Scheduling

Staff rostering

@&#ABSTRACT@&#


               
               
                  We present a novel generic programming implementation of a column-generation algorithm for the generalized staff rostering problem. The problem is represented as a generalized set partitioning model, which is able to capture commonly occurring problem characteristics given in the literature. Columns of the set partitioning problem are generated dynamically by solving a pricing subproblem, and constraint branching in a branch-and-bound framework is used to enforce integrality. The pricing problem is formulated as a novel three-stage nested shortest path problem with resource constraints that exploits the inherent problem structure. A very efficient implementation of this pricing problem is achieved by using generic programming principles in which careful use of the C++ pre-processor allows the generator to be customized for the target problem at compile-time. As well as decreasing run times, this new approach creates a more flexible modeling framework that is well suited to handling the variety of problems found in staff rostering. Comparison with a more-standard run-time customization approach shows that speedups of around a factor of 20 are achieved using our new approach. The adaption to a new problem is simple and the implementation is automatically adjusted internally according to the new definition. We present results for three practical rostering problems. The approach captures all features of each problem and is able to provide high-quality solutions in less than 15minutes. In two of the three instances, the optimal solution is found within this time frame.
               
            

@&#INTRODUCTION@&#

The generalized rostering problem is the problem of generating a feasible high-quality staff schedule (‘roster’) for a group of staff working collectively to provide some service. The roster will specify, for each staff member, the sequence of shifts and days off (termed the ‘roster-line’) to be worked during the roster period. This roster must satisfy pre-specified demand constraints which typically express minimum staffing requirements for individual shifts or time periods, and may include requirements for staff with certain skills or meeting particular contract conditions. The roster-line worked by each staff member is typically strictly governed by laws, union regulations and internal agreements, and has an associated quality measure. These requirements together can make it hard to create feasible rosters, let alone high quality ones.

Rosters have traditionally been created manually by the head of the section or by an experienced member of the staff. Often, the rosters were made by modifying former rosters or by putting together roster-lines and parts of roster-lines which were known to be good. It takes a lot of experience to build good rosters and even with experience, the process of building the rosters is very time consuming. Therefore, there has been and still is a large demand for automated rostering tools. Within the last decade the supply of software products has increased significantly to meet this demand.

One of the major obstacles to developing rostering software has been the varying requirements from one application to another. As a result, many rostering systems have been custom made to match the exact requirements of a particular company or institution. The main issue with this approach is the time and money needed for development of the system. For the same reason, automated scheduling systems have in the past been reserved for institutions with a large and very apparent need for automation. Our focus here is on developing a flexible but still efficient generic software framework that can be applied to a large variety of rostering problems. The system we have created has to be adapted to a given application, but this adaptation is easy and fast. Hence, using our approach, an effectively tailor-made product can be produced at significantly lower costs than before.

Staff rostering has already received a lot of attention in the literature. We refer to the extensive reviews of Burke et al. [11], Ernst et al. [27], and Cheang et al. [13]. Also, Ernst et al. [26] present a massive collection of references to papers on rostering. The EURO Working Group on Automated Timetabling [14] provides a good up-to-date overview of the literature.

The solution method presented here builds on the idea of column generation. Column generation is embedded in a branch-and-bound framework resulting in a so called branch-and-price algorithm; for an introduction to column generation, see [18]. Naturally, the literature on column generation solution methods to rostering is of special interest. Jaumard et al. [34] solve a nurse rostering problem using column generation. The subproblem is formulated as a shortest path problem with resource constraints, where each possible shift is represented by a node. It is solved with a two-stage algorithm proposed by the authors. Bard and Purnomo [3] solve a nurse rostering problem with individual preferences for the nurses. Columns are generated by a, so called, double swapping heuristic. High-quality solutions are found within minutes. In Bard and Purnomo [2] the model is extended to allow downgrading of workers with higher level skills. Beliën and Demeulemeester [5] schedule trainees in a hospital using branch-and-price. Interestingly, columns are generated for activities instead of the conventional columns for roster-lines of employees. The described problem of scheduling trainees is somewhat simpler than the generalized rostering problem, and only for this reason, it is possible to use the alternative column generation model. In a succeeding paper by the same authors [6], it is concluded that the activity-decomposed approach does not have the same modeling power. However, if the problem allows this model to be used, the performance may be enhanced by doing so.

A column generation approach to the nurse rostering problem is also described by Maenhout and Vanhoucke [40]. The approach has a number of features in common with our approach. The authors describe different pruning and branching strategies, e.g. Lagrangian dual pruning and branching on the residual problem. Beliën and Demeulemeester [7] extend the nurse rostering model to include scheduling of the operating room and show that considerable savings can be made by integrating the two scheduling problems.

Eitzen et al. [24] present a set covering model for a crew scheduling problem at a power station. Three column generation based solution methods are proposed to solve the set covering model: the column expansion method, the reduced column subset method, and branch-and-price. In the first, three phases are solved, where the skill set of each employee is gradually enlarged from one phase to the next. In the second, a restricted number of columns are generated randomly with no guarantee on quality. The latter method integrates dynamic column generation and constraint branching in a branch-and-bound framework. Al-Yakoob and Sherali [1] solve a crew rostering problem for a large number of gas stations using a column generation approach. The model takes the individual preferences of the employees into account. A heuristic founded on the column generation algorithm is able to solve realistic problems.

In the column generating subproblem presented here, two shortest path problems with resource constraints are solved. Much literature has been published on shortest path problems with resource constraints; Irnich and Desaulniers [32] provides a good literature review. Desrosiers et al. [20] present an early version of the algorithm with time as the only resource, which is generalized by Desrochers [17]. Lübbecke [38] suggests discarding all labels that cannot lead to a column with negative reduced cost. Dumitrescu and Boland [22] introduce a more extensive preprocessing scheme. Righini and Salani [46] present a significant improvement in performance by using bidirectional search. Chabrier [12] utilize an idea on the potential value of each node to improve performance further.

The idea behind the generic modeling of rules and preferences that we present is similar to that of an industrial system, described by Kohl and Karisch [36]. The authors describe a modeling tool, which is essentially a rule programming language, where the end user can maintain and modify rules in a flexible way. However, they also explain that the optimization method can only ‘ask’ simple questions about legality and cost.

The work presented here is based primarily on the work of Smith [49], Nielsen [44] and Engineer [25]. Smith [49] presents a column generation setup to solve a nurse rostering problem from Middlemore Hospital in Auckland. Following the promising results for this initial application, two projects followed, with the aim of building a generalized rostering framework which would be able to solve various rostering problems. Nielsen [44] describes a general modeling framework for rostering problems. Roster-lines are generated by an enumerative scheme including some constraint programming techniques. The author uses experimental data from Auckland Healthcare. Engineer [25] applies column generation to various rostering problems. He formulates the pricing problem as a three stage nested shortest path problem with resource constraints as described by Mason and Smith [42] and solves it using label setting methods. The algorithm developed proved to be both efficient and versatile enough to allow solution of applications with very different characteristics.

Our new approach extends the work of Engineer [25] by exploiting the computer science principle of generic programming. In generic programming, an algorithm abstracts over details, such as particular rostering rules, that are not essential for the design of the algorithm [33]. Generic programming allows ‘a single, generic algorithm [to] realize many concrete implementations’ and ‘provides maximal reusability without sacrificing performance’ [29]. Generic programming is an important growing area within computer science. For example, the Standard Template Library (STL) [30] and the associated Boost library [15] use generic programming to provide significant new capabilities for C++ programmers, while the Microsoft C# language has recently been enhanced to support generic programming. The importance of generic programming is shown by the inclusion of STL within the official C++ ISO standard [31], and the growing availability of generic libraries such as those for matrix manipulation [48], computational geometry [9], image processing [50], and numerical solution algorithms [39,16,52].

Edmonds et al. [23] comment that ‘the generic programming paradigm has emerged as an approach for library development that simultaneously meets the needs of flexibility and performance.’ However, despite this growing recognition by the computer science community of the benefits generic programming can offer, applications of generic programming are difficult to find in the operations research (OR) literature. Exceptions include the general purpose Boost library [15], which includes a range of generic graph-based algorithms, and the METSlib Tabu search package [41]. As an example of some OR activity in this area, Edmonds et al. [23] have developed parallel algorithms for the shortest path problem as part of a new Parallel Boost Graph Library [4]. These libraries seek to provide programmers with components to use in their software. Our approach is different, in that we use generic programming to customize a full application to meet the specific needs of the optimization problem being solved. As we will see, generic programming provides us with a faster, more flexible solution approach.

The contributions of this paper are a novel column generation algorithm and implementation using generic programming for the generalized rostering problem. Our work represents an important methodological contribution in that it demonstrates, for the first time, how generic programming can be applied within a column generation algorithm for a complex scheduling problem and shows that significant computational benefits can be gained using this new approach. Our modeling framework has proven sufficiently flexible to allow any constraint and cost we have observed in the literature to be modeled in the attribute-based setup. New instances are therefore solved without any modifications to the algorithm. Not only is the method versatile, it is also very efficient in its implementation. In a survey of the literature, Ernst et al. [27] point out that:
                        
                           Another important area requiring further work is generalization of models and methods. Currently, models and algorithms often require significant modification when they are to be transferred to a different application area, or to accommodate changes within an organization.
                        
                     
                  

Our approach alleviates exactly this problem in a very efficient way.

In Section 2, we define the generalized rostering problem, and give details of our integer programming formulation and an overview of the column generation subproblem. We also discuss the generality of our approach. Our solution method is described in Section 3, and the details of our generic programming implementation are given in Section 4. Following this, an example is presented in Section 5 and computational results for three realistic rostering instances are discussed in Section 6. Finally, our conclusions are presented in Section 7.

The inputs to a generalized rostering problem include staff, skills, shifts, and demands. Each shift is defined by a start date, start time and a duration that specifies when staff assigned to this shift will be at work. Each staff member has an associated subset of skills. These skills are combined with shifts to specify demands. For example, the company may specify that 2 or more ‘supervisor’ and/or ‘clinician’ staff shall be on duty from 10am to 12 noon next Tuesday. If the shifts that cover this time period are the Tuesday 8am–8pm ’D’ shift and 6am–2pm ’M’ shift, then this demand is expressed as a lower bound on the number of such shifts worked by staff with the clinician or supervisor skill. The earliest and latest shifts together define the scheduling time horizon of interest. The roster produced as output will specify the roster-line (sequence of shifts and days off) worked by each staff member during the scheduling horizon. We assume each staff member works no more than one shift per day, but nothing prevents the occurence of split shifts in which one shift represents two or more continuous periods at work during a day. A roster is feasible if all demands are satisfied using feasible roster-lines.

The generalized rostering problem can be modeled as a generalized binary set partitioning problem. Each column corresponds to a possible roster-line for a certain staff member, while each row corresponds to a demand constraint. Some demands may be defined as soft constraints and a penalty is applied if the demand is not met. The master problem combines the roster-lines in order to meet the demand constraints, while the column generation subproblem must generate feasible roster-lines.

The difficulty when modeling rostering problems is typically associated with the generation of high quality feasible roster-lines. As we illustrate in Section 2.3, the rules these roster-lines must satisfy may vary significantly from one problem to another. A column generator must be sufficiently flexible to handle these rules. We now formally define the master problem for which columns are generated.

Following the terminology of Desrosiers and Lübbecke [19], we first formulate the ‘integer master problem’ as follows. Given a set of employees, 
                           
                              E
                           
                        , and a set of demands, 
                           
                              D
                           
                        , the objective of the integer master problem is to find a combination of roster-lines, one for each employee, such that all demands are met at the lowest possible cost (where a low cost corresponds to a high quality). The set 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                              
                           
                         holds all feasible roster-lines for employee 
                           
                              e
                              ∈
                              E
                           
                        , where the definition of feasible depends on the particular rostering problem being solved. Three sets of decision variables are used. 
                           
                              
                                 
                                    λ
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                           
                         is a binary decision variable, where 
                           
                              
                                 
                                    λ
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                              =
                              1
                           
                         if roster-line r is chosen for employee e and 
                           
                              
                                 
                                    λ
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                              =
                              0
                           
                         otherwise. 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                         is the amount of under-coverage (slack) for demand d. Similarly, 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                         is the amount of over-coverage (surplus) for demand d. The amount of permitted under-and over-coverage is regulated by bounds on 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                         and 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                        , respectively.

Three sets of costs apply to the integer master problem. 
                           
                              
                                 
                                    c
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                           
                         gives the cost of roster-line r of employee e. 
                           
                              
                                 
                                    c
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                         and 
                           
                              
                                 
                                    c
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                         specify the cost of under-and over-coverage for demand d, respectively. Parameter 
                           
                              
                                 
                                    a
                                 
                                 
                                    ed
                                 
                                 
                                    r
                                 
                              
                           
                         describes the roster-lines, with 
                           
                              
                                 
                                    a
                                 
                                 
                                    ed
                                 
                                 
                                    r
                                 
                              
                              =
                              1
                           
                         if roster-line r of employee e contributes to demand d, and 
                           
                              
                                 
                                    a
                                 
                                 
                                    ed
                                 
                                 
                                    r
                                 
                              
                              =
                              0
                           
                         otherwise. b
                        
                           d
                         is the demand level to be met. The integer master problem is formulated as:
                           
                              (1)
                              
                                 
                                    min
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          e
                                          ∈
                                          E
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                e
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       e
                                    
                                    
                                       r
                                    
                                 
                                 
                                    
                                       λ
                                    
                                    
                                       e
                                    
                                    
                                       r
                                    
                                 
                                 +
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          d
                                          ∈
                                          D
                                       
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       d
                                    
                                    
                                       -
                                    
                                 
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       -
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          d
                                          ∈
                                          D
                                       
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       d
                                    
                                    
                                       +
                                    
                                 
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       +
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                e
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       λ
                                    
                                    
                                       e
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 1
                                 
                                 ∀
                                 e
                                 ∈
                                 E
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          e
                                          ∈
                                          E
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                e
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       a
                                    
                                    
                                       ed
                                    
                                    
                                       r
                                    
                                 
                                 
                                    
                                       λ
                                    
                                    
                                       e
                                    
                                    
                                       r
                                    
                                 
                                 +
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       -
                                    
                                 
                                 -
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       +
                                    
                                 
                                 =
                                 
                                    
                                       b
                                    
                                    
                                       d
                                    
                                 
                                 
                                 ∀
                                 d
                                 ∈
                                 D
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       λ
                                    
                                    
                                       e
                                    
                                    
                                       r
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 ∀
                                 e
                                 ∈
                                 E
                                 ,
                                 ∀
                                 r
                                 ∈
                                 
                                    
                                       R
                                    
                                    
                                       e
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 0
                                 ⩽
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       -
                                    
                                 
                                 ⩽
                                 
                                    
                                       u
                                    
                                    
                                       d
                                    
                                    
                                       -
                                    
                                 
                                 ,
                                 0
                                 ⩽
                                 
                                    
                                       s
                                    
                                    
                                       d
                                    
                                    
                                       +
                                    
                                 
                                 ⩽
                                 
                                    
                                       u
                                    
                                    
                                       d
                                    
                                    
                                       +
                                    
                                 
                                 
                                 ∀
                                 d
                                 ∈
                                 D
                              
                           
                        The objective (1) is to minimize the total cost of all roster-lines while also minimizing penalties from under-and over-coverage. A final feasible solution contains one roster-line for each employee (2). All demands must be met or the appropriate slack 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                         and surplus 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                         variables are adjusted accordingly (3)–(5) set the domains of the decision variables, where 
                           
                              
                                 
                                    u
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                         and 
                           
                              
                                 
                                    u
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                         give the maximum under-and over-coverage permitted in (3).

We will be solving this integer master problem using ‘branch-and-price’ in which the integer constraints (4) are relaxed to create the linear programming ‘master problem’. Furthermore, because we will be generating columns during the solution process, we will only have a subset of columns available at any stage. Let the set 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                                 
                                    ′
                                 
                              
                           
                         contain the roster-lines of employee e generated so far. Replacing 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                              
                           
                         with 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                                 
                                    ′
                                 
                              
                           
                         in the master problem gives us the ‘restricted master problem’ that we will be solving at each step of our solution process.

For any solution of the restricted master problem given by 
                           
                              
                                 
                                    λ
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                              ,
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    s
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                           
                        , a dual solution exists. Let τ
                        
                           e
                         be the dual variables of constraints (2) and similarly, let π
                        
                           d
                         be the dual variables of constraints (3). If a primal solution does not exist, the dual problem is unbounded and no meaningful dual values can be found. Instead, τ
                        
                           e
                        , π
                        
                           d
                         denote a dual ray that gives information on how to restore primal feasibility.

The subproblem, also referred to as the pricing problem, generates new columns for the restricted master problem. Given a vector of dual values, the subproblem returns a column with negative reduced cost, if one exists, by solving a resource constrained shortest path problem. Such a column will enter the basis in the restricted master problem and the dual values will be updated. If no additional columns exist, the restricted master problem solution is optimal, and so we have solved the master problem.

The subproblem is formulated as a three stage model and follows the setup described by Mason and Smith [42]. A roster-line is considered to be constructed from underlying entities. The association between the entities is illustrated in Fig. 1
                        . A shift entity defines a period of time during which an employee is working. A series of shifts worked in succession (one per day) forms an on-stretch entity. The length of on-stretches may be constrained in terms of minimum and maximum number of hours, shifts, days, etc. A period of one or more days where the employee is not working is referred to as an off-stretch. An on-stretch followed by an off-stretch forms a work-stretch. There are often restrictions on how on-stretches and off-stretches can be combined. Finally, a roster-line consists of a sequence of work-stretches. A roster-line spans the full scheduling horizon and typically has to respect constraints on the total amount of hours worked, the number of weekends worked, etc.

Shifts and off-stretches are referred to as simple entities while on-stretches, work-stretches and roster-lines are composite entities. Entities have attributes (also termed resources) which are tracked as the entities are constructed and extended. Attributes of a simple entity are part of the input data, whereas the attributes of a composite entity are calculated when the entity is created, using the attribute values of its component entities. A set of rules, typically stated as bounds on attribute values, define the validity of an entity. These rules should permit the construction of any entity that may occur as part of a legal roster-line. Rules may define hard constraints that must be satisfied or soft constraints for which a penalty (termed an attribute cost) is applied when a rule violation occurs. The attribute values are also used to calculate the cost associated with each entity. The cost of a new entity is calculated using costs derived from the entity’s attribute values and/or costs associated with its component entities. These entity costs may be employee dependent if staff have expressed individual preferences such as shifts requests.

Different rules and preferences may apply to each employee; therefore a separate subproblem exists for each of the employees. Given a set of legal shifts, 
                           
                              
                                 
                                    S
                                 
                                 
                                    e
                                 
                              
                           
                        , for employee e, a set of feasible on-stretches, 
                           
                              
                                 
                                    O
                                 
                                 
                                    e
                                 
                              
                           
                        , can be found. A set of legal work-stretches, 
                           
                              
                                 
                                    W
                                 
                                 
                                    e
                                 
                              
                           
                        , is created for all compatible combinations of on-stretches in 
                           
                              
                                 
                                    O
                                 
                                 
                                    e
                                 
                              
                           
                         and all legal off-stretches, 
                           
                              
                                 
                                    F
                                 
                                 
                                    e
                                 
                              
                           
                        . By sequencing legal work-stretches, roster-lines are generated and together define the set 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                              
                           
                        .

The objective of the subproblem for employee e is to find the feasible roster-line with the most negative reduced cost or to prove that no roster-line with negative reduced cost exists. For a given employee e, we can compute an effective dual value for each shift by summing the dual values π
                        
                           d
                         of the demands 
                           
                              d
                              ∈
                              D
                           
                         that are contributed to by this shift when worked by employee e. The reduced cost of any entity can then be computed by subtracting from its cost the sum of the effective duals of the shifts contained in that entity. Off-stretches have fixed costs only, i.e. there are no duals associated with off-stretches. In the case of a roster-line, the dual of the corresponding employee constraint, τ
                        
                           e
                        , must also be included. When the subproblem is used to restore primal feasibility in the master problem, the reduced costs are based solely on the values of the dual ray, with all costs being treated as zero.

As we discuss next, our use of this structure of nested entities, and the corresponding nested column generator we have developed, allows a computationally efficient expression of a wide range of rules and preferences. The user is free to specify what attributes need to be tracked by each entity type, and how these attribute values are calculated and used to determine the feasibility and/or cost of an entity. The use of nested entities allows the rules and preferences to be expressed where they naturally occur, ensuring that illegal or poor quality entities are rejected early in the column generation process.

The extent to which our system can model and solve different rostering problems is limited by the modeling power of the integer master problem and the column generator. As we now discuss, our experience with problems drawn from the literature and from our own industry contacts suggests that this modeling approach, and in particular the nested column generation, can express and efficiently process all common rules and requirements.

In a bibliographic survey by Cheang et al. [13] a list of commonly occurring constraints is presented, where the constraints are grouped into 16 different categories. Burke et al. [10] in a similar way list 26 sets of constraints that occur in practical nurse rostering problems. The list is a slight revision of a list originally formulated by Vanden Berghe [51].

Furthermore, the work of Bliddal and Tranberg [8], Nielsen [44], Engineer [25] and Poulsen [45] together describe 10 practical problems. These practical problems have been given special attention in this project. From the reports, a number of common characteristics can be found. The problems have a fixed planning period and a fixed set of shifts. Each staff member has individual preferences and their own paid hours targets. Some specific shift transitions are banned and shift assignments may be fixed in advance. These characteristics are all captured by our current model.

Each problem has individual rules. To illustrate, a few examples are listed below.
                           
                              •
                              On all days: at least one of the staff members was also there the day before [8].

A staff member cannot work two consecutive weekends [45].

Minimize the number of different shifts in an on-stretch [45].

One week with 60hours or more allows only 16hours the following week [45].

If working night shifts, at least two consecutive night shifts must be scheduled [44].

These constraints can easily be included in the model using appropriately defined attributes. Indeed, by introducing customized attributes, any of the constraints concerning internal roster-line rules can be implemented. A few rules reported in the literature concern roster-lines of multiple employees, and thus impact the master problem. These can be modeled as extended forms of the demand constraints presented in constraint (3). One such example concerns tutorship, where a ‘student’ employee must be supervised by another ‘tutor’ employee when at work. This can be modeled by introducing additional ‘tutorship’ demands in constraint (3), with zero right-hand sides (b
                        
                           d
                        
                        =0), for those periods when the student can work. Columns in which the student works during some time period have 
                           
                              
                                 
                                    a
                                 
                                 
                                    ed
                                 
                                 
                                    r
                                 
                              
                              =
                              -
                              1
                           
                         in the associated tutorship constraint, while columns for employees who can act as a tutor during that time period have 
                           
                              
                                 
                                    a
                                 
                                 
                                    ed
                                 
                                 
                                    r
                                 
                              
                              =
                              +
                              1
                           
                         in that constraint. Putting 
                           
                              
                                 
                                    u
                                 
                                 
                                    d
                                 
                                 
                                    -
                                 
                              
                              =
                              0
                           
                         and 
                           
                              
                                 
                                    u
                                 
                                 
                                    d
                                 
                                 
                                    +
                                 
                              
                              =
                              ∞
                           
                         then ensures that at least one tutor is on duty whenever the student is at work.

With the suggested extensions, the model presented here is able to deal with all the constraints of Cheang et al. [13] and Burke et al. [10] and with all constraints seen in the 10 industry examples mentioned earlier.

The restricted master problem as defined in Section 2.1 is an LP-problem and a standard solution tool (like CPLEX) can be applied to solve it. Branching is applied to remove fractional solutions from the solution space of the restricted master problem. In regular branch-and-bound algorithms, variable branching is the method of choice. It is, however, complex and in most cases highly inefficient to apply variable branching in a branch-and-price algorithm. Instead, we use constraint branching where certain constraints are (implicitly) introduced in the current restricted master problem.

Here, we use a specialization of the constraint branching method proposed by Ryan and Foster [47]. If the solution of the restricted master problem is fractional, the columns of one or more employees are in the solution with a fractional value. As two columns of an employee are never identical, two fractionally selected columns will differ in at least one of the included shifts. This in turn means that the employee is not assigned to that shift with a value of 1. In a feasible integer solution, employees are always assigned to shifts (with a value of 1) or not assigned to them at all (a value of 0). We may therefore branch on the employee/shift assignment.

When branching on an employee/shift assignment, the set of feasible columns of the employee is split into two subsets. One subset contains all columns for that employee in which the shift is included in the roster-line. The other subset contains the remaining columns for that employee. The two branches are created by removing the relevant roster-lines from the first and the second subset, respectively. In a branch-and-price setup, the branching decisions are imposed on new columns by forcing the subproblem of the particular employee to either include or exclude the shifts that have been branched on.

During our computational testing (Section 6), we identified a number of strategies that reduced the solution times for our problems. Firstly, the solutions to the linear programming relaxations often satisfy employee preferences to some fractional degree, meaning that some employee has a mix of roster-lines whose costs come from only a few alternative values. Our experiments showed that where there are many possible branching candidates (fractional employee/shift assignments), one should avoid branches in which the banned columns on either side of the branch have similar costs, and instead prefer branches where these costs differ to the greatest degree. This quickly resolves the fractional preference satisfaction and gives an immediate impact on overall cost and/or feasibility. Finally, when solving an LP after branching and/or adding more columns, it was also found to have a positive effect to stop the solution process as soon as the LP value is equal to the lower bound of the root node. Traditionally, generation continues as long as columns with negative reduced cost exist. However, if the LP value is equal to the lower bound, such columns are only included in the basis because of degeneracy in the LP problem and will never decrease the objective value.

As discussed in Section 2.2, the column generation subproblem involves the following steps as introduced by Mason and Smith [42].
                           
                              1.
                              Shifts are combined into on-stretches.

On-stretches and off-stretches are paired to form work-stretches.

Roster-lines are generated by sequencing work-stretches.

Our column generator always builds the complex entities by combining two simpler entities. For example, instead of describing an on-stretch by all the shifts it contains, we describe it by its last shift and its ‘parent’ on-stretch which contains all but the last shift in the on-stretch. This is illustrated in Fig. 2
                        . Note that the parent on-stretch may be an infeasible on-stretch, and may be null if the on-stretch contains only one shift. The definition of the composite entities that follows from this approach gives:
                           
                              
                                 
                                    
                                       
                                          
                                             on-stretch
                                             +
                                             shift
                                             →
                                          
                                       
                                       
                                          
                                             
                                             on-stretch
                                          
                                       
                                    
                                    
                                       
                                          
                                             on-stretch
                                             +
                                             off-stretch
                                             →
                                          
                                       
                                       
                                          
                                             
                                             work-stretch
                                          
                                       
                                    
                                    
                                       
                                          
                                             roster-line
                                             +
                                             work-stretch
                                             →
                                          
                                       
                                       
                                          
                                             
                                             roster-line
                                          
                                       
                                    
                                 
                              
                           
                        The three stages give rise to their own resource constrained shortest path problems. Attributes are algorithmically represented by resources. Each of these shortest path problems is solved by dynamic programming using label setting [32], where an entity is labeled using the values calculated for its attributes. Dominance is used to prevent unpromising entities proceeding to the next stage. The dominance rules associated with an attribute form part of the definition of that attribute. Each of these three problems is now addressed in detail.

Note that while we give some examples, we do not attempt to list all the resources that occur in the column generation subproblem, nor do we give the formulae by which their values are calculated. While such an approach may be appropriate for a traditional column generation algorithm, our generic programming approach gives the user much greater freedom to define their own attributes and specify the rules by which their values are processed using any valid C++ expressions.

The first stage of the column generation algorithm is to generate on-stretches from shifts. Shifts might have costs given by employee preferences, and will have dual values associated with them, as described earlier. There might also be costs associated with shift transitions, while typical attributes to track might include paid hours or the number of undesirable shifts. On-stretches are considered unique if they differ in their start time or end time, or if they have different non-dominated attribute values. We seek all unique minimum reduced cost on-stretches.

The on-stretch generation problem is modeled as a shortest path problem with resources in a graph where nodes represent shifts. An example of such a graph is shown in Fig. 3
                        . The graph consists of a node for each shift. Arcs between nodes exist when the two shifts are allowed to be consecutive in an on-stretch, i.e. they can be neither too close nor too far apart in time. To generate all on-stretches the all-to-all shortest paths problem is solved. This is done by solving a one-to-all shortest path problem from each of the nodes in the graph. For each of these problems, the start node is selected and the remaining graph is reduced to only allow on-stretches up to the maximum on-stretch length. Fig. 3 shows the shortest path problem with Node 1 as start node. If the maximum on-stretch length is 4days, all arcs leaving nodes 16–20 are removed.

Nodes may be excluded in the graph in order to generate roster-lines without certain shifts. In Fig. 3, shift 10 has been excluded. Shifts may be disallowed if the employee does not have the appropriate skills and employees may simply be restricted from certain shifts as part of the input data for the problem, e.g. it is common to have employees that can never work night shifts or must have days off on particular days.

The shortest path problems are solved with a label setting algorithm. The graph is acyclic and has an inherent topological order and the nodes are treated accordingly. All on-stretches are validated by checking the attribute values against the feasibility criterion given in the problem definition, and checks are performed to remove dominated entities (see Section 3.5). All unique non-dominated feasible on-stretches are sent to stage two.

The second stage is the simplest of the three. On-stretches from stage one are combined with off-stretches to form work-stretches. The start time of an off-stretch is not specified exactly, but instead an off-stretch start time window is given along with a minimum off-stretch duration in hours. An on-stretch/off-stretch pair is considered compatible if the on-stretch finish time occurs within the off-stretch’s start time window. All compatible on-stretch/off-stretch pairs are constructed, and the resulting work-stretch attribute values are calculated and checked for feasibility. Workstretch costs will often be specified to discourage a long on-stretch being followed by a short off-stretch; these and any other workstretch costs are calculated at this stage. Domination tests are performed (see Section 3.5) to remove unpromising work-stretches before proceeding to the third stage. The second stage is visualized in Fig. 4
                        .

The roster-line generation problem is another acyclic shortest path problem with resource constraints. The problem has a node for each day in the horizon. The work-stretches generated in stage two are the transitions between days and hence become the arcs of the graph. Usually, the arc leads to the day after the work-stretch ended.

In the generalized rostering problem, we have a predetermined start and end day, and this transfers to a source node and a sink node in the graph. The problem becomes a one-to-one shortest path problem. The labels applied to the end node represent complete roster-lines. Again, roster-line attributes of these roster-lines have to respect the feasibility criterion given in the problem definition. The best feasible roster-line is also the optimal solution to the pricing problem. A visualization of the shortest path problem is given in Fig. 5
                        .

For some attributes, it is possible to predict infeasibility prior to reaching the end node. Entities that can never lead to a feasible roster-line or a roster-line with negative reduced cost should be removed, as this results in fewer entities being constructed and hence a more efficient algorithm. We briefly describe the approach we implement below, and refer the reader to Dumitrescu and Boland [22] for a detailed discussion of this area.

Our system performs a feasibility analysis for all those roster-line attributes that are additive in the sense that the calculated attribute values are summations over the values in the component entities. Each of these attributes is processed in turn to create bounds that define feasible values for that attribute. We also apply this process to the reduced cost values, which have an imposed upper bound of zero to ensure we find a negative reduced cost column.

Let the set of feasible values for an additive attribute a at node i be defined by a lower bound, 
                           
                              
                                 
                                    lb
                                 
                                 
                                    i
                                 
                                 
                                    a
                                 
                              
                           
                        , and an upper bound, 
                           
                              
                                 
                                    ub
                                 
                                 
                                    i
                                 
                                 
                                    a
                                 
                              
                           
                        , with initial values 
                           
                              
                                 
                                    
                                       
                                          lb
                                       
                                       
                                          ^
                                       
                                    
                                 
                                 
                                    i
                                 
                                 
                                    a
                                 
                              
                           
                         and 
                           
                              
                                 
                                    
                                       
                                          ub
                                       
                                       
                                          ^
                                       
                                    
                                 
                                 
                                    i
                                 
                                 
                                    a
                                 
                              
                           
                        , respectively, as determined by the problem formulation. Because the roster-line graph is acyclic, the lower bound 
                           
                              
                                 
                                    lb
                                 
                                 
                                    i
                                 
                                 
                                    a
                                 
                              
                           
                         can be calculated as the minimum of all node i’s successor lower bounds minus the respective accumulation value of the associated successor arc. An upper bound can be computed in an analogous fashion. Thus let 
                           
                              
                                 
                                    δ
                                 
                                 
                                    i
                                 
                                 
                                    +
                                 
                              
                           
                         denote the set of outgoing arcs for node i, let 
                           
                              
                                 
                                    v
                                 
                                 
                                    w
                                 
                                 
                                    a
                                 
                              
                           
                         denote the value of attribute a associated with arc w, and let each arc w represent a transition from node w
                        orig to node w
                        dest. The bounds on an additive attribute a at each node i are then calculated by our system as follows:
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   lb
                                                
                                                
                                                   i
                                                
                                                
                                                   a
                                                
                                             
                                             =
                                             
                                                max
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               min
                                                            
                                                            
                                                               w
                                                               ∈
                                                               
                                                                  
                                                                     δ
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     +
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     lb
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           w
                                                                        
                                                                        
                                                                           dest
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                               -
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            
                                                               
                                                                  lb
                                                               
                                                               
                                                                  ^
                                                               
                                                            
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   ub
                                                
                                                
                                                   i
                                                
                                                
                                                   a
                                                
                                             
                                             =
                                             
                                                min
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               max
                                                            
                                                            
                                                               w
                                                               ∈
                                                               
                                                                  
                                                                     δ
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     +
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     ub
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           w
                                                                        
                                                                        
                                                                           dest
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                               -
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            
                                                               
                                                                  ub
                                                               
                                                               
                                                                  ^
                                                               
                                                            
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In the same way as bounds can be propagated backwards from the end node, we can also propagate bounds forward. The domain for an additive attribute a at node i is defined by bounds 
                           
                              
                                 
                                    
                                       
                                          
                                             dl
                                          
                                          
                                             i
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       
                                          
                                             du
                                          
                                          
                                             i
                                          
                                          
                                             a
                                          
                                       
                                    
                                 
                              
                           
                        , which are calculated as:
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   dl
                                                
                                                
                                                   i
                                                
                                                
                                                   a
                                                
                                             
                                             =
                                             
                                                max
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               min
                                                            
                                                            
                                                               w
                                                               ∈
                                                               
                                                                  
                                                                     δ
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     -
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     dl
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           w
                                                                        
                                                                        
                                                                           orig
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                               +
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            lb
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   du
                                                
                                                
                                                   i
                                                
                                                
                                                   a
                                                
                                             
                                             =
                                             
                                                min
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               max
                                                            
                                                            
                                                               w
                                                               ∈
                                                               
                                                                  
                                                                     δ
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     -
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     du
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           w
                                                                        
                                                                        
                                                                           orig
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                               +
                                                               
                                                                  
                                                                     v
                                                                  
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     a
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            ub
                                                         
                                                         
                                                            i
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    δ
                                 
                                 
                                    i
                                 
                                 
                                    -
                                 
                              
                           
                         is the set of incoming arcs at node i. These resulting domains can be used to eliminate arcs from the graph. We check all arcs against the value domain of their tail (origin) combined with the feasibile bounds of their head (destination). If, using that arc, none of the values of the domain for any attribute accumulate to values within the computed bounds, then the arc is deleted.

This roster-line bounding scheme exploits the nested subproblem structure of our formulation in that the bounds are calculated using the attribute values of the work-stretches generated in the second stage of the nested subproblem. Thus, this nested structure is an essential component of our bounding scheme.

Domination is an important concept in all three stages of the subproblem solution algorithm. An entity e
                        1 is said to be dominated by entity e
                        2 if any roster-line containing e
                        1 is worse (or no better) than a new roster-line created by replacing e
                        1 by e
                        2. For example, a 3-day on-stretch O
                        1
                        =
                        S
                        1
                        →
                        S
                        2
                        →
                        S
                        3 containing shifts S
                        1, S
                        2, S
                        3 might be dominated by O
                        2
                        =
                        S
                        1
                        →
                        S
                        4
                        →
                        S
                        3 if S
                        2 and S
                        4 are equivalent in paid hours, but S
                        4 is preferred by the employee. An efficient column generation algorithm must be able to identify and remove dominated entities. In general, entity e
                        1 is dominated by e
                        2 if all e
                        1’s attribute values are equal to, or worse than, e
                        2’s. The definition of ‘equal to or worse than’ is attribute dependent, and thus dominance rules must be specified by the user as part of the user’s attribute definition. Careful attention must be paid to the dominance rules specified for attributes that are used to calculate other attribute values.

@&#IMPLEMENTATION@&#

A major contribution of this work is the design of a software framework that allows an efficient implementation of our nested column generation framework. This implementation must be versatile enough to capture any common property of rostering problems, while at the same time being as efficient as a tailored implementation. This rather ambitious goal is met by the creation of a customizable software framework, where the problem definition is part of the input to the compiler, and thus the compiled code implicitly includes the problem definition.

We originally envisaged designing a new roster definition language and then writing an interpreter that would create C++ from a roster definition. However, we found instead that the Boost Preprocessor Library [35] allowed us to easily customize our core software by inserting user defined C++ code in the appropriate places. Thus, our roster definition became a carefully constructed C++ header file; see Dohn et al. [21] for the full details of this implementation. This approach has the added benefit of allowing the user to exploit the full expressive power of a modern computer language in their roster definition.

Our approach contrasts with a traditional pre-compiled system in which the types of attributes and the rules for their processing are pre-defined by the original software designer. This designer must try to predict how these attributes will be used, and then the user needs to coerce their problem definition into the designer’s framework. We avoid the inefficiencies that can arise from this by giving the user much greater control, allowing them to tune the implementation to best meet the needs of their specific problem.

Another approach we considered, but rejected, was to build a class framework in C++ with a ‘base’ attribute class that would then be specialized by the user using inheritance at compile time. To provide the entity functions such as IsFeasible() and CalculateCost() we detail below, the entity classes would then contain loops that iterated through all the attributes in the entity calling the appropriate attribute method. There are significant efficiency penalties associated with this approach. Firstly, a run time penalty is incurred every time an attribute call is made because (1) a function call must be made which has overhead, and (2), because the functions must be ‘virtual’, the exact attribute class to be called must be determined at run time (termed ‘late binding’). Secondly, compile time optimizations such as loop unrolling and code in-lining cannot be performed. The generic programming paradigm we adopt avoids these difficulties.

Our setup requires the code to be recompiled whenever a new problem is encountered, or new rules are added to a problem. It is thereafter possible to solve multiple instances of the same problem with the executable program. In our experience, rosters are typically built every 2, 3 or 4weeks, and thus the reduced runtimes we show in Section 6 will be realized many times a year. Roster rules typically change much less frequently. Some rule changes will require changes to parameter values which can be implemented without recompiling the code. More significant changes will require recompiling. However, the ready availability of open source or free compilers on both Linux and Microsoft Windows such as Visual Studio Express [43] and GCC [28] means that compiling new code is no longer the barrier it used to be.

The definitions of all the entity attributes, together with the demands, make up the full definition of the rostering problem. The problem definition is parsed into the code and in this way, the algorithm is customized for the problem being solved.

The user must specify the attributes to be tracked by each entity. Start time and end time are mandatory attributes, but all other attributes are customizable. Because these attributes are being specified at compile time, the specification includes code for tasks such as calculating new attribute values. The entities and their attributes can be listed as:
                           
                              
                                 
                                    
                                       
                                          
                                             Shift
                                             ≔
                                          
                                       
                                       
                                          
                                             
                                             (
                                             shift
                                             _
                                             start
                                             _
                                             time
                                             ,
                                             shift
                                             _
                                             end
                                             _
                                             time
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             shift
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             shift
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                          
                                             Offstretch
                                             ≔
                                          
                                       
                                       
                                          
                                             
                                             (
                                             offstretch
                                             _
                                             start
                                             _
                                             time
                                             ,
                                             offstretch
                                             _
                                             end
                                             _
                                             time
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             offstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             offstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                          
                                             Onstretch
                                             ≔
                                          
                                       
                                       
                                          
                                             
                                             (
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             ,
                                             onstretch
                                             _
                                             end
                                             _
                                             time
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             onstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             onstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                          
                                             Workstretch
                                             ≔
                                          
                                       
                                       
                                          
                                             
                                             (
                                             workstretch
                                             _
                                             start
                                             _
                                             time
                                             ,
                                             workstretch
                                             _
                                             end
                                             _
                                             time
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             workstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             workstretch
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                          
                                             Rosterline
                                             ≔
                                          
                                       
                                       
                                          
                                             
                                             (
                                             rosterline
                                             _
                                             start
                                             _
                                             time
                                             ,
                                             rosterline
                                             _
                                             end
                                             _
                                             time
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             rosterline
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             rosterline
                                             _
                                             custom
                                             _
                                             
                                                
                                                   att
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        The definition of attributes of simple entities is straightforward and simply introduces the attribute with a name and a numeric type such as integer or floating point number.

The definition of attributes of composite entities requires more information as attribute values need to be calculated whenever new entities are formed. Recall that entities are always created by adding one entity to another parent entity. We generally describe this operation as ‘accumulation’. The case where an object is created without a parent is called ‘initialization’. Thus, we have the following entity creation events:
                           
                              
                                 
                                 
                                 
                                 
                                 
                                    
                                       Initialization:
                                       
                                       
                                       
                                    
                                    
                                       
                                       shift(s)
                                       
                                       → on-stretch
                                    
                                    
                                       
                                       on-stretch(o)
                                       +off-stretch(f)
                                       → work-stretch
                                    
                                    
                                       
                                       work-stretch(w)
                                       
                                       → roster-line
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       Accumulation:
                                       
                                       
                                       
                                    
                                    
                                       
                                       on-stretch(o)
                                       +shift(s)
                                       → on-stretch
                                    
                                    
                                       
                                       roster-line(r)
                                       +work-stretch(w)
                                       → roster-line
                                    
                                 
                              
                           
                        
                     

In the attribute definitions for these composite entities, we have to specify the code used to calculate an attribute’s value during these events. Dominance, costs and feasibility details must also be given. Thus, in addition to the attribute name and type, the following must be specified for these attributes:
                           
                              •
                              Feasibility type: Whether or not bounds apply on the feasible attribute values.

Cost type: Any contribution that this attribute makes to the cost of the entity.

Initialization code and Accumulation code: The code that runs to calculate the attribute’s value when a new entity instance is created.

Domination criterion: What it means for one entity’s attribute value to be ‘equal or worse than’ another’s.

All entities have start time and end time attributes specified in integer minutes from the start of the roster period. The definitions of these two attributes are shown below for on-stretches, and illustrate typical attribute definitions. Note that the initialization function of the on-stretch refers to the shift (s) from which it is initialized. Likewise, the accumulation function may use values of the parent on-stretch (o) and the new shift (s). The functions may also look up the value of any other attributes of these entities.
                           
                              Attribute: onstretch_start_time
                              

Numeric type: Integer

Feasibility type: All values feasible

Cost type: No cost

Initialization: onstretch_start_time
                                 =
                                 s.shift_start_time
                              

Accumulation: onstretch_start_time
                                 =
                                 o.onstretch_start_time
                              

Domination: Dominate on equal values

Attribute: onstretch_end_time
                              

Numeric type: Integer

Feasibility type: All values feasible

Cost type: No cost

Initialization: onstretch_end_time
                                 =
                                 s.shift_end_time
                              

Accumulation: onstretch_end_time
                                 =
                                 s.shift_end_time
                              

Domination: Dominate on equal values

The start time and the end time of work-stretches and roster-lines are defined similarly.

In our framework, attributes are implemented as objects that have user-specified procedures for implementing feasibility checks, cost calculations, domination and initialization. For example, the onstretch_start_time attribute class definition might provide the following methods:
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             .
                                             IsFeasible
                                             (
                                             )
                                             
                                             {
                                             return
                                             
                                             true
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             .
                                             CalculateCost
                                             (
                                             )
                                             
                                             {
                                             return
                                             
                                             0
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             .
                                             Initialize
                                             (
                                             Shift
                                             
                                             s
                                             )
                                             
                                             {
                                             return
                                             
                                             s
                                             .
                                             shift
                                             _
                                             start
                                             _
                                             time
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             .
                                             Accumulate
                                             (
                                             Onstretch
                                             
                                             o
                                             ,
                                             Shift
                                             
                                             s
                                             )
                                             {
                                             return
                                             
                                             o
                                             .
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             onstretch
                                             _
                                             start
                                             _
                                             time
                                             .
                                             Dominates
                                             (
                                             Onstretch
                                             
                                             o
                                             )
                                             {
                                             return
                                             
                                             (
                                             value
                                             =
                                             =
                                             o
                                             .
                                             shift
                                             _
                                             start
                                             _
                                             time
                                             )
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        To simplify the task of defining attributes, the code framework provides many standard implementations for IsFeasible(), CalculateCost() and Dominates() that cover the most commonly occurring cases. These are implemented efficiently by using C++ templates.

Once the attributes have been defined, the code framework forms entity objects that contain the user-specified set of attributes for that entity. Entity objects also provide methods for feasibility checks, cost calculations, domination and initialization.

The code framework automatically generates these functions. For an on-stretch, for example, these include: Onstretch.Accumulate() and Onstretch.Initialize(), which accumulate/initialize all the attributes in an on-stretch; Onstretch.IsFeasible() which returns true if and only if IsFeasible() is true for all the attributes; Onstretch.CalculateCost(), which returns the sum of the costs of the attributes; and Onstretch.Dominates() which is true (and hence allows domination) only if all the attributes allow domination.

To implement these functions, the Boost library allows us to construct code that, at the conceptual level, might be written as:
                           
                              
                                 
                                 
                                    
                                       
                                          Onstretch.Initialize(Shift s){
                                    
                                    
                                       
                                          
                                          for all on-stretch attributes do
                                       
                                    
                                    
                                       
                                          
                                          
                                          attribute.Initialize(s)
                                    
                                    
                                       }
                                    
                                 
                              
                           
                        
                     

The Boost preprocessor unrolls this loop to give the following code which is then compiled.
                           
                              
                                 
                                 
                                    
                                       
                                          Onstretch.Initialize(Shift
                                          
                                          s){
                                    
                                    
                                       
                                          
                                          onstretch_start_time.Initialize(s)
                                    
                                    
                                       
                                          
                                          onstretch_end_time.Initialize(s)
                                    
                                    
                                       
                                          
                                          onstretch_custom_att
                                          1.Initialize(s)
                                    
                                    
                                       
                                          
                                          ⋮
                                    
                                    
                                       
                                          
                                          onstretch_custom_att
                                          
                                             n
                                          .Initialize(s)
                                    
                                    
                                       }
                                    
                                 
                              
                           
                        
                     

Because each attribute is referred to explicitly in this expanded code, its type is available to the compiler, and so the correct Initialize() function is called directly without the run-time overhead of late binding. Furthermore, because functions such as Initialize() are typically very simple, they can be inlined by the compiler, thereby removing the need for a function call. As we discuss shortly, these efficiency gains lead to significantly reduced run times.

While Boost makes the generic code somewhat obscure, it is possible to pre-process the code with the compiler, and then view, compile and debug source code that is specific to the particular problem being solved. We have found that this makes software development more intuitive as the problem attributes and rules are given explicitly in the code rather than being hidden in complex data structures.

To illustrate how the framework can be set up for a particular problem, an example is introduced below. The example is a nurse rostering problem from Middlemore Hospital in Auckland, New Zealand, which was also used by Smith [49] and Engineer [25]. (For clarity, a slight simplification of the problem is presented here.) The entities and their attributes are defined below. The associated C++ definitions of these (for the unsimplified problem) are given in Appendix A.
                        
                           
                              Shift
                              ≔
                              
                              (
                              shift
                              _
                              start
                              _
                              time
                              ,
                              shift
                              _
                              end
                              _
                              time
                              ,
                              shift
                              _
                              type
                              ,
                              shift
                              _
                              paid
                              _
                              hours
                              )
                           
                        
                     
                     
                        
                           
                              Offstretch
                              ≔
                              
                              (
                              offstretch
                              _
                              start
                              _
                              time
                              ,
                              offstretch
                              _
                              end
                              _
                              time
                              ,
                              offstretch
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              off
                              ,
                              offstretch
                              _
                              number
                              _
                              of
                              _
                              weekends
                              _
                              off
                              ,
                              offstretch
                              _
                              single
                              _
                              day
                              _
                              off
                              )
                           
                        
                     
                     
                        
                           
                              Onstretch
                              ≔
                              
                              (
                              onstretch
                              _
                              start
                              _
                              time
                              ,
                              onstretch
                              _
                              end
                              _
                              time
                              ,
                              onstretch
                              _
                              paidhours
                              ,
                              onstretch
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              on
                              )
                           
                        
                     
                     
                        
                           
                              Workstretch
                              ≔
                              
                              (
                              workstretch
                              _
                              start
                              _
                              time
                              ,
                              workstretch
                              _
                              end
                              _
                              time
                              ,
                              workstretch
                              _
                              paidhours
                              ,
                              workstretch
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              on
                              ,
                              workstretch
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              off
                              ,
                              workstretch
                              _
                              number
                              _
                              of
                              _
                              single
                              _
                              days
                              _
                              off
                              ,
                              workstretch
                              _
                              feasible
                              _
                              on
                              _
                              off
                              _
                              combination
                              )
                           
                        
                     
                     
                        
                           
                              Rosterline
                              ≔
                              
                              (
                              rosterline
                              _
                              start
                              _
                              time
                              ,
                              rosterline
                              _
                              end
                              _
                              time
                              ,
                              rosterline
                              _
                              paidhours
                              ,
                              rosterline
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              on
                              ,
                              rosterline
                              _
                              number
                              _
                              of
                              _
                              days
                              _
                              off
                              ,
                              rosterline
                              _
                              number
                              _
                              of
                              _
                              single
                              _
                              days
                              _
                              off
                              )
                           
                        
                     The definition of most of the attributes is straightforward. For example, the number of hours worked is accumulated in the attribute paidhours in all entities except in off-stretches, where it is not applicable. For on-stretches the attribute is defined as:
                        
                           Attribute: onstretch_paidhours
                           

Numeric type: Integer

Feasibility type: All values feasible

Cost type: No cost

Initialization: onstretch_paidhours
                              =
                              s.shift_paid_hours
                           

Accumulation: onstretch_paidhours
                              =
                              o.onstretch_paidhours
                              +
                              s.shift_paid_hours
                           

Domination: Dominate on equal values

The definition of workstretch_paidhours is similar, except that the initialization function becomes workstretch_paidhours 
                     =
                     o.onstretch_paidhours. In rosterline_paidhours the value is accumulated over workstretch_paidhours and the feasibility type is changed to ‘Bounded by upper and lower bound’. The actual values of the bounds are read as part of the data input and individually for each employee.

This problem includes a penalty discouraging long on-stretches. To implement this, the attribute onstretch_number_of_days_on has a piecewise linear cost function. The problem also specifies that 5 or more days on must be followed by at least 2days off. This is modeled by the attribute workstretch_feasible_on_off_combination defined as:
                        
                           Attribute: workstretch_feasible_on_off_combination
                           

Numeric type: Boolean

Feasibility type: Must be true
                           

Cost type: No cost

Initialization: workstretch_feasible_on_off_combination
                              =(o.onstretch_number_of_days_on
                              ⩽4) and (f.offstretch_number_of_days_off
                              ⩾2)

Domination: Ignore this for domination

Most of the other attributes have similarly simple definitions. These definitions are all specified in a single header file (see Appendix A) using a mixture of C++ code and Boost preprocessor commands.

In addition to the problem definition, instance-specific data must be provided. This input data consists of four data sets. Two of these list the shifts and off-stretches with values of start time, end time and the customized attributes. Another set holds the demands that specify staff requirements in terms of combinations of overlapping shifts and staff skills. Finally, the fourth data set list the employees along with their skills, preferences and employee-specific costs and bounds. The problem definition described above together with the actual data instance is all that is needed to solve a new problem.

To illustrate the capabilities of the algorithm, three real nurse rostering data instances are introduced, one from a hospital in New Zealand, and two from hospitals in Denmark. The three instances have different characteristics and it is therefore essential to have a versatile setup in order to be able to solve all three instances with the same approach. All three instances have a scheduling horizon of 4weeks.

Instance A has 85 nurses which must be allocated shifts of 5 different types. This is the same instance as described in Section 5 and Engineer [25] also presents computational results for this instance. There are penalties for long on-stretches, split-weekends and for certain shift transitions. The roster includes a mix of full time and part time staff, with the exact number of hours to be worked in a roster-line being specified for each different nurse group. The nurses have skills and contractual agreements that limit each nurse to work a subset of all shifts and prohibit certain shift sequences. Demands are specified for various combinations of skills, and typically involve more than one shift type.

Instance B contains 28 nurses and 4 shift types. Several demands with varying skill requirements exist for each shift. Ten of the nurses are part time employees. The hours to be worked for the 4weeks is specified with a small tolerance being allowed. A nurse cannot work two consecutive weekends and never more than one shift during a weekend. Furthermore, a sophisticated cost structure applies that distributes weekend shifts fairly and distributes off-days evenly over the weeks. This cost structure makes it very hard to find near-optimal solutions.

In Instance C, 40 nurses are scheduled on 18 shift types in two wards. Each nurse has an individually specified requirement on work hours per 4weeks and a set of individual requests and preferences on shifts. Continuity is desired in one of the wards and a sequence of less than three successive shifts in the ward is penalized. Consecutive weekends on are undesired and no more than 2weekends on duty in a month can be scheduled for each nurse.

To test the nested column generator using our compile-time customization approach, we embedded our new C++ column generator within the branch-and-cut-and-price framework of COIN-OR [37]. To reduce the run times (and sacrifice guarantees of optimality), we followed the approach described by Engineer [25] of allowing the user to artificially limit the number of entities generated in the subproblem, with the code then discarding poor entities when this limit was reached. We also used a partial depth first search referred to as diving in the branch-and-bound tree to find feasible solutions faster. Some tuning experiments were undertaken that indicated the best number of columns to add to the restricted master problem from each column generation was 15.

Tests were run on a PC with a Dual Core AMD Opteron (tm) 175 processor running 64 bit Linux with 2gigabytes of RAM. The results of these are summarized in Table 1
                     . The runs detailed in the upper table are heuristic in that they were performed with artificial limits applied to the number of entities allowed during each column generation iteration. The table shows LP and IP solution values, detailed timing and entity count information for the LP, branch-and-bound, and each of the different entity creation phases used by the nested generator. The total number of entities generated over each run are also shown, as well as how this number is reduced by dominance rules and feasibility tests and by applying the attribute bounds discussed in Section 3.4. Note that the order in which this filtering is applied is shown in the table, and is different for each entity. For reference, the true lower bound and the optimal solution from a test without entity limits are listed in the bottom of the table.

For Instances B and C, the root node lower bound is larger than the solution value of the best feasible solution. This is a consequence of the imposed entity limit, where columns with negative reduced cost may not be generated and hence the bounds may not be correct. On the other hand, the entity limits introduce a significant speed up, as evident from the run times as well as from the number of entities before and after discarding. Note that the algorithm terminates after finding a solution with value equal to or less than the lower bound. However, when bounds are heuristic, the solution found at this point is not guaranteed to be optimal.

The time distribution within the algorithm is clearly problem dependent. In one case (Instance C), the major part of the time is spent in the master problem. In another (Instance B), it is spent mainly in the subproblem and in the third (Instance A), time is divided equally between these. The distribution of time spent creating the different entity types within the pricing problem is again problem dependent and emphasizes the fact that each component of the column generator must be optimized to ensure high performance for all instances.

In all three instances, high-quality feasible solutions are found within 15minutes. In Instance A and Instance C, the best solution found is optimal. The low values for Instance A and C represent rosters with very few preferences being violated. In the latter case, only a single roster-line for one employee contains an undesired shift sequence, with all other preferences being met. In all three instances, all demand constraints are met without any violations.

An important contribution of this work is the use of generic programming compile-time customization and the benefit this gives over the more standard approach used in Engineer [25] in which a single executable modifies its behavior based on problem-specific data loaded at run time. To quantity the speed differences between the two approaches, our new software was run on Instance A, and the dual vectors (and associated staff members) were recorded for each of the 338 column generates required to solve this instance. The column generator from Engineer [25] was then run on Instance A using these 338 different dual vectors. All entity limits were removed from the column generators for these tests. Analysis of the resulting run times and entity counts showed that the number of on-stretches and work-stretches generated by the two systems are very similar. However, the new bounding scheme presented in Section 3.4 reduced the number of roster-lines to 37% of those generated by the older system. After correcting for this, we found that over the 338 tests, speedup factors between 5 and 100 were observed, giving a weighted average of approximately 20. Clearly, the compile time approach is giving us a significant performance improvement.

@&#CONCLUSIONS@&#

We have successfully implemented a generic programming implementation of a branch-and-price algorithm to solve the generalized rostering problem. The solution approach builds on a general underlying model and hence allows solution of problems with varying characteristics. From the literature and by looking at the rostering problems at hand, it was clear that a solution approach to the generalized rostering problem must be very flexible. At the same time, rostering problems are typically highly constrained and it is often a demanding task to even find feasible solutions. Therefore the solution approach must not only be flexible, but also very efficient.

To meet these requirements, we have modeled the problem as a generalized set partitioning problem and built a generic programming branch-and-price algorithm to solve the problem. The pricing problem is solved using an innovative three-stage approach which allows us to exploit the structure inherent in rostering problems, helping make the problem tractable in realistic settings. Using this approach, it is possible to represent in our model all the rostering rules seen in the application of former projects [8,44,25,45], as well as all commonly occurring requirements listed by Cheang et al. [13] and Burke et al. [10].

By following generic programming principles, we have developed a new approach for implementing branch-and-price in which we explicitly embed the problem definition in the program code. A separate executable is then created for each new problem definition, ensuring we achieve a high efficiency implementation throughout the algorithm. By embedding the problem definition in the code, we can realize much of the efficiency of a purpose built implementation without incurring the software development costs typically associated with such bespoke work. This also gives a more flexible system in that a user implementing the system can specify rules and attribute calculations using the full power of a programming language instead of being restricted to a set of pre-configured options. In a comparison to a former method, where the customization is included at run-time, a speed up of a factor 20 was observed, demonstrating the value of this new application of generic programming.

The value of the algorithm was illustrated for three different rostering applications. The model captures all features of the realistic problems and provides high-quality solutions in less than 15minutes for a scheduling horizon of 4weeks. The greater use of heuristic components can be introduced in the future to allow for additional speedups.

Burke et al. [11] state that:
                        
                           The current state of the art is represented by interactive approaches which incorporate problem specific methods and heuristics (that are derived from specific knowledge of the problem and the required constraints) with powerful modern metaheuristics, constraint based approaches and other search methods.
                        
                     
                  

We believe that we have provided a viable alternative to these methods. Furthermore, our compile-time customization constitutes a contribution not only to rostering. This approach can be applied to a wide range of optimization problems, and is likely to deliver similar improvements in run time performance.

@&#ACKNOWLEDGEMENTS@&#

The research leading to these results has received funding from the New Zealand Government and European Union Seventh Framework Programme (FP7-PEOPLE-2009-IRSES) under grant number 246647 (project OptALI). The first author was supported by the EliteForsk-grant of the Danish Ministry of Science, Technology and Innovation.

We wish to thank the anonymous referees whose comments and suggestions helped us improve this paper.

The following code listing shows the attribute definitions for the Middlemore Hospital rostering problem discussed in Section 5. Each attribute is defined by an internal name, type, and an optional text name. In the case of composite entities, we also define a feasibility rule, dominance rule, cost rule, initialisation function and accumulation function. The reader is referred to Dohn et al. [21] for the full specifications of this file.
                        
                           
                              
                              
                              
                              
                                 
                                    
                                       # define SHIFT_ATTRIBUTES ⧹
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (starttime
                                    
                                    , int, "Starttime"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (endtime
                                    
                                    , int, "Endtime")
                                       , ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (shifttype
                                    
                                    , int, "ShiftType"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours
                                    
                                    , int, "PaidHours"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (dayson
                                    
                                    , int, "DaysOn")
                                       , ⧹
                                    
                                 
                                 
                                    
                                       END
                                       
                                       )))))
                                    
                                    
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       # define OFFSTRETCH_ATTRIBUTES ⧹
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (starttime
                                    
                                    , int, "Start Time"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (endtime
                                    
                                    , int, "End Time"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (daysoff
                                    
                                    , int, "DaysOff"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (weekendsoff
                                    
                                    , int,"WeekendsOff"), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (singlesoff
                                    
                                    , int, "Single Days off"),⧹
                                    
                                 
                                 
                                    
                                       END
                                       
                                       )))))
                                    
                                    
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       # define ONSTRETCH_ATTRIBUTES ⧹
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours12,
                                    
                                    
                                       int,
                                       
                                       "", feas_all, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       o.paidhours12+((s.starttime 
                                       <
                                       20160)? s.paidhours.value: 0),
                                    
                                    
                                 
                                 
                                    
                                    
                                       (s.starttime 
                                       <
                                       20160)? s.paidhours.value: 0
                                       
                                       ),
                                       ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Paid hours over weeks 1 and 2
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours34,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       o.paidhours34+((s.starttime >=20160)? s.paidhours.value: 0),
                                    
                                    
                                 
                                 
                                    
                                    
                                       (s.starttime >=20160)? s.paidhours.value: 0
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Paid hours over weeks 3 and 4
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (starttime,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       o.starttime, s.starttime
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (endtime,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       s.endtime, s.endtime
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (dayson,
                                    
                                    
                                       int, "odayson", feas_lbub, domi_exact,
                                    
                                    
                                 
                                 
                                    
                                    
                                       cost_lookup, o.dayson
                                       
                                       +
                                       
                                       s.dayson, s.dayson), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (morntoaft,
                                    
                                    
                                       int, "morntoaft", feas_all, domi_preferlow, cost_linear,
                                    
                                    
                                 
                                 
                                    
                                    
                                       o.morntoaft+((s.starttime-o.prevsstarttime 
                                       >
                                       1445
                                    
                                    
                                 
                                 
                                    
                                    && s.starttime-o.prevsstarttime <=1890)? 1: 0), 0
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Morning to afternoon shift changes are penalised
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (prevsstarttime,int,
                                    
                                    
                                       "", feas_all, domi_none, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       s.starttime, s.starttime
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Previous shift start time
                                    
                                    
                                 
                                 
                                    
                                       END)))))))
                                    
                                    
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       # define WORKSTRETCH_ATTRIBUTES ⧹
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours12,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none, o.paidhours12), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours34,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none, o.paidhours34), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (starttime,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none, o.starttime), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (endtime,
                                    
                                    
                                       int, "", feas_all, domi_exact, cost_none, f.endtime), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (dayson,
                                    
                                    
                                       int, "", feas_all, domi_preferlow, cost_none, o.dayson), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (daysoff,
                                    
                                    
                                       int, "wdaysoff", feas_all, domi_preferlow, cost_lookup, f.daysoff), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (singledaysoff,
                                    
                                    
                                       int, "", feas_all, domi_preferlow, cost_none, f.singlesoff), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Single days off are penalised
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (feasonoff,
                                    
                                    
                                       int, "fe", feas_lbub, domi_none, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       (int)(o.dayson 
                                       <
                                       5∣∣ !f.singlesoff)), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Some on/off patterns are not permitted
                                    
                                    
                                 
                                 
                                    
                                       END
                                       
                                       ))))))))
                                    
                                    
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       # define ROSTERLINE_ATTRIBUTES ⧹
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours12,
                                    
                                    
                                       int, "2a", feas_lbub, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       r.paidhours12
                                       
                                       +
                                       
                                       w.paidhours12, w.paidhours12), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // Paid hours in weeks 1 & 2 (and 3 & 4) have lower & upper bounds
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (paidhours34,
                                    
                                    
                                       int, "2b", feas_lbub, domi_exact, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       r.paidhours34
                                       
                                       +
                                       
                                       w.paidhours34, w.paidhours34
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (dayson,
                                    
                                    
                                       int, "4", feas_lbub, domi_preferlow, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       r.dayson
                                       
                                       +
                                       
                                       w.dayson, w.dayson
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (daysoff,
                                    
                                    
                                       int, "5", feas_lbub, domi_preferlow, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       r.daysoff
                                       
                                       +
                                       
                                       w.daysoff, w.daysoff
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (singledaysoff,
                                    
                                    
                                       int, "16", feas_lbub, domi_preferlow, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       r.singledaysoff
                                       
                                       +
                                       
                                       w.singledaysoff, w.singledaysoff
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                    
                                       // There are bounds on the number of single days off
                                    
                                    
                                 
                                 
                                    
                                       ATT(
                                       
                                       (endtime,
                                    
                                    
                                       int, "", feas_all, domi_preferlow, cost_none,
                                    
                                    
                                 
                                 
                                    
                                    
                                       w.endtime, w.endtime
                                       
                                       ), ⧹
                                    
                                 
                                 
                                    
                                       END
                                       
                                       ))))))
                                    
                                    
                                    
                                 
                              
                           
                        
                     
                  

@&#REFERENCES@&#

