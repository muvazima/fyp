@&#MAIN-TITLE@&#@Java: Bringing a richer annotation model to Java

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A finer grained annotation model for Java that supports annotations on expressions and statement blocks.


                        
                        
                           
                           An extension to the standard annotation model to support annotation׳s members of any time that can be evaluated at run-time.


                        
                        
                           
                           Several case studies included an extension of AspectJ that supports the new annotation model.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Java

Meta-data

Annotations

Reflection

@&#ABSTRACT@&#


               
               
                  The ability to annotate code and, in general, the capability to attach arbitrary meta-data to portions of a program are features that have become more and more common in programming languages.
                  Annotations in Java make it possible to attach custom, structured meta-data to declarations of classes, fields and methods. However, the mechanism has some limits: annotations can only decorate declarations and their instantiation can only be resolved statically.
                  With this work, we propose an extension to Java (named @Java) with a richer annotation model, supporting code block and expression annotations, as well as dynamically evaluated members. In other words, in our model, the granularity of annotations extends to the statement and expression level and annotations may hold the result of runtime-evaluated expressions.
                  Our extension to the Java annotation model is twofold: (i) we introduced block and expression annotations and (ii) we allow every annotation to hold dynamically evaluated values. Our implementation also provides an extended reflection API to support inspection and retrieval of our enhanced annotations.
               
            

@&#INTRODUCTION@&#

Computational reflection is the ability of a system to reason and operate on its own structure. The compiler of a reflection-capable programming language implicitly produces meta-data describing both the structure of the program itself and the structure of the objects that the program manipulates. For instance, the binary form of a Java class includes meta-data about the class it extends, the interfaces it may implement, the methods and fields it defines and the type signatures of said methods and fields. Many reflection-capable programming languages (Java since version 5 and C#) also allow the programmer to explicitly attach arbitrary meta-data to some pieces of code. Annotations in Java are one example of such kind of meta-data.

Java annotations make it possible to decorate method, field and class declarations by adding custom pieces of information that may be available at compile-time or even at run-time. Every annotation is defined in its own separate class file, where a programmer can also specify its retention policy: namely, whether it will be available at run-time or not. When they are retained at run-time, annotations are also available for inspection using the reflection API. C# allows arbitrary data to be stored in assemblies as well, using custom attributes. Similar to Java, attributes may decorate method, class, and field declarations. They are serialized into the assembly at compile-time and ignored by the runtime system, but they can still be retrieved using the platform׳s native reflection API. Both C# attributes and Java annotations show common limits:
                        
                           1.
                           They have limited granularity: While it is possible to decorate any kind of declarations with meta-data (e.g., classes and fields declarations), it is impossible to decorate a generic statement, an expression or a code block. In other words, this kind of meta-data cannot appear in the body of a method.

They accept only a strict subset of types: In particular, Java annotations can only hold values that can be resolved statically (for instance, it is not possible to assign the return value of a method call), and the only accepted types are primitive values, Strings, Classes, enums, annotations, and arrays of the preceding types.

The values that they hold must be resolvable in a static context: they cannot hold values that are only known at run-time (e.g., the result of a method call).

Many Java tools overcome the limitations of the language annotation model using non-standard, custom extensions, and employing workarounds such as stylized comments. In most of these cases, the provided annotations are often predefined and specific to a particular purpose; moreover, because the richer annotation constructs are non-standard, they are often mutually incompatible; finally, the constraints of allowing only static values or arbitrary types can only be worked around. Among the others, verification tools and defect detectors for Java (cf. JML in [1,2]) use custom annotations to specify constraints such as loop invariants, pre- and post-conditions, etc.; worst-case execution time analyzers use stylized comments for loop counts [3–5]; UML reverse-engineering tools such as eUML2
                        1
                     
                     
                        1
                        
                           http://www.soyatec.com/euml2/
                        
                      use annotations in comments to describe relations between classes and methods. There is not much literature about extending annotations with more types and support for runtime-bound values. Dynamic annotations by Noguera et al. [6] embed Groovy expressions in string attributes of plain Java annotations so that they can be evaluated at run-time. However, frameworks that make heavy use of annotations such as the AOP framework Spring, often require programmers to work around the limitation that Java annotations cannot hold runtime-bound values. Even though there is not much literature on the topic, we have found enough help requests on web forums on this subject to believe that it is a known problem, needing a solution.
                        2
                     
                     
                        2
                        cf., http://stackoverflow.com/search?q=change+annotation+runtime.
                      Many aspect frameworks are also known to suffer from the fragile pointcut problem (e.g., see [7,8]), that can be dealt with by making pointcuts more explicit, using annotations. In this case, a finer-grained annotation model, coupled with runtime-bound values would make pointcut definition easier, less tailored to the syntax of a program, and, in general, more flexible.

Our contribution is @Java, an extension to Java with a richer annotation model that (i) supports custom types and runtime-bound values in annotations, together with (ii) a finer-grained annotation model, that goes beyond the scope of methods, and allows annotations on blocks and expressions.


                     Use Case: @AspectJ. 
                        Listing 1
                        Unselectable join points in the Fibonacci computation. 
                              
                           
                        

The fragile pointcut problem is a consequence of the limitation of pattern-based pointcut languages such as AspectJ [9]. However, pointcut expressions grow in complexity as it becomes necessary to select particular code regions without affecting the others. In addition, there are some computational patterns, although simple, that cannot be captured by AspectJ at all [10]. For instance, code between two method calls, a specific invocation of some method, and code bound to statements like 
                        
                           
                              if
                           
                        
                     , 
                        
                           
                              for
                           
                        
                     , and expressions cannot be easily matched unless we resort to artificial refactorizations or very complex pointcut expressions.

In Listing 1 we are showing the Fibonacci series computation, where a couple of unselectable join points are marked with two small red circles. The first is the evaluation of a boolean expression that does not involve any method call, the second is the first invocation of the recursive method within its body. These join points could be selected if the boolean expression and the first method call were wrapped into two new methods: but these methods would serve no other function than exposing the join point, at the expense of the readability and simplicity of the code.

The coarse grain of the join point model and its dependency on the program syntax allows the capture of only those join points that relate to the application interface, like method invocations, field manipulations and exception handler execution [9], without taking into account their position or context. Thus, it is really hard to pick a particular join point among those that are associated with the same event (e.g., one particular invocation of a given method), and to select those join points that do not appear explicitly in the application interface (for instance, those that are attached to an expression or those that are found inside a loop). This often hinders a neat separation of concerns.

AspectJ supports pointcut definition through annotations. Annotations can be used to tackle the problem of pointcut fragility, by making pointcuts more explicit. In this case, the pointcut would target the annotation name instead of patterns, which makes the definition easier to express and less semantically error-prone. Yet, because of the restrictions in Java׳s annotation model, join points such as those in Listing 1 would be still unselectable.

Hereafter, we will show how to exploit @Java׳s richer annotation model to implement an extension on top of AspectJ called @AspectJ that includes finer-grained annotations and dynamically evaluated annotations that have been shown [6,11] to be extensions that help to overcome the limitations in AspectJ׳s join point model.

The rest of this paper is structured as follows: in Section 2 we describe the @Java extension with respect to Java׳s native annotation model. In Section 3 we describe the implementation of the @Java compiler. In Section 4 we present the @AspectJ extension, and we also present two other case studies to demonstrate the features of @Java in practice. In Section 6 we provide an overview of the related work and in Section 7 we draw our conclusions and describe our future work.

In this section we describe the Java annotation model and we detail the features that the @Java extension provides. The model that we presented here builds upon the previous work in [12].


                     Annotations in Java. Almost since its introduction, the Java platform has always supported some form of meta-data to describe internal data structures and to direct the behavior of the virtual machine and of the compiler. For instance, modifiers such as 
                        
                     , 
                        
                      in Java code, instruct the compiler to treat some values in a special way; similarly, the interfaces Serializable and Clone are often called marker interfaces, because they do not declare any methods and they just tag a class with a specific property. 
                        Listing 2
                        Java annotations. 
                              
                           
                        

Since Java 5, the platform provides a general purpose and customizable annotation mechanism (also known as meta-data facility) that allows the programmer to define and use annotation types. The facility consists of a syntactic mechanism to declare annotations, annotate declarations, APIs to retrieve such annotations, along with an internal binary representation to represent them in class files. Annotations are defined using a special 
                        
                      type. The definition of an annotation type is similar to an interface declaration. Listing 2 shows how to create and use an annotation type in Java. Annotations can be markers, single-valued, or multi-valued. Annotation types with no members or that provide default values for all members may be used as marker annotations. Single-valued annotations expect one parameter, multi-valued one or more named parameters.

The Annotation class also provides meta-annotation types that describe properties of a new annotation type, and that are used to actually annotate other annotations. Among the others, @Target specifies which elements of a program can be annotated by the annotation that is being defined, and @Retention instructs the compiler whether the annotation should be made available in the class file, possibly for run-time consumption. The Java core reflection API provides methods to dynamically retrieve annotations that have a run-time retention policy. The classes Method, Field and Class all implement the AnnotatedElement interface that includes methods to access the associated annotations (if any). For instance, isAnnotationPresent(A.class) returns true when @A decorates the target element, and getAnnotations() returns an array of all the annotations decorating a given element. The following code snippet shows how the getAnnotation() API can be used to retrieve the A annotation associated with a given class. 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

In short, annotations in a Java program play the role of user-defined parameterized keywords, describing properties of a particular piece of code. These properties can be exploited to direct the compilation process, or even describe run-time-specific properties. For instance, in the case of AOP, annotations may be employed to mark specific code sections that need advising.

The main limit in Java׳s current annotation model is that annotations can only be attached to element declarations—e.g., method and field declarations—but they cannot decorate a specific code section or an expression. Moreover, they can only be resolved statically: it is not possible to assign the return value of a method call, or the value of a field, unless it is defined 
                        
                     , and the only allowed values that can be assigned are primitive values, Strings, Classes, enums, annotations, and arrays of the preceding types. 
                        Listing 3
                        
                           Foo.java 
                           
                              
                           
                        


                     @Java in a nutshell. The @Java language is a natural extension to Java that supports a richer annotation model, where assignment of runtime-computed values is supported, and even blocks and expressions can be annotated. These richer annotation types are defined following the familiar, native Java syntax, with only a few extensions.

In @Java, annotation may hold values of any Java type, and members can be dynamically evaluated; that is, they can refer non-constant values that are only known at runtime. We call annotations that use this feature Dynamically Evaluated Annotations (DEAs). DEAs extend seamlessly the native Java model, without requiring any additional hints to the compiler. The @Java compiler detects occurrences of extended types in annotations (that is, types that are not native to Java׳s annotation model), and it works behind the scenes to make the usage of these custom types as seamless as possible. Thus, DEAs in @Java code look and feel mostly identical to Java annotations; but, because they support non-
                        
                      values, DEAs, as opposed to traditional annotations, are evaluated dynamically at run-time (hence, the name). For instance, Listing 4 shows the 
                        
                      annotation that takes a 
                        
                      instance as its 
                        
                     .


                     Block and expression annotations are an extension to the native Java annotation model to support finer-grained meta-data injection in code. Block annotations (see Listing 3) can be used to decorate a statement or a sequence of statements. Syntactically, an annotated block is a Java block (a sequence of zero or more statements, enclosed within braces) preceded by an annotation. Block annotations may also be nested. Annotated expressions are Java expressions that have been surrounded by braces, and are preceded by an annotation (see Listing 3). The main difference between a block annotation and an expression annotation is that the expression annotation evaluates to a result (simply put, it can be assigned to a variable). Annotated expressions can be nested as well. On the other hand, consistently with Java blocks, an annotated block groups a sequence of zero or more statements, and it does not evaluate to a result, in the sense that a block can never be assigned to a variable. Listing 4 shows an example of annotated code that uses both block (@Trace) and traditional (@Author) annotations with DEAs. 
                        Listing 4
                        Example usage for block and dynamically evaluated annotations. 
                              
                           
                        

Java 5 provides the reflective API to inspect method, class or field declarations for the presence of an annotation. Likewise, the @Java language comes with an extended reflection API to inspect DEAs and look for annotated blocks and expressions inside method bodies. This extension is meant to fit seamlessly within Java׳s annotation model, and it therefore abides to the rules that the native annotation model (directly or indirectly) imposes.


                        Dynamically evaluated annotations. The introduction of DEAs poses some interesting questions. For instance, one problem with DEAs is when they should be evaluated. In the case of block and expressions, it makes sense to evaluate them during program execution. In particular, our choice was to evaluate the contents of the annotation after the code that it contains has executed. In every other case, DEAs annotate declarations, just like their native Java counterparts. The choice here was to lazily calculate their value only when they are inspected using reflection.

DEAs may contain references to class fields, results of method invocations, constructors, and in general, valid Java expressions. Block and expression annotations are also allowed to refer local variables. The value held by the annotation assumes the value that is being passed. For instance, the annotation @Trace in Listing 4 would contain the number of times (hits) the body of the while loop has been actually executed. This information may be extracted a posteriori using reflection. The @Author annotation in the same listing decorates the class with rich data about the author that is retrieved from an external source. DEAs can be retrieved using an extended API. In the introduction we showed that a common problem for programmers using frameworks that make extensive use of annotations is to be able to assign updatable values to their annotations. It is easy to see that DEAs are able to hold stateful object instances that can be updated at run-time. 
                           Listing 5
                           Example usage of the extended reflection API for DEAs. 
                                 
                              
                           


                        Block and expression annotations. Expression and block annotations are represented by subclasses of Annotation. Since these annotations occur in the body of a method, they can be retrieved by interrogating a Method object (that is, the reification of a method that the reflection API returns). However, by the same reasoning, block and expression annotations may occur in constructors, and expression annotations may occur in the initialization expression of a field.

The implementation of the Method, Constructor and Field classes is then augmented by adding specific methods to deal with annotated expressions (see Table 1
                         for a short summary). For instance, the method getExpressionAnnotations() returns an array of all the expression annotations. Moreover, Method and Constructor also include methods related to block annotations. For instance, if m is a Method instance, then m.getBlockAnnotations() returns an array of all the block annotations in the body of that method. In Listing 6, we are retrieving an array of every block annotation Block occurring in Listing 3. In this particular case, there is only one annotation of that type, but the method returns an array because multiple occurrences are possible in principle. 
                           Listing 6
                           Using the extended reflection API. 
                                 
                              
                           

There are also methods to access the bytecode and source code representation of an annotated construct. For instance, getAnnotatedBlocks() returns an array of AnnotatedBlock instances. This class provides the programmer with additional methods to inspect the annotated code block. For instance it is possible to iterate over the bytecode and over the lines of the source code, and there are methods that describe the offset in the file where the block begins (see Table 2
                        ). Similar operations are available for expression annotations (e.g., getAnnotatedExpressions()).

@Java׳s reflection API does not allow the programmer to perform further manipulations on the annotated code, since it is limited to introspection operations, like Java׳s native reflection library. The so-called intercession, that is, reflective alteration of the behavior of a program, can be realized by way of third-party tools such as Javassist [13] and BCEL 
                        [14] to perform source code or bytecode manipulation. An example is shown in Listing 7. 
                           Listing 7
                           Extruding a code block using BCEL. 
                                 
                              
                           

@&#IMPLEMENTATION@&#

@Java bytecode is compatible with standard Java bytecode and does not require a custom virtual machine to execute. This way, performance-wise, the generated bytecode is comparable to code without annotations; a small performance hit can be noticed using DEAs, but it is mostly related to the computation of the dynamic values, which is to be expected (for a more detailed evaluation, see Section 5). Compilation through the atjavac tool is performed in three phases. In the first phase, atjavac behaves like a source-to-source translator from @Java׳s extended syntax to a Java-compatible intermediate representation. In the second phase, the standard javac compiler is invoked over the translated files. In the third phase, the atjavac executable strips out the intermediate representation of @Java׳s annotations, and replaces them with custom attributes in the bytecode.
                        3
                     
                     
                        3
                        Recall that custom attributes are allowed in Java bytecode [15].
                      Although DEAs are orthogonal to block and expression annotations, the compilation process for the former requires a bit more machinery than for the other two, and therefore we deem easier for the reader to first understand the compilation process for block and expression annotations. We will then proceed to describe DEAs as well.

In the first phase @Java block and expression annotations are translated into regular Java syntax, so that the input files can be compiled using javac (see Listings 3 and 8). 
                           Listing 8
                           
                              Foo.java (Listing 3) as translated by atjavac. 
                                 
                              
                           

The begin and end of annotated blocks and expressions are marked using special placeholder method calls. This way, atjavac will be able to find the annotated blocks and expression, even in the compiled class file. Their string arguments are defined in such a way that they are both unique and easily identifiable in the compiled code. They encode information about the position in the source code of the annotated block: an internal numeric identifier, row and column of the beginning of the block, row and column of the end of the block, the nesting level of the block annotation; the last part is the string representation of the block annotation. In particular, a block is surrounded by two method invocations, while an expression is passed as the argument of an internal method which simply returns the result of the evaluated expression. In both cases, these methods act only as dummy placeholders; they will be removed in the third phase. Notice that in @Java we cannot annotate blocks that contain 
                           
                         or 
                           
                         statements, or other statements that would cause the execution flow to escape from the annotated block; similarly, these statements are admissible in an annotated block when their target is in the block as well (e.g. a surrounding loop statement). This is because annotated blocks are supposed to be self-contained execution units.

@Java annotations are also transformed into method annotations for dummy, machine-created, empty methods: this is needed to delegate to javac the verification and compilation into bytecode of the annotation. Dummy methods have always the form BA_n_r_c or EA_n_r_c, where BA and EA stand for block and expression annotation respectively, n is a numeric identifier for the block or expression annotation, r and c are the line and column numbers at which the annotated block or expression begins. These methods will be completely stripped out in the third phase. The annotations will be transformed into custom bytecode attributes.


                        
                           Listing 9
                           
                              Trace.java as translated by atjavac. 
                                 
                              
                           

Similar to block and expression annotations, even DEAs have to be simulated by mapping them onto native Java constructs. In this case, the atjavac tool generates a companion class that holds the dynamic values. For instance, consider Listing 4. The 
                           
                         annotation holds the value of a local variable, and is therefore only known at run-time. The companion class is automatically generated, it is inserted as an inner class inside the code of the class containing the DEA, and it is annotated with a special internal meta-annotation (
                           
                        ). For instance, in Listing 9 the usage of 
                           
                         block annotation causes the atjavac tool to generate the inner class 
                           
                        . The tool marks this inner class as a companion class using the 
                           
                         annotation holding a unique identifier; for instance, in this case, the unique identifier is “
                           
                        ”, where 0 indicates the annotation in this class, 
                           
                         tells the compiler that it annotates a block, and 4 and 6 are respectively the row and column at which the annotation is found. This companion class contains one field for each dynamically evaluated value in 
                           
                        . In this case, there is only one field, 
                           
                        . A companion class instance is finally automatically inserted in a private field. In this case, the 
                           
                         class is instanced and assigned to the private field 
                           
                         (the “
                           
                        ” prefix stands for “instance”). The name for this class and its instance are automatically generated (the numeric index is automatically incremented for each DEA that is found in the code). When the user requests a value attached to a DEA using the API call described in Section 2.1, it is automatically resolved to the value that is held by the companion object instance.
                           4
                        
                        
                           4
                           There are a number of special cases, but we will not describe these technical details as we deemed them to be of little interest for the reader.
                         In order to avoid an explosion in the number of companion classes, some additional steps are taken; for instance, when several annotations of the same type occur in the same file, only one companion class is generated. For the sake of brevity, we will not discuss the details of these optimizations. In the case of an expression annotation, the process is similar but the call to the dummy method 
                           
                         shown in Listing 3 is substituted with the method 
                           
                        . The additional argument (1) identifies the expression annotation as dynamic, and (2) it is a 
                           
                        , so that the method can be passed as many assignments as there are dynamic values. In Listing 10 we show a small example just to help the reader understand the idea. It is easy to see that DEAs in expressions require more string identifiers (about twice as much as non-dynamic expression annotations). 
                           Listing 10
                           How expression annotations with DEAs gets translated by atjavac. 
                                 
                              
                           

From a syntactic point of view, the differences between Java and @Java are minimal. The implementation of the @Java parser was therefore really simple and straightforward. We have extended the Java grammar to support our extended syntax and we generated the parser using JavaCC.
                           5
                        
                        
                           5
                           See at javacc.java.net.
                         As shown in Listing 11, the required changes to the input grammar are really few. Semantic actions associated to the productions take care of the transformations described above. We will not further describe the process, since it is nothing more than a simple application of the syntax-directed translation technique. 
                           Listing 11
                           Extensions to Java׳s Grammar. 
                                 
                              
                           

The productions in Listing 11 extend the Java parser to support code blocks and expression annotations. As you can see, an annotated block or expression is delimited by extra braces, as described in Section 2. Notice how the change influences the grammar: annotations in Java can only decorate declarations, while @Java annotations can decorate statement and expressions as well. The grammar has to be altered to support DEAs as well: in fact, now annotations can be assigned any valid Java expression; Java׳s original grammar is limited even syntactically to constant values or static final members.

In the third phase, dummy method definitions and placeholder method invocations are stripped out.
                           6
                        
                        
                           6
                           These methods can optionally be retained by passing a flag to 
                                 
                              .
                         Placeholder method invocations have the sole purpose of making it easy for atjavac׳s bytecode postprocessor to locate the begin and the end of an annotated expression or block. These method calls hold data that the original corresponding expression or block annotations held. In this phase, the postprocessor collects position information and meta-data and stores all of them inside custom bytecode attributes. For instance, two of these custom attributes are RuntimeVisibleBlockAnnotations and RuntimeVisibleExpressionAnnotations. These attributes of the bytecode item methods, keep track of any block or expression annotation (respectively) occurring in a method or in a constructor. Since unrecognized attributes are simply ignored by any standard-compliant Java virtual machine, an @Java class file can be interpreted by any standard JVM implementation.

In this section we show some example usage of the @Java extension. We will describe the implementation of the @AspectJ use case that we presented in the introduction, with the help of an example (parallelization of a loop using annotations). We will also show two further use cases. The first will employ annotations for co-evolution of code models, and the second presents another tool implemented on top of the @Java toolset: the 
                        
                      tool for reverse-engineering of UML models using annotations in code.

The AspectJ language for AOP in Java supports using annotations to express pointcuts. Annotations make pointcut expressions less fragile to code changes and easier to understand. However, these pointcuts still have to obey to the limitations of the underlying annotation mechanism, such as, for instance, its granularity. In this example we are introducing 
                           @
                           AspectJ
                        , an extension to AspectJ similar to the one envisioned by Eaddy and Aho [11], that targets a Java language extension where block and expression annotations are allowed. In this example we will use block and expression annotations in @Java to implement the @AspectJ extension.
                           7
                        
                        
                           7
                           The @AspectJ prototype can be found at http://cazzola.di.unimi.it/ataspectj.html.
                         In particular, we will show how expression and block annotations can be employed to capture local values and modify them at run-time, and how to use the extended reflection API described in Section 2.1 to perform bytecode manipulation on annotated code.

The AspectJ grammar is extended with two new primitive pointcuts to hook into annotated expressions and blocks. The syntax is very simple: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        where @X1 is an expression annotation and @InParallel is a block annotation.

The extensions to AspectJ can exploit @Java׳s translation mechanism. For instance, the @expr pointcut expression can be easily translated to a call() pointcut expression that targets the dummy method calls described in Listing 8. These method calls are usually cleaned up by 
                           
                         during the last phase of compilation, but it is possible to retain them using a compilation flag (Section 3). The @block pointcut expression requires a bit more work. One strategy is to extrude the annotated block to a new method, so that it can be captured using a primitive pointcut expression. Even though this operation is less trivial than the case of @expr, @Java provides the tools to perform the operation. In Section 2.1 we showed how to use BCEL to extrude a code block (Listing 7). For an in-depth description of the problem see [16]. 
                           Listing 12
                           Mandelbrot computation, with @InParallel. 
                                 
                              
                           


                        Example: Parallelization of a serial loop. We propose again here a shortened version of the example in [16] to parallelize a loop using annotations and @AspectJ. Listing 12 shows a typical Mandelbrot computation that has been decorated with several new annotations. In particular, there is one block annotation 
                        @InParallel(grid) and several expression annotations: @X1, @X2, @Y1, @Y2, @Width, @Height. Remembering that the y-coordinate on a screen increases from top to bottom, then the idea is that the point at coordinates 
                           (
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           )
                         moves from the upper-left corner of the canvas 
                           (
                           0
                           ,
                           0
                           )
                         to the point at coordinates 
                           (
                           
                              
                                 X
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           )
                        , which is the lower-right corner of the canvas. 
                           
                         and 
                           
                         are self-explanatory. Using expression annotations and @AspectJ, it is possible to hook the annotated values and alter them to compute non-overlapping regions of the pictures in parallel. The 
                           
                         block annotation will mark the code section that should be parallelized, and the number of threads over which the computation should span. Using DEAs, it is even possible to get the 
                           
                         parameter from a field, a local variable or a configuration singleton, so that the number of threads can be configured without recompiling from the source, e.g.: 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        
                     

In particular, if multi-threading is enabled, a width×height canvas can be divided into M=grid×grid smaller non-overlapping w×h rectangles, where w=width/M and h=height/M. Then the program can spawn M separate threads that will work on a single rectangle each.

Loop variables in Listing 12 compute a rectangle width×height. The rectangle׳s upper left vertex is at the coordinates 
                           (
                           0
                           ,
                           0
                           )
                        . Thus, the loop variables i and j in Listing 12 vary as follows: 
                           
                              
                                 
                                    
                                       X
                                    
                                    
                                       1
                                    
                                 
                                 ≤
                                 
                                    i
                                 
                                 <
                                 
                                    
                                       X
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       1
                                    
                                 
                                 ≤
                                 
                                    j
                                 
                                 <
                                 
                                    
                                       Y
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        with 
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                           =
                           0
                        , 
                           
                              
                                 X
                              
                              
                                 2
                              
                           
                           =
                           
                              width
                           
                        , 
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           =
                           0
                        , 
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           =
                           
                              height
                           
                        . Now, if the computation of the big rectangle gets divided into M computations of smaller rectangles, and R
                        
                           N
                         is the N-th rectangle, with 
                           0
                           ≤
                           
                              N
                           
                           <
                           
                              M
                           
                        , then 
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 X
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                         for R
                        
                           N
                         can be defined as follows:
                           
                              (1)
                              
                                 
                                    
                                       X
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    N
                                 
                                 /
                                 
                                    grid
                                 
                                 ×
                                 w
                                 ,
                                 
                                 
                                    
                                       X
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       X
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 w
                                 ,
                                 
                                    
                                       Y
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    N
                                 
                                 
                                 mod
                                 
                                 
                                    grid
                                 
                                 ×
                                 h
                                 ,
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       Y
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 h
                                 .
                              
                           
                        
                        
                           Listing 13
                           Parallelizing aspect. 
                                 
                              
                           

The annotated expressions of Listing 12 serve two purposes: storing some special values, and rewrite the result of some expressions. In particular, @Width, @Height decorate the width and height values, so that the aspect can store them in two fields, for later use (see Listing 13). The other expression annotations @X1, @X2, @Y1 and @Y2, decorate values that should be recomputed. In fact, as we said above, the loop conditions and constraints must be adapted to work on smaller rectangles.

The pointcut @block(InParallel) has been bound to an around advice. The advice computes the size of the grid by first inspecting the annotated block using Java׳s reflection API and computing the square of the grid value. Finally, for each rectangle, a new thread is spawned. The coordinates X
                        1, X
                        2, Y
                        1, and Y
                        2 are pre-computed as in Eq. (1), and represented as fields of a Rectangle object. The Rectangle is an abstract class which extends Thread and leaves run() undefined. When a new thread is spawned, run() is defined in place so that it can invoke the proceed() special method of AspectJ. In this context, the method executes the code in the annotated block. The expressions annotated with @X1, @X2, @Y1, and @Y1 can be then hooked to actually return a recomputed value, based on the thread that performs the computation. The result has been implemented in a simple Swing application.
                           8
                        
                        
                           8
                           For a video demo see: http://cazzola.di.unimi.it/video/Mandelbrot.mp4.
                         
                        
                           Listing 14
                           Movie rental example in [17]. 
                                 
                              
                           

In general, design models should always be up-to-date and consistent with the code they are supposed to represent. However, as software systems grow, it is not uncommon that updating the initial design documents becomes less and less of a priority. In the rest of the section we will show how annotations in code make it possible to bind code to a model, to simplify what is known as model co-evolution.

In Listing 14 we have represented the example that Fowler describes in his book ([17, Chapter 1]) of a movie rental system. The UML activity diagram has been overlaid to the related code. In this version, the amount of money the customers should be charged with when they rent some movies is calculated within the statement() method of the Customer class. However, the calculation is logically related to the rental transaction, and its code would be better extruded to a new method. Unfortunately, once the change has been carried out, the model becomes outdated. The code represented by the sequence of activities: 
                           
                              
                                 Get
                                 
                                 Movie
                                 →
                                 Get
                                 
                                 Price
                                 
                                 Code
                                 →
                                 Get
                                 
                                 Charges
                              
                           
                        would better be factored out to a new method getCharge() of the Rental class.

Obviously, the old code section has to be replaced with an invocation to the new method (see Listing 15). But once the change has been carried out, our problem becomes that the old activity diagram does not model the code anymore, and it needs updating. Using @Java block annotations, it is possible to annotate the new call to getCharge() in statement(). The annotation (@ExtractMethodTrail(first, last)) indicates that every UML activity between Get Movie (first parameter) and Get Charges (last parameter) has been moved to getCharge(). Then, getCharge() can be decorated with a method annotation to indicate that it is the result of a refactoring operation. 
                           Listing 15
                           Movie rental of Listing 14 refactored. 
                                 
                              
                           

In Listing 15, the @MoveMethod(sourceClassName) annotation indicates that the code of getCharge() previously occurred in another class, and @ExtractMethod indicates that the method has been factored out from the body of another method. When the source files will be compiled, they will contain metadata that describes the refactoring action; a tool can then exploit the annotations to update the models. For instance, if the UML diagram overlaid to Listing 14 was represented using the XMI standard, then a program could walk the XML DOM and update it using the information contained in the refactored classes. The problem of model and code co-evolution by using annotations has been deeply explored in [18], where the whole set of Fowler׳s refactoring patterns [17] has been considered.

According to Chikofsky and Cross׳ Taxonomy [19], reverse engineering is “process of analyzing a subject system to (i) identify the system׳s components and their interrelationships and (ii) create representations of the system in another form or at a higher level of abstraction.” The 
                           
                         tool [18,20–22] reverse-engineers UML diagrams from @Java code. In this example we will see that this tool uses the richer annotations provided by @Java to decorate blocks and expressions, and even runtime-evaluated expressions (using DEAs). The extended reflection API (Section 2.1) together with BCEL is used to instrument code to follow execution traces and draw diagrams that depend on code execution (for instance, UML activity diagrams). 
                           
                         is (i) a suite of @Java annotations to decorate code with structural information that is needed to generate a model automatically, (ii) an automated tool that generates the UML diagram from code, statically or, if needed, dynamically. The suite includes specialized annotation types for several kinds of UML diagrams, including class diagrams, activity diagrams, state diagrams, object diagrams, and sequence diagrams. For instance, Listing 16 annotates a code snippet using 
                           
                        , 
                           
                        , and 
                           
                        . 
                           
                         instruments the code; executing the program several times with different inputs makes it possible to automatically extract an activity diagram, shown in Fig. 1
                        . The 
                           
                         approach helps bridging the model/implementation gap [23]; block annotations can be used to group together statements that can be represented as a single call action in the model, thereby abstracting away irrelevant implementation details. 
                           Listing 16
                           Simple annotated code for an activity diagram. 
                                 
                              
                           

The suite of annotations for sequence diagrams includes the 
                           
                         annotation that annotates a block of code representing a message between two instances. The annotation requires two values: the name of the message, as a string, and an array of Class objects. 
                           
                              
                                 
                                    
                                       
                                    
                                 
                              
                           
                        The result for this simple snippet is shown in Fig. 2
                        . 
                           Listing 17
                           Dynamic annotations for object diagrams. 
                                 
                              
                           

In fact, sequence and object diagrams are particularly interesting because they depend on an execution trace. Thus, they require more information to be reverse-engineered, beside what it is possible to obtain via static analysis. In this case 
                           
                         instruments code using BCEL to add specific API calls in the places marked by the annotations. When the code gets executed, the trace is recorded to generate the corresponding diagram. In Listing 17 we show some example code for a class School that may have several ClassRooms, Teachers and Courses. A Course relates a Teacher instance to a ClassRoom instance. @Relation annotates an assignment or the 
                           
                         method of a list. When the user instantiates a school, 
                           
                         can follow the execution trace and generate its object diagram. For instance, the execution of the code in Listing 18 tracks down the object diagram in Fig. 3
                        . Notice how dynamically evaluated annotations (see Sections 2.1 and 3.2) are used in this case to track a particular object instance. The instance can be then retrieved by 
                           
                         for further inspection; for instance, a Teacher instance can be inspected using reflection to get the name of that particular teacher. 
                           Listing 18
                           Dynamic annotations for object diagrams. 
                                 
                              
                           

@&#EVALUATION@&#

In our tests, @Java only had a small impact on execution performances. This is not surprising given that custom attributes are ignored by any compliant JVM, and that dummy method calls are usually stripped out automatically by 
                        
                      (Section 3.4). We will show that, once loaded, execution times are comparable to regular non-annotated classes. On the other hand, load times do increase; but this is to be expected, since @Java׳s richer annotation model requires to store more attributes in the bytecode, and DEAs even require to load the inner classes that hold runtime-evaluated values (Section 3.4). Dynamic annotations have a bigger impact on performances because of the additional overhead that is necessary to calculate and store dynamic values (Section 3). This additional overhead obviously does not only affect load times, but also program execution, because the dynamic evaluation might be performed at run-time: in particular, this happens with block and expression annotations, because they are in the body of a method. However, in this case, the performance hit is comparable to executing the piece of code in the DEA as if it were part of a regular program. Again, this is not unexpected, but it is a consequence of how this piece of code gets translated by 
                        
                      (Section 3.3). In the case of a DEA on a declaration (for instance on a method or on a class) the evaluation would only occur at the moment of retrieval using the reflective API.

The tests that we show here should not be intended as exhaustive, but only as a mere example of the performance hit due to the use of finer-grained and dynamically evaluated annotations in Java code. The tests were performed on an Intel(R) CORE(TM)2 Duo CPU T5450 @ 1.66GHz using Java HotSpot(TM) Client VM (build 1.5.0_13-b05, mixed mode),
                        9
                     
                     
                        9
                        However @Java reportedly works as expected on Java 6.
                      with option -Xint.


                     Table 3
                      shows three test suites. Each test was executed 10,000 times and the result in the tables are average values. The first row (experiment 1) shows a comparison of the execution times between a simple class with no annotations and the same class annotated using @Java block and expression annotations. The simple test consisted in annotating in different ways the body of the following 
                        
                      loop: 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

In the first column we see the execution time without any annotation; the second execution time corresponds to annotating the whole statement with the annotation 
                        
                     , the third execution time corresponds to annotating only the increment expression. We can say that the difference in this case is unappreciable. The second row (experiment 2) shows the measurements achieved by repeating the experiment with an extra call to 
                        
                     . The three columns show the execution time without any annotation but with the call to 
                        
                      in the loop body, the execution time when decorating the statement in the loop body with the annotation 
                        
                      and the execution time when using the same annotation to decorate only the increment expression (i.e., in an expression annotation). Notice that the method call has been moved from the loop to the annotation. We can see from the table that using DEAs leads to a performance hit, but the values are all comparable. Again, this is not surprising, since the method invocation is still performed during the loop execution. The third row (experiment 3) shows a similar test, but instead of a simple static method call, the test consisted in cloning an object with six fields. Similar to the previous test, first we timed the execution of the same loop, this time with object cloning instead of the static method invocation of the previous test. Then we moved this method call to the value of an annotation 
                        
                      (with value being of course of 
                        
                      type), first used as a block annotation, and then an expression annotation, decorating the increment expression. Here the differences are even smaller. The last row (experiment 4) shows different timing for class loading, when the class contains DEAs. For this example we repeated 300 times the smallest bytecode instruction (
                        
                     , corresponding to the assignment 
                        
                      when 
                        
                      is 
                        
                     ). And decorated it differently (whole block, only the assigned value), with the annotation 
                        
                     ). Load times show a large increment because of the additional statements (the method call), but also because of the overhead that DEAs impose (companion objects, and so on). In conclusion, using block and expression annotations does not introduce significant penalties on the execution time and due to how these annotations are implemented (i.e., they are translated into traditional annotations and extra code is stripped out); these penalties are independent from the number of annotations that occur in the code; the loading time is – unsurprisingly – affected by the number of annotations that are introduced in the code. On the other hand, DEAs have an obvious impact on performance, because they require their arguments to be evaluated at runtime; this performance hit depends on the number of dynamically evaluated values that they are holding.


                     Table 4
                      shows a breakdown of the file sizes. In the first column, the load times are file sizes for a class that does not sport any annotation; in the second and third columns the file has been decorated with block and expression with DEAs respectively. Because of the way expression annotations are recognized inside bytecode by 
                        
                      (identifier strings) many string values are added to constant pool: expression annotation uses about twice as much entries as block annotations (Section 3.1). The BCEL framework that we employ to instrument and modify bytecode does not allow the programmer to remove entries from the constant pool, but only to modify their values. Thus, every dummy string that occurs in the @Java class cannot be deleted but it is just blanked. The result is that the file size does increase, but with a gentler curve (empty strings take only 3 bytes of space). In our experience, with respect to the case studies, the number of annotations in a class tends to be low (between 10 and 20); therefore, we believe that the file size would not increase by a big factor even in real-world cases.

@&#RELATED WORK@&#

As we saw in the introduction, many processing tools employ custom annotation models to describe code properties that can be exploited in many ways. Whenever it is possible, most of these tools stick to Java׳s native annotation model. When a higher level of granularity is required, the limits of the native model are usually worked around by employing some form of custom stylized comment, such as the one in XDoclet [24]. There is a Java community effort that goes in the direction of standardizing annotations in defect detection tools (JSR 305
                        10
                     
                     
                        10
                        
                           http://jcp.org/en/jsr/detail?id=305.
                     ), but it is limited to standard Java annotations. Block and statement annotations have been considered for inclusion in the JSR 308 proposal
                        11
                     
                     
                        11
                        
                           http://jcp.org/en/jsr/detail?id=308.
                      for a while, but despite their undoubted usefulness, they were finally dropped for lack of time. The proposal in its current state (September 2012, draft 2) focuses on supporting type annotations, so that it is possible to annotate any occurrence of a type. In particular, one application for type annotations is
                     type qualifiers such as @NonNull or @ReadOnly. For instance 
                        
                           List<@NonNull
                           
                           String>
                           myList
                        
                      declares a list of String object myList that must never contain null instances. Type qualifiers could be then complemented with compiler plugins to check their semantics. Java׳s reflection API is extended to support this new kind of annotation, but introspection is still limited to fields, methods and class declarations. Clearly, even without considering dynamically evaluated annotations, type annotations go in a direction that is only slightly related to the purpose of @Java.

Eaddy and Aho [11] provide a compelling example for statement and block-level annotations: they make it possible to achieve a finer-grained level of control on join point selection in AspectJ-like AOP frameworks. We showed an example for this in Section 4. Using statement annotations it is possible to inject the cross-cutting behavior at specific locations in the source code (e.g., logging). Moreover, statement annotations can be exploited to advise specific object instances and local variables. However, on the contrary of our work, the article only describes the benefits the extension would introduce, and it does not provide with a description of an actual implementation and dynamically evaluated annotations are not considered as well.

The work by Noguera et al. [6] introduces a concept of dynamic annotations, but limited to the scope of aspect-oriented programming. The idea is that annotations may contain boolean expressions represented as strings of Groovy code that would be evaluated at run-time. When these expressions evaluate to true, the annotation is considered activated. For instance consider one class Person with one field age; then the annotation 
                        
                           @Baby("target.age
                           <=1")
                        
                      would be activated only when the Person is at most 1 year old. An aspect would then match the annotation @Baby only for all those instances whose boolean expression evaluates to true. This kind of annotation permits us to evaluate particular dynamic conditions at run-time, but they have limited applicability. Finer-grained annotations are not considered in this work.

@Java is similar in principle to our previous work with [a]C# [25], an extension to C# that supports block annotations. In this work we showed how to parallelize a serial loop as we described for @Java in Section 4 and the annotated source code block was manipulated and extruded. However, [a]C# implemented a pure source-to-source translator. Annotations are not retained in the .NET bytecode representation, and therefore no reflective computation is possible. @Java has been inspired by this work and builds upon its foundations: in fact, as seen in Section 2 the reflective API makes available the annotated code in both source and bytecode form for manipulation. In particular, in Section 4, we describe how the bytecode can be transformed using BCEL. Neither expression annotations nor DEAs are supported in [a]C#.

@&#CONCLUSIONS AND FUTURE WORK@&#

Many code processing tools define their own annotation models, especially when a finer-grained annotation model is required, since Java׳s annotation model limits to field, method and class declarations. In this paper we have presented @Java, an extension to the Java language with a richer annotation model supporting custom types and dynamically evaluated members, as well as support for annotating at a finer-grained level (block and expressions). @Java has been developed to feel as much of a natural extension as possible. Block and expression annotations are declared just like any other regular Java annotation whereas DEAs are smoothly integrated to the traditional annotation syntax. The extended reflection API follows the standard, implicit or explicit conventions in Java׳s own native reflective API.

@Java does not provide a predefined set of annotations, but provides the tools that are necessary to build around them a complete framework. @Java׳s APIs allow us to manipulate the annotated source code and bytecode to perform operations such as extrusion, removal and injection of code.

@Java׳s compiler is still in its early stage. The compiler runs on top of the standard javac tool, and therefore it must first translate custom annotations to a backward-compatible form. A future effort may involve developing patches for the Java virtual machine and compiler to support the @Java richer annotation model. The reflective library may evolve, for instance by providing built-in code manipulation APIs without requiring external libraries.

We are also developing tools on top of @Java. As we saw in Section 4, the @Java richer annotation model can be employed to reverse engineer UML diagrams starting from code, or co-evolve code with its model. Moreover, we also employed it to provide a finer-grained join point selection mechanism in an AspectJ-like AOP framework that we called @AspectJ.

A prototype of @Java can be found at the URL http://cazzola.di.unimi.it/atjava.html.

@&#REFERENCES@&#

