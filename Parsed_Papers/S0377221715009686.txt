@&#MAIN-TITLE@&#A new group ranking approach for ordinal preferences based on group maximum consensus sequences

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A total ranking list involving group consensus preferences is achieved.


                        
                        
                           
                           A group consensus mining approach is proposed without candidate generation.


                        
                        
                           
                           An optimization model involving maximum consensus sequences is developed.


                        
                        
                           
                           Flexibility is provided in solving ranking problems using different input formats.


                        
                        
                           
                           Minimum consensus levels and maximum disagreement levels are adjustable.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Group decisions and negotiations

Data mining

Group consensus

Optimization model

@&#ABSTRACT@&#


               
               
                  Group ranking problems involve aggregating individual rankings to generate group ranking which represents consolidated group preference. Group ranking problems are commonly applied in real-world decision-making problems; however, supporting a group decision-making process is difficult due to the existence of multiple decision-makers, each with his/her own opinions. Hence, determining how to best aid the group ranking process is an important consideration. This study aims to determine a total ranking list which meets group consensus preferences for group ranking problems. A new group consensus mining approach based on the concept of tournament matrices and directed graphs is first developed; an optimization model involving maximum consensus sequences is then constructed to achieve a total ranking list. Compared to previous methods, the proposed approach can generate a total ranking list involving group consensus preferences. It can also determine maximum consensus sequences without the need for tedious candidate generation processes, while also providing flexibility in solving ranking problems using different input preferences that vary in format and completeness. In addition, consensus levels are adjustable.
               
            

@&#INTRODUCTION@&#

Group ranking problems involve aggregating individual rankings to generate group ranking which represents consolidated group preferences. Group ranking problems are commonly applied in decisions involving real world problems, such as ranking proposals from several reviewers (Cook, Golany, Penn, & Raviv, 2007), rank aggregation on the web (Beg & Ahmad, 2003) and ranking of advertising models based on customer surveys (Chen, Cheng, & Huang, 2013). However, supporting a group decision-making process is intensely difficult due to the existence of multiple decision-makers, each with his/her own perceptions about the way a decision should be made (Matsatsinis, Grigoroudis, & Samaras, 2005; Morais & Almeida, 2012). Therefore, in recent decades, determining how to best support the group ranking process has remained an important challenge.

There are various types of group ranking problems. According to Chen et al. (2013), group ranking problems can be classified according to the format of input preferences, as well as the completeness of input and output preferences. Users express input preferences in three major formats: weighting models, ranking lists (Chen & Cheng, 2009) and pairwise comparisons. The completeness of user-specified preferences can be divided into two types: total ranking preference and partial ranking preference (where only a subset of items is evaluated) (Chen & Cheng, 2010). The completeness of the final output results can be classified as constituting a total ranking list (Cook et al., 2007; Ma, 2010) or maximum consensus sequences (Chen & Cheng, 2009). A maximum consensus sequence is the longest ranking list of items that the majority agrees with and the minority disagrees with. The proposed approach can deal with the following types of ranking problems: (1) the format of input preferences: ranking lists and ordinal pairwise comparisons, (2) completeness of input preferences: total ranking and partial ranking preferences, (3) completeness of output results: maximum consensus as well as a total ranking list. The pairwise comparison matrix adopted in this study differs from that in the Analytical Hierarchy Process (AHP) (Saaty, 1980). In the conventional AHP, precise preferences are required in a ratio-scale pairwise comparison matrix. However, in this study, only dominance relationships between two alternatives need to be specified by users in an ordinal pairwise comparison matrix. In addition, decision makers are usually only able to provide incomplete information because of time pressure, lack of data, and their limited knowledge related to the specific problem domain (Kim & Byeong, 1999). Therefore, this study provides the flexibility whereby users can input incomplete preferences.

Most previous studies minimize the total disagreements among multiple input preferences in order to achieve an overall ranking list; however, the fact that users might achieve little or no consensus on the final results is often overlooked. Chen and Cheng (2009) proposed a method to mine maximum consensus sequences from multiple users’ ranking preferences, based on the concept of the Apriori algorithm (Agrawal & Srikant, 1994). Instead of achieving an overall ranking list by minimizing total disagreements among multiple input preferences, their study generates only maximum consensus sequences. The group consensus preference can be realized by the maximum consensus sequence, and items of conflict can be detected. However, their method suffers from some major limitations. First, like many Apriori-based algorithms, candidate generation generates large numbers of subsets, resulting in the tedious workload of scanning, filtering and counting. In addition, maximum consensus sequences are usually fragmented; in practice, a complete total ranking list is generally of more help in making decisions. Finally, only input preferences with a ranking list format can be treated. This study aims to improve on these limitations by first determining maximum consensus sequences without a candidate generation process, and then developing an optimization model to obtain a final total ranking list.

This study aims to generate a total ranking list involving group consensus preferences for group ranking problems. A new group consensus mining approach based on the concept of tournament matrices and directed graphs is first developed, and then an optimization model involving maximum consensus sequences is constructed. The major advantages of the proposed approach are listed as follows.

                        
                           (1)
                           The proposed approach can obtain a total ranking list of alternatives based on maximum consensus sequences.

Compared to Apriori-based consensus mining methods, the proposed approach can determine maximum consensus sequences without the need for tedious candidate generation processes.

The proposed approach can provide flexibility in solving ranking problems with different formats and with varying degrees of completeness in the input preferences, including ranking lists and ordinal pairwise comparison formats, as well as partial and total completeness of input preferences.

Minimum consensus levels and maximum disagreement levels are adjustable.

In regard to solving group ranking problems, many methods have been proposed to generate a collective preference by aggregating different individual preferences. For instance, a value function approach for group ranking problems derives the final ranking lists using scores or value functions. Practice usually uses an additive form because it is more understandable for decision makers (Belton & Stewart, 2002; Ma & Li, 2011). For example, Ma (2010) adopted an additive score function and employed decision balls to visualize group ranking problems. Greco et al. (2008) presented a UTAGMS approach for ranking problems using a set of additive value functions resulting from ordinal regression. In addition to additive functions, the Cobb–Douglas (1928) form with constant return to scale is a commonly used non-linear score function for ranking problems (Ma & Li, 2008). Brugha (2000) pointed out that relative measured weights and scores should be synthesized using a power function, a kind of Cobb-Douglas function. The major limitation of the value function approaches is that most score or value functions have to be assumed in advance and users may have no consensus on the final ranking results.

A distance-based approach for group ranking problems uses a distance measurement to minimize total disagreement among multiple input preferences (Fernandez & Olmedo, 2005; Ma, 2012). Cook (2006) reviewed various distance-based models in ordinal preference ranking and demonstrated their levels of complexity by mathematical programming formulations. A distance-based approach has been widely applied in practice. For instance, Cook et al. (2007) proposed a branch-and-bound model based on a distance-based approach to support construction of an aggregate ranking of proposals from reviewers’ partial ordinal rankings. By minimizing total distance, distance-based methods can obtain a complete total ranking list. However, like most value function approaches, users may have no consensus or only a slight consensus concerning the final total ranking lists.

In a multiple criteria environment, the concept of AHP (Saaty, 1980) has been widely applied in solving group decision problems (Lai, Wong, & Cheung, 2002; Altuzarra, Moreno-Jimenez, & Salvador, 2007; Dong, Zhang, Hong, & Xu, 2010). Group priorities can be identified through ratio-scaled judgments of pairwise preferences between alternatives specified by decision makers. The two most commonly used methods in AHP group decision-making are the aggregation of individual judgments (AIJ) and the aggregation of individual priorities (AIP) (Altuzarra et al., 2007). In AIJ, a new group judgment matrix is constructed by aggregating individual judgment matrices; priority methods are then employed to obtain the final group ranking (Dong et al., 2010). In AIP, the group's priorities are derived from individual priorities, using an aggregation method. The most popularly-adopted aggregation method acts as the weighted geometric mean for both the AIJ and AIP methods. After that, aggregation of individual preference structures (AIPS) (Escobar & Moreno-Jiménez, 2007) was proposed, which combined AHP and Borda count (Borda, 1981) to capture the perception of decision makers, as well as the uncertainty of the individuals. However, AHP has been shown to lack a rigorous theoretical basis (Barzilai, 2005). Recently, a robust ordinal regression method, called the UTAGMS-GROUP, was proposed for multiple criteria group ranking problems (Greco, Kadzinski, Mousseau, & Slowinski, 2012; Kadzinski, Greco, & Slowinski, 2013). This method considers all compatible instances of a preference model, computes the necessary and the possible results, and then searches for consensus and disagreement between decision makers. However, a final total ranking list may not be obtained by this method.

The vote-counting approach for group ranking problems is based on ways of counting votes regarding group decision makers' preferences. Condorcet (1785) proposed a method based on vote-counting, known as the simple majority rule method, in which a relationship preferred by more voters is declared the winner. Borda (1981) developed an approach, called the Borda count, to obtain final ranking lists by counting the total of the ranks for each alternative evaluated by the voters. Morais and Almeida (2012) developed a position-based analysis of individual rankings composed of filtering, vetoing and choosing phases to solve group decision-making involving water resources. Recently, some counting-based data mining approaches have been applied in solving group ranking problems. For instance, Chen and Cheng (2009, 2010) employ the concept of an Apriori algorithm to mine maximum consensus sequences through repetitive candidate generation as well as counting and filtering processes. This approach can treat incomplete input preferences, and no score functions have to be assumed in advance; however, like most Apriori-based approaches, Chen and Cheng's approach (Chen & Cheng, 2009) has the following disadvantages: multiple scans of database and large numbers of candidates to be processed. In addition, maximum consensus sequences, rather than a total ranking list, can be achieved; however, the former are usually fragmented. This study aims to improve on these limitations.

The proposed approach aims to find maximum consensus among users, and then construct an optimization model involving maximum consensus to achieve a total ranking list. Given a group ranking problem, denote U = {u
                     1, u
                     2, … , um
                     } as m users in the group where users can be reviewers, managers, agents, individual decision makers, etc. Denote A = {a
                     1, a
                     2, … , an
                     } as n distinct alternatives for evaluation. In this study, the preference of user uk
                      for n alternatives can be specified as a ranking list or ordinal pairwise comparison matrix of alternatives.

For input preference with ranking list format, let Sk
                      be a user sequence which indicates the ranking list of alternatives for user uk
                     . The length of sequence Sk
                     , denoted as L(Sk), represents the number of alternatives in this sequence. A user may specify a total ranking or partial ranking preference. In the case of many alternatives, it may be difficult for users to specify the total ranking. This is the reason why this study provides flexibility with various degrees of completeness in the input preferences. The length of sequence Sk
                      is less than, or equal to, n. The sequence Sk
                      can be represented as:

                        
                           (1)
                           
                              
                                 
                                    S
                                    
                                       k
                                       
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          a
                                          
                                             α
                                             1
                                          
                                       
                                       ⊕
                                       
                                          a
                                          
                                             α
                                             2
                                          
                                       
                                       ⊕
                                       …
                                       ⊕
                                       
                                          a
                                          
                                             α
                                             i
                                          
                                       
                                       ⊕
                                       …
                                       ⊕
                                       
                                          a
                                          
                                             α
                                             
                                                L
                                                (
                                                
                                                   S
                                                   k
                                                
                                                )
                                             
                                          
                                       
                                    
                                    }
                                 
                                 ,
                              
                           
                        
                     where 
                        
                           
                              a
                              
                                 α
                                 i
                              
                           
                           ∈
                           
                           A
                        
                      and 
                        
                           
                              a
                              
                                 α
                                 i
                              
                           
                           ≠
                           
                              a
                              
                                 α
                                 j
                              
                           
                        
                      if i ≠ j, 1 ≤ αi
                      ≤ n. All alternatives in Sk
                      are distinct. In a sequence, the relationship between alternative ai
                      and aj
                      is denoted as (ai
                      ⊕ aj
                     ), where ⊕ is a sequence comparator. In this study, the sequence comparator ⊕ belongs to {>, =} in which “>” and “=” indicate that the preceding alternative is more preferable than, and equal in preference, to the succeeding one, respectively. For instance, let A = {a
                     1, a
                     2, … , a
                     5}; the user sequence of u
                     3 can be specified as S
                     3 = {a
                     3  > a
                     2 = a
                     1 > a
                     4 = a
                     5} with L(S
                     3) = 5.

Most group decision problems aim to discover group consensus sequences with lengths as large as possible. Therefore, this study assumes that all consensus sequences obey transitive relations; for instance, if both {a
                     1 > a
                     2} and {a
                     2 > a
                     3} are consensus sequences, then {a
                     1 > a
                     2 > a
                     3} is also a consensus sequence. In addition, the users in the group are assumed to be of equal importance in this study.

For input preference with a pairwise comparison format, denote Rk
                      as the ordinal pairwise comparison matrix of alternatives for user uk
                     . The element located in the ith row and jth column in matrix Rk
                     , denoted as Rk
                     (i, j), stands for a judgment of uk
                      regarding the relationship between alternatives ai
                      and aj
                     . In this study, the relationship between ai
                      and aj
                      is denoted as (ai
                      ⊗ aj
                     ), where ⊗ is a pairwise comparator and 
                        
                           ⊗
                           ∈
                           {
                           
                              >
                              ,
                              
                              =
                              ,
                              
                              <
                           
                           }
                        
                     . The pairwise comparators “>”, “=” and “<” indicate that ai
                      is more preferable than, equal in preference to, and less preferable than, aj
                     , respectively. For a decision problem with n alternatives, at most 
                        
                           n
                           ×
                           (
                           n
                           −
                           1
                           )
                           /
                           2
                        
                      judgments require evaluation by each user. It is worth noting that the pairwise comparison matrix adopted in this study is different from that in AHP (Saaty, 1980). In the conventional AHP, precise and complete preferences are required in a ratio-scale pairwise comparison matrix. However, in this study, only dominance relationships between two alternatives are needed in an ordinal pairwise comparison matrix. The reason why this study adopts ordinal rather than ratio-scale pairwise comparison matrix is that the former is easier for users to evaluate and the latter may achieve violations in priorities (Escobar, Aguarón, & Moreno-Jiménez, 2015). The ordinal pairwise comparison matrix in this study can be incomplete.

If a user chooses to specify sequence preference Sk
                     , it can be transferred to an ordinal pairwise comparison matrix Rk
                      by adhering to the following rules: for the relationship between ai
                      and aj
                     ,

                        
                           (1)
                           if ai
                               is the preceding alternative of aj
                               in Sk
                               and i < j
                              
                                 
                                    (i)
                                    if there is a “>” comparator between ai
                                        and aj
                                       , then Rk
                                       (i, j) = “>”;

if all comparators between ai
                                        and aj
                                        are “=”, then Rk
                                       (i, j) = “=”;

if ai
                               is the preceding alternative of aj
                               in Sk
                               and i > j
                              
                                 
                                    (i)
                                    if there is a “>” comparator between ai
                                        and aj
                                       , then Rk
                                       (j, i) = “<”;

if all comparators between ai
                                        and aj
                                        are “=”, then Rk
                                       (j, i) = “=” .

Denote Tk
                       = [Tk
                     (i, j)]
                        n × n
                      as a modified tournament matrix corresponding to Rk
                     . The entries of Tk
                     , denoted as tournament value Tk
                     (i, j), are defined as:

                        
                           
                              
                                 
                                    T
                                    k
                                 
                                 
                                    (
                                    
                                       i
                                       ,
                                       
                                       j
                                    
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             1
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   R
                                                   k
                                                
                                                
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                
                                                =
                                                
                                                ``
                                                >
                                                ""
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   R
                                                   k
                                                
                                                
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                
                                                =
                                                
                                                ``
                                                =
                                                ""
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             
                                                
                                                   if
                                                   
                                                
                                                
                                                   R
                                                   k
                                                
                                                
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                
                                                =
                                                
                                                ``
                                                <
                                                ""
                                                ,
                                             
                                          
                                       
                                    
                                 
                                 
                                 for
                                 
                                 i
                                 <
                                 j
                                 .
                              
                           
                        
                     
                  

For instance, given S
                     3 = {a
                     3  > a
                     2  = a
                     1  > a
                     4  =  a
                     5}, the modified tournament matrix T
                     3 for R
                     3 is listed in Table 1
                     . The concept of the modified tournament matrix is modified from a round-robin tournament matrix (McCarthy & Benjamin, 1996).

Let AGR (agreement) represent that the judgments of uk
                      and uh
                      regarding the relationship between ai
                      and aj
                      (i.e. the relationship between Rk
                     (i, j) and Rh
                     (i, j)) are the same. Let DAGR (disagreement) indicate that the judgments of uk
                      and uh
                      regarding the relationship between ai
                      and aj
                      are in critical contradiction of each other. All AGR and DAGR relationships between Rk
                     (i, j) and Rh
                     (i, j) are defined and listed in Table 2.
                     
                  

The judgments of uk
                      and uh
                      about the relationship between ai
                      and aj
                      can be checked according to the following rules:

                        
                           (i)
                           If 
                                 
                                    
                                       |
                                    
                                    
                                       T
                                       k
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    −
                                    
                                       T
                                       h
                                    
                                    
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       |
                                       =
                                       0
                                    
                                 
                              , the judgments of uk
                               and uh
                               about the relationship between ai
                               and aj
                               are consistent (AGR);

if 
                                 
                                    
                                       |
                                    
                                    
                                       T
                                       k
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    −
                                    
                                       T
                                       h
                                    
                                    
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       |
                                       >
                                       1
                                    
                                 
                              , the judgments are conflicting (DAGR).


                     
                        Definition 1
                        (AGR support, DAGR support): The AGR support of a pairwise comparison (ai
                            ⊗ aj
                           ), denoted as AGR_sup(ai
                            ⊗ aj
                           ), is defined as the number of users having AGR judgments with (ai
                            ⊗ aj
                           ) divided by the total number of users. The DAGR support of (ai
                            ⊗ aj
                           ), denoted as DAGR_sup(ai
                            ⊗ aj
                           ), is defined as the number of users having DAGR judgments with (ai
                            ⊗ aj
                           ) divided by the total number of users.


                     
                        Definition 2
                        (Group consensus judgment, group consensus tournament matrix): This study aims to find maximum consensus sequences which are the longest ranking lists of alternatives that the majority agrees with and the minority disagrees with. A majority is a subset of a group consisting of more than half the group's members; contrarily, a minority consists of less than half the group's members. Let min_AGR (agreement threshold) and max_DAGR (disagreement threshold) be the minimum AGR support and maximum DAGR support given by decision makers, respectively. A group consensus judgment (ai
                            ⊗ aj
                           ) is defined as:

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   AGR
                                                   _
                                                   sup
                                                
                                                
                                                (
                                                
                                                   a
                                                   i
                                                
                                                ⊗
                                                
                                                   a
                                                   j
                                                
                                                )
                                             
                                          
                                          
                                             ≥
                                          
                                          
                                             
                                                
                                                   min
                                                   _
                                                   AGR
                                                
                                                
                                                and
                                                
                                                
                                                   DAGR
                                                   _
                                                   sup
                                                
                                                (
                                                
                                                   a
                                                   i
                                                
                                                ⊗
                                                
                                                   a
                                                   j
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                             ≤
                                          
                                          
                                             
                                                max
                                                _
                                                DAGR
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

It is worth mentioning that parameters min_AGR and max_DAGR are specified by decision makers and used to provide flexibility to adjust required consensus level. For instance, if decision makers wish to find a maximum consensus that all users agree with and no user disagrees with, then min_AGR and max_DAGR can be set as 100 percent and 0, respectively. However, it may be difficult to find consensus with such a high consensus level in practice; thus, decision makers can adjust these two parameters to discover a consensus with a lower consensus level. For example, decision makers may set min_AGR = 80 percent and max_DAGR = 20 percent, which means that they would like to find a maximum consensus where more than 80 percent users agree and less than 20 percent uses disagree with.


                     
                        Definition 3
                        Counting matrix


                        A counting matrix is an n x n matrix consisting of the count of a specific judgment in Tk
                           (i, j) for all k. Denote CM1, CM0 and CM–1 as counting matrices for judgments “>” (i.e. Tk
                           (i, j) = 1), “=” (i.e. Tk
                           (i, j) = 0) and “<” (i.e. Tk
                           (i, j) = –1), respectively. The element located in the ith row and jth column in matrix CM1, denoted as CM1(i, j), stands for the count of Tk
                           (i, j) = 1 for all k. Similarly, CM0(i, j) and CM–1(i, j) indicate the count of Tk
                           (i, j) = 0 and Tk
                           (i, j) = –1.

For instance, if there are five users, the pairwise judgments of the relationship between a
                     1 and a
                     2 for the five users are: a
                     1 > a
                     2, a
                     1  > a
                     2, a
                     1 < a
                     2, a
                     1 = a
                     2 and a
                     1 > a
                     2, respectively. The element (1,2) of the modified tournament matrix for each user can be listed as T
                     1(1,2) = 1, T
                     2(1,2) = 1, T
                     3(1,2) = –1, T
                     4(1,2) = 0 and T
                     5(1,2) = 1; therefore, the element of counting matrices can be generated as CM1(1,2) = 3, CM0(1,2) = 1, CM–1(1,2) = 1.

After three counting matrices are built, the group consensus tournament matrix Tg
                      can be generated based on Definition 2. For instance, following the previous example, if decision makers set min_AGR = 60 percent and max_DAGR = 30 percent, then Tg
                     (1,2) = 1. The remaining entries of Tg
                     (i, j) can be calculated in a similar way.

This study proposes a rank-tracking algorithm based on the concept of direct graphs to obtain maximum consensus sequences from a group consensus tournament matrix. The algorithm traces elements in a group consensus tournament matrix and builds the corresponding directed graphs step by step. The major concept of this algorithm is to find maximum consensus sequences by discovering the longest path in the directed graphs. For instance, if there are two paths {a
                     1 > a
                     4} and {a
                     1 > a
                     2 > a
                     3 > a
                     4} from a
                     1 to a
                     4, then only the latter one will be kept because the length of the path is longer. Let bi,j
                      be a directed arc from ai
                      to aj
                     . Denote bi,*
                      as arcs starting from ai
                      and b*,,j
                      as arcs ending at aj
                     . Let B be a set of bi,j
                     , which is used to record directed arcs in a directed graph. After a group consensus tournament matrix Tg
                      is generated, the following rank-tracking algorithm is used to generate maximum consensus sequences.


                     Rank-tracking algorithm
                  

Input a n × n consensus tournament matrix Tg
                     
                     
                        
                           
                              
                              
                                 
                                    
                                       B = 
                                          ϕ
                                       
                                    
                                 
                                 
                                    
                                       i = 1
                                 
                                 
                                    For j = i+1 to n
                                    
                                 
                                 
                                    {If Tg
                                       (i, j) 
                                          ≥
                                        0, add bi
                                       
                                       , 
                                       
                                          j
                                        into B
                                    
                                 
                                 
                                     If Tg
                                       (i, j) < 0, add b j,i
                                        into B}
                                 
                                 
                                    For i = 2 to n–1
                                 
                                 
                                    {For j = i + 1 to n
                                    
                                 
                                 
                                     {If Tg
                                       (i, j) 
                                          ≥
                                        0
                                 
                                 
                                      {If there is no path from ai
                                        to aj
                                        in B
                                    
                                 
                                 
                                       {add bi,j
                                        into B
                                    
                                 
                                 
                                           check each bi,*
                                        in B; if there is another path from ai
                                        to a*
                                       , remove bi,*
                                        from B
                                    
                                 
                                 
                                           check each b*,j
                                        in B; if there is another path from a*
                                        to aj
                                       , remove b*,j
                                        from B}
                                 
                                 
                                      Else ignore bi,j
                                       }
                                 
                                 
                                     If Tg
                                       (i, j) < 0
                                 
                                 
                                      {If there is no path from aj
                                        to ai
                                        in B
                                    
                                 
                                 
                                       {add bj,i
                                        into B
                                    
                                 
                                 
                                           check each bj,*
                                        in B; if there is another path from aj
                                        to a*
                                       , remove bj,*
                                        from B
                                    
                                 
                                 
                                           check each b*,i
                                        in B; if there is another path from a*
                                        to ai
                                       , remove b*,i
                                        from B}
                                 
                                 
                                      Else ignore bj,i
                                       }
                                 
                                 
                                    }}
                                 
                              
                           
                        
                     
                  

Output the maximum consensus sequences from the final directed graph based on B.

At first, for i = 1, all arcs are added into set B. Next, for i > 1, each bi,j
                      (or bj,i
                      if Tg
                     (i, j) < 0) is checked; if there is already any path from ai
                      to aj
                      in B then bi,j
                      is ignored; otherwise, check each bi,*
                      and b*,j
                     . If there is more than one path from ai
                      to a*
                      or from a*
                      to aj
                      in B, then keep only the longest one. Because this study aims to find maximum consensus sequences, only the longest path is kept.

Looking at T
                     3 in Table 3
                      for example, applying the proposed rank tracking algorithm to T
                     3 yields the directed graphs depicted in Fig. 1(a)–(d). Only the directed arc with relationship “=” is marked in the graphs. The arc is ignored or deleted and is indicated as “X”. For i  = 1, B = {b
                     1,2, b
                     3,1, b
                     1,4, b
                     1,5}, as shown in Fig. 1(a). For i = 2, when j = 3, b
                     3,2 is checked (T
                     3(2,3)  = –1) and ignored because there is already a path from a
                     3 to a
                     2 {b
                     3,1, b
                     1,2} in B; when j = 4, b
                     2,4 is added into B and b
                     1,4 is deleted because {b
                     1,2, b
                     2,4} is in B; similarly, when j = 5, b
                     2,5 is added into B and b
                     1,5 is removed from B. After checking all j for i = 2, B = {b
                     2,5, b
                     2,4, b
                     1,2, b
                     3,1} as shown in Fig. 1(b). For i =3, when j = 4, b
                     3,4 is checked and ignored since {b
                     3,1, b
                     1,2, b
                     2,4} is in B; similarly, when j =5, b
                     3,5 is ignored because {b
                     3,1, b
                     1,2, b
                     2,5} in is B. After checking all j for i =3, B = {b
                     2,5, b
                     2,4, b
                     1,2, b
                     3,1} as shown in Fig. 1(c). For i = 4, when j = 5, b
                     4,5 is added into B and b
                     2,5 is removed from B because {b
                     2,4, b
                     4,5} is in B. The final directed graph is shown in Fig. 1(d) with B = {b
                     4,5, b
                     2,4, b
                     1,2, b
                     3,1}. The maximum consensus sequences can be derived from the final directed group in Fig. 1(d) as {a
                     3 > a
                     1 = a
                     2 > a
                     4 = a
                     5}.

It is worth noting that the maximum consensus sequences found by the proposed approach may differ from the sequences determined by Chen and Cheng's approach (Chen & Cheng, 2009). Because the proposed approach is based on the assumption of transitivity, it may find longer consensus sequences than Chen and Cheng's approach does. For instance, if both {a
                     1 > a
                     2} and {a
                     2  > a
                     3} are consensus sequences, then {a
                     1  > a
                     2  > a
                     3} must be a consensus sequence in the proposed approach; however, {a
                     1  >  a
                     2  > a
                     3} may not be considered a consensus sequence in Chen and Cheng's approach.

In addition, Chen and Cheng's approach can only obtain maximum consensus sequences; however, maximum consensus sequences are usually fragmented. In practice, a total ranking list is generally more helpful in making decisions. In order to determine a total ranking list, this study proposes a group consensus-ranking model (Model 1) incorporating constraints from maximum consensus sequences. The proposed model combines the concept of a vote-counting approach with a value function approach. The number of votes is used as the basis for calculating the scores of alternatives. An additive score function is assumed because of its popularity and simplicity (Belton & Stewart, 2002).

Denote Score(i) as the score of alternative ai
                      and CS
                      as the set of maximum consensus sequences determined by the rank-tracking algorithm. The major concept of the proposed optimization model includes:

                        
                           (1)
                           Constraints from maximum consensus sequences: if {ai
                               > aj
                              } in CS, Score(i) is designed to be at least 1 point greater than Score(j). If {ai
                               = aj
                              } in CS, Score(i) is equal to Score(j). The range of scores is between 0 and n (i.e. the number of alternatives).

Constraints from counting matrix: according to the vote-counting approach, if {ai
                               ⊕ aj
                              } not in CS
                               and CM1(i,j) > CM–1(i, j) which means the number of judgments with {ai
                               > aj
                              } is greater than that of judgments with {ai
                               < aj
                              }, Score(i) is then designed to be greater than, or equal to, Score(j); conversely, if CM1(i,j) < CM–1(i, j), then Score(i) ≤ Score(j). Denote zi,j
                               as a binary variable used to indicate whether or not CM1(i,j) is greater than CM–1(i, j). If CM1(i,j) > CM–1(i, j), zi,j
                               = 0; if CM1(i,j) < CM–1(i, j), zi,j
                               = 1.

Objective function: the difference between Score(i) and Score(j) is approximated by the difference between CM1(i,j) and CM–1(i, j) multiplied by a positive variable w which is a scaling variable between scoring and counting. The greater the difference between CM1(i,j) and CM–1(i, j), the greater the difference between Score(i) and Score(j) yielded. For instance, if CM1(2,3) = 3 and CM–1(2,3) = 1, it means that there are three users with judgments {a2 > a3} and one user with judgment {a2 < a3}, the difference between Score(2) and Score(3) is approximated as 2 w (3–1=2); if CM1(2,3) = 5 and CM–1(2,3) = 1, the difference between Score(2) and Score(3) is approximated as 4 w. The scaling variable w is employed here because the ranges of two compared items are different with 
                                 
                                    −
                                    n
                                    ≤
                                    S
                                    c
                                    o
                                    r
                                    e
                                    (
                                    i
                                    )
                                    −
                                    S
                                    c
                                    o
                                    r
                                    e
                                    (
                                    j
                                    )
                                    ≤
                                    n
                                 
                               and 
                                 
                                    −
                                    m
                                    ≤
                                    C
                                    
                                       M
                                       1
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    −
                                    C
                                    
                                       M
                                       
                                          −
                                          1
                                       
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    ≤
                                    m
                                 
                              . The scaling variable w and variables Score(i) for all i are designed as decision variables in the proposed model. The value function adopted here is the sum of the absolute deviations resulting from the above approximations, which represents the total error of approximations. The objective function is to minimize the value function; that is, the value of the objective function indicates minimal total error of approximations.

The proposed optimization model is developed as follows:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          M
                                          i
                                          n
                                          
                                          Obj
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                n
                                                −
                                                1
                                             
                                          
                                          
                                             ∑
                                             
                                                j
                                                >
                                                i
                                             
                                             n
                                          
                                          
                                             |
                                             
                                                (
                                                S
                                                c
                                                o
                                                r
                                                e
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                −
                                                S
                                                c
                                                o
                                                r
                                                e
                                                
                                                   (
                                                   j
                                                   )
                                                
                                                )
                                             
                                             −
                                             w
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          ×
                                          (
                                          C
                                          
                                             M
                                             1
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          −
                                          C
                                          
                                             M
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          )
                                          |
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 s
                                 u
                                 b
                                 j
                                 e
                                 c
                                 t
                                 
                                 t
                                 o
                                 
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    i
                                    )
                                 
                                 ≥
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    j
                                    )
                                 
                                 +
                                 1
                                 ,
                                 
                                 ∀
                                 
                                 
                                    a
                                    i
                                 
                                 >
                                 
                                    a
                                    j
                                 
                                 
                                 
                                    in
                                    
                                 
                                 C
                                 S
                                 ,
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    j
                                    )
                                 
                                 ,
                                 
                                 ∀
                                 
                                    a
                                    i
                                 
                                 =
                                 
                                    a
                                    j
                                 
                                 
                                    
                                    in
                                    
                                 
                                 C
                                 S
                                 ,
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 C
                                 
                                    M
                                    1
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 +
                                 n
                                 ×
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ≥
                                 C
                                 
                                    M
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 >
                                 i
                                 
                                    
                                    and
                                    
                                 
                                 
                                    a
                                    i
                                 
                                 ⊕
                                 
                                    a
                                    j
                                 
                                 
                                 
                                    not
                                    
                                    in
                                    
                                 
                                 C
                                 S
                                 ,
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    i
                                    )
                                 
                                 +
                                 n
                                 ×
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ≥
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    j
                                    )
                                 
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 >
                                 i
                                 
                                 
                                    and
                                    
                                 
                                 
                                    a
                                    i
                                 
                                 ⊕
                                 
                                    a
                                    j
                                 
                                 
                                    
                                    not
                                    
                                    in
                                    
                                 
                                 C
                                 S
                                 ,
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          C
                                          
                                             M
                                             1
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          −
                                          n
                                          ×
                                          
                                             (
                                             1
                                             −
                                             
                                                z
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                             
                                             )
                                          
                                          ≤
                                          C
                                          
                                             M
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          ∀
                                          i
                                          ,
                                          j
                                          >
                                          i
                                          
                                          
                                             and
                                             
                                          
                                          
                                             a
                                             i
                                          
                                          ⊕
                                          
                                             a
                                             j
                                          
                                          
                                             
                                             not
                                             
                                             in
                                             
                                          
                                          C
                                          S
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    i
                                    )
                                 
                                 −
                                 n
                                 ×
                                 
                                    (
                                    1
                                    −
                                    
                                       z
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    )
                                 
                                 ≤
                                 S
                                 c
                                 o
                                 r
                                 e
                                 
                                    (
                                    j
                                    )
                                 
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 >
                                 i
                                 
                                 
                                    and
                                    
                                 
                                 
                                    a
                                    i
                                 
                                 ⊕
                                 
                                    a
                                    j
                                 
                                 
                                    
                                    not
                                    
                                    in
                                    
                                 
                                 C
                                 S
                                 ,
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 0
                                 ≤
                                 S
                                 c
                                 o
                                 r
                                 e
                                 (
                                 i
                                 )
                                 ≤
                                 n
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 >
                                 i
                                 ,
                                 
                                 w
                                 >
                                 0
                                 .
                              
                           
                        
                     
                  


                     Eqs. (2) and (3) are constraints from maximum consensus sequences and set for the relationships of ai
                      and aj
                      found in CS
                     . Eqs. (4)–(7) are constraints from counting matrix and set for relationships not found in CS
                     . In Eq. (4), if CM1(i,j) > CM–1(i, j), then zi,j
                      must be 0; otherwise, Eq. (4) will be in contradiction with Eq.(6). In this case, Eqs. (4) and (5) are activated and Eqs. (6) and (7) are unconstrained; thus Score(i) must be greater than or equal to Score(j). Similarly, if CM1(i,j) < CM–1(i, j), then zi,j
                      must be 1; Eqs. (6) and (7) are activated, and Score(i) must therefore be less than or equal to Score(j). When CM1(i,j) = CM–1(i, j), zi,j
                      can be 0 or 1, depending on the objective function.

This model is a non-linear model because of the absolute term in the objective function. From the work of Li (Li, 1996), this model can be transformed into the following linear model:

Model 1 Group consensus-ranking model

                        
                           (10)
                           
                              
                                 
                                    
                                       
                                          M
                                          i
                                          n
                                          
                                          Obj
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             ∑
                                             
                                                j
                                                >
                                                i
                                             
                                             n
                                          
                                          
                                             (
                                             
                                                (
                                                S
                                                c
                                                o
                                                r
                                                e
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                −
                                                S
                                                c
                                                o
                                                r
                                                e
                                                
                                                   (
                                                   j
                                                   )
                                                
                                                )
                                             
                                             −
                                             w
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          ×
                                          (
                                          C
                                          
                                             M
                                             1
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          −
                                          C
                                          
                                             M
                                             
                                                −
                                                1
                                             
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          )
                                          +
                                          2
                                          ×
                                          q
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          s
                                          u
                                          b
                                          j
                                          e
                                          c
                                          t
                                          
                                          t
                                          o
                                          
                                          
                                             (
                                             S
                                             c
                                             o
                                             r
                                             e
                                             
                                                (
                                                i
                                                )
                                             
                                             −
                                             S
                                             c
                                             o
                                             r
                                             e
                                             
                                                (
                                                j
                                                )
                                             
                                             )
                                          
                                          −
                                          
                                             (
                                             C
                                             
                                                M
                                                1
                                             
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                             
                                             −
                                             C
                                             
                                                M
                                                
                                                   −
                                                   1
                                                
                                             
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          2
                                          ×
                                          q
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          )
                                          ≥
                                          0
                                          ,
                                          
                                          ∀
                                          i
                                          ,
                                          j
                                          >
                                          i
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (12)
                           
                              
                                 q
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ≥
                                 0
                                 ,
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 >
                                 i
                                 ,
                              
                           
                        
                     
                  

(2)–(9).

By applying Model 1 to group decision problems in order to calculate the score of each alternative, a total ranking list incorporating the maximum consensus sequences can be found.

The major advantage of the proposed optimization model is the ability to find a ranking list involving group maximum consensus sequences by combining the concepts of the vote-counting approach and value function approach. Because maximum consensus sequences are designed as constraints in the proposed model, the order of ranking result must be consistent with those of maximum consensus sequences.

A flowchart of the proposed approach is shown in Fig. 2
                     . The group ranking process is illustrated in the following seven major steps:

                        
                           
                              Step 1
                           
                           (Input preferences): Users can choose to input preferences in the form of a ranking list (Sk
                              ) or ordinal pairwise comparison matrix (Rk
                              ).

(Transfer to tournament matrix): Transfer each Sk
                               or Rk into a modified tournament matrix Tk.

(Generate counting matrix): Generate three counting matrices: CM1, CM0 and CM–1.

(Develop a group consensus matrix): Construct group consensus matrix Tg
                               = [Tg
                              (i,j)]
                                 nxn
                               based upon the constraints of min_AGR and max_DAGR.

(Find maximum consensus sequences): Apply the rank-tracking algorithm to Tg
                               to derive maximum consensus sequences.

(Calculate score): Perform Model 1 to calculate the score of each alternative

(Output ranking): Output a total ranking list.

Two examples are shown below.


                     
                        Example 1
                        The first example, denoted as Example 1, illustrates the process of the proposed approach. Given a group ranking problem, suppose there are five users {u
                           1, u
                           2, … , u
                           5} in a group and five alternatives {A, B, C, D, E} requiring evaluation.

The proposed group ranking approach is described as follows:

                        
                           
                              Step 1
                           
                           (Input preferences): Users u
                              1, u
                              2 and u
                              3 specify ranking list preferences as listed in Table 4(a) where u
                              2 inputs a partial ranking list preference. User u
                              4 specifies ordinal pairwise comparison preferences, as shown in Table 4(b), and u
                              5 inputs an incomplete ordinal pairwise comparison matrix, as listed in Table 4(c).

(Transfer to tournament matrix): All users’ input preferences are transferred to the corresponding modified tournament matrix {T
                              1, … , T
                              5}, as shown in Table 3(a)–(e).

(Generate counting matrix): Three counting matrices: CM1, CM0 and CM–1 are generated based on T
                              1, … , T
                              5, as shown in Table 5
                              (a)–(c).

(Develop a group consensus matrix): Given min_AGR = 60 percent and max_DAGR = 20 percent, a group consensus matrix Tg
                               is built, as shown in Table 6(
                              a).

(Find maximum consensus sequence): Applying a rank-tracking algorithm to Tg
                               in Step 4 yields directed graphs, as shown in Fig. 3
                              . Fig. 3(a)–(d) show each step of tracking based on row Tg
                              . Fig. 3(d) is the final directed graph. The maximum consensus sequences are {A > B > D = E} and {C > B > D = E}.

(Calculate score): Applying Model 1 to this example yields Obj = 5.2, w = 0.4, Score(A) = 2.65, Score(B) = 1.65, Score(C) = 2.65, Score(D) = 0.65 and Score(E) = 0.65.

(Output ranking): Output a total ranking list {A=C>B>E=D}.

In order to compare the results of different min_AGR and max_DAGR, this study tested several settings. First, max_DAGR was fixed at 20 percent and min_AGR was changed from 60 percent to 80 percent, and then 100 percent sequentially. The group consensus tournament matrices of min_AGR = 80 percent and 100 percent are shown in Table 6(b) and (c), respectively, and the corresponding directed graphs are depicted in Figs. 4 and 5. For min_AGR = 80 percent and max_DAGR = 20 percent, the final consensus sequences are {A > B > D} and {A > B > E}; applying Model 1 yields Obj = 4.67, w = 0.33, Score(A) = 2, Score(B) = 1, Score(C)  = 1.67, Score(D)  = 0 and Score(E)  = 0, with a final total ranking list {A>C>B>E=D}. For min_AGR = 100 percent and max_DAGR = 20 percent, the final consensus sequence is {A > D}, and the scores of the five alternatives are 1, 0.55, 0.76, 0 and 0.27, respectively, with Obj = 2, w = 0.18 and a final total ranking list {A > C > B > E > D}.

Next, min_AGR is fixed at 60 percent; max_DAGR is changed from 20 percent to 40 percent and then 0 percent. The group consensus tournament matrices of max_DAGR = 40 percent and 0 percent are listed in Table 6(d) and (e). Because the consensus tournament matrix of max_DAGR = 40 percent is the same as that of max_DAGR = 20 percent, the corresponding directed graphs are also the same as those of max_DAGR = 20 percent, as shown in Fig. 3. The final total ranking lists of both conditions are also the same. For max_DAGR = 0 percent, the corresponding directed graphs are depicted in Fig. 6 with consensus sequences {A > B > E} and {A > D = E}, and the scores of the five alternatives are 2.25, 1.25, 1.25, 0.25 and 0.25, respectively, with Obj = 4.67, w = 0.33 and a final total ranking list {A > C = B > E = D}.

The comparison results of different min_AGR and max_DAGR are listed in Table 7. When max_DAGR is fixed in combination with a larger value of min_AGR, the shorter length of consensus sequences can be found. Contrarily, when min_AGR is fixed in combination with a larger value of max_DAGR, the longer length of consensus sequences can be found.


                     
                        Example 2
                        In order
                           
                            to make comparisons, the second example, denoted as Example 2, is modified from Chen and Cheng's study (Chen & Cheng, 2009). Given a group-ranking problem with 10 users and 10 proposals, each decision maker provided a ranked list of all proposals, as listed in Table 8. In this example, min_AGR and max_DAGR were set at 60 percent and 20 percent, respectively. Applying Chen and Cheng's approach to this example yields four maximum consensus sequences {D > E > F > G}, {D > E > F > H}, {C > G}, {D > B} with length 4, 4, 2 and 2, respectively. The corresponding directed graph is shown in Fig. 7(a). In Fig. 7, each node represents a proposal, and a solid directional arc from D to E indicates that users prefer D to E. Users have no consensus on proposals A, I and J. Chen and Cheng's approach did not achieve a total final ranking. Applying the proposed approach to Example 2 finds five consensus sequences {D > E > F > G = H}, {C > G = H}, {I > G = H}, {D > A} and {D > B} with length 5, 3, 3, 2 and 2, respectively. The corresponding directed graph is shown in Fig. 7 (b). Applying Model 1 to this example yields Obj = 22, w = 0.25, Score(A)  = 1, Score(B)  = 1, Score(C)  = 2, Score(D) = 3, Score(E)  = 2, Score(F)  = 1, Score(G)  = 0, Score(H)  = 0, Score(I)  = 2 and Score(J)  = 1. A final total ranking list {D > C = E = I > A = B = F = J > G = H} is achieved.

The maximum consensus sequences found using both approaches are listed in the third and fourth columns of Table 9
                     
                     
                     . The maximum consensus sequences {D > E > F > G} and {D > E > F > H} determined using Chen and Cheng's approach are included in the maximum consensus sequence {D > E > F > G = H} generated by the proposed approach, and {C > G} by the former is contained in {C > G = H} by the latter. The length of maximum consensus sequences determined by the proposed approach is longer than those produced using Chen and Cheng's approach. Besides, the proposed approach can obtain a final total ranking list that is more helpful to decision makers. In addition to Chen and Cheng's approach, a popular vote-counting approach, Borda count (Borda, 1981), is compared here. The results by Borda count are listed in the second column of Table 9. The Borda count approach can only obtain a total ranking list; however, the ranking list may not fulfill group consensus. For instance, the relationship between G and H is {G > H} by Borda count; nevertheless, seven out of ten users rank {G = H}. As shown in Table 9, only the proposed approach can achieve a total ranking list fulfilling group maximum consensus sequences.

@&#DISCUSSIONS@&#

The major contribution of the proposed approach is to find a total ranking list involving group maximum consensus sequences. The proposed approach can also provide flexibility in solving ranking problems with different formats and with varying degrees of completeness in the input preferences. This is helpful especially in the case when many alternatives need to be evaluated because users may find it difficult to specify complete ranking lists when the number of alternatives is large.

The other significant contribution of this paper is to facilitate three way trade-offs among (1) agreement, (2) disagreement and (3) rank orderings. Compared to conventional group ranking methods, this study provides flexibility whereby decision-makers can adjust an acceptable consensus level, including agreement threshold (min_AGR) and disagreement threshold (max_DAGR). This could then facilitate the decision-makers’ direct interactive engagement with the clients, and then arrive at a preferred compromise solution.

Most Aprior-based algorithms require repetitive candidate generation and counting to find maximum consensus sequences. The computational time increases when the number of alternatives or users grows. However, the proposed rank-tracking algorithm is based on the concept of directed graphs and discovers maximum consensus sequences by tracking a consensus tournament matrix. The computational complexity of the proposed rank-tracking algorithm is 
                        
                           
                              (
                              n
                              ×
                              
                                 (
                                 n
                                 −
                                 1
                                 )
                              
                              /
                              2
                              )
                           
                           ×
                           
                              (
                              n
                              +
                              n
                              )
                           
                           =
                           
                              (
                              
                                 n
                                 3
                              
                              −
                              
                                 n
                                 2
                              
                              )
                           
                        
                     . That is, the time complexity will increase considerably when the number of alternatives increases. This is the major restriction of the proposed approach. However, the computational time of the rank-tracking algorithm will not be affected when the number of users increases. Therefore, the proposed approach is most suitable for group ranking problems involving a smaller number of alternatives and a larger number of users.

For the proposed group consensus-ranking model, the number of variables used in this optimization model is 
                        
                           n
                           ×
                           (
                           n
                           −
                           1
                           )
                           +
                           11
                        
                     , including 10 for score(i), 1 for w and n(n–1)/2 for both zi,j
                      and qi,j
                     . The computational time also depends on the number of alternatives rather than the number of users. Because the optimization model has been linearized, the computational time of the proposed optimization model is largely decreased.

The proposed approach is meant for ranking problems which seek a single decision under a consensus building perspective in a group decision scenario. The users in the group are assumed to be of equal importance. The proposed approach can be widely applied to many real world problems such as ranking projects from a lot of reviewers, ranking promotion gifts from a group of customers and ranking suppliers by many managers.

@&#CONCLUSIONS@&#

This study aimed to propose a new group-ranking approach for ordinal preferences based on the concept of group consensus preference. A group consensus mining method based on the concept of tournament matrices and directed graphs was first developed to discover maximum consensus sequences, and then an optimization model involving maximum consensus sequences was proposed to achieve a total ranking list. The proposed approach can be widely applied to many real world problems and is most suitable for group ranking problems involving a smaller number of alternatives and a larger number of users.

Compared to previous methods, the proposed approach is able to determine maximum consensus sequences without the need for candidate generation processes. It is also able to obtain group maximum consensus sequences as well as a total ranking list where the majority of users have a consensus. Minimum consensus levels and maximum disagreement levels are adjustable to facilitate three way trade-offs among agreement, disagreement and rank orderings. In addition, the proposed approach provides flexibility in solving ranking problems using ranking lists or ordinal pairwise comparison preference formats with incomplete input preferences.

Future research could address the group ranking problems where the users have different levels of importance. In that case, the concept of maximum consensus sequences should be adapted to the new context. In addition, further research can also focus on how to assist the decision-makers to choose an acceptable consensus level, for instance, developing interactive interface and visual aids to facilitate interaction between decision-makers and their clients.

@&#ACKNOWLEDGMENT@&#

This research is supported by the Ministry of Science and Technology of the Republic of China under contract MOST 103-2410-H-239-007-MY2.

@&#REFERENCES@&#

