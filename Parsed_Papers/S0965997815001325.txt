@&#MAIN-TITLE@&#Optimal industrial reactor design: development of a multiobjective optimization method based on a posteriori performance parameters calculated from CFD flow solutions

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An open-source software to couple CFD and multiobjective optimization is presented.


                        
                        
                           
                           The influence of bioreactor geometry on shear stress and RTD is analyzed by CFD.


                        
                        
                           
                           Parallel evolutionary algorithm for solving CFD optimization problems is implemented.


                        
                        
                           
                           A pilot-scale continuous bioreactor is optimally designed.


                        
                        
                           
                           The software showed robustness allowing its future application on different problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multiobjective optimization

Computational fluid dynamics

Bioreactor

Shear stress

Residence time distribution

Open source code

@&#ABSTRACT@&#


               
               
                  The increase in the use of biofuels raised new challenges to engineering problems. In this context, the optimization of chemical reactors, particularly bioreactors and photobioreactors, is crucial to improve the production of biofuels in a sustainable manner. This paper reports the development of an optimization method and its application to the design of a continuous flow bioreactor envisaged to be used in industrial fermentation processes. Mass and momentum conservation equations are simulated via CFD and specific a posteriori performance parameters, determined from the flow solution, are fed into a multiobjective evolutionary algorithm to obtain corrections to the parameters of the geometrical configuration of the reactor. This heuristics is iterated to obtain an optimized configuration vis-à-vis the flow aspects portrayed by the performance parameters, such as the shear stress and the residence time variations. An open source computer package (PyCFD-O) was developed to perform CFD simulations and the optimization processes automatically. First, it calls the pre-processor to generate the computational geometry and the mesh. Then it performs the simulations using OpenFOAM, calculates the output parameters and iterates the procedure. The PyCFD-O package has proved reliable and robust in a test case, a ∼1 m3 continuous fermentation reactor. The multiobjective optimization procedure actually corresponds to search for the Pareto frontier in the solution space characterized by its geometric parameters and the associated performance parameters (dispersion o residence times and shear stresses). Optimal design configurations were obtained representing the best tradeoff between antagonistic objectives, i.e. the so-called non-dominant solutions.
               
            

@&#INTRODUCTION@&#

The search for new ways to provide energy and transportation fuel for the society has been constantly increasing. One of the great challenges for scientists and academic researchers is to provide fuels without impacting the environment. Bioethanol is a very interesting and promising alternative, particularly when it is produced from sugarcane or other types of intensive farming crops, such as corn, beet, etc.

The production of bioethanol is economcally feasible only within a production-processing scale interval. The lower limit is usually related to fixed costs and the upper limit is commonly determined by agricultural operations (plowing, harvesting, etc.) and logistics costs. For instance, a typical sugarcane mill in Brazil has an industrial unit capable of processing 400–600 tsc/h during 200–220 days per year with a surrounding cultivation area of 20,000–30,000 ha [36]. Fig. 1
                      shows an example of a continuous flow fermenter for the conversion of sucrose into ethanol in a sugarcane mill. At these scales, any efficiency improvement results in a very significant overall optimization in terms of production rates and environmental impacts. Due to the difficulty in the development of experimental analyses, the expensive materials used and time limitations, computational fluid dynamics (CFD) tools are a useful alternative for the study of the flow inside chemical reactors and for a better definition of their design principles. The last decade has seen a rapid increase in the number of numerical simulation studies on chemical processes. The development of CFD and the availability of more powerful computers have created new possibilities for the modeling and design of this type of equipment.

As shown in Table 1
                     , CFD has been extensively used in the last decade to simulate various types of chemical reactors which, ideally, should provide optimum conditions to the corresponding chemical or fluidic processes. Its geometrical configuration strongly influences the flow conditions regarding mass transfer, shear stress, mixing, control of pH, temperature distribution, decantation, etc. [38], particularly at large scales. Despite this, most of research work is based on bench-top (<0.01 m3) or small scale (<0.1 m3) reactors, even though the ability to extrapolate the results may be compromised. For instance, in a fermenter heat generation due to the conversion of sucrose into ethanol is proportional to the processed volume and heat removal is limited by the interfacial area. Thus, when increasing the size of the reactor by multiplying all linear dimensions by a scale factor λ, heat generation will grow with λ
                     3 while heat removal increases proportionally to λ
                     2 with obvious negative consequences in terms of temperature control.In addition, the scale factor affects differently different dimensionless groups, such as Reynolds, Froud and Prandtl. Consequently, even fundamental flow characteristics may change by going from small to large scale. For example, the flow may be laminar in a bench top reactor and turbulent in its large scale version, or a gas-liquid stratification interface may be smooth in the first while it may be oscillatory in the later, resulting in significant differences in performance. Although numerical simulation has already proven to be very useful and insightful in analyzing and predicting complex flow behavior, CFD tools are not commonly used to its full capacity to optimize reactor performance [12].

Traditionally, the process of design optimization with CFD is based on a trial-and-error approach in which a number of prospective configurations are simulated and the results are compared. Depending on the simulation results, operational variables and/or reactor geometry are manually changed and numerically tested producing new results. This design process is usually cumbersome and time-consuming, in addition to being subjective to a certain level. The key to fully automatize this design cycle, i.e. prospective configuration → CFD simulation → performance analysis → performance optimization → changes in prospective configuration, is to develop a computational platform to implement each of these instances, in addition to representing design criteria enforcing performance requirements through adequate mathematical equations.

Computational Fluid Dynamics coupled with optimization techniques started to be used in the 70s in studies focused on aerospace problems [16] and then in aeronautical and automotive areas [7, 20]. Several optimization methods have been used to determine the best way to obtain the ideal structural parameters. Classical optimization techniques, such as gradient-based methods are known for their lack of robustness and tendency to get trapped by local optima. Generic and robust search based methods, as Genetic Algorithms (GA) [10, 15, 31], offer several attractive features and have been widely used for shape design optimization [6, 20, 24, 30] and, in particular, multiobjective problems. These methods have been successfully tested in many practical cases, such as: aerodynamic shape optimization in airplanes [7, 20] and automobiles [23, 24]. The basic idea associated with the GA approach is to search for optimal solutions by using an analogy with Charles Darwin's evolutionary theory. During the iteration procedure (or “evolution”, using GA terminology), the optimization variables or genes are manipulated by various operators (crossover, mutation,...) for the creation of new candidate solutions, i.e. new sets of optimization variables. The use of fully automatic Genetic Algorithms coupled with CFD for a multiobjective bioreactor optimization problem still remains limited by computing time and is far from being a practical tool for engineering applications.

This paper describes a fully automatic CFD optimization method and its application to the design of a continuous flow fermenter for the conversion of sucrose into ethanol in a sugarcane mill. An open source CFD code was developed to obtain an optimal geometrical configuration within an acceptable computing time. The computational platform is composed of a set of numerical procedures: mesh generation, CFD, a Python implementation of a Genetic Algorithm, a shell-script and complementary programs for the automatic execution of the procedures. The optimization problem has two performance parameters which have to be minimized simultaneously: (1) the dispersion of the residence time (related to the biochemical reaction efficiency) and (2) the maximum shear stress (influences cell death). In the following the flow problem is formulated and the multiobjective genetic algorithm, based on the concept of Pareto dominance, is described. The algorithms for mesh generation, CFD solution and parallelization are elaborated afterwards. Results are then shown and discussed, followed by concluding remarks.

Continuous fermentation differs from traditional batch fermentation methods in that feedstocks are continuously fed to the reactor while products are continuously removed from it. Provided operating variables are kept within nominal conditions, this configuration has several advantages such as virtually eliminating the inherent down-time for cleaning and sterilization, and the long lags before the organisms enter a brief period of high productivity. In addition, both CAPEX and OPEX tend to be smaller due to the intrinsic simplicity of the equipment. However, elaborate design methods are required to assure proper performance, especially for large scale reactors. Among the many causes of performance deterioration at large scales probably the dispersion of the residence times is one of the most important. The reason for this is related to the fact that, in a small continuous reactor, dissipation tends to prevail over dynamic effects and, consequently, the flow field tends to be well organized, or even laminar. Thus, the residence times associated with each flow line connecting the input to the output differs little from the design value, i.e. the ideal reaction time. In an industrial fermenter, typically within 100–1000 m3, dynamic effects are preponderant causing intense turbulence, formation of large eddies, etc., and the flow lines tend to scatter over the entire reactor volume which significantly increases dispersion of the residence times. Thus, the amount of fluid that stays the proper period of time confined in the reactor, i.e. the ideal residence time for an effective chemical reaction, is significantly reduced causing degradation of the conversion performance. This particular aspect will be examined in the following test case, as well as other important effects related to upscaling.

The prospective geometrical configuration for this study was inspired by the type of industrial reactor used for the continuous fermentation of sucrose into ethanol in some sugarcane mills in Brazil, as shown in Fig. 1. It comprises a cylindrical reservoir fed tangentially by the bottom and drained from the top through a centered outlet pipe to ensure a proper CO2 exhaustion. Fig. 2 shows a schematic representation of the initial geometry and Table 2
                      shows the corresponding parameterization and initial values, set for an internal volume of approximately 1 m3 or 1000 l. To restrict the optimization to a pre-defined theoretical residence time (reactor volume / volumetric flow rate) the reactor's height (H
                     Bio) and diameter (D
                     Bio) were not varied. Also the outlet's diameter (d
                     out) and the inlet's length (L
                     in) and diameter (d
                     in) were fixed. The only parameters allowed to vary during the optimization procedure were the inlet angle (α) and the height of the outlet tube (H
                     out).

After defining of the computational geometry and obtaining of a corresponding mesh, the numerical simulation can be performed. The computational fluid dynamics package OpenFOAM [27] was applied to solve the governing fluid flow equations, including transport equation for a passive scalar. The residence time distribution (RTD) and shear stress are determined from which the two objective parameters are calculated.

The set of equations numerically solved by OpenFOAM [27] enforces the conservation of mass and momentum or, specifically, the unsteady Navier–Stokes equation in its conservative form. Additional hypothesis are that the flow inside the reactor is isothermal and incompressible. The governing equations are listed in Table 3
                     . The fluid is water with properties calculates at 30 °C (303.15 K). Turbulence effects were taken into account with the K-ε model, and Navier–Stokes equations were solved by the Finite Volume method [18]. The solver in this study uses PISO loop (Pressure Implicit with Splitting of Operators) to solve the Navier–Stokes equations [17,18]. Based on volumetric continuity, a pressure equation is solved to correct the predicted momentum because of pressure change. This is a correction loop consisting of an implicit momentum predictor followed by a series of pressure solutions and explicit velocities corrections.

Most of microalgae and some fungi of industrial interest are sensitive the shear stresses which, above a certain limit, can cause cell damage leading to cell death [5]. These shear stresses usually result from an inadequate design, especially when not enough attention is paid to the relation between vorticity generation and the reactor's geometry. This is a very well-known problem in photobioreactors (PBRs) [21] but, despite the severe degradation of performance that elevated hydrodynamic shear stresses can cause, few studies have been published in this regard. Entry pointers on this subject are the work by [37], which analyses the effects of shear on the cultivation of two microalgae species in tangential flow filtration systems, and the paper by [8] in which the influence of hydrodynamic stresses, CO2 mass transfer and light availability on the growth of Phaeodactylum tricornutum is assessed.

One of the a posteriori performance parameters considered in this work is the total shear stress, thus accounting for the influence of viscosity and turbulence. The total shear stress tensor, denoted by SST(Shear Stress Total), is the sum of the viscous stress from momentum transfer at molecular level and the stress term arising from the fluctuating velocity field (Reynolds stress). The stress tensor is given by following equation:

                        
                           (1)
                           
                              
                                 
                                    τ
                                    total
                                 
                                 =
                                 
                                    μ
                                    eff
                                 
                                 
                                    (
                                 
                                 
                                    (
                                    ∇
                                    U
                                    +
                                    
                                       
                                          (
                                          ∇
                                          U
                                          )
                                       
                                       T
                                    
                                    −
                                    
                                       
                                          1
                                          2
                                       
                                    
                                    I
                                    
                                       (
                                       ∇
                                       .
                                       U
                                       )
                                    
                                    )
                                 
                                 ,
                              
                           
                        
                     with the effective viscosity being defined by

                        
                           (2)
                           
                              
                                 
                                    μ
                                    eff
                                 
                                 =
                                 μ
                                 +
                                 
                                    μ
                                    T
                                 
                              
                           
                        
                     
                  

where μ is the viscosity of the fluid and μT
                      is the turbulent viscosity of the fluid. The calculation of the turbulent viscosity depends on the turbulence model applied to the problem. In this work the standard 
                        
                           k
                           −
                           
                              ɛ
                           
                        
                      model is applied. Consequently, the coefficient of turbulent viscosity is given by:

                        
                           (3)
                           
                              
                                 
                                    μ
                                    T
                                 
                                 =
                                 ρ
                                 C
                                 
                                    
                                       K
                                       2
                                    
                                    
                                       ɛ
                                    
                                 
                                 .
                              
                           
                        
                     
                  

Since the magnitude of 
                        
                           τ
                           total
                        
                      calculated from Eq. (1) is typically a nodal quantity, it is necessary to convert the nodal value into an elemental variable for the optimization method. For this, the nodal value was converted to an elementary variable calculated by frequency distribution called weighted shear stress (SSTw
                     ). The SSTw
                      calculation takes into account the frequency points at certain intervals of shear stress values. These points become more relevant to the SSTw
                      calculation for high values of frequency and shear stress.

The second a posteriori performance parameters considered in this work is the dispersion of the residence time distribution (RTD), an important aspect affecting the performance of a chemical reactor. This is crucial in continuous large scale reactors because of the increased possibilities of having phenomena such as, for instance, short-circuiting and internal recirculation making reactants to spend insufficient or excessive time within the reactor, even though the average residence time may still be matching the ideal value [7, 13, 14]. In other words, a perfect geometric configuration and operation conditions would produce streamlines over which any fluid element would travel in the exact same time as the ideal residence time defined by the kinetics of the chemical reactions taking place in the reactor. Under these circumstances the residence time distribution collapses to a Dirac delta function and its dispersion tends to zero. In an actual reactor this cannot be, at least due to the boundary layers, and residence times associated with each streamline tend to disperse around an average value. In addition, since the actual average residence time can only be calculated a posteriori, i.e. after the entire flow field is known, it may not even coincide with the theoretical average residence time calculated by dividing the reactor volume by the volumetric flow rate.

In this work RTD probability distributions E(t) were obtained by the concentration method: a non-reacting non-diffusing tracer is injected into the reactor's inlet and its concentration is measured over the time at the outlet producing the function C(t). Further assumptions are that the reactor is operating in steady state and the tracer does not modify the fluid or the flow field. Dyes and radioactive substances along with inert gases are the most commonly used tracers in practice. The most common method of injection is the pulse input δ(t) because of its practical simplicity and also due to its good mathematical properties in deconvolving E(t) from C(t). This being, E(t) is related to C(t) through the following equation:

                        
                           (4)
                           
                              
                                 E
                                 
                                    (
                                    t
                                    )
                                 
                                 =
                                 
                                    
                                       C
                                       (
                                       t
                                       )
                                    
                                    
                                       
                                          ∫
                                          0
                                          ∞
                                       
                                       
                                          C
                                          (
                                          t
                                          )
                                          d
                                          t
                                       
                                    
                                 
                              
                           
                        
                     
                  

This simple relation allows the calculation of the (actual) average residence time τ and the corresponding standard deviation σ through the following integrals:

                        
                           (5)
                           
                              
                                 τ
                                 =
                                 
                                    1
                                    
                                       
                                          ∫
                                          0
                                          ∞
                                       
                                       
                                          C
                                          (
                                          t
                                          )
                                          d
                                          t
                                       
                                    
                                 
                                 .
                                 
                                    ∫
                                    0
                                    ∞
                                 
                                 
                                    t
                                    .
                                    C
                                    (
                                    t
                                    )
                                    d
                                    t
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    σ
                                    2
                                 
                                 =
                                 
                                    1
                                    
                                       
                                          ∫
                                          0
                                          ∞
                                       
                                       
                                          C
                                          (
                                          t
                                          )
                                          d
                                          t
                                       
                                    
                                 
                                 .
                                 
                                    ∫
                                    0
                                    ∞
                                 
                                 
                                    
                                       
                                          (
                                          t
                                          −
                                          τ
                                          )
                                       
                                       2
                                    
                                    .
                                    C
                                    
                                       (
                                       t
                                       )
                                    
                                    d
                                    t
                                 
                              
                           
                        
                     
                  

The reactor optimization problem consists in simultaneously minimizing SSTw
                      and σ
                     2 by modifying the parameters defining the reactor's geometry, i.e. the inlet angle (α) and the height of the outlet tube (Hout
                     ). This is achieved automatically by the PyCFD-O package through a multiobjective evolutionary algorithm (MOEA). A large number of simulations and, hence, a considerable computational effort, is intrinsic to any MOEA in order to explore the entire design space. Since the objective values associated with each set of design parameters can be evaluated independently, a natural way of speeding up the optimization problem is to implement the numerical simulations in parallel, using several processors, as described in Section 4.4.

A multiobjective optimization problem consists in optimizing (i.e. minimizing or maximizing) several objectives functions simultaneously, with a number of inequality or equality constraints. In mathematical terms, a multiobjective optimization problem can be formulated as:

Find 
                        
                           X
                           =
                           (
                           
                              x
                              i
                           
                           )
                        
                     
                     
                        
                           ∀
                           i
                           =
                           1
                           ,
                           2
                           ,
                           .
                           .
                           .
                           ,
                           
                              N
                              
                                 p
                                 a
                                 r
                                 a
                                 m
                              
                           
                        
                      such as fi
                     (X) is a minimum (respectively maximum) 
                        
                           ∀
                           i
                           =
                           1
                           ,
                           2
                           ,
                           .
                           .
                           .
                           ,
                           
                              N
                              
                                 o
                                 b
                                 j
                              
                           
                        
                      subject to:

                        
                           (7)
                           
                              
                                 
                                    g
                                    j
                                 
                                 
                                    (
                                    X
                                    )
                                 
                                 =
                                 0
                                 
                                 ∀
                                 j
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 M
                                 ,
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    h
                                    k
                                 
                                 
                                    (
                                    X
                                    )
                                 
                                 ≤
                                 0
                                 
                                 ∀
                                 k
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 N
                                 ,
                              
                           
                        
                     where X is a vector containing the Nparam
                      design parameters, 
                        
                           
                              (
                              
                                 f
                                 i
                              
                              )
                           
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              
                                 N
                                 
                                    o
                                    b
                                    j
                                 
                              
                           
                        
                     are the objective functions and Nobj
                      is the number of objectives. An element x* ∈ X is called a feasible solution or decision variable and the functions gj
                      and hk
                      are generally called a constraint function. The solution space Xis usually restricted by a series of constraints and bounds on the decision variables. In other words, upper and lower limits are imposed on all parameters:

                        
                           (9)
                           
                              
                                 
                                    x
                                    i
                                 
                                 ∈
                                 
                                    [
                                    
                                       x
                                       
                                          i
                                          ,
                                          min
                                       
                                    
                                    ,
                                    
                                       x
                                       
                                          i
                                          ,
                                          max
                                       
                                    
                                    ]
                                 
                                 ,
                                 
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 
                                    N
                                    
                                       o
                                       b
                                       j
                                    
                                 
                                 .
                              
                           
                        
                     
                  

The objective function 
                        
                           
                              (
                              
                                 f
                                 i
                              
                              
                                 (
                                 X
                                 )
                              
                              )
                           
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              .
                              .
                              ,
                              
                                 N
                                 
                                    o
                                    b
                                    j
                                 
                              
                           
                        
                      returns a vector containing the set of Nobj
                      values associated with the elementary objectives to be simultaneously optimized. In this study, two design parameters 
                        
                           (
                           
                              N
                              
                                 p
                                 a
                                 r
                                 a
                                 m
                              
                           
                           =
                           2
                           )
                        
                      and two objectives 
                        
                           (
                           
                              N
                              
                                 o
                                 b
                                 j
                              
                           
                           =
                           2
                           )
                        
                      are considered.

In many real-life problems, objectives under consideration conflict with each other. Hence, optimizing Xwith respect to a single objective often results in unacceptable results with respect to the other objectives. Therefore, a perfect multiobjective solution that simultaneously optimizes each objective function is almost impossible. A reasonable solution to this type of multiobjective problem is to search for the so-called non-dominant solutions, which will be elaborated in the sequel.

The simplest way to solve multiobjective problem is to use a trade-off between the objectives by linearly combining them using some fixed weights prescribed by the user [10, 20]. The resulting single objective function is optimized by either a classical gradient-based or a simplex method [25, 34]. However, this simplification of the problem has some limitations. For instance, the choice of the weights associated with each objective obviously changes the solution of the optimization problem. A bad choice can lead to completely sub-optimal results in comparison with the solution obtained when inter-related objectives were considered in an independent manner. Moreover, this method does not allow the access to the whole set of optimal solutions.

In the case of a set of solutions X to the true multiobjective problem 
                        
                           
                              (
                              
                                 f
                                 i
                              
                              
                                 (
                                 X
                                 )
                              
                              )
                           
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              .
                              .
                              ,
                              
                                 N
                                 
                                    o
                                    b
                                    j
                                 
                              
                           
                        
                      comparing each solution xi
                      ∈ X is more complex task. The set of parameters X can be compared according to Pareto's rule [10]. For instance, if all objective functions are for minimization, a feasible solution x
                     1 is said to dominate another feasible solution x
                     2(x
                     1 > x
                     2), if and only if, fi
                     (x
                     1) < fi
                     (x
                     2) for 
                        
                           i
                           =
                           1
                           ,
                           .
                           .
                           .
                           ,
                           
                              N
                              
                                 o
                                 b
                                 j
                              
                           
                        
                     . A solution is said to be Pareto optimal if it is not dominated by any other solution in the space. In other words, a Pareto optimal solution cannot be improved with respect to any objective without worsening at least one other objective. The set of all feasible non-dominated solutions in X is referred as the Pareto optimal set, the corresponding objective function values in the objective space is called Pareto front.

Generating the Pareto set can be computationally expansive and is often infeasible, because the application of exact optimization methods is inadequate. For this reason, a number of stochastic search strategies, such as simulated annealing and evolutionary algorithms, have been developed. The application of these methods usually do not guarantee to identify optimal trade-offs, but result in good approximations, i.e., a set of solutions whose objective vectors are not too far away from the optimal objective vectors.

Since 1970s several evolutionary methodologies have been proposed, mainly genetic algorithms (GA) and evolution strategies [3]. These approaches operate on a set of candidate solutions. Using strong simplifications, this set is subsequently modified by two basic principles: selection and variation. Selection mimics the competition for reproduction and resources, the other principle, variation, imitates the natural capability of creating new individuals x′s by recombination (crossover) and mutation.

The GA has been the most popular heuristic approach to multiobjective design and optimization problems [19]. GA is based on an analogy with Darwin's laws of natural selection [15]. The ability of a GA to simultaneously search different regions of a solution space makes it possible to find a diverse set of solutions for difficult problems with non-convex, discontinuous, and multi-modal solutions spaces.

The set of coupled numerical tools used to solve the multiobjective optimization problem is now described and schematically shown in Fig. 3
                     .

PyCFD-O (python CFD optimization) is an object-oriented python code for Unix/Linux systems developed to couple CAD/computer aided engineering (CAE) tools, multiobjective optimization and computational fluid dynamics (CFD) software. It can be summarized in six stages, as shown in Fig. 3:
                        
                           
                              1.
                              Parametric CAD: In this stage the initial design variables are set or are updated from the obtained values of the optimization method in order to generate the geometry (CAD preparation).

Mesh generation: With the geometry defined the mesh generation is started. The PyCFD-O allows the usage of the OpenFOAM native meshing software and the SALOME software [26]. SALOME is an open-source software that provides a platform for pre and post-processing for numerical simulation allowing the integration into heterogeneous systems. PyCFD-O checks if the mesh has been successfully generated and the mesh quality before the CFD simulation.

Pre-processing: This stage is responsible to setup the CFD solver with the flow specifications and also to setup the parallel processing of the solver.

CFD solver: Execution of the OpenFOAM [27] to solve the configured flow simulation.

Post-processing: After the completion of the CFD solver, the correct execution and convergence of the simulation are checked. If all went well the software performs the data extraction and calculates the optimization parameters that will be needed in the optimization method. If not, the same geometry is executed again changing some parameters, such as mesh thickness, until the execution returns successful.

Optimization method: The optimization parameters are exported and the optimization method completes the execution and returns, if necessary, the new population of the geometry parameters to be evaluated. PyCFD-O has implemented two optimization methods in python: NSGA-II [10,11] and a generic evolutionary multiobjective optimization method. However the package allows the implementation and integration of others optimization methods. If possible, each individual of the population is evaluated in parallel. PyCFD-O works with parallel processing in clusters with PBS (Portable Batch System) to perform job scheduling.

The NSGA-II (Nondominated Sorting Genetic Algorithm) algorithm was proposed by Deb [10,11] and is a GA based on the obtaining of a new offspring population from the original one by applying the typical genetic operators (selection, crossover, and mutation). The individuals in the two populations are sorted according to their rank and the best solutions are chosen so that a new population is created. In the case of selection of individuals with the same rank, a density estimation based on measuring the crowding distance to the surrounding individuals belonging to the same rank is used to get the most promising solutions.

NSGA-II is a generational algorithm, in which there is a current population that is used for creation of an auxiliary one (the offspring population). Both populations are then combined for obtaining of the new current population. Typically, both the current and the auxiliary populations have the same size.

An alternative to a generational GA is a steady state GA, which basically means that there is only a population, without using an auxiliary one. Therefore, new individuals are incorporated immediately in the evolutionary cycle and parents and offspring coexist in the same population. As a consequence, steady state GAs are characterized by an increased search capability in the solution space.

A steady state version of NSGA-II can be easily implemented by an offspring population of size 1, i.e. the ranking and crowding procedures must be applied whenever a new individual has been created. Therefore the computational complexity of the algorithm will increase notably.

In the present case, the evaluation of the objectives functions relies on the open-source software Salome, for geometry and mesh generation, and OpenFOAM for solving the flow and transport equations. Therefore, the evaluation of an individual set of parameters requires four steps:

                           
                              1.
                              generation of the geometry from the design variables;

generation of an appropriate mesh for the previously generated geometry;

CFD simulation, i.e. solution of the governing coupled flow and transport equations on the mesh generated in the previous step;

post-processing of the results for the calculation of the values of the objective functions for the specific design variables.

Steps 1 and 2 were performed using the open-source software SALOME, where the mesh used was tetrahedral. In the step 3 a transient solver to monophasic, incompressible and turbulent flow was implemented in OpenFOAM. Step 4 was developed in python (pyCFD-O).

As shown in Fig. 2 the geometry parameters used to study the fluid dynamic of the bioreactor are the inlet angle (α) and outlet height (Hout
                           ). The geometry constraints are prescribed in terms of lower and upper limits to the optimization parameters to allow the optimizer to deal only with practical shapes.

                              
                                 (10)
                                 
                                    
                                       
                                          α
                                          min
                                       
                                       ≤
                                       α
                                       ≤
                                       
                                          α
                                          max
                                       
                                       ,
                                       
                                       were
                                       
                                       
                                       α
                                       ∈
                                       
                                          [
                                          
                                             0
                                             ∘
                                          
                                          ,
                                          
                                             90
                                             ∘
                                          
                                          ]
                                       
                                       ;
                                    
                                 
                              
                           
                           
                              
                                 (11)
                                 
                                    
                                       
                                          H
                                          
                                             o
                                             u
                                             t
                                          
                                          min
                                       
                                       ≤
                                       
                                          H
                                          
                                             o
                                             u
                                             t
                                          
                                       
                                       α
                                       ≤
                                       
                                          H
                                          
                                             o
                                             u
                                             t
                                          
                                          max
                                       
                                       ,
                                       
                                       were
                                       
                                       
                                       
                                          H
                                          
                                             o
                                             u
                                             t
                                          
                                       
                                       ∈
                                       
                                          [
                                          0.1
                                          ,
                                          1.3
                                          ]
                                       
                                       .
                                    
                                 
                              
                           
                        

After the definition of the geometry the mesh is automatically produced by SALOME through the modification of the journal file containing the important geometrical parameters as variables. The knowledge on α and Hout
                            is sufficient for a full definition of the geometry and the automatic generation of the mesh. PyCFD-O checks if the mesh has been successfully generated before the CFD computation, which is a problem for a complex three-dimensional configuration. If some error occurs in mesh generation, PyCFD-O automatically changes some parameters and regenerates a new grid with the same geometry. A typical example of a resulting grid is shown in Fig. 4
                           . The internal fluid region is meshed by tetrahedral cell elements using the NETGEN algorithm of SALOME. The typical number of tetrahedral cells in a mesh lies between 200, 000 and 610, 000.

The PyCFD-O code now starts OpenFOAM automatically using python scripts. The inlet boundary is set to 
                              
                                 
                                    u
                                    
                                       i
                                       n
                                       l
                                       e
                                       t
                                    
                                 
                                 =
                                 1
                                 
                                 
                                    m
                                    /
                                    s
                                 
                              
                            and the fluid is water at 30 oC (303.15 K). Wall boundary conditions are considered to be no-slip and the outlet boundary flux was set to 0 m2/s2. The discretized governing equations are solved iteratively in a segregated manner and using a finite-volume description [18, 27]. The problem is transient and the Euler method is applied. The residual error for the flow equation is 
                              
                                 10
                                 
                                    −
                                    6
                                 
                              
                           . The velocity–pressure coupling is treated with the standard PISO pressure-correction method. A total period of 200 s of flow was simulated. A mesh study has been carried out considering the bioreactor discharge and the velocity profile in which errors of less than 4% and 6% were obtained respectively.

After the CFD computation, PyCFD-O calculates the variance of the distribution of residence times and weighted average of the shear stress. These two parameters are the two objectives of the optimization problem.

As previously mentioned, an important issue related to genetic algorithms (GAs) is the high computation effort necessary for performing evaluations of the objectives associated with the population. The evaluation of a large number of individuals for a large number of generations can lead to unaffordable CPU times in practical engineering cases. On the other hand, GAs is easily and efficiently parallelizable. At each generation, all N individuals can be evaluated independently on different processors, since the central algorithm requires only the values of the objectives to iterate. In the current case, the parallelization was implemented by python interfacing program (see Fig. 3) responsible for the evaluation of the 
                        
                           
                              N
                              
                                 o
                                 b
                                 j
                              
                           
                           =
                           2
                        
                      values associated with the N configurations. A master-slave paradigm [15] was retained by the message passing interface (MPI) communication with python. All the evaluations were carried out on a SGI Linux cluster running under SUSE Linux Enterprise Server 11. Table 4
                      shows the SGI cluster specifications.


                     Fig. 5
                      shows a schematic description of this multi-processor optimization procedure. The master-slave paradigm involves two sets of processors. The master that is responsible for pre- and post-processing of work orders, and the slave procedures that are responsible for the actual execution of the orders (CFD solver execution). The CFD solver in each node is also executed in parallel through the proper tools provided by OpenFOAM for the decomposition of the mesh. Typical results leading to Pareto fronts can be extracted from these calculations and are presented and discussed in the next section.

Alternatively, if one CFD simulation requires a lot of computational effort (memory and time), each evaluation could be performed in parallel. In this situation, more than one node would simultaneously collaborate in the evaluation of one single CFD evaluation.

In the next sections, a description of the influence of the geometric parameters on the DTR is showed followed by a discussion of the preliminary investigations of the design space. In this section, it is also presented the parallel processing analysis to reduce the computational time required to optimize the bioreactor design parameters. Finally discussions about the non-dominated designs are presented with a discussion on the optimized geometries.

A preliminary investigation was carried out to determine the influence of the geometric parameters α and Hout
                      on the hydrodynamics behavior of the problem being examined. The aim was to analyze how the geometric parameters affected the DTR and SST. In order to execute the tests five geometries of different α and Hout
                      were analyzed, as showed in Table 5
                     . The total time of computational flow simulation was 500 s.


                     Fig. 6 shows the comparison of the RTD curves obtained using the CFD predictions. Table 6
                      shows the mean residence time (τ), variance (σ
                     2) and weighted shear stress.

The results in Fig. 6 show that the asymptotic portion of curve E(t) at high values of the mean residence time τ (Table 6) indicates the presence of dead zones in the reactor. It also can be seen that the curve E(t) shows the presence of channeling (bypassing or short-circuits). The short-circuit effects are more evident in Fig. 6
                     
                     C, curve 90_0.1. The short-circuit in geometry 90_0.1 results in a large variance (σ
                     2) (Table 6). The variance magnitude is an indication of the “spread” of the residence time distribution [13]. In geometries with short-circuits there is little or no exchange of material with the well-mixed regions, and, consequently, virtually no reaction occurs there. The stagnant zones keep the material inside the reactor for longer than the required time for the reaction to take place. In both cases, stagnant zones and/or short-circuits, the chemical reaction is less efficient and the overall performance of the reactor is reduced. Geometry 0_1.3 shows the smallest variance, as it can be seen in Table 6 and represented in Fig. 6, curve 0_1.3. However, geometry 0_1.3 does not show the lowest SST. The effect of shear stress for the optimal design of PBRs is very important due to the algae survival [21]. In this way, coupled computational fluid dynamics and multiobjective design optimization methods become an interesting tool for obtaining an optimal bioreactor.

The influence of the geometric parameters on the flow behavior can be inferred from the streamlines and from fluid tracer distribution isosurface, as showed in Figs. 7 and 8. The inlet angle α contributes to an organized flow inside the bioreactor.

In order to reduce the total computation time, the process was parallelized and carried out on a multi-node Linux PC cluster, as discussed in Section 4.4. The first analyses compare the OpenFOAM parallelization to execute 50 iterations of the solver. Fig. 9
                      shows the processing time and the speed-up obtained on the SGI Monalisa cluster and Pegasus workstation. Pegasus workstation configuration is Core i7 3930K, 3.2 GHz, 12MB cache with 32GB of RAM and GPU Nvidia GTX 590.

The speed-up is defined here as the ratio between the wall-clock time obtained when using Nproc
                      processors compared to the one needed with a single processor. The theoretical optimal value of the speed-up using Nproc
                      processors is Nproc
                     . In practical cases, the communication times between processors reduce the speed-up value to below the theoretical maximum. In the present case, the parallel speed-up obtained is nearly optimal. This is not a surprise, since the quantity of information transferred is small since each node is responsible to solve a single geometry.

The other analyses involved the parallelization of the optimization method. On Monalisa workstation the computational cost of the CFD solver of a geometry running in parallel in a node with 32 cores is approximately 20 h (mesh with approximately 600,000 elements). The computational complexity of NSGA-II is O(MN
                     2), where M is the number of objectives and N is the population size. With 
                        
                           M
                           =
                           2
                        
                      and 
                        
                           N
                           =
                           10
                        
                      the computational complexity is 200, i.e. 200 evaluations of the solver are necessary. This means that, if each geometry required for the optimization method should be solved sequentially, the necessary processing time would approximately 170 days. With master-slave parallelization as described in Section 4.4, it is possible to reduce almost linearly the total processing. More specifically, for instance, the total processing time can be reduced to 43 days using 4 nodes.

After some tests, 4 compute nodes were employed for the evaluations and the GA was optimized using 10 individuals at every generation. The parents in the first generation are generated by a random method. The non-dominated individuals at each generation belong to the elite group. The crossover probability is 50% and the mutation probability is 50% and the number of generations adopted was 10. The input values and the corresponding results for each design tested in the PyCFD-O are kept in a database created along the optimization process. The user can manipulate this data, generate plots and perform advanced analysis on any combination of parameters.

The two optimization objectives (σ
                     2 and SSTw
                     ) are plotted against each other, as shown in Fig. 10. A trade-off line, i.e. the candidate Pareto front as described earlier on Section 3, can be identified along which the best designs are located. Furthermore, the chart also shows the design IDs concentrated along the candidate Pareto frontier where seven geometries were found. Table 7
                      shows
                     
                     
                     
                      the non-dominated solutions of the problem. The final design must be a compromise between DTR and shear stress. This is typical of multiobjective problems involving contradictory objectives. The performed evaluations allowed for the establishment of a general tendency and for the definition of the influence of each parameter on the estimated values.

Considerable variations have been tested by the optimization procedure, exploring the whole parameter space before identifying the best solution, as can be seen in the Fig. 11. Such large variations would certainly not have been considered by manual optimization. The automatic optimization required in this case a considerable computing time but lead to a reduction of the variance (σ
                     2) by 47% and the SSTw
                      by 48%, compared with the worst feasible baseline configuration. The performed evaluations allowed for the establishment of a general tendency and for the definition of the influence of each parameter on the estimated values.

Three different optimal geometries with the corresponding streamlines are presented in Fig. 12. The flow configuration shown in Fig. 12A corresponds to a low variance, but with high SSTw
                     . Higher variance is brought about by a near tangential angle 
                        
                           (
                           α
                           =
                           
                              90
                              ∘
                           
                           )
                        
                      shown in Fig. 12C, although in these cases the SSTw
                      tend to be smaller. Fig. 13 shows the DTR curves for these three cases. It is possible to observe the presence of short-circuits in the geometry 87.3_1.19 (Fig. 13) which reflects the higher variance value σ
                     2. Geometries 43.5_1.15 and 62.7_1.28 have better behaved RTD curves (unimodal distributions in Fig. 13) reflecting in a good flow distribution. Thus, depending on the specific engineering requirements of the problem it is possible to choose one of the optimized geometries with higher or lower variance and shear stress, or to choose a trade-off combination of both parameters, such as the one shown in Fig. 12B.


                     Figs. 14 and 15 show the relationship between the optimizations parameters and the geometric parameters of the reactor (angle and H
                     out). Fig. 14 indicates that for a minimum RTD variance the injection angle α and the height of the outlet tube H
                     out should be around 60–80º and 1.2–1.3 meters, respectively. Fig. 15 shows the correlation between αand H
                     out in function of the weighted SST. The surface presents the lowest values of the weighted SST with higher values of the H
                     out and α. The high values of shear stress for the geometries with a near tangential inlet 
                        
                           (
                           α
                           =
                           
                              0
                              ∘
                           
                           )
                        
                      are due to a high entrance velocity of the fluid which causes high shear stress rates with the reactor wall. These results suggest, as a general trend, that optimal design parameters lay between 60° ≤ α ≤ 80° and 1.2 m ≤ Hout
                      ≤ 1.3 m, in regard of minimum RTD variance and SSTw
                      simulations objectives.

@&#CONCLUSIONS@&#

The main objective of this work was to develop a multiobjective optimization procedure for the design of industrial reactors, based on a posteriori performance parameters calculated from CFD flow simulations. An open source software (PyCFD-O) was developed allowing to couple CFD models to an optimization heuristics based on a multiobjective genetic algorithm in which the non-dominant Pareto solutions are the best fit ones. Since exploratory search methods have intrinsically high computation costs, several parallelization strategies were implemented to reduce the overall simulation time.

A test case was studied to demonstrate the possibilities of the proposed optimization method. More specifically, the design of a ∼1 m3 continuous flow fermenter (Fig. 2) for the conversion of sucrose into ethanol in a sugarcane mill was optimized in regard of two antagonistic performance parameters: dispersion of the residence times and averaged shear stress. Optimal multiobjective design solutions were obtained in terms of two geometric parameters: injection angle between 60° ≤ α ≤ 80° and outlet tube height between 1.2m ≤ Hout
                      ≤ 1.3 m, which are actually the non-dominant configurations in the solutions space.

Although multidisciplinary optimization methods are commonly used in many areas of engineering, its application to rector design, and particularly to industrial bioreactors, is a highly innovative research area.

@&#ACKNOWLEDGMENTS@&#

The authors are grateful to CAPES (Coordenação de Aperfeiçoamento de Pessoal de Nível Superior) and FAPESP (Fundação de Apoio a Pesquisa do Estado de São Paulo, proc. 2010/00442-5) for the financial support given to this research.

@&#REFERENCES@&#

