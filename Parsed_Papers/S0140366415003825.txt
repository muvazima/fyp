@&#MAIN-TITLE@&#PrivHab+: A secure geographic routing protocol for DTN

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           PrivHab+ is a secure geographic routing protocol that learns the habits of the nodes.


                        
                        
                           
                           PrivHab+ compares nodes and selects the best to carry a message towards a location.


                        
                        
                           
                           PrivHab+ makes use of cryptographic techniques to preserve nodes’ privacy.


                        
                        
                           
                           PrivHab+ performance is studied under the scope of a podcast distribution application.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Opportunistic networking

Delay-Tolerant networking

DTN routing

Georouting

Privacy

@&#ABSTRACT@&#


               
               
                  We present PrivHab+, a secure geographic routing protocol that learns about the mobility habits of the nodes of the network and uses this information in a secure manner. PrivHab+ is designed to operate in areas that lack of network, using the store-carry-and-forward approach. PrivHab+ compares nodes and chooses the best choice to carry messages towards a known geographical location. To achieve a high performance and low overhead, PrivHab+ uses information about the usual whereabouts of the nodes to make optimal routing decisions. PrivHab+ makes use of cryptographic techniques from secure multi-party computation to preserve nodes’ privacy while taking routing decisions. The overhead introduced by PrivHab+ is evaluated using a proof-of-concept implementation, and its performance is studied under the scope of a realistic application of podcast distribution. PrivHab+ is compared, through simulation, with a set of well-known delay-tolerant routing algorithms in two different scenarios of remote rural areas.
               
            

Many initiatives have been implemented to improve the life conditions of people living in developing countries by universalising the access to knowledge and information. These applications usually target rural areas and are very likely to deal with challenges like a sparse population, and a lack of data communication networks.

The need of infrastructure constrains the reach of these applications, because they cannot operate in regions lacking it. It happens that regions where the communication networks are unavailable or spotty, are usually the ones where these services would be more needed and valuable. Delay Tolerant Networking (DTN), based on the store-carry-and-forward strategy, is designed to operate in these challenged scenarios. DTN deals with the absence of simultaneous end-to-end paths [3] through the usage of mobile devices that opportunistically establish contact and exchange messages between them.

Routing protocols designed to operate in DTN scenarios usually generate and use information about node behaviours, as the historic of contacts established with each other node [27]. Then, they share this information with neighbours in order to improve the decision making [26]. Moreover, in some cases, a node is linked to a person, e. g. because it is carried in a pocket or backpack [31], or because they travel in the same vehicle. Therefore, the information that routing protocols use and share can be seen as private information about people’s whereabouts or frequent behaviours. The more accurate and sensitive this information is, the more useful it is for the routing protocol, the more important is to protect its privacy [2]. Accordingly, a protocol that protects the privacy of this information expands the amount of scenarios where it can be used [13].

Our main contributions are summarised below:

                        
                           •
                           We introduce the concept of node’s habitat, the area where a node is more likely to be found. The habitat is built by exploiting the life-cycles of the network users. It is a very useful tool for making routing decisions by comparing two nodes’ habitats and selecting the best choice to deliver a message to its destination. We use an elliptic model of habitat to allow devices of small capabilities to work and to operate with it.

We define PrivHab+, a novel DTN secure geographical routing protocol designed to operate in areas without network infrastructure. PrivHab+ uses the learnt information about the usual whereabouts of the nodes to find the best neighbour to carry the messages. PrivHab+ protects node’s privacy by cryptographically protecting this information to avoid its disclosure.

The rest of this article is organised as follows. In Section 2, reviews the state of the art and provides a description about some related work of Geographical Routing Protocols, Secure Routing Protocols and Social-based Routing Protocols. In Section 3, we present the habitat, a useful information to compare nodes while routing messages. We explain how it is modelled and updated. Later, we introduce the concepts of homomorphic cryptography and Taxicab geometry, both needed to preserve nodes’ privacy while routing using the habitat. In Section 4.5, we present PrivHab+, a routing protocol that uses the habitats of the nodes to route messages while preserving the privacy of the nodes of the network. In Section 5, we analyse the knowledge obtained by each participant of the protocol and we reason about the privacy that PrivHab+ provides. In Section 6, we present the proof-of-concept we have implemented, and we use it to measure the performance of PrivHab+. In Section 7, we expose the results of the simulations that compare PrivHab+ with a set of well-known DTN routing protocols. Finally, Section 8 concludes this paper.

@&#RELATED WORK@&#

In this section, we provide the reader with a review of the related work. First, we present the state of the art of Geographical Routing Protocols. Later, we analyse the different proposals of Secure Routing Protocols in Delay Tolerant Networks. Then, we review some Social-based Routing Protocols that are related, somehow, to our proposal. Finally, we provide some conclusions about the study of the state of the art.

Geographical Routing Protocols have been studied both in Ad-hoc Networks and Delay Tolerant Networks. Most protocols, like GPSR [19] a protocol with support to Wireless Sensor Networks (WSN), always forward packets to the next hop that is geographically closest to the destination at the moment of the transmission. This approach becomes non useful when nodes cannot form a simultaneous path towards the destination and have to carry the packet until the next encounter. Besides, GPSR only takes into account the position of the nodes at the moment of the transmission, but not their movement. In [1], GPSR is modified to adapt it to DTN by being energy-efficient. However, messages are routed in the basis of a neighbourhood table that does not adapt well to a scenario where the topology of the network changes quickly. Using LAROD [23], nodes forward packets to neighbours inside a certain area located between the forwarder and the destination, without taking into account the mobility patterns of these nodes. In [24], a Location Service called LoDIS is presented to improve LAROD by using gossip-based techniques to update the location of the destination at each hop. Using LoDIS, the performance of the routing is greatly improved, but the privacy of all nodes results heavily damaged because their locations and speed vectors are periodically broadcasted. Moreover, LoDIS uses the speed vector of the nodes to predict their short-term future locations. This model loses precision in networks where the latencies are big due to a low level of connectivity, or because the packets travel big distances before reaching their destination. MoVe [25] is a routing protocol designed to work in Vehicular Networks where nodes forward messages to a neighbour if the neighbour is expected to come closer to the destination. In MoVe, nodes exchange information to determine whether the message shall be forwarded. Nodes use the speed vectors to make routing decisions. This information is not protected and does not take into account the recent past to infer routines or typical movement patterns. GeoDTN+Nav [6] is designed for routing in a network of streets, and it has three forwarding modes. In the DTN mode, it requires the nodes to know where they are heading. This requirement can be easily met by certain types of vehicles, like buses or taxis, but it is not reasonable with other types of nodes (e.g. nodes carried by walking people).

Most Secure Routing Protocols aim to protect the routing algorithm’s performance against malicious behaviours [18]. By design, it supposes that nodes voluntarily share any intimate information (battery level, state of the buffer, current location, speed vector, most visited places, past encounters with neighbours, etc.) for the good of the network. These protocols usually consider that the only thing that has to be protected is the performance of the network. Besides, some Secure Routing Protocols, as SEAD [15], provide end-to-end security services to the contents of the messages, such as integrity, authentication, non-repudiation or confidentiality. Unfortunately, there are little proposals of routing algorithms that respect and protect the privacy of all the nodes that form the network. A system called ALAR, presented in [29], allows a source to send a message through a DTN without revealing its physical location and proposes an anti-localisation routing protocol. However, the only information that ALAR protects is the location where the source was when the message was sent. This proposal is incomplete because it only protects one concrete information. However, it proves that, in certain scenarios, nodes are unwilling to share all their information for the good of the network. For this reason, nodes privacy has to be protected. In Ad-hoc Networks, there is a mechanism designed to protect the privacy of the nodes. Pseudonym generators such as [17,4] provide anonymity to the nodes of the network by breaking the relation between nodes and identifiers. This way, an observer cannot gather enough information to learn the behaviour of a node. Pseudonyms change over time, and it is difficult to relate the new ones with the past ones. However, these mechanisms are not compatible with routing protocols where nodes need to share information with their neighbourhood. Hence, the usage of one of these mechanisms indirectly decreases the performance of the network, because they restrict the routing protocols that can be used. Some mechanisms, as the one presented in [43], only protect, by design, the identities of the sender and the receiver of the message. Other Secure Routing Protocols for Ad-hoc Networks, as the one presented in [7] and [33], are based on symmetric key cryptography or hash functions, and on source routing or distance vector protocols. This approach is unsuitable for DTN. An anonymous communication solution for DTN has been presented in [20], but it is designed to hide the identity of the nodes, not to protect the private information that these nodes use to make routing decisions.

There are some Social-based Routing Protocols that are related, somehow, to the present work. Social-based routing protocols are based on the idea of using the recent past to model the behaviour of a node and predict how it will behave in the near future. BUBBLE RAP [16] classifies nodes using their popularity inside their community. Then, messages are forwarded to more popular nodes until they reach the community of the destination. Its design is not good to send messages to hop-distant destinations because locations are not considered. So, during the first hops messages can be carried into the opposite direction of their destination while they are forwarded to more popular nodes. MobySpace [26] leverages the life-cycles of the nodes to track what points of interest are more visited by every node. These life-cycles are modelled this using a multi-dimensional probability vector, and messages are forwarded to nodes with a vector closer to the one of the destination. The classic Euclidean distance is used to measure the distance between vectors. This is a very interesting approach to our concept of habitat, but lacks adaptability. In MobySpace, the points of interest have to be defined a priori by an external agent, and some infrastructure is needed to allow nodes to detect if they are close or not to one of these points. Besides, MobySpace may lead to situations where a node that spends most of the time at point A, very close to B, is considered a bad choice because the destination is expected to be on B, without taking into account that A is near B. SANE [31] uses these same principles but defines the points of interest in a very broad sense, allowing the usage of more abstract concepts, and substitutes the Euclidean distance by a metric called “cosine similarity”. HiBOp [2] extends this approach using any contextual information about nodes to make routing decisions. One of its drawbacks is the big amount of memory needed to store information about every contact. Besides, the authors do not explain how this contextual information can be updated as the behaviours of the nodes change. In [32], a general framework called CAR is presented. CAR goes one step further and not only uses the recent past to model the behaviour of a node, but it also tries to predict the future values of the attributes that define the context. However, all predictions are finally condensed in a single value, the probability of delivery. This probability is used to decide the node where every message is forwarded. This system is only useful to calculate the probability of delivery to known nodes. But it has limitations in scenarios with hop-distant destinations, where the first forwarders do not know almost anything about the destination because they never met before. CSI [14] models the spatio-temporal behaviours of the nodes using behavioural profiles, and forwards one-to-many messages through the nodes that are more similar to the destinations. Besides, the authors realise the importance of the privacy of the nodes and present a privacy-preserving mode of operation. This way the protocol can operate in scenarios where nodes are not willing to send its behavioural profiles to other nodes when needed.

Unfortunately, although at [2] the authors recognise that privacy is an important issue to consider and that more work is needed to solve it, [14] is the only one proposal that takes into account the privacy of the nodes. In all other cases, nodes are expected to broadcast their information about the locations they visit or the details about their interests to the neighbours.

@&#SUMMARY@&#

Geographical Routing Protocols are a common routing solution to Delay Tolerant Networks, but almost all proposals use contemporaneous information and short-term predictions, so they fail to take into account long-term trends of nodes’ mobility. However, in scenarios where the distances to travel are big, and the density of nodes is low, it is more valuable to know where a node will go in the next hours than where it is currently headed [34,35].

The existence of several Secure Routing Protocols that protect the privacy of the nodes, even if they are limited, proves that in DTN we cannot assume that nodes are willing to share any information for the good of the network. Given the impact of routing protocols on the performance of the network, and taking into account the sensitivity of the information they use, the fact that there are no routing protocols that protect this information is a surprise.

To our knowledge, this work is the very first proposal that combines these two fields in a Secure Geographical Routing Protocol for DTN that uses and at the same time protects participants’ private information.

Finally, our contributions, both the habitat as a model of nodes’ behaviours and the protocol used to compare it, could fit, after some adaptation, in a variety of frameworks. For example, in some of the Social-based protocols reviewed, or in Haggle [40], a more general one. Note that this only refers to a lower level, to the way nodes store and exchange information. For the sake of simplicity, we will consider a Bundle-based DTN [36] during the rest of this article.

In this section, we explain how routing protocols need to compare nodes to make decisions, and we present the tools that PrivHab+ will use. We introduce the habitat concept. Then, we show how we model it using an ellipse, how we automatically calculate it and the parameters involved in the calculations. We explain the meaning of the different parameters and how to use them. Then we analyse how we can use additive homomorphic cryptography to compare habitats while preserving the privacy of their owners, and the drawbacks of this approach. Finally, we explain how to solve these drawbacks by simply changing the usual Euclidean geometry by the Taxicab geometry.

DTN operation is based on opportunistic, usually unpredictable, contacts between pairs. Each time two or more nodes come close enough to be within communication range, an opportunity arises: messages can be forwarded between them in order to improve their probabilities of reaching their destination. At this moment, the routing protocol has to decide what messages must be relayed to what nodes. In fact, the quality of routing protocols depends on the decision they make
                           1
                        
                        
                           1
                           The quality of a routing protocol also depends on the forwarding policy. This policy is used to decide if multiple copies of a single message are created, and if the nodes keep a message after they forwarded it. We provide more discussion about this topic at the end of Section 4.5.
                        . The core of this decision-making process is an elemental operation, a comparison: given a node carrying a message and one neighbour, compare the two nodes to decide who is a better choice to carry the message towards its destination. Each time a routing protocol performs a comparison whose result is mistaken, a message will be relayed to a node that is less likely to deliver it to its destination than the previous one. This leads to a decrease of the performance of the network.

Our proposal solves the routing problem by comparing nodes using their habitat, a novel concept that takes advantage of the routine and the life-cycles of the nodes, to make routing decisions.

In a DTN, nodes may be carried by people, placed on any form of vehicle, located in a static known place, etc. Regardless of the type of the carrier, it is very likely that their mobility pattern becomes routine. For example, a static node will obviously remain immobile; a node carried by a person will probably spend a lot of time in the vicinity of the carrier’s home or workplace; a node placed on a bus will pass over and over by the same points of their route; and a node placed on a taxi will usually be inside a certain area. We can benefit on this to predict the areas they will visit on the future based on the areas they visited on the past.

This implies that every node has an habitat, the area where the node is more likely to be found. Fig. 1
                         shows a heatmap, the most usual representation of a habitat. The heatmap contains the information of the areas where a node spends more time. It is obvious that a being with a habitat like the one presented in the figure can be found, eventually, in a location where he has not been never before. However, it will be far more likely to found him in the darker areas, where he has been repeatedly in the recent past. PrivHab+ makes use of this logic. This proposal is the very first approach that makes use of this concept to design a Geographical Routing Algorithm.

Therefore, we propose a system for location-aware nodes equipped with a navigation system to periodically obtain and use their location to update their habitat. For example, Global Positioning System (GPS) receivers are relatively inexpensive and lightweight, so it is reasonable to assume that all devices in the network could be equipped with one. We propose to use a relatively simple model of habitat to allow nodes to calculate it consuming the minimum energy and computational resources, and to operate quickly with it to make routing decisions. We model each habitat using an ellipse because it is simple enough to achieve an efficient protocol. Moreover, the ellipse can represent with precision far more shapes than other considered models, as the circle, the square or the rectangle
                           2
                        
                        
                           2
                           Besides, in Taxicab geometry (it will be explained below), both the circle, the square and the rectangle are specific types of ellipses. So using the generalisation, the ellipse, we provide the tools needed to use any of these models.
                        . Additionally, the usage of a simple geometric shape allows nodes to calculate their habitat using a mobile average, this way we avoid the need for maintaining a historic of past locations.

We model each habitat H using an ellipse
                           3
                        
                        
                           3
                           Definition: the set of points such that the distance from any point in that set to a given point called focus plus the distance from that point to the other focus is equal to the ellipse’s radius
                        . Therefore, each habitat is defined by three characteristics: two focal points and a radius. From now on, we will refer as 
                           
                              F
                              1
                              =
                              (
                              
                                 x
                                 1
                              
                              ,
                              
                                 y
                                 1
                              
                              )
                           
                         and 
                           
                              F
                              2
                              =
                              (
                              
                                 x
                                 2
                              
                              ,
                              
                                 y
                                 2
                              
                              )
                           
                         to the two focal points of the habitat and we will use r to denote their radius.

We assume that every geographic coordinate (a pair latitude–longitude) can be mapped
                           4
                        
                        
                           4
                           Any cartographic projection can be used.
                         to Cartesian coordinates (x, y) and that this mapping is known by all the nodes of the network. With a frequency of ω updates/hour, all nodes obtain their location 
                           
                              L
                              =
                              (
                              x
                              ,
                              y
                              )
                              ,
                           
                         and use an exponentially weighted moving average (EWMA) to update their habitat. The habitat 
                           
                              H
                              =
                              (
                              F
                              1
                              ,
                              F
                              2
                              ,
                              r
                              )
                           
                         is updated using the previous version of the habitat 
                           
                              
                                 H
                                 
                                    o
                                    l
                                    d
                                 
                              
                              =
                              
                                 (
                                 F
                                 
                                    1
                                    
                                       o
                                       l
                                       d
                                    
                                 
                                 ,
                                 F
                                 
                                    2
                                    
                                       o
                                       l
                                       d
                                    
                                 
                                 ,
                                 
                                    r
                                    
                                       o
                                       l
                                       d
                                    
                                 
                                 )
                              
                           
                         and the current location L. The same process is used to build the habitat for the first time at system start-up and to adapt it to any changes in nodes’ behaviours.

To initialise the system, the first known location L
                           0 is used to initialise the habitat with the two focal points at the same coordinates of L
                           0 and 
                              
                                 r
                                 =
                                 0
                              
                           .

                              
                                 (1)
                                 
                                    
                                       
                                          H
                                          0
                                       
                                       =
                                       
                                          (
                                          
                                             L
                                             0
                                          
                                          ,
                                          
                                             L
                                             0
                                          
                                          ,
                                          0
                                          )
                                       
                                    
                                 
                              
                           
                        

Let F1
                              old
                            be the nearest focal point to L and F2
                              old
                            be the farthest to L focal point. The focal points of the habitat H are calculated by using EWMA to average the focal points of the previous version of the habitat Hold
                            and the current location L. This first step is depicted in Fig. 2
                           .

                              
                                 (2)
                                 
                                    
                                       F
                                       1
                                       =
                                       L
                                       *
                                       α
                                       +
                                       F
                                       
                                          1
                                          
                                             o
                                             l
                                             d
                                          
                                       
                                       *
                                       
                                          (
                                          1
                                          −
                                          α
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    
                                       F
                                       2
                                       =
                                       L
                                       *
                                       
                                          α
                                          β
                                       
                                       +
                                       F
                                       
                                          2
                                          
                                             o
                                             l
                                             d
                                          
                                       
                                       *
                                       
                                          (
                                          1
                                          −
                                          
                                             α
                                             β
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

By using β > 1, the current location L weights more when calculating the new position of the nearest focal point than when calculating the new position of the farthest focal point. This means that L attracts more the nearest focal point, modifying the habitat’s eccentricity depending on the relative position of L and Hold
                           . The higher the β used, the more will change the form factor of the habitat when new distant samples are taken
                              5
                           
                           
                              5
                              Experiments using β < 50 have shown that the form factor of the habitats hardly changes and the elliptic habitats usually tend to be quasi-circular habitats. Therefore, we recommend to use β > 50.
                           .

Let d(L, F) be the distance between L and a focal point F. Once F1 and F2 have been updated. The radius r of the habitat is updated by averaging using EWMA the old radius rold
                            and the added distances d(L, F1) and d(L, F2) between each focal point of H and L. This second step is depicted in Fig. 3
                           .

                              
                                 (4)
                                 
                                    
                                       r
                                       =
                                       
                                          (
                                          d
                                          
                                             (
                                             L
                                             ,
                                             F
                                             1
                                             )
                                          
                                          +
                                          d
                                          
                                             (
                                             L
                                             ,
                                             F
                                             2
                                             )
                                          
                                          )
                                       
                                       *
                                       α
                                       +
                                       
                                          r
                                          
                                             o
                                             l
                                             d
                                          
                                       
                                       *
                                       
                                          (
                                          1
                                          −
                                          α
                                          )
                                       
                                    
                                 
                              
                           
                        

The time span that a habitat considers is a very important parameter. For example, a reader’s habitat that considers only the last 2 hours is very likely to be a small circle around its current location. But if the habitat considers the last 24 hours, it will probably be a bigger ellipse containing both the reader’s home and the reader’s place of work. If the considered time span is one week, the reader’s habitat will also take into account the places where he or she spends the weekends, and so on.

When the time span of a habitat matches the life-cycle
                              6
                           
                           
                              6
                              Usual life-cycles of people are a day or a week. People usually move very similarly to how they moved in the previous cycle.
                            of the nodes of the network, then it will become very useful to predict the areas that the nodes will visit again in the near future.

In order to perform meaningful comparisons between habitats that consider the same time span, PrivHab+ requires the nodes of the network to know it and to calculate the parameter α using Eq. (5). Let ω be the frequency of update of the habitat in updates/hour, and let T be the time span that a habitat has to consider in hours.

                              
                                 (5)
                                 
                                    
                                       α
                                       =
                                       
                                          2
                                          
                                             T
                                             ω
                                             +
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        

Using a parameter α calculated this way, due to the characteristics of EWMA, the last Tω locations added to the average tend to weight the 86, 47% of the total. During the rest of the article, we will assume that a habitat considers a time span of T hours if its parameter α has been calculated this way.

When two nodes come close enough to establish a communication, their habitats have to be compared in order to choose the best choice for every message. But the habitat is a sensitive information about the recent movements of a node, when a node is carried by an animal or a vehicle, or placed somewhere, this is not a problem. However, When the node is linked to a person, its habitat is a private information of this person. In fact, we cannot expect nodes to harm their own privacy by sharing sensitive information with their neighbours. For this reason, nodes’ privacy has to be preserved during the routing process. Our protocol has to allow a node to compare its habitat with the one of its neighbour at the same time that avoids the disclosure of information about any habitat to the other part.

Our protocol uses techniques of public-key cryptography, but we require the cryptosystem used to have a concrete property: to be homomorphic. An homomorphic cryptosystem is one in which, given two encrypted operands E(a) and E(b), one can operate them and compute 
                           
                              E
                              (
                              a
                              +
                              b
                              )
                           
                         or E(a · b) without separately decrypting each one. This way, a node can cypher and send information about its habitat to a neighbour, and the neighbour can operate it without violating the privacy of the first node
                           7
                        
                        
                           7
                           
                              Sections 4.5 and 5 will provide more details about this process.
                        . A fully homomorphic cryptosystem, like [10], capable of performing both the addition and the multiplication, would be ideal, but this system is not viable nowadays because of the computational power it requires.

The presented protocol uses the additive homomorphic Paillier cryptosystem [42], capable of performing the addition and the subtraction of two cyphered operands and the multiplication by a unencrypted scalar. This cryptosystem is briefly described next.

In a communication between Alice and Bob, Alice starts by selecting two random primes p and q and computes 
                           
                              n
                              =
                              p
                              q
                           
                        ; plaintext messages are elements of 
                           
                              Z
                              n
                           
                        ; however, ciphertext messages are elements of 
                           
                              Z
                              
                                 n
                                 2
                              
                           
                        . Then Alice picks a random 
                           
                              g
                              ∈
                              
                                 Z
                                 
                                    n
                                    2
                                 
                                 *
                              
                           
                         such that 
                           
                              g
                              c
                              d
                              (
                              
                                 (
                                 L
                                 
                                    (
                                    
                                       g
                                       λ
                                    
                                    
                                    mod
                                    
                                    
                                       n
                                       2
                                    
                                    )
                                 
                                 )
                              
                              ,
                              n
                              )
                              =
                              1
                              ,
                           
                         where 
                           
                              λ
                              =
                              
                              lcm
                              (
                              p
                              −
                              1
                              ,
                              q
                              −
                              1
                              )
                           
                         and 
                           
                              L
                              (
                              x
                              )
                              =
                              (
                              x
                              −
                              1
                              )
                              /
                              n
                           
                        . Alice’s public key
                           8
                        
                        
                           8
                           Note that if Bob does not trust Alice when she generates her Paillier modulus, he can insist she proves its validity, that it is the product of exactly two nearly equal primes [28].
                         is PkA
                        : (n, g) and her private key is pkA
                        : (λ, p, q).

To encrypt a message m, Bob picks a random 
                           
                              r
                              ∈
                              
                                 Z
                                 n
                                 *
                              
                           
                         and computes 
                           
                              c
                              =
                              E
                              
                                 (
                                 m
                                 )
                              
                              =
                              
                                 g
                                 m
                              
                              ·
                              
                                 r
                                 n
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              ,
                           
                         the cyphertext of m. Finally, Bob can easily compute 
                           
                              E
                              
                                 (
                                 a
                                 +
                                 b
                                 )
                              
                              =
                              E
                              
                                 (
                                 a
                                 )
                              
                              ·
                              E
                              
                                 (
                                 b
                                 )
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              =
                              
                                 g
                                 
                                    a
                                    +
                                    b
                                 
                              
                              ·
                              
                                 
                                    (
                                    
                                       r
                                       1
                                    
                                    ·
                                    
                                       r
                                       2
                                    
                                    )
                                 
                                 n
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              
                                 )
                                 ,
                              
                           
                        
                        
                           
                              E
                              
                                 (
                                 a
                                 −
                                 b
                                 )
                              
                              =
                              E
                              
                                 (
                                 a
                                 )
                              
                              /
                              E
                              
                                 (
                                 b
                                 )
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              =
                              
                                 g
                                 
                                    a
                                    −
                                    b
                                 
                              
                              ·
                              
                                 
                                    (
                                    
                                       r
                                       1
                                    
                                    /
                                    
                                       r
                                       2
                                    
                                    )
                                 
                                 n
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              
                                 )
                                 ,
                              
                           
                         and 
                           
                              E
                              
                                 (
                                 a
                                 ·
                                 s
                                 )
                              
                              =
                              E
                              
                                 
                                    (
                                    a
                                    )
                                 
                                 s
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              =
                              
                                 g
                                 
                                    a
                                    ·
                                    s
                                 
                              
                              ·
                              
                                 
                                    (
                                    
                                       r
                                       1
                                       s
                                    
                                    )
                                 
                                 n
                              
                              
                              mod
                              
                              
                                 n
                                 2
                              
                              
                                 )
                              
                           
                         without decrypting the operands.

Finally, to decrypt a ciphertext c, Alice computes 
                           
                              D
                              
                                 (
                                 c
                                 )
                              
                              =
                              L
                              
                                 (
                                 
                                    c
                                    λ
                                 
                                 
                                 mod
                                 
                                 
                                    n
                                    2
                                 
                                 )
                              
                              =
                              m
                           
                        .

The usage of Paillier’s cryptosystem restricts the operations we can use to compare habitats. Concretely, distances cannot be calculated because there is no way to calculate a square root. For this reason, we move from the usual Euclidean geometry to Taxicab geometry [22].

Taxicab is a geometry in which the distance between two points is the sum of the absolute differences of their Cartesian coordinates, instead of being the usual Euclidean distance. This distance function is usually called Manhattan distance
                           9
                        
                        
                           9
                           This name alludes to the grid layout of most streets on the island of Manhattan. The shortest path a car could take between two intersections in the borough have length equal to the intersections’ distance in taxicab geometry.
                         and is depicted in Fig. 4. Manhattan distances can be calculated without computing any square root
                           10
                        
                        
                           10
                           In order to calculate a Manhattan distance, the absolute value of a subtraction has to be computed. This operation is also not supported by any homomorphic cryptosystem, but, in Section 4.5, we explain how to calculate it benefiting from Taxicab geometry properties.
                        , an operation that is not supported by any homomorphic cryptosystem.

Throughout the entire article, all geometric calculations will be operated in Taxicab geometry, and all references to distances will refer to Manhattan distances. Fig. 5
                        
                         provides some examples of the aspect of different ellipses in Taxicab geometry. Note that in Taxicab geometry, the ellipse is a generalisation of the circle (an ellipse with the two focal points located at the same place, this also applies in Euclidean geometry); the rectangle (an ellipse with a radius equal to the distance between the two focal points); and the square (an ellipse with a radius equal to the distance between the two focal points, and the two focal points placed diagonally between them). In this article we provide the tools to operate with the general case, the ellipse, optimisations and simplifications to operate with specific types of ellipses can be easily inferred.

Finally, Fig. 6
                         concludes this section with a visual summary of how we adapt the habitat concept to use it as the basis of a Secure Geographical Routing Protocol. First, the real habitat (represented by the heatmap) is modelled using an ellipse due to efficiency reasons, then, the ellipse is considered under Taxicab geometry in order to protect nodes’ privacy.

In this section, we present PrivHab+, the very first habitat-based geographical routing protocol that protects the privacy of the participants. Firstly, we introduce the notation needed during the rest of the section and explain the routing algorithm from a high-level point of view. Then, we take some considerations about the privacy of all participants and how the operands coming from others have to be treated. Later, we explain the method to solve the three geometric problems our routing algorithm needs to solve. Following, we provide a method to solve the three geometric problems without hurting the privacy of any participant. Then, we present the messages that has to be exchanged during the execution of the protocol and we explain how PrivHab+ can be implemented using any forwarding policy, and we provide some examples. Finally, we reason about the two-party design of PrivHab+.

For the sake of clarity, we provide Table 1
                        , which contains the notation used to refer to each one of the different elements that will appear in this section and a brief description of its meaning. From now on, we will use this notation.

We propose a routing protocol that operates in two different phases: 1) approximation phase, when messages are routed towards a geographic area using PrivHab+; 2) delivery phase, when messages are delivered to their destination using the classical DTN techniques of routing and delivery (e.g. direct delivery or Spray-and-Wait [38]). In this paper, we focus on the first phase.
                     

During approximation, we use the habitats HA
                         and HB
                         of nodes A and B to decide who is the best choice to carry a message whose destination is located near P. We assume that an approximate location of the destination can always be known or guessed by the sender of the message, e.g. via the usage of a distributed secure position service like [41] and [37], or via the usage of an alternate communication channel. There are three different situations as depicted in Fig. 7, where our routing algorithm has to decide who is the best option:

                           
                              (a)
                              If P is located outside both habitats, then the best choice will be the node whose habitat is nearest to P (HB
                                  in Fig. 7) because it will likely bring the message nearer to its destination.

If P is located inside one habitat and outside the other, then the best choice will obviously be the node with the habitat that contains P (HA
                                  in Fig. 7).

If P is located inside both habitats, then the best choice will be the node whose habitat is smaller (HB
                                  in Fig. 7). We consider that it is more likely that this node will pass near P sooner.

We will use this algorithm during the rest of the article to decide the node that is the best choice to deliver every message to its destination.

On one hand, the location P is used during routing’s first phase to approach the destination of a message. Therefore, this is a routing information, carried by the message, which have to be known by the routers that take custody of the message because they will need it in the next executions of PrivHab+. When the destination does not want the forwarders to associate P to its identity, a pseudonym mechanism can be used. The presented protocol is fully compatible
                           11
                        
                        
                           11
                           When a node B sends a tuple EA
                              (Z), EA
                              (W) with Z, W ≥ 0, it is indistinguishable to A if B is a better carrier than A or if B is the destination of the message. See Section 4.5 for more details.
                         with pseudonym generator mechanisms as [17] or [4] that generate pseudonyms of the destination or the forwarders using its public key, or [30] that uses a secret shared between the nodes and hashing functions. These mechanisms can also be used by nodes that are very jealous of their privacy to avoid other nodes keeping track of the locations where they have encountered.

Moreover, although P could not be linked to a node thanks to the usage of pseudonyms, it must remain hidden to the nodes that do not need this information to perform the routing. This measure is crucial to reduce the amount of information that B can infer about HA
                         (see Section 5 for more details).

On the other hand, the habitat is a private information that every node maintains and updates. It has to be used during the approximation phase to decide who are the best node to carry messages near their destination, but it cannot be made public because this will hurt the privacy of nodes. For this reason, both A and B need the protocol to be secure and do not reveal information about their habitats to the other part.

As we seen in the previous sections, to perform our routing algorithm and compare the two habitats HA
                         and HB
                        , we need to answer three different questions:

                           
                              1.
                              How far is P from habitat H?

Is P contained inside habitat H?

Is HA
                                  smaller than HB
                                 ?

However, in order to protect the privacy of the participants, PrivHab+ uses homomorphic cryptography. For this reason, the set of operations we can use to do the calculations becomes heavily restricted when using operands coming from different nodes. In particular, we can only use addition, subtraction and multiplication by a non-cyphered operand.

For the sake of clarity, we will use the next paragraphs to briefly explain two different ways to solve these three problems: 1) from a geometric point of view; and 2) using the homomorphic cryptography’s constrained tools. Note that, geometrically, a habitat is equivalent to an ellipse.

The distance from a point P to an ellipse E with two focal points F1 and F2 and a radius r in Taxicab geometry is solved this way:

First, we calculate distances d(F1, P), between F1 and P, and d(F2, P), between F2 and P, using Eq. (6).

                              
                                 (6)
                                 
                                    
                                       
                                          d
                                          
                                             (
                                             F
                                             ,
                                             P
                                             )
                                          
                                          =
                                          |
                                       
                                       
                                          F
                                          x
                                       
                                       −
                                       
                                          P
                                          x
                                       
                                       
                                          |
                                          +
                                          |
                                       
                                       
                                          F
                                          y
                                       
                                       −
                                       
                                          P
                                          y
                                       
                                       
                                          |
                                       
                                    
                                 
                              
                           
                        

Then, we define E′, the closest point of the border of E to P. We split these two distances into two parts: the part that is contained within ellipse; and the part that is outside the ellipse
                              12
                           
                           
                              12
                              Note that, in the Euclidean geometry, the distance between a point and an ellipse cannot be calculated this way because Eq. (7) only holds in the Taxicab geometry.
                           .

                              
                                 
                                    
                                       d
                                       
                                          (
                                          F
                                          1
                                          ,
                                          P
                                          )
                                       
                                       =
                                       d
                                       
                                          (
                                          F
                                          1
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                       +
                                       d
                                       
                                          (
                                          
                                             E
                                             ′
                                          
                                          ,
                                          P
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 (7)
                                 
                                    
                                       d
                                       
                                          (
                                          F
                                          2
                                          ,
                                          P
                                          )
                                       
                                       =
                                       d
                                       
                                          (
                                          F
                                          2
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                       +
                                       d
                                       
                                          (
                                          
                                             E
                                             ′
                                          
                                          ,
                                          P
                                          )
                                       
                                    
                                 
                              
                           
                        

Then, we add these two distances and we subtract the radius 
                              
                                 r
                                 =
                                 d
                                 
                                    (
                                    F
                                    1
                                    ,
                                    
                                       E
                                       ′
                                    
                                    )
                                 
                                 +
                                 d
                                 
                                    (
                                    F
                                    2
                                    ,
                                    
                                       E
                                       ′
                                    
                                    )
                                 
                              
                           . As a result, we obtain the double of the distance between the ellipse and P without knowing the exact location of E′.

                              
                                 
                                    
                                       d
                                       
                                          (
                                          F
                                          1
                                          ,
                                          P
                                          )
                                       
                                       +
                                       d
                                       
                                          (
                                          F
                                          2
                                          ,
                                          P
                                          )
                                       
                                       −
                                       r
                                       =
                                       2
                                       ·
                                       d
                                       
                                          (
                                          
                                             E
                                             ′
                                          
                                          ,
                                          P
                                          )
                                       
                                       =
                                    
                                 
                              
                           
                           
                              
                                 (8)
                                 
                                    
                                       d
                                       
                                          (
                                          F
                                          1
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                       +
                                       d
                                       
                                          (
                                          F
                                          2
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                       +
                                       2
                                       ·
                                       d
                                       
                                          (
                                          
                                             E
                                             ′
                                          
                                          ,
                                          P
                                          )
                                       
                                       −
                                       d
                                       
                                          (
                                          F
                                          1
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                       −
                                       d
                                       
                                          (
                                          F
                                          2
                                          ,
                                          
                                             E
                                             ′
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

The absolute value of a cyphered operand cannot be calculated with the constrained tools of homomorphic cryptography. However, we can take advantage of Eq. (9) to walk around this issue and calculate the absolute value of a subtraction if we know beforehand the relation between the two operands.

                              
                                 (9)
                                 
                                    
                                       
                                          |
                                          Z
                                          −
                                          W
                                          |
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      Z
                                                      −
                                                      W
                                                   
                                                
                                                
                                                   
                                                      :
                                                      Z
                                                      >
                                                      W
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      W
                                                      −
                                                      Z
                                                   
                                                
                                                
                                                   
                                                      :
                                                      Z
                                                      <
                                                      W
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In order to use Eq. (9) to obtain the absolute value needed to calculate the distance from a point to the habitat (see Eq. (6)), we need to know the relation between the coordinates of P: (Px, Py
                           ) and the coordinates of the two focus points F1: (F1
                              x
                           , F1
                              y
                           ) and F2: (F2
                              x
                           , F2
                              y
                           ).

So we first divide the space into 9 regions, depending on their relation to the two focus of the habitat, as depicted in Fig. 8
                           . To know the region where P is located, we calculate the maximum and minimum values of the coordinates of the two focus using Eq. (10). Then we compare them with the coordinates of P.

                              
                                 
                                    
                                       F
                                       
                                          x
                                          
                                             m
                                             i
                                             n
                                          
                                       
                                       =
                                       M
                                       i
                                       n
                                       
                                          (
                                          F
                                          
                                             1
                                             x
                                          
                                          ,
                                          F
                                          
                                             2
                                             x
                                          
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       F
                                       
                                          x
                                          
                                             m
                                             a
                                             x
                                          
                                       
                                       =
                                       M
                                       a
                                       x
                                       
                                          (
                                          F
                                          
                                             1
                                             x
                                          
                                          ,
                                          F
                                          
                                             2
                                             x
                                          
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       F
                                       
                                          y
                                          
                                             m
                                             i
                                             n
                                          
                                       
                                       =
                                       M
                                       i
                                       n
                                       
                                          (
                                          F
                                          
                                             1
                                             y
                                          
                                          ,
                                          F
                                          
                                             2
                                             y
                                          
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 (10)
                                 
                                    
                                       F
                                       
                                          y
                                          
                                             m
                                             a
                                             x
                                          
                                       
                                       =
                                       M
                                       a
                                       x
                                       
                                          (
                                          F
                                          
                                             1
                                             y
                                          
                                          ,
                                          F
                                          
                                             2
                                             y
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

Once we know the region where P is located, we can use Eqs. (6) and (9) to calculate the distances between F1, F2 and P. Table 2 shows how to calculate the added distance between the two focus points and P depending on the region where P is located.
                        

After 
                              
                                 d
                                 (
                                 F
                                 1
                                 ,
                                 P
                                 )
                                 +
                                 d
                                 (
                                 F
                                 2
                                 ,
                                 P
                                 )
                              
                            is obtained from Table 2, the last thing to do is to subtract the radius r, using Eq. (8) to obtain 2 · d(H, P), the double of the distance between P and the habitat H.

Finally, Eq. (11) shows how to use the double of the distance to compare two habitats and decide which one is closer to a certain point P.

                              
                                 (11)
                                 
                                    
                                       2
                                       ·
                                       d
                                       
                                          (
                                          
                                             H
                                             A
                                          
                                          ,
                                          P
                                          )
                                       
                                       −
                                       2
                                       ·
                                       d
                                       
                                          (
                                          
                                             H
                                             B
                                          
                                          ,
                                          P
                                          )
                                       
                                       <
                                       0
                                       ⇔
                                       d
                                       
                                          (
                                          
                                             H
                                             A
                                          
                                          ,
                                          P
                                          )
                                       
                                       <
                                       d
                                       
                                          (
                                          
                                             H
                                             B
                                          
                                          ,
                                          P
                                          )
                                       
                                    
                                 
                              
                           
                        

Note that a distance between P and H calculated this way will be negative if P is contained inside H. On the next paragraphs we will explain how benefit from this fact to know if P is inside or outside the habitat. Note also that the usage of other models of habitat as the square, the circle or the rectangle, that are specific types of ellipses, would simplify the calculations because some regions would disappear and would not need to be considered.

Given an ellipse E characterised by two focal points F1: (F1
                              x
                           , F1
                              y
                           ) and F2: (F2
                              x
                           , F2
                              y
                           ) and a radius r, a point P: (Px, Py
                           ) is contained inside E if and only if Eq. (12) holds.

                              
                                 (12)
                                 
                                    
                                       
                                          |
                                       
                                       
                                          P
                                          x
                                       
                                       −
                                       F
                                       
                                          1
                                          x
                                       
                                       
                                          |
                                          +
                                          |
                                       
                                       
                                          P
                                          y
                                       
                                       −
                                       F
                                       
                                          1
                                          y
                                       
                                       
                                          |
                                          +
                                          |
                                       
                                       
                                          P
                                          x
                                       
                                       −
                                       F
                                       
                                          2
                                          x
                                       
                                       
                                          |
                                          +
                                          |
                                       
                                       
                                          P
                                          y
                                       
                                       −
                                       F
                                       
                                          2
                                          y
                                       
                                       
                                          |
                                          ≤
                                          r
                                       
                                    
                                 
                              
                           
                        

As we have seen, to calculate the distance from a point P to a habitat H, what we really calculate is the double of the distance from a point P located outside the habitat H to the nearest point of H. If P is located inside the habitat, due to the usage of Eq. (9), the absolute value of the distance will be a negative value
                              13
                           
                           
                              13
                              Note that our protocol checks several times if an operand ρ is positive or negative. In the Paillier cryptosystem, ρ will be an element of 
                                    
                                       Z
                                       n
                                    
                                 . To check this condition, if we ensure that n is sufficiently large and that all values ρ we will use are ρ ≤ n/2, then we can consider that ρ > n/2⇔ρ < 0.
                           . Far from being a drawback, we benefit from this property to use the calculated distance to the habitat to know if P is contained inside it, as shown in Eq. (13).

                              
                                 (13)
                                 
                                    
                                       d
                                       (
                                       H
                                       ,
                                       P
                                       )
                                       ≤
                                       0
                                       ⇔
                                       P
                                       ∈
                                       H
                                    
                                 
                              
                           
                        

Given two ellipses, E
                           1 and E
                           2, and their respective radius r
                           1 and r
                           2, the smaller ellipse is the one that have the lesser radius. Therefore, E
                           1 is the smaller ellipse if Eq. (14) holds, otherwise, E
                           2 is the smaller one.

                              
                                 (14)
                                 
                                    
                                       
                                          r
                                          1
                                       
                                       <
                                       
                                          r
                                          2
                                       
                                    
                                 
                              
                           
                        

To compare the size of habitats HA
                            and HB
                           , we subtract their radius rA
                            and rB
                            one from another. Then, we check the sign of the result to decide which habitat is the smallest.

                              
                                 
                                    
                                       
                                          (
                                          
                                             r
                                             A
                                          
                                          −
                                          
                                             r
                                             B
                                          
                                          )
                                       
                                       *
                                       n
                                       o
                                       n
                                       c
                                       e
                                       ≥
                                       0
                                       ⇔
                                       
                                          H
                                          A
                                       
                                       >
                                       
                                          H
                                          B
                                       
                                    
                                 
                              
                           
                           
                              
                                 (15)
                                 
                                    
                                       
                                          (
                                          
                                             r
                                             A
                                          
                                          −
                                          
                                             r
                                             B
                                          
                                          )
                                       
                                       *
                                       n
                                       o
                                       n
                                       c
                                       e
                                       <
                                       0
                                       ⇔
                                       
                                          H
                                          A
                                       
                                       <
                                       
                                          H
                                          B
                                       
                                    
                                 
                              
                           
                        

Note on Eq. (15) that we use a positive nonce. This value is unknown for the other part of the transaction. It is used to hide the real relation between the radius of the habitats and provide a randomised response. Later, the other part will binarise the result by taking into account only its sign.

Let A be the node that carries a set of messages mi
                        , with a habitat HA
                        : (F1
                           A
                        , F2
                           A
                        , rA
                        ). Let Pi
                        : (Pxi, Pyi
                        ) be the point where each message mi
                         wants to be carried to, and B be a neighbour with a habitat HB
                        : (F1
                           B
                        , F2
                           B
                        , rB
                        ). We denote a message sent by A to B with A → B: message. By the previous definitions, A want to know if B is a better choice to carry each message mi
                         towards Pi
                        .

PrivHab+ consists in five steps, the first of them is totally asynchronous, and requires nodes to exchange three messages. Depending on the result of the execution of the algorithm, an additional last one (the forwarded message) is sent.

                           
                              0.
                              Node A calculates 
                                    
                                       
                                          d
                                          
                                             A
                                             i
                                          
                                       
                                       =
                                       d
                                       
                                          (
                                          
                                             H
                                             A
                                          
                                          ,
                                          
                                             P
                                             i
                                          
                                          )
                                       
                                       ,
                                    
                                  the distance between its habitat and every Pi; A uses 
                                    
                                       
                                          d
                                          
                                             A
                                             i
                                          
                                       
                                       =
                                       0
                                    
                                  if P ∈ HA
                                  and dAi
                                  ≥ 1 otherwise. As A knows both HA
                                  and Pi
                                 , and the operations do not need to be performed using homomorphic encryption.

Besides, node B calculates the characteristics of its habitat: Fxmax, Fxmin, Fymax
                                  and Fymin
                                  using Eq. (10). This calculations can be done asynchronously (e. g. when the habitat is updated).

From that moment on, each time B establishes a contact with and any other node, B starts by announcing the characteristics of its habitat to its neighbours
                                    14
                                 
                                 
                                    14
                                    This announcement can be made during the neighbour discovery process, by adding this information to the beacons.
                                 .

                                    
                                       
                                          
                                             B
                                             →
                                             A
                                             :
                                             
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            F
                                                            
                                                               x
                                                               
                                                                  m
                                                                  a
                                                                  x
                                                               
                                                            
                                                            )
                                                         
                                                         ,
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            F
                                                            
                                                               x
                                                               
                                                                  m
                                                                  i
                                                                  n
                                                               
                                                            
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            F
                                                            
                                                               y
                                                               
                                                                  m
                                                                  a
                                                                  x
                                                               
                                                            
                                                            )
                                                         
                                                         ,
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            F
                                                            
                                                               y
                                                               
                                                                  m
                                                                  i
                                                                  n
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Node A compares each received value with the corresponding coordinates of each point Pi
                                 . The comparisons are done by subtracting the corresponding coordinate of Pi
                                  from the characteristics of the habitat and then multiplying the result, to randomise it, with a random one-use value denoted nonce. A compares Fxmax
                                  with Pxi
                                  using Eq. (16), and calculates the other comparisons the same way. The first two received values are compared with Pxi
                                  and the last two with Pyi
                                 .

                                    
                                       (16)
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            F
                                                            
                                                               x
                                                               
                                                                  m
                                                                  a
                                                                  x
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            
                                                               P
                                                               
                                                                  x
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                   )
                                                
                                                
                                                   n
                                                   o
                                                   n
                                                   c
                                                   e
                                                
                                             
                                             =
                                             
                                                E
                                                B
                                             
                                             
                                                (
                                                
                                                   (
                                                   F
                                                   
                                                      x
                                                      
                                                         m
                                                         a
                                                         x
                                                      
                                                   
                                                   −
                                                   
                                                      P
                                                      
                                                         x
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                ·
                                                n
                                                o
                                                n
                                                c
                                                e
                                                )
                                             
                                          
                                       
                                    
                                 
                              

Then A sends the comparisons
                                    15
                                 
                                 
                                    15
                                    We have used “{” and “}
                                          i
                                       ” to enclose the part of the information that is repeated one time for each message mi
                                       .
                                  to B together with the coordinates of each Pi
                                 , the distance dAi
                                  and the radius rA
                                  of HA
                                 .

                                    
                                       
                                          
                                             A
                                             →
                                             B
                                             :
                                             
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               r
                                                               A
                                                            
                                                            )
                                                         
                                                         ,
                                                         
                                                            {
                                                            
                                                               E
                                                               B
                                                            
                                                            
                                                               (
                                                               
                                                                  (
                                                                  F
                                                                  
                                                                     x
                                                                     
                                                                        m
                                                                        a
                                                                        x
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     P
                                                                     
                                                                        x
                                                                        i
                                                                     
                                                                  
                                                                  )
                                                               
                                                               ·
                                                               n
                                                               o
                                                               n
                                                               c
                                                               e
                                                               )
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               P
                                                               
                                                                  x
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                         ,
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            
                                                               (
                                                               F
                                                               
                                                                  x
                                                                  
                                                                     m
                                                                     i
                                                                     n
                                                                  
                                                               
                                                               −
                                                               
                                                                  P
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                               
                                                               )
                                                            
                                                            ·
                                                            n
                                                            o
                                                            n
                                                            c
                                                            e
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               P
                                                               
                                                                  y
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                         ,
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            
                                                               (
                                                               F
                                                               
                                                                  y
                                                                  
                                                                     m
                                                                     a
                                                                     x
                                                                  
                                                               
                                                               −
                                                               
                                                                  P
                                                                  
                                                                     y
                                                                     i
                                                                  
                                                               
                                                               )
                                                            
                                                            ·
                                                            n
                                                            o
                                                            n
                                                            c
                                                            e
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               E
                                                               A
                                                            
                                                            
                                                               (
                                                               2
                                                               
                                                                  d
                                                                  
                                                                     A
                                                                     i
                                                                  
                                                               
                                                               )
                                                            
                                                            ,
                                                            
                                                               E
                                                               B
                                                            
                                                            
                                                               (
                                                               
                                                                  (
                                                                  F
                                                                  
                                                                     y
                                                                     
                                                                        m
                                                                        i
                                                                        n
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     P
                                                                     
                                                                        y
                                                                        i
                                                                     
                                                                  
                                                                  )
                                                               
                                                               ·
                                                               n
                                                               o
                                                               n
                                                               c
                                                               e
                                                               )
                                                            
                                                            }
                                                         
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

For each Pi, B decrypts all the received comparisons. Node B knows that each decrypted value greater than zero means that the characteristic of the habitat is greater than the corresponding coordinate of Pi
                                 . This way B decides the region where Pi
                                  is placed. Then, B calculates distance 2dBi
                                 . Afterwards, B computes the comparison between 2dAi
                                  and 2dBi
                                 , using Eq. (17), and the comparison of radius
                                    16
                                 
                                 
                                    16
                                    The added element dAi
                                        · rB
                                        blurs the comparison. This way A can only infer information about HB
                                       ’s radius when Pi
                                        is contained both by HA
                                        and HB
                                       . See Section 5 for more details.
                                  
                                 rA
                                  and rB
                                  using Eq. (18).

                                    
                                       (17)
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            2
                                                            
                                                               d
                                                               
                                                                  A
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                      
                                                         
                                                            E
                                                            B
                                                         
                                                         
                                                            (
                                                            2
                                                            
                                                               d
                                                               
                                                                  B
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                   )
                                                
                                                
                                                   n
                                                   o
                                                   n
                                                   c
                                                   e
                                                
                                             
                                             =
                                             
                                                E
                                                B
                                             
                                             
                                                (
                                                
                                                   (
                                                   2
                                                   
                                                      d
                                                      
                                                         A
                                                         i
                                                      
                                                   
                                                   −
                                                   2
                                                   
                                                      d
                                                      
                                                         B
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                ·
                                                n
                                                o
                                                n
                                                c
                                                e
                                                )
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      
                                                         E
                                                         A
                                                      
                                                      
                                                         (
                                                         
                                                            r
                                                            A
                                                         
                                                         )
                                                      
                                                      ·
                                                      
                                                         E
                                                         A
                                                      
                                                      
                                                         
                                                            (
                                                            2
                                                            
                                                               d
                                                               
                                                                  A
                                                                  i
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            r
                                                            B
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         E
                                                         A
                                                      
                                                      
                                                         (
                                                         
                                                            r
                                                            B
                                                         
                                                         )
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                n
                                                o
                                                n
                                                c
                                                e
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (18)
                                       
                                          
                                             
                                             =
                                             
                                                E
                                                A
                                             
                                             
                                                (
                                                
                                                   (
                                                   
                                                      r
                                                      A
                                                   
                                                   +
                                                   2
                                                   
                                                      d
                                                      
                                                         A
                                                         i
                                                      
                                                   
                                                   ·
                                                   
                                                      r
                                                      B
                                                   
                                                   −
                                                   
                                                      r
                                                      B
                                                   
                                                   )
                                                
                                                ·
                                                n
                                                o
                                                n
                                                c
                                                e
                                                )
                                             
                                          
                                       
                                    
                                 
                              

The last step for B is to send the results, but before that, B orders each pair of comparisons in a random way unknown to A.

                                    
                                       
                                          
                                             B
                                             →
                                             A
                                             :
                                             
                                                
                                                   
                                                      
                                                         {
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               (
                                                               2
                                                               
                                                                  d
                                                                  
                                                                     A
                                                                     i
                                                                  
                                                               
                                                               −
                                                               2
                                                               
                                                                  d
                                                                  
                                                                     B
                                                                     i
                                                                  
                                                               
                                                               )
                                                            
                                                            ·
                                                            n
                                                            o
                                                            n
                                                            c
                                                            e
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               (
                                                               
                                                                  r
                                                                  A
                                                               
                                                               +
                                                               2
                                                               
                                                                  d
                                                                  
                                                                     A
                                                                     i
                                                                  
                                                               
                                                               ·
                                                               
                                                                  r
                                                                  B
                                                               
                                                               −
                                                               
                                                                  r
                                                                  B
                                                               
                                                               )
                                                            
                                                            ·
                                                            n
                                                            o
                                                            n
                                                            c
                                                            e
                                                            )
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                         or
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            E
                                                            A
                                                         
                                                         
                                                            (
                                                            
                                                               (
                                                               
                                                                  r
                                                                  A
                                                               
                                                               +
                                                               2
                                                               
                                                                  d
                                                                  
                                                                     A
                                                                     i
                                                                  
                                                               
                                                               ·
                                                               
                                                                  r
                                                                  B
                                                               
                                                               −
                                                               
                                                                  r
                                                                  B
                                                               
                                                               )
                                                            
                                                            ·
                                                            n
                                                            o
                                                            n
                                                            c
                                                            e
                                                            )
                                                         
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               E
                                                               A
                                                            
                                                            
                                                               (
                                                               
                                                                  (
                                                                  2
                                                                  
                                                                     d
                                                                     
                                                                        A
                                                                        i
                                                                     
                                                                  
                                                                  −
                                                                  2
                                                                  
                                                                     d
                                                                     
                                                                        B
                                                                        i
                                                                     
                                                                  
                                                                  )
                                                               
                                                               ·
                                                               n
                                                               o
                                                               n
                                                               c
                                                               e
                                                               )
                                                            
                                                            }
                                                         
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Finally, node A decrypts each pair of comparisons. For every message mi
                                  for whom the two decrypted values are equal or greater than 0, A learns that B is a better choice. Knowing that, A applies its forwarding policy (more details are provided below) to decide if any message has to be sent to B.

                                    
                                       
                                          
                                             A
                                             →
                                             B
                                             :
                                             
                                                
                                                   {
                                                   
                                                      m
                                                      i
                                                   
                                                   }
                                                
                                                i
                                             
                                          
                                       
                                    
                                 
                              


                        Fig. 9
                         provides a schema of the messages exchanged during each phase of the protocol.

After the execution of PrivHab+, node A carrying message mi
                         knows if the execution was successful and if B is a better choice to carry the message towards its destination. Then, A decides if the message has to be forwarded to B, and if a copy of mi
                         has to be kept in A. The number of copies of every message flowing through the network will be directly determined by the forwarding policy used. Therefore, this decision, determined by the forwarding policy of A, can have an impact on the performance of PrivHab+.

PrivHab+ is compatible with any forwarding policy. As this paper is essentially focused on the decision making, meaning the comparison of two nodes to decide who is the best choice, the study of the forwarding policy is out of the scope of this paper. However, we provide next a set of examples of different forwarding policies that could be applied. Note that we do not pretend this set to be complete. Further research is planned by the authors to study and analyse all possible options to find the best policy for each scenario.

                           
                              •
                              
                                 Direct single-copy policy: nodes always forward the message to the node that is a better choice, no copies of the messages are created.


                                 Direct multi-copy policy: nodes always forward the message to the node that is a better choice, but each node that has forwarded a message keeps one copy of it.


                                 Limited multi-copy policy: nodes forward the message to the node that is a better choice and keep a copy a limited amount of times. When a node reaches the threshold for a message, no more copies of this message are created, and it is not forwarded more by this node. Many different strategies can be used to define the threshold of every node and every message.


                                 Probabilistic policy: messages are forwarded to the node that is a better choice a X% of times. They are also forwarded to nodes that are a worse choice a or do not have a habitat to compare a Y% of times. Besides, nodes keep a copy of the forwarded message the Z% of times, where X, Y and Z are parameters of the network.


                                 Multi-criteria policy: nodes execute other routing algorithms and combine their output with PrivHab+’s one to decide if the message has to be forwarded and if a copy has to be kept at the node.

For the sake of simplicity, during the rest of this paper we will assume that PrivHab+ uses, by default, the direct single-copy forwarding policy.

At [9], the authors have studied the enormous complexity of realising a multi-party secure comparison between an indefinite number of nodes. Besides, encounters between two nodes are the most common [12], encounters between three, four or more nodes are so rare that they cannot have a huge impact on the performance of the network. For the sake of simplicity and to maintain the computational overhead as low as possible, we have designed PrivHab+ to operate between two nodes.

PrivHab+ solves the encounters where three or more nodes meet, iterating its execution. PrivHab+ low overhead allow nodes to execute it more than once, and the “winner” of each comparison can be compared again with another neighbour. This process can be repeated until all nodes have been compared and the best has been found, or until the connectivity window ends. Fig. 10
                         illustrates this process. This way, if the communication ends suddenly before all comparisons are finished, PrivHab+ will find at least a partial “winner”. In the figure, if the communication ends before forwarding the message to the best node (N3), this partial “winner” would be N2, who is better than N0 and N1.

In this section, we analyse the knowledge obtained by each participant of PrivHab+ under the scope of secure multi-party computations. We first consider the passive adversary mode, where one participant executes the protocol and then makes inferences to obtain knowledge about the other participant’s inputs. Then, we consider the active adversary mode, where one participant tampers its messages to try to obtain an advantage. Then, we reason about the security obtained in the two models.

A secure multi-party computation [11] consists in computing a function on any input, on a network where different participants hold each input, and ensuring that no more information is revealed to a participant than what can be inferred from that participant’s input and the computed output.

Following, we treat routing as a secure multi-party computation problem where the result of a routing algorithm has to be computed using private data held by the candidate nodes to carry the message. In order to consider PrivHab+ as a secure protocol, we need to prove that it reveals only the result of the function and the inferences that can be deduced from this output with one or more input values [8]. We consider a passive adversary mode where the participants exchange truthful messages and then analyse them trying to obtain information about the other part’s habitat.


                           Table 3 summarises all knowledge that can be learned by A, the node that carries the message, about HB
                           , the habitat of the candidate node B. In all cases, the obtained knowledge is inferred using the output of the protocol and the inputs provided by A. None information can be learned from the messages exchanged with B, because they are encrypted with B’s key, and the ones that A can decrypt are randomised through the usage of random nonce values.
                        

The knowledge obtained by B depends on the forwarding policy of A. The only thing B knows is not the output of PrivHab+, but the fact that the message has finally been forwarded or not. If the forwarding policy used makes possible to not send the message when B is a better choice, or to send the message even if B is a worse choice, then B cannot infer PrivHab+’s output. Therefore, in this situation B cannot learn anything about HA
                           . Assuming that B knows A’s forwarding policy, we will analyse the worst-case scenario: a direct (single-copy or multi-copy) forwarding policy that allows B to know the output of PrivHab+ from the forwarding of the message.


                           Table 4
                            summarises all knowledge that can be learned by B, the candidate node to take custody of the message. Only one information, P’s region, can be learned from the message received from A. HA
                            characteristics are encrypted with A’s key, and the comparisons that B can decrypt are randomised through the usage of random nonce values. Only the region where P is located is revealed. This knowledge about P’s region is necessary for B to calculate dB
                           . Node B can also infer the relation between dA
                            and dB
                           , even without knowing
                              17
                           
                           
                              17
                              Node B does not even know dB
                                  until receiving P with the message and computing the distance again. The reason is that dB
                                  is calculated via homomorphic cryptography and only A can decrypt it.
                            
                           dB
                           , from the forwarding of the message. Note that maintaining P hidden to B (only P’s region is revealed) if the message is not forwarded is crucial to avoid that B can calculate dB
                            and use it to infer more information about HA
                           .

@&#CONCLUSIONS@&#

Anything learned by A about HB
                           , or by B about HA
                           , from the protocol is also learnable from the output alone. The computation made is a routing protocol, so, if m is forwarded to B, coordinates of P are revealed to B because they will be needed in the next executions. Otherwise, the only thing B learns about P is the region
                              18
                           
                           
                              18
                              The region where P is located is far less accurate that the coordinates of P or the distance between P and HB
                                 . Moreover, B does not even know who is the destination, and therefore, B cannot relate this P’s region with any node.
                            where it is located in relation with HB
                           , because this knowledge is necessary for B to compute dB
                           .

Therefore, PrivHab+ is secure to A and B because it reveals only the result of the algorithm and inferences derived from this result. Besides, PrivHab+ provides best-effort privacy to P because it hides its location and reveals only the region where P is located. As we have explained in the previous section, this can be easily enhanced by breaking the relation between the destination and P using a pseudonym generator mechanism.

In the active adversary mode, we consider an attacker that may use untruthful information about their own habitat, the messages they carry, or the location P where a message is intended, in order to disclose private information about the other part’s habitat.

A node carrying a message can lie about P, dA
                            and rA
                            in order to uncover information about HB
                           . There are two strategies that an active attacker A can follow: 1) Produce chosen-destination arbitrary messages using a set of false P′ and 
                              
                                 d
                                 A
                                 ′
                              
                            to try to discover the area covered by HB
                           ; and 2) tamper 
                              
                                 r
                                 A
                                 ′
                              
                            to learn about rB
                           .

                              
                                 1.
                                 
                                    Discover the area covered by HB: every time PrivHab+ is executed, A learns that HB
                                     is located completely outside a circle with centre at P and radius dA
                                     if node A is chosen as the best choice. The same way, A learns that at least one part of HB
                                     is located inside a circle with centre at P and radius dA
                                     if the best choice is B. Therefore, node A can exploit this by producing arbitrary messages destined to a set of locations P′ and using set of false distances 
                                       
                                          
                                             d
                                             A
                                             ′
                                          
                                          ,
                                       
                                     and then repeatedly execute PrivHab+ to try to learn the area covered by HB
                                    . The knowledge that A can obtain from this is summarised by Table 5
                                    .


                                    Discover rB: the result of an execution of PrivHab+ consists of a tuple containing two results randomly ordered. Each result can be greater or equal than zero (≥ 0), or negative (< 0). One of them, the radius comparison, only makes sense if and only if 
                                       
                                          
                                             d
                                             A
                                          
                                          =
                                          0
                                       
                                    . In order to know the result of the radius comparison, A needs to repeatedly execute PrivHab+ using the same values 
                                       
                                          
                                             d
                                             A
                                             ′
                                          
                                          =
                                          0
                                       
                                     and 
                                       
                                          
                                             r
                                             A
                                             ′
                                          
                                          ,
                                       
                                     and a different P, until obtaining a different result in one of the two comparisons. When this happens, node A learns which result corresponds to each comparison, and learns if rB
                                     is higher or lesser than 
                                       
                                          r
                                          A
                                          ′
                                       
                                    . Note that the only way to obtain a different result in one comparison using this method is by using two false 
                                       
                                          P
                                          1
                                          ′
                                       
                                     and 
                                       
                                          P
                                          2
                                          ′
                                       
                                     that are located one inside HB
                                     and the other outside it. Table 6 summarises this process.
                                 

Node B does not initiate the execution of PrivHab+, nor controls the amount of messages mi
                            that will be routed. Then, its only chance to lie is manipulating the results of the comparisons sent in Step 3. The candidate node B can lie about its habitat, using 
                              
                                 H
                                 B
                                 ′
                              
                            instead of HB
                           , or about the distance from its habitat to P, using 
                              
                                 d
                                 B
                                 ′
                              
                            instead of dB
                           . Given that using a tampered habitat 
                              
                                 H
                                 B
                                 ′
                              
                            will lead to the calculation of an untruthful distance 
                              
                                 
                                    d
                                    B
                                    ′
                                 
                                 ,
                              
                            both cases can be treated likewise. Table 7
                            summarises all knowledge learned by B in these two cases.

Node B will obtain more information about HA
                            lying than being truthful only if B finally receives the message and 
                              
                                 
                                    d
                                    B
                                    ′
                                 
                                 >
                                 
                                    d
                                    B
                                 
                                 ,
                              
                            or if B does not receive the message and 
                              
                                 
                                    d
                                    B
                                    ′
                                 
                                 <
                                 
                                    d
                                    B
                                 
                              
                           . In both cases, P, and, therefore dB
                           , are unknown to B prior of the exchange. Therefore, B wants 
                              
                                 d
                                 B
                                 ′
                              
                            to be high to obtain more information if B will win the comparison, but a higher 
                              
                                 d
                                 b
                                 ′
                              
                            makes B less likely to win it. Equivalently, B wants 
                              
                                 d
                                 B
                                 ′
                              
                            to be small if B will lose the comparison, but a lesser 
                              
                                 d
                                 b
                                 ′
                              
                            makes B more likely to be selected as the best candidate. Besides, B will not obtain P if does not receive the message, and knowing the distance between HA
                            and P is not useful if P is unknown. For these reasons, there is no a straightforward strategy to select 
                              
                                 H
                                 B
                                 ′
                              
                            or dB
                            and guarantee that B will take an advantage from this.

@&#CONCLUSIONS@&#

An active attacker can try to learn things about the other part’s habitat by using untruthful information during the execution of PrivHab+. A can try to learn the area covered by HB
                            and its radius rB
                           , while B can try to learn the distance from HA
                            to P. In both cases, the information obtained by the attacker is the same information (the result of one or more comparisons) that he can infer from a truthful execution of the protocol. The only thing an attacker can change is the value to compare with the other part’s radius or distance. However, the attacker can only benefit from these changes if the change made and the result of PrivHab+ are aligned. And in all cases happens that changing the value to improve its usefulness decreases the probability of obtaining the desired result.

As A is the node that starts the transaction and the only one that knows the number of messages he carries, he can determine how many times to execute PrivHab+. If A executes PrivHab+ enough times, using untruthful information and the attacks described in Section 5.2.1, he can completely uncover the area covered by HB
                            and its radius. Given that nodes always operate with encrypted data, there is no way for one part to tell apart a truthful execution of PrivHab+ from an untruthful one. However, B can decrease the effectiveness of these attacks by limiting the amount of interactions per unit of time with every other node.

When A is performing a series of untruthful executions to discover B’s habitat, A wants to know the result of the previous execution to improve the amount of obtained information in the next one. For example, A can start by selecting an evenly spread set of positions to try to discover the area covered by HB
                           . However, when A has found that there is a part of HB
                            inside the circle defined by one of these positions, it is much more useful to A to investigate this circle and its surroundings than continue with the remaining positions. Therefore, B can reduce the effectiveness of the attacker by taking the countermeasure of forcing A to send him at once the information needed to perform all the executions before sending any response.

Finally, when combining the two proposed measures, limiting the amount of executions per unit of time, and requiring all the information at once before sending any results to A, the effectivity of an active attack becomes greatly reduced, and the attacker ends learning almost the same things that he would learn by being truthful. Besides, the information protected by PrivHab+, the habitat, changes periodically. For this reason, slowing enough an attack can be considered equivalently as avoiding it, because when time passes the habitats change and the first things learned by the attacker become obsolete.

@&#EXPERIMENTAL RESULTS@&#

In this section we present some details about the proof-of-concept we have implemented. Then, we provide measurements of the computational and communication overhead introduced by the presented protocol.

@&#IMPLEMENTATION DETAILS@&#

We have deployed an implementation of the presented protocol on two different sets of devices: three Raspberry Pi boards
                           19
                        
                        
                           19
                           Raspberry Pi Broadcom BCM2835 SoC full HD, 700 MHz Low Power ARM1176JZ-F, 512 MB SDRAM, 512 MB SD with Raspbian, equipped with a Wi-Pi Wireless Adapter (802.11n up to 150 Mbps), a GPS receiver NL-302U (baud rate: 4800 bauds) and a dual output 5000 mAh battery.
                        , and two i5 laptops
                           20
                        
                        
                           20
                           Intel Core-i5 (third generation): dual core 3.3 GHz, 4 GB RAM, WiFi 802.11 b/g/n Dual Antenna, with Ubuntu 14.04 LTS, equipped with a GPS receiver NL-302U (baud rate: 4800 bauds).
                        . The Raspberry Pi boards are very cheap low-end devices, ideals to deploy a cheap prototype network that will allow us to run field experiments in a near future. The laptops have been chosen as representatives of short-term high-end mobile devices, indeed the i5 processor slightly outperforms the iPhone 6’ A8, the most powerful mobile phone processor prior to the writing of this article. The objective of this proof-of-concept implementation is to demonstrate the viability of the proposal, and to obtain a measure of the overhead that PrivHab+ adds to every transaction.

We have established a DTN network using the chosen devices and we have used this implementation to send 500 messages of sizes between 10MB and 20MB. We have repeated the tests five times, using Paillier’s length keys of 512, 1024 and 2048 bits. We have measured the average time needed to make the calculations and to exchange all messages of Fig. 9. The obtained results are shown in Table 9, and have been incorporated to the simulations.
                     

As can be seen in Table 9, PrivHab+ execution time depends heavily on the key length used. When using keys of 512 bits, PrivHab+ can be executed by a low-end device in less than a second, meaning an overhead of less than a 5% when sending messages larger than 10MB. The execution time increases to almost 5.5 s when using keys of 1024 bits. Given the average length of connectivity windows in remote village scenarios presented in [12], this overhead is acceptable. The usage of keys of 2048 bits or more in low-end devices is discouraged because of the high overhead times they produce. In a high-end processor, PrivHab+ can be executed in less than a second even when using extra-large keys of 2048 bits. Due to this, the key length should be chosen keeping in mind the devices used and the time that can be spent by executing the protocol.

PrivHab+ can be executed once to simultaneously route all messages. This is called a multi-destination execution. This execution is faster but its result is all-or-nothing, meaning that no message can be routed if the connectivity window suddenly ends before finishing the execution of PrivHab+. In contrast, PrivHab+ can be executed to route one message at a time. This is called the iterated execution. This execution is slower, lasts 20% more time than the multi-destination execution, but when the communication suddenly ends, all previously processed messages have been routed. Fig. 11
                         depicts the time needed by PrivHab+ to execute the protocol when routing messages using both types of execution. The authors suggest to use a mixed strategy: using one multi-destination execution to route the first messages and then iterate each message one by one.

Finally, Table 8 shows the percentage of time consumed by each operation. The time needed to compute and send the first message, during steps 0 and 1, is not counted as a part of PrivHab+’s overhead because this message can be computed and sent asynchronously during the neighbour discovery phase, as explained in Section 4.5. As can be seen, the communicational overhead is quasi negligible, and most of the time is spent to compute the third message, at step 3. In fact, the computation of the third message is the most time-consuming operation because it includes decrypting the second message, calculating the distance between the habitat and the destination, and calculating the results operating with cyphered operands.

In this section we explain the two scenarios we have chosen to evaluate PrivHab+’s performance, and how we have modelled and simulated it. Afterwards, we provide the obtained results of both scenarios, comparing PrivHab+ performance and characteristics with other popular DTN routing algorithms. Finally, we provide a qualitative comparison with all other evaluated routing protocols.

To carry out the first set of simulations, we have chosen a podcasts distribution scenario located in the Cajamarca region, in Perú, where the NGO Practical Action
                        
                           21
                        
                        
                           21
                           More information about this programme at http://practicalaction.org/podcasting-3
                           
                         records podcast radio programmes targeted to farmers in Compact Discs and physically distributes them to the local radio stations. The scenario consists of an NGO office located in the village of Chota that distributes radio podcast programs to two NGO’s local radio stations located in the villages of Huambos and Cutervo. We substituted the physical distribution method by a digital and automated one using DTN networking. The podcasts are distributed through an opportunistic network. This application has to deal with challenges like a sparse population, with the receivers of the information far away from each other, a rugged terrain and a lack of data communication networks.

This scenario has been chosen because its characteristics make it ideal to evaluate the performance of a geographic routing protocol. Firstly, the area, shown in Fig. 12
                        , is full of mountains that restrict the movement of the nodes, so short-term movement information as the speed vector of a node is not useful to route messages. Secondly, due to the movement patterns of nodes there are pairs of nodes whose probability of encounter is almost zero. These nodes are forced to use intermediate nodes to carry their messages towards its destination. Besides, it is based on a real application of DTN networking placed in an environment that lacks network infrastructure, where a solution based in the usage of small and cheap devices would be viable.

To carry out the second set of simulations, we have chosen another podcasts distribution scenario located in Gwanda, in Zimbabwe. Due to the success of their initiative in other rural areas, the NGO Practical Action
                        
                           22
                        
                        
                           22
                           More information about this programme at http://practicalaction.org/podcasting-gwanda
                           
                         use a manpower of 60 cooperators to bring the podcasts to the villagers. The poor radio signal of the area makes unusable the approach of recording CDs and distributing it to the local radio stations. Therefore, the cooperators, equipped with portable MP3 players and speakers, have to physically travel to the NGO office to obtain new podcasts. The scenario consists of an NGO office located in the village of Gwanda that distributes radio podcast programs to five cooperators that roam around Gwanda, the village of Sablevale and the two main farm’s zones near Gwanda. We implemented a digital and automated distribution method that distributes the podcasts through an opportunistic network. This application has to deal with challenges like a sparse population, mobile receivers of the information, and a lack of data communication networks.

This scenario has been chosen to evaluate the performance of PrivHab+ because it has some characteristics different than the previous one. The area is smaller than the Cajamarca’s one (15 × 7km) and, as shown in Fig. 13
                        , the main physical obstacle that restricts the movement of the nodes is the Mtshabezi River. Besides, the density of nodes is higher, and there are five different mobile destinations, although the NGO knows the approximated zone where they are assigned. As there are more destinations than in the Cajamarca scenario, and nodes are very unlikely to be useful to deliver messages to more than one destination. Therefore, there are more nodes whose usefulness to deliver messages to certain destinations is almost zero, and a good decision making is critical to obtain a good performance.

The application we consider in these two scenarios is a podcast distribution application based on the needs of the NGO Practical Action. This NGO already has a manpower of cooperators devoted to distributing the podcasts physically in the two explained scenarios. Therefore, we assume that it could be easy to assign one cheap device to every cooperator. This way, Practical Action could transform its manpower of cooperators into a Delay Tolerant Network of mobile nodes.

One can think that a cooperator that has been assigned by the NGO to a certain area, and that has received a device from the NGO in order to distribute the podcasts in that area, may not be very concerned about the privacy of its habitat or the amount of buffer occupied by the podcasts. However, if the NGO wants to extend the network cheaply by adding other types of nodes, e.g. volunteers that want to help the NGO, there are two characteristics of PrivHab+ that can make it more useful than other DTN routing solutions: 1) PrivHab+ protects the privacy of its users; and 2) PrivHab+ can achieve a good performance occupying a small buffer.

A volunteer could just install an app on his PDA to become part of the network. This way, he could help the podcast distribution by simply carrying his mobile device in the pocket when he performs his daily routine. Given that hurting people’s privacy do not seem a good way to incentivise them to install an app, it is important that PrivHab+ guarantees their privacy. The same way, we cannot expect users to renounce to a big part of their storage capacity to carry podcasts because they probably want to continue using their devices normally. As a high usage of resources will give the users reasons for leaving the network, it is desirable to reduce as much as possible the impact on the users’ devices. Therefore, it is useful that PrivHab+ is capable of achieving a good performance even using small storage buffers.

In our interpretation of these scenarios, nodes implement a mobility pattern that takes into account home and work locations. Nodes have a 200 MB buffer and a wireless interface featuring a communication range of 30 m and speed up to 500 kbps. Messages of 10–20 MB
                           23
                        
                        
                           23
                           This is the size of an audio file with ID3 version 2.4.0, extended header, contains: MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, stereo, with a duration between 10 and 20 min.
                         are injected periodically in the network by the NGO office, who knows the location, exact on the first scenario, approximated on the second one, of the waypoints and the destinations. The type and the amount of nodes simulated in each scenario are shown in Table 10.
                     

During the approximation phase nodes calculate their habitat as explained in Section 3, and the protocol detailed in Section 4.5 is used to make the routing decisions. For the sake of simplicity, nodes implementing PrivHab+ use a direct single-copy forwarding policy. During the delivery phase, nodes use direct delivery to give the messages to their destination. We have modelled the computational and communication overhead introduced by PrivHab+ considering that nodes need 5.5 additional seconds to perform each transaction. This overhead time is based on real experimentation, it is the average time consumed by a Raspberry Pi board using a 1024 bits key.

In both scenarios, we have compared the performance obtained by PrivHab+ (using 
                           
                              T
                              =
                              48
                           
                         h on the first scenario, 
                           
                              T
                              =
                              24
                           
                         on the second one, and 
                           
                              β
                              =
                              60
                           
                         on both) with a bench-mark of well-known routing protocols used in [32]: Prophet [27], Binary Spray & Wait (L = 40) [38], Epidemic and Random [39]. We have added two routing protocols to this set: MaxProp [5] and First Contact. All simulations have been performed using The Opportunistic Network Simulator (The ONE) [21], and have been repeated twenty times using different random seeds, then, the average results of the twenty repetitions have been calculated.

Results obtained on the first scenario are shown in Fig. 14, where the performance of all the compared protocols in terms of delivery ratio and latency is depicted. Single-copy protocols, as First Contact and Random obtain a medium-to-high delivery ratio because they do not face most of the problems related to the size of the buffers and nodes’ congestion. In contrast, their latency is high. Random’s decision making is equally likely to make a bad or a good choice at every relay, but the latter ones are far more rare and valuable. First Contact performs slightly better because it avoids loops and forces messages to move away from their origin after they have visited all the near neighbours. Flooding-based protocols, as Epidemic and Prophet, obtain low latencies but also low delivery ratios. These protocols fill the buffers early and force nodes to drop messages. Most messages are dropped before reaching to its destination, but the ones that are not dropped arrive fast. MaxProp, also a flooding-based protocol, obtains a low latency and a good delivery ratio because of its better dropping policy based on probabilities of delivery. BS&W has a replication-based approach that limits flooding and performs a sort of depth-spread. BS&W performs similar to MaxProp in terms of latency, but obtain a medium delivery ratio because of its lack of a dropping policy that avoids dropping messages near their destination. Finally, PrivHab+ obtains the highest delivery ratio thanks to the quality of its decision making. PrivHab+ takes the best decisions because it is the only one that takes into account both the location of the destination and the mobility patterns of the
                         neighbours. Even with the drawback of using a single-copy forwarding policy, PrivHab+’s obtains a very low latency that is only slightly improved by flooding-based protocols that obtain lower delivery ratios.


                        Table 11 shows the average number of aborted relays, dropped messages, hops performed by the delivered messages, and the network overhead (calculated as the relation between the number of the relays done and the number of delivered messages). A low network overhead is desirable in scenarios where the resources are constrained. Reducing the number of relays saves battery and increases the amount of time nodes are operational, improving this way the performance of the whole network.

Epidemic and Prophet generate an enormous overhead of around one thousand percent that means that almost all nodes effort while forwarding messages is wasted, because the forwarded messages will probably be dropped before being delivered to their destination. Besides, Epidemic force messages to pass through a high number of intermediate hops after arriving its destination, causing a higher latency. MaxProp and Binary Spray & Wait (BS&W) generate a smaller amount of dropped messages and a lesser network overhead. These two protocols try to compensate their poor decision making by generating copies. Creating copies fills the buffers and consumes a lot of energy, but these two protocols create copies in a clever way than Epidemic and Prophet, consume fewer resources and need a lesser number of hops to obtain better results. Between them, MaxProp better delivery ratio can be explained because it spreads messages in a more equitable way through the network than BS&W. Note that MaxProp manages to drop less than a half of messages than BS&W and needs almost two average hops less to reach each message’s destination. Random and First Contact reduce highly the amount of messages dropped because do not flood the network with copies. However, their network overhead is also high because the majority of their relays are bad choices. Note that their number of hops and aborted relays is really high because messages spend a lot of time being relayed to nodes that will not approach them to its destination. Finally, PrivHab+ generates the smallest amount of dropped messages and the lowest network overhead because PrivHab+’s routing decisions are much better than the decisions taken by all other protocols.

Results obtained on the second scenario are shown in Fig. 15, where the performance of all the compared protocols in terms of delivery ratio and latency is depicted. In comparison with the results of Fig. 14 of the previous scenario, we can identify three main differences.

The first difference is that latencies obtained by all protocols are around a 50% lower. The reason is that physical distances in the Gwanda scenario are smaller. As a consequence, messages have to spend less time being carried by a node from one village to another.

The second difference is that two flooding-based protocols as Epidemic and Prophet, that ranked 3rd and 4th in the Cajamarca scenario in terms of latency, perform a little worse in this scenario. Both protocols are unable to tell the not useful relays apart from the useful ones. For this reason, they are harmed by the higher amount of nodes that are not useful to deliver messages to certain destinations. PrivHab+’s ability to identify useful relays through the comparison of habitats has benefited from this circumstance to obtain a lower latency (ranking 3rd).

Finally, the third difference is the lower delivery ratio of First Contact, Random and BS&W. The density of nodes is higher, so First Contact and Random have to make more routing decisions, and they usually make the wrong one. BS&W decreased delivery ratio is a consequence of the big share of created copies that are forwarded to the higher amount of not useful nodes. The rest of the results obtained are similar between the two scenarios. PrivHab+ low latency is only slightly improved by replication-based protocols like BS&W and MaxProp. However, in terms of delivery ratio, PrivHab+ greatly outperforms all other compared protocols, specially Epidemic, BS&W and Prophet.


                        Table 13
                         shows the average number of aborted relays, dropped messages, hops performed by the delivered messages, and the network overhead introduced by each protocol. As in the Cajamarca scenario, Epidemic and Prophet generate an enormous overhead. This means that almost all nodes effort while forwarding messages is wasted, because most of the forwarded messages are dropped before being delivered to their destination. The decreased efficiency of BS&W in this scenario is reflected in the introduced network overhead and in the number of hops. In this scenario, both values are higher than MaxProp’s. Note that MaxProp’s number of hops is the smallest one, but its delivery ratio it’s not the best. The reason is that sometimes MaxProp does not forward messages to nodes with low probabilities of encounter (because they never met the destination before) that are good choices because of their habitats. PrivHab+ recognise this nodes and use them to carry the messages, and this way it achieves a higher delivery ratio. Random and First Contact drop a small amount of messages because they do not flood the network with copies, but their overhead and number of hops are also high because the majority of their relays are bad choices. Finally, PrivHab+ generates the smallest amount of dropped messages and the lowest network overhead because PrivHab+’s routing decisions are much better than the decisions taken by all other protocols.

The small network overhead produced by PrivHab+ could allow users to use the same devices to run other applications like e-mail, voice messaging, blog-style publications, etc. Note that, being PrivHab+ the protocol with the higher computational overhead (5.5 s), it is also the one with the lowest amount of aborted relays. In fact, PrivHab+ takes better routing decisions. This reduces the total number of relays needed to deliver a message to its destination and the time that messages last in the network. As a consequence, nodes carry less messages and can forward all of them before the opportunistic contacts end. Therefore, we can state that the computational and communication overhead introduced by PrivHab+ is perfectly assumable because it is compensated by its better decision making, improving the performance of the network.


                        Table 12 summarises the whole comparison between all protocols. In addition to those already mentioned, delivery ratio, latency and network overhead; we also take into consideration nodes’ privacy, the protocol’s complexity, and the suitability to reach hop-distant destinations. Delivery ratio, latency and network overhead are the main performance indicators of a routing protocol. The importance of privacy has been discussed before. The protocol’s complexity could be important while using small devices and the number of nodes in the network grows. The suitability to reach hop-distant destinations is a capital aspect in scenarios where messages have to be forwarded many times due to the long distances between the source and the destination.

Nodes’ privacy is protected by PrivHab+, which is the only one that uses private information in a secure manner. Privacy is obviously not considered by the protocols that do not use node-related information to make choices. Besides, it is heavily violated by Prophet and MaxProp while nodes exchange their likelihood to contact others without protecting it. Furthermore, security of these two protocols cannot be easily enhanced, because they need to flood the network with a private information that is the basis of their operation.

The complexity of PrivHab+, BS&W, Epidemic, First Contact and Random is constant. These protocols need to perform always the same amount of operations to make a routing decision. MaxProp and Prophet need to update and compare an amount of probabilities that grow linear with the number of nodes of the network. When operating in networks with lots of nodes, both probabilistic protocols have to limit the amount of encounter probabilities they store, decreasing this way their performance.

Finally, in big scenarios where destinations are distant and messages have to be carried by many nodes, flooding-based protocols become poor routing protocols because they tend to congest the nodes that are nearest to the origin. This is what happens with Prophet and Epidemic. BS&W is slightly better because it avoids creating all the copies near the source node. First Contact is better than Random because, eventually, the message moves away from the origin, but both does it slowly anyway. The transitiveness of probabilities makes MaxProp perform well in this circumstance. However, as nodes that are far away in terms of hops are very likely to be far away too in terms of geographic distance, PrivHab+ is the most suitable routing protocol for delivering messages to hop-distant destinations because it is designed to make messages travel distances towards their destination.

PrivHab+ decision making is based on the comparison of habitats. For this reason, it requires the scenario to be big enough to benefit from a geographic routing approach, and it is only useful when the movement patterns of the nodes constitute some kind of routine. When this happens, this decision making allows PrivHab+ to deliver more messages to their destination, even when using a single-copy forwarding policy. Besides, in these scenarios PrivHab+ performs faster than all other protocols except BS&W and MaxProp and consumes far less network resources. Moreover, it preserves nodes’ privacy and performs really well when the number of nodes is high and the destinations of the messages are distant. Finally, PrivHab+ is efficient enough to be executed in small and cheap devices and the overhead that introduces is compensated by the quality of the routing decisions it makes, improving the performance of the network.

@&#CONCLUSIONS@&#

We have defined an elliptic model of habitat. The habitat models node’s whereabouts based on the idea of exploiting life-cycles. The habitat is useful to compare the intermediate nodes to decide who is a better choice to carry each message towards its destination. We have presented PrivHab+, a secure geographical DTN routing protocol that uses the habitat to make routing decisions. PrivHab+ takes advantage of Taxicab geometry and makes use of homomorphic cryptography techniques to preserve the privacy of the participants while comparing the habitats of the candidate nodes.

PrivHab+ has been analysed as a secure multi-party computation to proof that the protocol is secure. The only knowledge that can be learned by each participant about others intimacy is the same that could be inferred from the output of the protocol. This is an important point that makes PrivHab+ recommendable to use in scenarios where nodes are so related, directly or indirectly, to a person that their privacy needs to be protected.

We have developed a proof-of-concept implementation that demonstrates that the presented protocol is viable and that it can be executed on small devices with a good performance. Both the computation and the communication overhead introduced by PrivHab+ is proven to be affordable and to not degrade the performance of the network. Besides, simulations based on two podcast distribution scenarios have shown that PrivHab+ performs better than a set of well known DTN routing protocols and minimises the network overhead. The qualitative comparison between PrivHab+ and the other routing protocols shows that PrivHab+ is a good choice not only for this two scenarios. In fact, PrivHab+ is a good choice in any DTN scenario where nodes are linked to people, where mobility patterns are routinary, and where the considered distances are high, forcing the need of lots of hops to reach each destination.

As future lines of research, we plan to study the impact of different forwarding policies on the performance of PrivHab+, to improve the elliptic model of habitat using a more complex representation, that does not have to be necessarily a geometric figure, and to develop an enhanced version of PrivHab+ that compares simultaneously three or more habitats. We also plan to study the performance of PrivHab+ in different scenarios and to present more real applications that could benefit from this secure geographic routing protocol.

@&#ACKNOWLEDGMENTS@&#

The authors wish to thank Gerard García Vandellós for his work in the implementation of the proof-of-concept software and the insights he provided that helped to improve the presented protocol.

This work has been partially funded by the Ministry of Science and Innovation of Spain, under the reference project TIN2014-55243-P, by the Catalan Government under the reference project 2014SGR691 and by the Autonomous University of Barcelona under the reference number 472-03-01/2012.

@&#REFERENCES@&#

