@&#MAIN-TITLE@&#Optimized FPGA based continuous wavelet transform

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We design highly optimized architecture for continuous wavelet transform in FPGA.


                        
                        
                           
                           Lookup tables are highly recommended in case of implementing complex algorithms.


                        
                        
                           
                           Zero-free wavelet function and scale reduction save extensive amount of block RAM.


                        
                        
                           
                           Spartan 3AN FPGA device is suitable for real time EEG analysis with the CWT.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

CWT

EEG

ERP

FPGA

Optimization

@&#ABSTRACT@&#


               
               
                  A memory efficient field programmable gate array (FPGA) method is described that facilitates the processing of the continuous wavelet transform (CWT) arithmetic operations. The CWT computations were performed in Fourier space and implemented on FPGA following several optimization schemes. First, the adapted wavelet function was stored in a lookup table instead of computing the equation each time. Second, the utilization of FPGA memory was highly optimized by only storing the nonzero values of the wavelet function. This reduces 89% of the memory storage and allows fitting the entire design into the FPGA. Third, the design decreases the number of multiplications and shortens the time to produce the CWT coefficients. The proposed design was tested using EEG data and demonstrated to be suitable for extracting features from the event related potentials. Fourth, wavelet function scales were eliminated which saves further resources. The achieved computation speed allows for real time CWT application.
               
            

@&#INTRODUCTION@&#

The one dimensional continuous wavelet transform (1-D CWT) is a widely used feature extraction tool for nonstationary signals with applications to many different disciplines [1–3]. The complexity implied in the CWT belongs to the high number of convolutions involved especially between large sequences. In case of using the CWT in real time applications, high processing speed becomes critical to overcome these heavy convolution calculations and this can be achieved by using the field programmable gate array (FPGA) platform [4]. There are only a few studies in the literature concerning the implementation of the CWT into VLSI [5–9]. The complexity of mapping the CWT convolver in VLSI design was investigated in [5] and various realizations were presented, although they all depend on the convolution method. Other works rely on a General Purpose Processor (GPP) or DSP processor [7,8] or require high end FPGA devices [6,9] to implement the CWT. What has not been published is a CWT design that is fast and can be implemented on low cost FPGA devices.

Mathematically, the CWT is the convolution between the analyzed signal X(t) and the wavelet function ψ(t) in the time domain such that [10]:
                        
                           (1)
                           
                              C
                              (
                              s
                              ,
                              b
                              )
                              =
                              
                                 ∫
                                 
                                    -
                                    ∞
                                 
                                 
                                    ∞
                                 
                              
                              X
                              (
                              t
                              )
                              .
                              
                                 
                                    ψ
                                 
                                 
                                    s
                                    ,
                                    b
                                 
                                 
                                    ∗
                                 
                              
                              (
                              t
                              )
                              .
                              dt
                           
                        
                     where C(s, b) is the wavelet coefficient at time b and scale s and the symbol ∗ refers to the complex conjugate.

Eq. (1) can be implemented in the time domain for small size of input signals where the number of total convolutions is also small.

An alternative method to calculate the CWT for a sampled signal is to use Fourier space instead of the time domain [11]. This can be achieved by transforming both input signals of (1) X(t) and ψs
                     
                     ,
                     
                        b
                     (t) into the frequency domain using the fast Fourier transform (FFT) which replaces the complex convolution with simple multiplication using the following relationship [12]:
                        
                           (2)
                           
                              g
                              1
                              (
                              t
                              )
                              *
                              g
                              2
                              (
                              t
                              )
                              ⇔
                              G
                              1
                              (
                              ω
                              )
                              ×
                              G
                              2
                              (
                              ω
                              )
                           
                        
                     where lowercase g is the time domain components and uppercase G is the relative frequency domain representation. The product can be transformed back to the time domain using the inverse FFT giving the CWT coefficients [11]. Some of the most commonly used nonorthogonal wavelet functions in the CWT analysis are the Morlet, Paul and the Mexican hat. Their formulas in the time and frequency domain are shown in Table 1
                      
                     [11] where the representation of these formulas in both time and frequency domains are computationally complex. For example, in the time domain, the Morlet wavelet function consists of a complex sinusoid in the term 
                        
                           
                              
                                 e
                              
                              
                                 i
                                 
                                    
                                       ω
                                    
                                    
                                       0
                                    
                                 
                                 t
                              
                           
                        
                      multiplied by a Gaussian envelope. The spectrum of this modulated Gaussian permits for simple interpretation of results due to its smoothness [1]. The normalization factor π
                     −1/4 ensures that the Morlet wavelet has unit energy. In the frequency domain, the Morlet wavelet uses the Heaviside step function and in both domains, the Morlet expressions are complex. The mathematical background for the Paul and the DOG wavelet functions are also complex in both domains as one can see from Table 1.

The selection of the more appropriate wavelet function for a given application depends on the information required to be extracted from the signal. For example, detecting evolutionary or transient phenomena in a signal requires a wavelet function that reflects more localized wavelet coefficients [13].

Compared against the previous works presented above, the CWT design in this paper is a novel, generalized and configurable feature extraction engine for low end FPGA platforms. The design uses Fourier space techniques and employs several optimization methods to improve speed and significantly reduce resource requirements. The proposed design is not limited to a fixed wavelet function ψ(t) but can be easily adapted to different wavelet functions without the need to resynthesize or redesign the circuit. The proposed design uses optimized lookup tables (LUTs) in a block RAM (BRAM) to store the pre-calculated wavelet function. This is advantageous since the pre-calculated wavelet function only needs to be downloaded to the BRAM which means that the circuit design is not affected. It also means that the contents of the LUT can be easily replaced by another wavelet function when required by changing the LUT contents. This makes the low cost Spartan 3AN (1.4M gate) [4] suitable for the proposed design.

This paper is organized as follows; Section 2 presents the CWT design description, Section 3 gives the optimizations used in the CWT design and Section 4 outlines an implementation example based on Electroencephalogram (EEG) analysis. Section 5 presents the discussion and conclusions are provided in Section 6.

The computation of the CWT in Fourier space has been previously shown as an efficient and quick approach to implement the CWT using the FFT [12]. The design flow for the FFT based digital CWT can be seen in Fig. 1
                      
                     [14]. From Fig. 1, block A contains the wavelet function in the time domain, g2(t), at different scales and the FFT process required to transfer this function to the frequency domain. Both the input signal, g1(t), of length 2
                        n
                     , and the wavelet function (g2(t)) are stored in a buffer. After applying the FFT on both g1(t) and g2(t) the results G1(ω) and G2(ω) are stored in buffers C1 and C2 respectively. The contents of these two buffers are multiplied before applying an IFFT to produce the wavelet coefficients at all the wavelet scales.

Closer examination of the design flow for the CWT in Fig. 1 reveals that the wavelet functions in block A can be implemented using 3 possible methods:
                        
                           1.
                           Directly calculate the wavelet function in the time domain at different scales then apply the FFT to transform both the wavelet function and the signal into the frequency domain then start the multiplications with the signal to be analyzed.

Directly calculate the wavelet function in the frequency domain at different scales, then apply the FFT on the input signal and perform the multiplications between the wavelet function and the input signal.

Store the pre-calculated frequency domain-wavelet function points in a lookup table (LUT). In this case, once the length of the input signal and its sampling period are known, the points of the wavelet function can be pre-calculated and downloaded as a LUT. This also enables data reduction schemes to be employed on the wavelet values.

Methods 1 and 2 to calculate the CWT are structurally complex and implementing them in hardware cannot be easily realized. The trigonometric function, square root, power or factorials in the wavelet function in both domains (Table 1) require significant FPGA resources as well as adding further computations which increase the run time. In addition, they require a separate design and synthesis for each new wavelet basis function to be used. Method 3 uses a LUT for implementing block A and avoids all the mentioned complexity in methods 1 and 2 where no transform operations or wavelet function calculations are required. Therefore method 3 was selected for the CWT design because it reduces the complexity and the calculation time during real time application.

Although the FFT-IFFT method reduces the total operations required to calculate the wavelet coefficients, further optimization schemes were followed to reduce the FPGA resource usage and speed up the calculations. These optimizations result from adapting the LUT in the design as explained in the next sections.

The LUT was used to store the points of the wavelet function which were pre-calculated in the frequency domain G2(ω) and downloaded to the LUT (C2). The wavelet function stored in C2 is constant and can always be used with any input time series. When the wavelet base function needs to be changed, another wavelet function can be calculated and stored in C2. This approach makes the design versatile since it is applicable to many different types of wavelet functions.

As the LUT method is used to store the points of the wavelet function in the frequency domain, the transform of the wavelet function to the frequency domain can be optimized. The shape of the wavelet basis function at different scales can be used to optimize the storage size required as can be seen in Fig. 2
                        . The shape of the wavelet function contains a large number of zeros especially at higher scales. These zeros represent a considerable portion of the points of the wavelet function at each scale. The wavelet functions in Table 1 at scales 10 and 20 for Morlet, Paul and the Mexican hat are shown in Fig. 2. It can be noticed that zeros represent a considerable part of each vector of 1024 points for each wavelet type. These zeros can therefore be excluded from the LUT with only the nonzero points being stored. This has a large benefit in saving area in the LUT as well as multiplication operations when mapped into FPGA design. This case does not apply when these wavelet functions are in the time domain [11].

It can also be seen in Fig. 2 that the higher wavelet scales (e.g. scale 20) are compressed and have the least number of nonzero points which facilitates memory optimization more so than the lower scales (e.g. scale 10). The lower scale (scale 10) has a wider distribution and occupies more memory locations.

The exclusion of zeros in Section 3.2 allows further optimization to block B in Fig. 1 by reducing the total number of multiplications required since multiplication with zero does not need to be performed as it is trivially equal to zero. The multiplication process between the input signal and the wavelet function was performed as follows: each sample of the wavelet function was multiplied by the corresponding real and imaginary samples from the signal (both in the frequency domain) using two multipliers in parallel. Since zeros were removed from the wavelet function, the indices of the input signal depend on the indices of the wavelet function at a certain scale s. At higher scales, only a few points from the wavelet function are used with the multiplication circuit since most of the wavelet function vector points are zeros (see Fig. 2). The products of multiplication are stored in the LUT C3 (see Fig. 1).

Based upon prior knowledge of the input signal frequency components, certain wavelet scales can be eliminated that take calculation time in addition to LUT storage and hence only need to consider the scales that correspond to the frequencies of interest in the signal.

The optimization schemes in this section are effective for the CWT design and they are all implemented in a case study as outlined in the following section.

This section shows a design example for the proposed methodology which analyzes an EEG signal using the Morlet wavelet. The EEG is a weak signal with amplitudes <100μV and typically examined frequency components occur between 0.5 and 100Hz [15]. The example presented in this section provides a demonstration for the optimizations listed in Section 3. This section shows a CWT example using the Morlet wavelet function in transforming an EEG signal in FPGA. Section 4.1 describes the application and shows how the zero-exclusion case is employed. Sections 4.2 and 4.3 presents a criteria to increase the frequency of operation for the whole system.

The Frequency-domain based Morlet wavelet function was chosen for the CWT design among the other functions since it is a simple function and suitable for spectral analysis [16]. This Morlet wavelet function has a center frequency equal to 1 for a good trade-off between time and frequency localization [2]. The Morlet wavelet was calculated in the frequency domain and represented with a sequence of 1024 points at each scale. The EEG signal was broken into epochs of 1024ms sampled at 1000Hz. A typical EEG
                           1
                           The Griffith University ethics number for human research was (PSY/92/09/HREC).
                        
                        
                           1
                         used in this application can be seen in Fig. 3
                         which is the response when a participant is presented a specific stimulus. In the present study this was an unexpected (or “oddball”) event. The brain response is contained within the event related potential (ERP). This reflects a synchronous firing of a population of neurons within few hundreds of milliseconds after the stimulus is presented and contains the well-known P300 component. The P300 component has a peak approximately 300–500ms after the presentation of the stimulus [15]. A signal length of 1024ms was sufficient for the stimulus to be processed and for a brain response to be recorded. The finite signal length in the ERP application (1024ms) allows fixing the number of wavelet scales required for analysis to 37 where the number of these scales depends on the length of the analyzed signal and its sampling interval [11]. A fixed number of wavelet function scales enables pre-storing the wavelet function at those scales inside the FPGA BRAM. Both points of the Morlet wavelet and the EEG signal were represented by 16 bits in the design.

The Xilinx Spartan 3AN FPGA was used as a target technology due to its low cost, availability and its common use. Previous work by the authors has employed a FFT-IFFT approach to calculate the CWT [17]. The FFT engine employed was a Xilinx FFT core V.5 and was configured with radix-4 burst I/O to perform the FFT-IFFT with the designed VHDL controllers. Radix-4 configuration option is an area-speed trade-off between radix-2 and the streaming architecture (other available configuration options for the FFT core) [18]. The detailed implementation architecture including FFT-IFFT, resource utilization are available in [17].

Instead of storing the Morlet wavelet for the whole scale of 1024 points and for 37 times, zeros can be excluded from computations and only nonzero points were considered as outlined in 3.2. The inclusion of the whole length of scales requires (37×1024point)×16bit/point
                        =606,208 bit locations. By excluding zeros, the total number of required locations including all the 37 scales was reduced to 4138×16bit
                        =66,208 locations. To comply with the memory standard as a power of 2, the number of locations is further reduced to end with 4096×16bit
                        =65,536 (or 4K×16) total locations to store the Morlet function (about 89% reduction compared to using all points of all scales). The later reduction is done here by excluding some nonzero points from the wavelet function at scale number one which corresponds to the frequency 1000Hz (normally considered to be well out of the EEG frequency range) and has no serious effect on the produced results. As a result of zero-exclusion, the total number of multiplications is reduced from 2 (real and imaginary components)×37K) to only 2×4K. Table 2
                         shows the wavelet scales applied with the corresponding frequencies and the indices range with the length of the nonzero Morlet points. For example, at scale 17, Morlet nonzero wavelet values are in the index range 23–101 (out of 1024). This range is multiplied by the corresponding range from the EEG in the frequency domain.

When the multiplication process was completed, the next step was to perform the IFFT. The number of points at each scale product depends on the nonzero Morlet values at that scale. Zero insertion before and after each product array was performed during the IFFT data loading task to complete a vector of 1024 point. The IFFT was repeated 37 times. The resulting CWT coefficients required two arrays of bits, each being: 37scales
                        ×1024point
                        ×16bit memory size. One is for the real CWT component and another one for the imaginary component. Due to the limited size of memory inside the Spartan 3AN (BRAM) to save all the CWT coefficients, the SRAM chip was used (see Fig. 1).

The static RAM (SRAM) is located on the Altium NanoBoard which is the design environment [19] outside the FPGA and was used because the rest of the available BRAM was not enough to store the CWT coefficients on the size of two 37scale
                        ×1024point
                        ×16bit (2×37 K points). For that, two BRAMs (each 1K
                        ×16 bit) were used to temporarily store the wavelet coefficients at individual scales after the completion of every inverse FFT process. One of them was for real CWT component and the other for the imaginary component. While the FFT core loads new data and computes the inverse FFT of that data for the next scale, the CWT coefficients inside the BRAM were transferred into the SRAM. Before unloading new scale of wavelet coefficients, the FFT core requires 1024 clock cycles for loading+1366 clock cycles for computation=2390 clock cycles. The real and imaginary CWT coefficients were transferred from the BRAM into the SRAM in parallel using 2 clocks per coefficient (2048 clock cycles for one full scale). Therefore, there was enough time for the BRAM data to be copied to the SRAM before the BRAM is overwritten by the next scale of wavelet coefficients. Table 3
                         illustrates the data transfer schedule from the FFT core passing into the BRAM and then to the SRAM at two different times T1 and T2.


                        Fig. 4
                         shows the schematic diagram control circuit for “write/read” of the BRAM in the Altium environment. As long as the data is valid by the FFT core output, the output dvp becomes high and the BRAM is addressed by the core output xk_indexp[9..0]. The WE input for the BRAM receives logic high from the and-gate (Fig. 4). The other input of the and-gate is from the core input fwd_invp. This pin controls the FFT process; when at ‘1’, the core performs the forwards FFT whereas ‘0’ changes the task to the inverse FFT. Accordingly, the BRAM cannot receive data unless the fwd_dvp
                        =’0’ and the dvp
                        =’1’ at the same time. When all the CWT coefficients for one scale are transferred into the BRAM, the dvp is switched to ‘0’ to change the address source of the BRAM to be addressed by a VHDL based controller. This monitors the transfer of data from the BRAM into the SRAM. Not all the wiring connections are shown in Fig. 4.

The implication for the involvement of the SRAM was that the maximum theoretical access time for the SRAM according to the data sheet is 12ns (maximum speed of data transfer is about 80MHz which justifies the reason for indirect storage in the SRAM). This forces the maximum frequency of operation for the system to be 80MHz (with the SRAM). However, the critical path of the CWT design allows rising the clock frequency up to 125MHz (without the SRAM). Since the SRAM was controlled to receive data at the rate 2 clock/sample, the design can operate at 125MHz and the SRAM receives the CWT coefficients at half of this rate (62.5M sample/s). This technique results in a very short time to produce the CWT coefficients. The total occupied BRAM for the CWT design was 90% from the available BRAM inside the FPGA compared to 140% utilization without the involvement of the SRAM in the design.

According to Section 3.4, as most of the EEG frequency components are less than 60Hz [20], upper frequency components can be omitted to reduce the number of computations and save required BRAM. Fig. 5
                         shows the FFT single sided amplitude spectrum of an EEG signal. The frequency components of the EEG are concentrated in the lower area in Fig. 5(a) representing the EEG frequencies of interest whereas Fig. 5(b) shows very small frequency components and therefore, the frequency range 60–200Hz can be ignored and excluded from the CWT computation.

Excluding higher frequencies means that the lower scales of Morlet are not going to be involved in the computation and therefore there is no need to calculate or store them in the BRAM. Only the CWT for the frequency range 2–60Hz is covered which is where the major EEG frequency components are located. Fig. 6
                         shows the scales excluded from computation. These are scales 1–16 which reflect the frequency components in the EEG signal higher than 62Hz as presented in Table 2. The rest of the scales 17–37 (corresponds to 2–62.5Hz) cover the typical frequencies of the EEG. The 4096 locations required to store the 4096 points for the wavelet function at 37 scales in Table 2 was reduced to only 499 locations by this exclusion which means saving of the BRAM by more than 87%. The number of total multiplications and the total computation time are also reduced.

The exclusion of the unnecessary scales resulted in an improvement in the timing report for the design compared to the first case that included the wavelet function at all scales. Table 4
                         shows a comparison between the first case (37 scales included) and the second case (scales 17–37 only considered). From Table 4, it can be noticed that both designs operate at 125MHz. However, in the scale-excluded case, it indicates a higher speed in calculating the CWT. A run time of 1ms was achieved for the entire CWT scale set which is reduced to 0.6ms in the scale-excluded set. In addition, the reduction in computations shortens the critical path which raises the design clock rate to 133MHz resulting in lower computation time. With the 133MHz, the time of computations is reduced to 0.57ms instead of 0.6ms, which is almost half the required time of the entire-scale case. The achieved improvement in the maximum clock rate is due to a shorter critical path as a result of reduction in complexity.

Despite the increase in the run time to calculate the CWT (in case the SRAM was not used) to few milliseconds only (calculated theoretically), the involvement of the SRAM was indispensable to overcome the space limitation in the FPGA BRAM.

Software calculation of the CWT was used to verify the result produced by the FPGA. Matlab was used to calculate the CWT as well as to display the results from the FPGA. Fig. 3 shows the ERP signal used to test the CWT-FPGA and also used to generate the same CWT-software based analysis. As a result, Fig. 7
                        (a) shows the CWT scalogram based on the FPGA and Fig. 7(b) shows the CWT scalogram based on the software (Matlab) calculation. Only the frequencies of interest were included. The differences between Fig. 7(a and b) are due to the quantization error in Fig. 7(a). The impact of quantization error on the results was addressed in [21] and indicated the validity of the undertaken FPGA method.

@&#DISCUSSION@&#

In order to check the performance of the CWT engine design, the time taken to compute the CWT needs to be compared to other designs in the literature [7–9] as given in Table 5
                     . Comparison is not easy due to the different implementations and different hardware platforms. Table 5 shows a range of parameters to allow a more fair comparison between these references. In addition, both [7,8] are applications in the biomedical field with the same signal size used in this work. The listed works in Table 5 shows different CWT algorithms implemented on different VLSI technologies and at different operational frequencies. Lower run time in the table indicates better implementation.

Although our FPGA target technology has moderate specifications, with the presented optimizations, it was suitable to the CWT design entirely and able to achieve the minimum run time of 0.57ms compared to previous works listed in Table 5. Refs. [7,8] had employed different VLSI technologies, however, the signal length is close to the one adapted in this work. They achieved run times of 5ms and 47.9ms respectively. Ref. [9] is closer to compare with the work presented in this paper since both employ FPGA chips whereas [7,8] used the processor solution. Ref. [9] employed a high end FPGA device to implement the lifting scheme for a two-dimensional signal and obtained a run time of 12.16ms. Finally, compared to the software case, the same processing algorithm implemented in this paper consumes 16ms in Matlab using Apple MacBook Pro PC running Windows 7–64 bits with the following specifications; dual core i5 CPU@ 2.4GHz, 4GB RAM.

The achieved low run time in the presented design is highly related to the optimizations of using LUT, zero exclusion, reduction in multiplications and scale elimination followed in Section 3 of this paper that effectively reduce the operations and the CWT calculation time. The wavelet function was directly stored in the memory which saved extra 37 FFT computations. In addition, zero exclusion assisted in saving 89% of memory usage comparing with the case no zero exclusion being made. Furthermore, in the method of zero exclusion, the eliminated scales (1–16) have reduced 87% from the BRAM required to store the wavelet function compared against the case that uses the Morlet wavelet function at all scales (1–37). This leads to a reduction in the number of required operations, an increase in the operational frequency and reducing the total computation time. The differences between Fig. 7(a and b) are belonging to the quantization error produced during the FFT-IFFT processing and in representing the points of the signals by a finite word length (16 bit/point) in the FPGA [21].

According to the applied optimization methods, the improvement in the CWT design is summarized in Table 6
                     .

From Table 6, one can notice that the scale reduction was useful in further reducing the design running time. Without the zero exclusion, the available BRAM is not enough to store the wavelet function and the design intermediate results since the wavelet function alone requires 606,208 locations to be stored which exceed the available BRAM in the FPGA. This number is reduced to only 11% (65,536 locations) when the zero exclusion was adapted. Storing the design input signals in the BRAM (inside the FPGA) was an aim to speed up the whole processing time and leave the SRAM ICs (outside the FPGA) to be occupied by the whole CWT coefficients.

@&#CONCLUSIONS@&#

This paper has presented a CWT architecture to process nonstationary signals with the Morlet wavelet function using a Spartan 3AN FPGA. The implemented architecture was flexible and generic due to the pre-calculations performed on the wavelet function. Since these calculations were performed in the frequency domain, the heavy convolutions were replaced with multiplications. In addition, as the shape of the wavelet function in the frequency domain contains a large number of zeros, the exclusion of these zeros assisted in reducing the total number of calculations required for the CWT. The presented design with optimizations was examined by an ERP signal that showed the validity of the technique. The achieved run time of 0.57ms leads to the conclusion that the proposed CWT can be used to extract features from signals in real time applications. Future work will consider signals of variable length for analysis.

@&#ACKNOWLEDGMENT@&#

This work was supported by the Ministry of Higher Education and Scientific Research of IRAQ.

@&#REFERENCES@&#

