@&#MAIN-TITLE@&#Integer programming techniques for solving non-linear workforce planning models with learning

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We address a class of production problems that model human learning with non-linear curves.


                        
                        
                           
                           We reformulate the non-linear program to an equivalent mixed integer program (MIP).


                        
                        
                           
                           We present a specialized algorithm for solving the MIP.


                        
                        
                           
                           We show that the MIP is much easier to solve than the non-linear program.


                        
                        
                           
                           We show that the specialized algorithm is superior to a state-of-the-art solver.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Production planning and scheduling

Human learning

Nonlinear programming

@&#ABSTRACT@&#


               
               
                  In humans, the relationship between experience and productivity, also known as learning (possibly also including forgetting), is non-linear. As a result, prescriptive planning models that seek to manage workforce development through task assignment are difficult to solve. To overcome this challenge we adapt a reformulation technique from non-convex optimization to model non-linear functions with a discrete domain with sets of binary and continuous variables and linear constraints. Further, whereas the original applications of this technique yielded approximations, we show that in our context the resulting mixed integer program is equivalent to the original non-linear problem. As a second contribution, we introduce a capacity scaling algorithm that exploits the structure of the reformulation model and reduces computation time. We demonstrate the effectiveness of the techniques on task assignment models wherein employee learning is a function of task repetition.
               
            

@&#INTRODUCTION@&#

Peter Senge famously wrote that the learning organization is “continually expanding its capacity to create its future” (Senge, 2006). Citing employee learning as an effective way to create capacity from existing resources, Levinthal and March (1993) argue that effective management of employee learning can lead to a sustainable competitive advantage. Some go further and claim that, in the modern business environment, the only sustainable competitive advantage will come from a company’s ability to learn more effectively than its competitors (Kapp, 1999). Even if it is not the only source of competitive advantage, Moustaghfir (2009) identifies learning as a core component of organizational capabilities that are “immune to competitive duplication.” In this paper, we address the issue of learning at the operational level by developing solution techniques for workforce planning models that incorporate individual on-the-job learning.

In particular, this paper focuses on a class of multi-period workforce planning models that recognize human learning and forgetting over a fixed planning horizon in environments that can be characterized as task assignment. We consider a workforce that produces a product, the production of which requires the completion of a sequence of tasks. Inventory is allowed to accumulate in between each task in the sequence. We assume that the workforce’s current skill levels and thus their productivity are heterogeneous. As workers perform a particular task, they gain experience that correspondingly leads to a productivity improvement as they learn on the job. In addition, when workers are not doing a particular task, they forget some of what they have learned and their productivity on that particular task erodes. We assume that each worker has his or her own rate of learning and forgetting for each task. The objective is to maximize production over a fixed time horizon.

In humans, the relationship between experience and productivity, also known as learning (possibly also including forgetting), is non-linear. Thus, prescriptive models incorporating learning are difficult to solve. This paper helps overcome this challenge in two ways.

First, it adapts a reformulation technique for non-convex optimization problems that enables linearization of the learning curves. For general non-convex optimization, the reformulation yields an approximation of the original non-linear program (NLP). However, in our application, the non-linear functions have a specific structure that has not previously been explored. Specifically, they are functions of the number of times an individual has performed a task over a fixed number of periods, and thus have discrete and finite domains. In this case, solutions to the mixed integer program (MIP) resulting from the reformulation are optimal for the original non-linear program. As a result, we can solve MIPs instead of NLPs, and with the superior capabilities of MIP solvers to those of NLP solvers, we are able to solve problems that are significantly larger than what has been previously possible.

The reformulation technique associates a binary variable with each element of the domain of the non-linear function we wish to linearize. In our application this translates to representing each potential skill level for each worker in each period of the planning horizon with a binary variable. As a result, as instance sizes grow, the resulting MIPs become large, increasing solve times. Thus, as a second contribution, we derive structural properties of the feasible region of the MIP that in turn motivate a capacity scaling algorithm wherein these variables are generated dynamically. With an extensive computational study, we see that this algorithm reduces solution time. The capacity scaling algorithm can be applied to any MIP resulting from the reformulation technique.

The remainder of this paper is organized as follows. In Section 2, we review the relevant literature. Section 3 presents our reformulation technique, and Section 4 introduces the capacity scaling heuristic that exploits the structure of the reformulation. Section 5 presents the non-linear and reformulated math programs for the workforce planning model on which we perform computational tests. The section also demonstrates how to implement the capacity scaling algorithm with the reformulated workforce planning model. Using instances of different sizes and characteristics, Section 6 studies the computational times associated with the reformulated math program and the scaling algorithm. Section 7 offers conclusions and opportunities for future work.

@&#LITERATURE REVIEW@&#

Given its importance, a significant body of research has been devoted to developing quantitative models of individual learning and forgetting. These models are often called learning curves. Of particular interest for this paper is research devoted to on-the-job or experiential learning, which is sometimes also called autonomous learning. Dar-El (2000) provides a comprehensive review of both learning and forgetting models as well as parameter estimation for learning models developed before 2000. Jaber and Sikström (2004) and Anzanello and Fogliatto (2011) provide overviews that account for more recent work on learning and forgetting models. Taking advantage of improved data collection capabilities resulting from bar code readers and other similar devices, Nembhard and Uzumeri (2000a) conclude that a three-parameter hyperbolic function provides best fits observations of individual learning. Nembhard and Uzumeri (2000b) extend the three-parameter hyperbolic function to incorporate forgetting. Nembhard (2001) examines several models of forgetting and identifies those with robust performance. Shafer, Nembhard, and Uzumeri (2001) introduce a model that accounts for the recency of a task. Jaber and Sikström (2004) provide a numerical analysis that, for three models, identifies in which particular applications each model has the best statistical fit of the learning and forgetting measured in the application. While our work is amenable to other models of learning and forgetting, we focus this work on the exponential function used in Nembhard and Norman (2007, chap. 4). The function was introduced by Thomas and Nembhard (2005) as an exponential learning and forgetting function designed to achieve the performance of the three-parameter hyperbolic function while allowing for improved tractability in optimization models.

A number of authors have incorporated models of learning or of learning and forgetting into optimization models for workforce management. While the existing work covers a variety of different applications, a common theme is the challenge in solving large-sized instances. The success of exact solution approaches has been particularly limited. Nembhard and Norman (2007) introduce a task-assignment model that includes learning and forgetting. Computational results are presented for a two workers, four tasks, and 10 time periods example. For ease of exposition, we choose a model similar to what is presented in Nembhard and Norman (2007) to illustrate our reformulation technique. Heimerl and Kolisch (2010) also consider an assignment model with the addition of constraints that represent the firm’s desired skill composition at the end of a specified period of time. Kim and Nembhard (2010) use a non-linear mixed integer program to test the effects of experimental factors on cross-training policy selection. While the number of tasks is difficult to determine, the largest problem size considered has three workers and 24 periods. For the situation in which each station has infinite buffers and a problem similar to that studied in this paper, Nembhard and Bentefouet (2012) identify the structure of the optimal policy for the case where the number of tasks and workers is the same. The result allows the authors to solve the problem up to 96 workers, 96 tasks, and 246 periods. Using the flow-line production scenario used in this paper as an application and for small problems of two to three workers and two to three tasks, Bentefouet and Nembhard (2013) identify structural properties that characterize the optimal solution. The results do not generalize.

In addition to the specific structural results, however, Bentefouet and Nembhard (2013) present a model that provides an upper bound on the production that can be achieved from the application discussed in this paper. The nature of the formulation of the upper bound problems allows the authors to linearize the learning functions in a way that is a special case of the reformulation presented in Section 3. As noted in Bentefouet and Nembhard (2013), solutions to their presented model do not generally offer implementable task assignment schedules. The techniques discussed in this paper do offer implementable task assignments. The authors of this paper are not aware of any papers that offer a mixed integer reformulation of a non-linear function with a discrete domain.

To overcome the non-linearities of the learning and forgetting functions, a number of authors consider approximation schemes. In the literature that follows, none of the authors addresses how well their schemes approximate the learning and forgetting functions nor do they discuss whether or not the approximation impacts solution quality relative to using the actual learning and forgetting functions. Nembhard and Bentefouet (2012) introduce a rectangular approximation for learning/forgetting functions. For a problem similar to the application used in this paper, the approximation can solve 10 worker, 10 task, and 40 period problems. Corominas, Olivella, and Pastor (2010) introduce a piece-wise linear transformation of a convex learning function for a task assignment problem that incorporates learning resulting from experience with related tasks. The largest problem solved in that paper has five tasks, four workers, and 20 time periods. Olivella, Corominas, and Pastor (2013) combines piecewise linearization with constraint relaxation. Sayin and Karabati (2007) also use a piecewise linear approximation of the learning function, but in a problem in which they first try to maximize utility and then skill improvement. In addition to the linearization, the problem is solved for only a single period with each period’s solution implemented as part of a simulation. Problems with at most 18 workers and four different skills are solved. Gutjahr, Katzensteiner, Reiter, Stummer, and Denk (2008) consider maximizing a weighted average of economic gains and skill development for a project selection problem. As part of the selection process, assignments to selected projects are optimized. Gutjahr et al. (2008) introduce a first-order approximation of the non-linear learning curve and are resultantly able to solve the approximate model to optimality for an example with 14 candidate projects requiring a mix of 40 skills (analogous to tasks in our discussion) with 28 workers over 24 periods.

A number of heuristic approaches to task assignment with learning can be found in the literature. Yan and Wang (2011) consider a model with the same learning function considered in this paper. They introduce a genetic algorithm and solve a problem with six workers and five tasks over 40 periods. Other heuristic approaches can be found in Wirojanagud, Gel, Fowler, and Cardy (2007) and Fowler, Wirojanagud, and Gel (2008).

In this section, we present a technique that uses a set of binary variables and constraints to reformulate a non-linear function. This technique was first presented in Beale and Tomlin (1970) and more recently put into context in Burer and Letchford (2012). The technique was initially developed for general, non-convex optimization problems, and its application results in a mixed integer program that approximates the original non-linear program. Our use of the reformulation technique yields an exact reformulation (solving the resulting mixed integer program yields an optimal solution to the original non-linear program). Finally, while our motivation is non-linear learning curves, we provide a presentation that demonstrates the reformulation for any non-linear function with a discrete domain.

Let X be a vector of binary decision variables and g(X) a linear function whose range is characterized by a discrete and finite set 
                        K
                     . As an example, in the workforce planning application we will consider later, g(X) is the sum of variables that determine workers’ accumulated experience. We consider a function f(g(X)), which, as in the application we discuss later, is such that f(g(X)) > 0, ∀ feasible vectors X. We do not assume a particular form for f( · ), but are particularly interested in cases where it is non-linear. In our application, f( · ) is a learning curve that takes workers’ accumulated experience as input. Our goal is to model f( · ) with linear constraints and binary variables so that we can solve a mixed integer program instead of a non-linear program.

Given our definition of f( · ) and its discrete and finite domain, the range of the function f( · ) can be enumerated (although we do not assume that the values in the range are integer). Thus, we introduce a single continuous variable r, with which we will model the value of f(k), and a binary variable zk
                      for each potential value 
                        
                           k
                           ∈
                           K
                        
                     . We then define constraints to ensure that when zk
                      = 1, r takes on the value f(k). Formally, we use the following constraints:

                        
                           (1)
                           
                              
                                 r
                                 =
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 f
                                 
                                    (
                                    k
                                    )
                                 
                                 
                                    z
                                    k
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 g
                                 
                                    (
                                    X
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 k
                                 
                                    z
                                    k
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    z
                                    k
                                 
                                 =
                                 1
                                 ,
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    z
                                    k
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 
                                 k
                                 ∈
                                 K
                                 ,
                                 r
                                 ∈
                                 ℜ
                                 .
                              
                           
                        
                     Together, constraints (1), (2), and (3) ensure that r = f(g(X)). Note that constraint (3) is necessary for the formulation to be correct. For example, consider the case in which 
                        
                           K
                           =
                           {
                           1
                           ,
                           2
                           ,
                           3
                           }
                           .
                        
                      Without constraint (3), for values of X such that g(X) = 3, z
                     1 = z
                     2 = 1, r = f(1) + f(2) would be feasible, when in fact we should have r = f(3).

The correctness of the reformulation is given in the following theorem:

                        Theorem 1
                        If 
                              
                                 
                                    z
                                    ¯
                                 
                                 ,
                                 
                                    r
                                    ¯
                                 
                              
                            satisfy constraints (1), (2), and (3) for 
                              
                                 
                                    X
                                    ¯
                                 
                                 ∈
                              
                            domain of g(X), then 
                              
                                 
                                    r
                                    ¯
                                 
                                 =
                                 f
                                 
                                    (
                                    g
                                    
                                       (
                                       
                                          X
                                          ¯
                                       
                                       )
                                    
                                    )
                                 
                                 .
                              
                           
                        

By definition, 
                              
                                 g
                                 (
                                 
                                    X
                                    ¯
                                 
                                 )
                                 ∈
                                 K
                                 ,
                              
                            and there is a variable 
                              
                                 
                                    z
                                    ¯
                                 
                                 
                                    g
                                    (
                                    
                                       X
                                       ¯
                                    
                                    )
                                 
                              
                            defined. Because exactly one variable zk
                            can equal one, we must have that 
                              
                                 
                                    
                                       z
                                       ¯
                                    
                                    
                                       g
                                       (
                                       
                                          X
                                          ¯
                                       
                                       )
                                    
                                 
                                 =
                                 1
                              
                            by constraint (2). As a result, by constraint (1) we have that 
                              
                                 
                                    r
                                    ¯
                                 
                                 =
                                 f
                                 
                                    (
                                    g
                                    
                                       (
                                       
                                          X
                                          ¯
                                       
                                       )
                                    
                                    )
                                 
                                 .
                              
                           
                           □

If f(k) = a + h(k), we may rewrite constraint (1) as 
                        
                           r
                           =
                           a
                           +
                           
                              ∑
                              
                                 k
                                 ∈
                                 K
                              
                           
                           h
                           
                              (
                              k
                              )
                           
                           
                              z
                              k
                           
                           .
                        
                      Lastly, we note that when solving a maximization problem wherein the objective is non-decreasing in r we can relax constraint (1) to 
                        
                           r
                           ≤
                           
                              ∑
                              
                                 k
                                 ∈
                                 K
                              
                           
                           f
                           
                              (
                              k
                              )
                           
                           
                              z
                              k
                           
                        
                      without changing the set of optimal solutions.

Capacity scaling is a well-known algorithmic strategy, often applied to network flow models, wherein an optimization problem that is similar to, yet easier to solve, than the original is repeatedly solved in order to produce high quality solutions to the original problem (Ahuja and Orlin, 1995). We use facet-defining valid inequalities of the above reformulation model to create these simpler problems.

Specifically, we consider the set

                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          S
                                          =
                                       
                                    
                                    
                                       {
                                    
                                    
                                       
                                          z
                                          ∈
                                          
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             n
                                          
                                          ,
                                          x
                                          ∈
                                          ℜ
                                          ,
                                          y
                                          ∈
                                          ℜ
                                          :
                                          x
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          =
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             a
                                             j
                                          
                                          
                                             z
                                             j
                                          
                                          ,
                                          y
                                          ≤
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          f
                                          
                                             (
                                             
                                                a
                                                j
                                             
                                             )
                                          
                                          
                                             z
                                             j
                                          
                                          ,
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             z
                                             j
                                          
                                          =
                                          1
                                          ,
                                          y
                                          ≤
                                          b
                                          }
                                       
                                    
                                 
                              
                           
                        
                     and seek to find facets of its convex hull, conv(S). As above, we have assumed that f(aj
                     ) > 0 ∀j = 1, …, n. Thus, we limit our attention to cases wherein b > 0. We note, that in the definition of the set S, we have modeled g(X) with the single variable x. We next show in Theorem 2 that, by tightening the right-hand side coefficients in the inequality 
                        
                           y
                           ≤
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              n
                           
                           f
                           
                              (
                              
                                 a
                                 j
                              
                              )
                           
                           
                              z
                              j
                           
                        
                      based on the value of b to

                        
                           (6)
                           
                              
                                 y
                                 ≤
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 min
                                 
                                    (
                                    f
                                    
                                       (
                                       
                                          a
                                          j
                                       
                                       )
                                    
                                    ,
                                    b
                                    )
                                 
                                 
                                    z
                                    j
                                 
                                 ,
                              
                           
                        
                     one arrives at a facet of conv(S).

                        Theorem 2
                        The inequality 
                              
                                 y
                                 ≤
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 min
                                 
                                    (
                                    f
                                    
                                       (
                                       
                                          a
                                          j
                                       
                                       )
                                    
                                    ,
                                    b
                                    )
                                 
                                 
                                    z
                                    j
                                 
                              
                            defines a facet of conv(S).

It is easy to see that the inequality is valid. We first prove that dim(conv(S)) = n. We note that the two equations defining S,

                              
                                 
                                    
                                       
                                          
                                             
                                                0
                                                =
                                                x
                                                −
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   a
                                                   j
                                                
                                                
                                                   z
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           and

                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                                =
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   z
                                                   j
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           are linearly independent, and thus dim(conv(S)) ≤ (n + 2) − 2 = n. We next consider the following n points pi, i = 1, …, n in S, such that

                              
                                 
                                    
                                       
                                          p
                                          i
                                       
                                       :
                                       
                                          z
                                          i
                                       
                                       =
                                       1
                                       ,
                                       
                                          z
                                          j
                                       
                                       =
                                       0
                                       ,
                                       j
                                       ≠
                                       i
                                       ,
                                       x
                                       =
                                       
                                          a
                                          i
                                       
                                       ,
                                       y
                                       =
                                       min
                                       
                                          (
                                          f
                                          
                                             (
                                             
                                                a
                                                i
                                             
                                             )
                                          
                                          ,
                                          b
                                          )
                                       
                                    
                                 
                              
                           and the point

                              
                                 
                                    
                                       
                                          p
                                          0
                                       
                                       :
                                       
                                          z
                                          1
                                       
                                       =
                                       1
                                       ,
                                       
                                          z
                                          j
                                       
                                       =
                                       0
                                       ,
                                       j
                                       >
                                       1
                                       ,
                                       x
                                       =
                                       
                                          a
                                          1
                                       
                                       ,
                                       y
                                       =
                                       0
                                       .
                                    
                                 
                              
                           One can easily see that these n + 1 points are linearly (and hence affinely) independent. Thus, we have that dim(conv(S)) ≥ n and ultimately that dim(conv(S)) = n. We next consider the face

                              
                                 (7)
                                 
                                    
                                       F
                                       =
                                       
                                          {
                                          
                                             (
                                             z
                                             ,
                                             y
                                             ,
                                             x
                                             )
                                          
                                          ∈
                                          S
                                          :
                                          y
                                          =
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          min
                                          
                                             (
                                             f
                                             
                                                (
                                                
                                                   a
                                                   j
                                                
                                                )
                                             
                                             ,
                                             b
                                             )
                                          
                                          
                                             z
                                             j
                                          
                                          }
                                       
                                    
                                 
                              
                           induced by the valid inequality. We note that 
                              
                                 
                                    p
                                    0
                                 
                                 ∉
                                 F
                              
                            and thus F⊂conv(S) and dim(F) < n. However, the n points pi, i = 1, …, n above are in F. We see that they are linearly independent and thus dim(F) > =n − 1. Coupled with the observation that dim(F) < n, we have that dim(F) = n − 1 and the inequality induces a facet.□

Next, we consider an optimization problem P resulting from the use of the reformulation technique presented in Section 3 and of the form

                        
                           
                              
                                 maximize
                                 
                                 y
                              
                           
                        
                     subject to

                        
                           
                              
                                 y
                                 ≤
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 f
                                 
                                    (
                                    
                                       a
                                       j
                                    
                                    )
                                 
                                 
                                    z
                                    j
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           
                              
                                 x
                                 =
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    a
                                    j
                                 
                                 
                                    z
                                    j
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    z
                                    j
                                 
                                 =
                                 1
                                 ,
                              
                           
                        
                     
                     
                        
                           
                              
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 ∈
                                 F
                                 ,
                              
                           
                        
                     where 
                        F
                      is a set representing other constraints involving and potentially linking the x and y variables. Theorem 2 suggests that, by artificially constraining y, one may be able to solve the resulting optimization problem in much less time than required to solve P. With this insight, we define the problem P( 
                        b
                      ) to be P, albeit with the extra constraint y ≤ 
                        b
                      . We next present in Algorithm 1
                      a capacity scaling algorithm for problems of the form P where P( 
                        b
                      ) is repeatedly solved for different values of 
                        b
                      .

We note that, if one knew an upper bound 
                        
                           y
                           ¯
                        
                      on the optimal value of y (say by solving the linear relaxation of P), then when 
                        
                           
                              
                                 b
                                 ̲
                              
                              k
                           
                           ≥
                           
                              y
                              ¯
                           
                           ,
                        
                      solving P( 
                        b
                      
                     
                        k
                     ) is equivalent to solving P. Thus, Algorithm 1 could be converted to an exact algorithm by first determining 
                        
                           y
                           ¯
                        
                      and then iterating until 
                        
                           
                              
                                 b
                                 ̲
                              
                              k
                           
                           ≥
                           
                              y
                              ¯
                           
                           .
                        
                      Also, if we always have 
                        b
                      
                     
                        k
                      ≤ 
                        b
                      
                     
                        k + 1 then the solution to P( 
                        b
                      
                     
                        k
                     ) will be feasible for P( 
                        b
                      
                     
                        k + 1).

To offer a concrete example of the techniques presented in this section, we next present a non-linear task assignment model that we will ultimately reformulate to a mixed integer program (MIP). We also provide details for how to apply Algorithm 1 to the resulting MIP.

We consider a model that prescribes the assignment of individuals to tasks over a discretized planning period, where the tasks are ordered sequentially such that task j requires the finished work of task j − 1 and the objective is to maximize the output of finished product (the last task, 
                        
                           |
                           J
                           |
                        
                     ). The rate at which an individual is able to produce output of task j in period τ is governed by a functional model of learning and forgetting. The input to this function is the number of times the individual has performed task j in periods up to and including τ.

We denote the set of individuals by 
                        
                           I
                           ,
                        
                      the set of tasks by 
                        
                           J
                           ,
                        
                      and the periods in the planning horizon by 
                        
                           T
                           .
                        
                      We assume that production begins in period 1. We define the binary variable 
                        
                           x
                           
                              i
                              j
                           
                           t
                        
                      to indicate whether individual 
                        
                           i
                           ∈
                           I
                        
                      performs task 
                        
                           j
                           ∈
                           J
                        
                      in period 
                        
                           t
                           ∈
                           T
                           ,
                        
                      the continuous variable 
                        
                           o
                           
                              i
                              j
                           
                           t
                        
                      to indicate the amount produced by individual 
                        
                           i
                           ∈
                           I
                        
                      of task 
                        
                           j
                           ∈
                           J
                        
                      in period 
                        
                           t
                           ∈
                           T
                           ,
                        
                      and the continuous variable 
                        
                           r
                           
                              i
                              j
                           
                           t
                        
                      to indicate the productivity rate of individual 
                        
                           i
                           ∈
                           I
                        
                      at task 
                        
                           j
                           ∈
                           J
                        
                      in period 
                        
                           t
                           ∈
                           T
                           .
                        
                      Finally, we define the continuous variable 
                        
                           b
                           
                              j
                           
                           t
                        
                      to indicate the amount of work-in-process inventory available at task 
                        
                           j
                           ∈
                           J
                        
                      at the end of period 
                        
                           t
                           ∈
                           T
                           ,
                           t
                           ≥
                           2
                           .
                        
                      We let 
                        
                           b
                           
                              j
                           
                           0
                        
                      denote the initial inventory available at task 
                        
                           j
                           ∈
                           J
                           .
                        
                     
                  

In this work, we illustrate our reformulation using the following learning and forgetting curve:

                        
                           (8)
                           
                              
                                 
                                    r
                                    
                                       i
                                       j
                                    
                                    τ
                                 
                                 
                                    (
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       τ
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    )
                                 
                                 =
                                 
                                    I
                                    
                                       i
                                       j
                                    
                                 
                                 +
                                 
                                    K
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    [
                                    1
                                    −
                                    
                                       e
                                       
                                          −
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      t
                                                      =
                                                      1
                                                   
                                                   τ
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                   t
                                                
                                             
                                             
                                                L
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    ]
                                 
                                 
                                    e
                                    
                                       
                                          
                                             ∑
                                             
                                                t
                                                =
                                                1
                                             
                                             τ
                                          
                                          
                                             x
                                             
                                                i
                                                j
                                             
                                             t
                                          
                                          −
                                          τ
                                       
                                       
                                          F
                                          
                                             i
                                             j
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     While we illustrate our techniques on the learning function found in Nembhard and Norman (2007), they can be applied to others, including the hyperbolic learning function used in Sayin and Karabati (2007), the logistic learning function used in Gutjahr et al. (2008), and the exponential learning function of Heimerl and Kolisch (2010) (if assignments are restricted to being binary). The curve represents the productivity of individual i on task j in period τ as a function of i’s experience on task j up to time τ. Individual i’s experience level in period τ is dictated by 
                        
                           
                              ∑
                              
                                 t
                                 =
                                 1
                              
                              τ
                           
                           
                              x
                              
                                 i
                                 j
                              
                              t
                           
                        
                      or the number of repetitions individual i has had on task j by that time. In the τ periods, individual i also has 
                        
                           
                              ∑
                              
                                 t
                                 =
                                 1
                              
                              τ
                           
                           
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 t
                              
                              −
                              τ
                           
                        
                      periods in which forgetting occurs. For worker i and job j, Iij
                      is i’s initial expertise at task j, Kij
                      is i’s steady-state production rate for task j, Lij
                      is i’s learning rate for task j, and Fij
                      is i’s forgetting rate for task j. In practice, parameters Iij, Kij, Lij
                     , and Fij
                      are statistically determined based on observations collected on individual i on task j or a related task.

The Assignment with Learning (AwL) model, which was first presented in Nembhard and Norman (2007), seeks to

                        
                           
                              
                                 maximize
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    ∑
                                    
                                       t
                                       ∈
                                       T
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       |
                                       J
                                       |
                                    
                                    t
                                 
                              
                           
                        
                     subject to

                        
                           (9)
                           
                              
                                 
                                    b
                                    
                                       1
                                    
                                    1
                                 
                                 =
                                 
                                    b
                                    
                                       1
                                    
                                    0
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       1
                                    
                                    1
                                 
                              
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    b
                                    
                                       1
                                    
                                    t
                                 
                                 =
                                 
                                    b
                                    
                                       1
                                    
                                    
                                       t
                                       −
                                       1
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       1
                                    
                                    t
                                 
                                 
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 t
                                 ≥
                                 2
                                 ,
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    b
                                    
                                       j
                                    
                                    t
                                 
                                 =
                                 
                                    b
                                    
                                       j
                                    
                                    
                                       t
                                       −
                                       1
                                    
                                 
                                 +
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       j
                                       −
                                       1
                                    
                                    t
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 J
                                 ,
                                 t
                                 ∈
                                 T
                                 ,
                                 t
                                 ≥
                                 2
                                 ,
                                 j
                                 ≥
                                 2
                              
                           
                        
                     
                     
                        
                           (12)
                           
                              
                                 
                                    b
                                    
                                       j
                                    
                                    1
                                 
                                 =
                                 
                                    b
                                    
                                       j
                                    
                                    0
                                 
                                 +
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       j
                                       −
                                       1
                                    
                                    1
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    o
                                    
                                       i
                                       j
                                    
                                    1
                                 
                                 
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 J
                                 ,
                                 j
                                 ≥
                                 2
                                 ,
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       J
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ≤
                                 1
                                 
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 t
                                 ∈
                                 T
                                 ,
                              
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       I
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ≤
                                 1
                                 
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 J
                                 ,
                                 t
                                 ∈
                                 T
                                 ,
                              
                           
                        
                     
                     
                        
                           (15)
                           
                              
                                 
                                    o
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ≤
                                 
                                    r
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 j
                                 ∈
                                 J
                                 ,
                                 t
                                 ∈
                                 T
                                 ,
                              
                           
                        
                     
                     
                        
                           (16)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             r
                                             
                                                i
                                                j
                                             
                                             t
                                          
                                          =
                                          
                                             I
                                             
                                                i
                                                j
                                             
                                          
                                          +
                                          
                                             K
                                             
                                                i
                                                j
                                             
                                          
                                          
                                             [
                                             1
                                             −
                                             
                                                e
                                                
                                                   −
                                                   
                                                      
                                                         1
                                                         L
                                                      
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      ∑
                                                      
                                                         t
                                                         =
                                                         1
                                                      
                                                      τ
                                                   
                                                   
                                                      x
                                                      
                                                         i
                                                         j
                                                      
                                                      t
                                                   
                                                
                                             
                                             ]
                                          
                                          
                                             e
                                             
                                                
                                                   
                                                      1
                                                      F
                                                   
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   (
                                                   
                                                      ∑
                                                      
                                                         t
                                                         =
                                                         1
                                                      
                                                      τ
                                                   
                                                   
                                                      
                                                         x
                                                         
                                                            i
                                                            j
                                                         
                                                         t
                                                      
                                                      −
                                                      
                                                         (
                                                         τ
                                                         )
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                          ∀
                                          
                                             i
                                             ∈
                                             I
                                          
                                          ,
                                          
                                             j
                                             ∈
                                             J
                                          
                                          ,
                                          
                                          
                                             τ
                                             ∈
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (17)
                           
                              
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 ,
                                 
                                    o
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ∈
                                 
                                    ℜ
                                    +
                                 
                                 ,
                                 
                                    r
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ∈
                                 
                                    ℜ
                                    +
                                 
                                 
                                 
                                 
                                 i
                                 ∈
                                 I
                                 ,
                                 j
                                 ∈
                                 J
                                 ,
                                 t
                                 ∈
                                 T
                                 ,
                              
                           
                        
                     
                     
                        
                           (18)
                           
                              
                                 
                                    b
                                    
                                       j
                                    
                                    t
                                 
                                 ∈
                                 
                                    ℜ
                                    +
                                 
                                 
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 J
                                 ,
                                 t
                                 ∈
                                 T
                                 .
                              
                           
                        
                     The objective maximizes the output of finished product (task 
                        
                           |
                           J
                           |
                        
                     ). Constraints (9) and (10) represent the relationship between inventory levels and production quantities at the first task. Constraints (11) define the relationship between production and inventory at all except the first task, with initial conditions considered in constraints (12). Constraints (13) ensure that each individual performs at most one task in a period and constraints (14) ensure that at most one individual can do each task in a period. Constraints (15) bound an individual’s output of a task in a period by their productivity rate (we assume the rates are normalized such that all periods are of length one). Constraints (16) dictate an individual’s productivity rate at a task in a period based on prior performance of that task. Finally, constraints (17) and (18) restrict the domains of the decision variables.

Before discussing whether this model is computationally tractable, we first make an observation. This model allows for, and even encourages “practicing.” That is, an individual can perform a task (
                        
                           
                              x
                              
                                 i
                                 j
                              
                              t
                           
                           =
                           1
                        
                     ) without producing any output (
                        
                           
                              o
                              
                                 i
                                 j
                              
                              t
                           
                           =
                           0
                        
                     ). While such a combination is not beneficial when learning is not recognized, in this model, practicing can lead to greater output. The model can be adapted to disallow practicing by assuming a parameter μ that represents the minimum amount of output an individual can possibly produce and adding the constraint

                        
                           
                              
                                 μ
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 ≤
                                 
                                    o
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 .
                              
                           
                        
                     
                  

Because of the nonlinearities in the constraints, particularly in constraints (16), instances of this model can prove very difficult to solve for all but small instances. For example, we developed a test set of instances with five workers, 10 tasks, and 10 periods, and found that KNITRO 7.0 (Waltz and Plantenga, 2009) was unable to produce a feasible solution for any of them in 2 hours of execution.

In this section, we present a reformulation of AwL using the technique described in Section 3. Due to its discrete nature, the learning and forgetting function given in Eq. (8) is a candidate for our reformulation technique. Productivity is a function of the number of times individual i has performed task j in periods up to and including τ (the 
                           
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 τ
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 t
                              
                           
                         and 
                           
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 τ
                              
                              
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    t
                                 
                                 −
                                 τ
                              
                           
                         terms in Eq. (8)). Thus, in period τ, we can compute the productivity rate of the worker knowing only how many times the task was performed in periods t = 1, …, τ. As there are only τ possible values for how many times the task was performed, we can enumerate the potential values of 
                           
                              r
                              
                                 i
                                 j
                              
                              τ
                           
                         and apply the reformulation technique.

We next present our reformulation, called the Assignment with Reformulated Learning model (AwRL), of the AwL. As noted previously, for a fixed time period, the domain of Eq. (8) is the possible numbers of times a task has been performed for an individual and is discrete and finite. As a result, the range of Eq. (8), the potential productivity rates, is also discrete and finite. Thus, for constraints (16), we can enumerate the set of potential productivity rates for individual i at task j in period t (there are t of them given that at most one task may be done per period) and define the binary variable 
                           
                              z
                              
                                 i
                                 j
                              
                              
                                 k
                                 t
                              
                           
                         to indicate whether individual i is prescribed the productivity rate 
                           
                              
                                 r
                                 ¯
                              
                              k
                           
                         at task j in period t.

Specifically, assume we have calculated the pairs 
                           
                              (
                              k
                              ,
                              
                                 
                                    r
                                    ¯
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    k
                                    t
                                 
                              
                              )
                           
                         where 
                           
                              
                                 
                                    r
                                    ¯
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    k
                                    t
                                 
                              
                              =
                              
                                 I
                                 
                                    i
                                    j
                                 
                              
                              +
                              
                                 K
                                 
                                    i
                                    j
                                 
                              
                              
                                 [
                                 1
                                 −
                                 
                                    e
                                    
                                       −
                                       
                                          k
                                          
                                             L
                                             
                                                i
                                                j
                                             
                                          
                                       
                                    
                                 
                                 ]
                              
                              
                                 e
                                 
                                    
                                       k
                                       −
                                       t
                                    
                                    
                                       F
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    r
                                    ¯
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    t
                                    t
                                 
                              
                              =
                              
                                 I
                                 
                                    i
                                    j
                                 
                              
                              +
                              
                                 K
                                 
                                    i
                                    j
                                 
                              
                              
                                 (
                                 1
                                 −
                                 
                                    e
                                    
                                       −
                                       
                                          t
                                          
                                             L
                                             
                                                i
                                                j
                                             
                                          
                                       
                                    
                                 
                                 )
                              
                           
                         is used as an upper bound in a constraint that linearizes constraints (15). We reformulate the previous model, using the variables 
                           
                              z
                              
                                 i
                                 j
                              
                              
                                 k
                                 t
                              
                           
                         by removing constraint sets (15) and (16) and adding the following:

                           
                              (19)
                              
                                 
                                    
                                       o
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    ≤
                                    
                                       
                                          r
                                          ¯
                                       
                                       
                                          i
                                          j
                                       
                                       
                                          t
                                          t
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                    ,
                                    t
                                    ∈
                                    T
                                    ,
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       o
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    ≤
                                    
                                       r
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                    ,
                                    t
                                    ∈
                                    T
                                    ,
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    
                                       r
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    =
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       τ
                                    
                                    
                                       
                                          r
                                          ¯
                                       
                                       
                                          i
                                          j
                                       
                                       
                                          k
                                          t
                                       
                                    
                                    
                                       z
                                       
                                          i
                                          j
                                       
                                       
                                          k
                                          t
                                       
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                    ,
                                    t
                                    ∈
                                    T
                                    ,
                                 
                              
                           
                        
                        
                           
                              (22)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       τ
                                    
                                    k
                                    
                                       z
                                       
                                          i
                                          j
                                       
                                       
                                          k
                                          τ
                                       
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       τ
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    τ
                                    ∈
                                    T
                                    ,
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       τ
                                    
                                    
                                       z
                                       
                                          i
                                          j
                                       
                                       
                                          k
                                          t
                                       
                                    
                                    =
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                    ,
                                    t
                                    ∈
                                    T
                                    .
                                 
                              
                           
                        
                     

Constraints (19) linearize constraints (15) based on the maximum possible productivity rate for individual i at task j in period t. Constraints (20) bound the output of an individual at a task by their productivity rate at that task in that period. Constraints (21) and (22) ensure that the productivity rate of an individual in period τ corresponds to the number of times they performed the task in the periods up to and including τ. Finally, constraints (23) ensure that each individual is assigned exactly one rate in each period. We derive the values 
                           
                              
                                 r
                                 ¯
                              
                              
                                 i
                                 j
                              
                              
                                 k
                                 t
                              
                           
                         that parameterize our reformulation through enumeration.

We next discuss how we adapt the capacity scaling algorithm presented in Section 4 to produce high quality solutions to the AwRL. We first relax the constraints (21) to 
                           
                              
                                 r
                                 
                                    i
                                    j
                                 
                                 t
                              
                              ≤
                              
                                 ∑
                                 
                                    k
                                    =
                                    1
                                 
                                 τ
                              
                              
                                 
                                    r
                                    ¯
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    k
                                    t
                                 
                              
                              
                                 z
                                 
                                    i
                                    j
                                 
                                 
                                    k
                                    t
                                 
                              
                              .
                           
                         We then enforce artificial bounds 
                           
                              
                                 b
                                 ̲
                              
                              
                                 i
                                 j
                              
                              
                                 t
                                 ν
                              
                           
                         on 
                           
                              r
                              
                                 i
                                 j
                              
                              t
                           
                         through the constraints

                           
                              (24)
                              
                                 
                                    
                                       r
                                       
                                          i
                                          j
                                       
                                       t
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       τ
                                    
                                    min
                                    
                                       (
                                       
                                          r
                                          
                                             i
                                             j
                                          
                                          
                                             k
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             b
                                             ̲
                                          
                                          
                                             i
                                             j
                                          
                                          
                                             t
                                             ν
                                          
                                       
                                       )
                                    
                                    
                                       z
                                       
                                          i
                                          j
                                       
                                       
                                          k
                                          t
                                       
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                    ,
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        in the hope that, because by Theorem 2 constraints (24) are facet-defining, the resulting integer program will solve quickly.

Thus, we let AwRL( 
                           b
                         ) denote the AwRL with the constraints (24) defined by the vector 
                           b
                         . We then iteratively create the vector 
                           b
                         and solve the resulting instance of the AwRL( 
                           b
                         ). While any task assignment that is feasible for the AwRL is also feasible for the AwRL( 
                           b
                         ) (and vice-versa), constraints (24) may lead a task assignment to have a lower objective function value in the AwRL( 
                           b
                         ) than in the AwRL.


To create the value 
                           
                              
                                 b
                                 ̲
                              
                              
                                 i
                                 j
                              
                              
                                 t
                                 ν
                              
                           
                         at iteration ν of the heuristic, we choose an experience level 
                           
                              c
                              
                                 i
                                 j
                              
                              
                                 t
                                 ν
                              
                           
                         and then set 
                           
                              
                                 
                                    b
                                    ̲
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    t
                                    ν
                                 
                              
                              =
                              
                                 r
                                 
                                    i
                                    j
                                 
                                 
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                       
                                          t
                                          ν
                                       
                                    
                                    t
                                 
                              
                              =
                              
                                 r
                                 
                                    i
                                    j
                                 
                                 t
                              
                              
                                 (
                                 
                                    c
                                    
                                       i
                                       j
                                    
                                    
                                       t
                                       ν
                                    
                                 
                                 )
                              
                              .
                           
                         Thus, we artificially constrain the impact learning can have on an individual’s productivity rate. To generate the initial values 
                           
                              
                                 c
                                 
                                    i
                                    j
                                 
                                 
                                    t
                                    1
                                 
                              
                              ,
                           
                         we solve the optimization problem

                           
                              
                                 
                                    maximize
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       o
                                       
                                          i
                                          |
                                          J
                                          |
                                       
                                       t
                                    
                                    ,
                                 
                              
                           
                        subject to constraints (9), (10), (11), (12), (13), (14), (19), and the variable definitions in constraints (17) and (18). This problem, which we call TA-MAX, is the task assignment model without learning, wherein workers can always produce at their maximum productivity rate. We then set 
                           
                              
                                 c
                                 
                                    i
                                    j
                                 
                                 
                                    t
                                    1
                                 
                              
                              =
                              
                                 ∑
                                 
                                    τ
                                    =
                                    1
                                 
                                 t
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 τ
                              
                           
                         and 
                           
                              
                                 
                                    b
                                    ̲
                                 
                                 
                                    i
                                    j
                                 
                                 
                                    t
                                    1
                                 
                              
                              =
                              
                                 r
                                 
                                    i
                                    j
                                 
                                 t
                              
                              
                                 (
                                 
                                    c
                                    
                                       i
                                       j
                                    
                                    
                                       t
                                       1
                                    
                                 
                                 )
                              
                              .
                           
                         We also note that, as TA-MAX is a relaxation of the AwRL, it also provides a bound on the optimal value of the AwRL.

We present the Capacity Scaling for the AwRL (CS-AwRL) algorithm in Algorithm 2
                        . In the for-loop entered in Step 5, the allowed experience level is updated based on the most recent task assignment. However, because there is no guarantee that the task assignment will change from one iteration to the next, we include the if-statement in Step 10 wherein all allowable experience levels are increased by one level. We then update the maximum allowable production rates in Step 18 and repeat.

With the bound zUB
                         provided by solving TA-MAX, we can calculate both absolute and relative gaps for each primal solution found. If tolerances are given for each of those gaps, we can terminate the CS-AwRL when one of those gaps is within the stated tolerance. Similarly, if the condition in Step 12 is never true, i.e. the level of learning allowed for each individual on each task in each period is not artificially constrained, then solving AwRL( 
                           b
                         
                        
                           ν
                        ) is equivalent to solving AwRL and the algorithm can terminate. Because of Steps 18 and 12 in each iteration, at least one rate will be increased unless they have all reached their upper limit. Thus, the CS-AwRL is an exact algorithm.

To study the computational effectiveness of our reformulation technique and scaling algorithm, we solve instances of the AwRL using Gurobi 5.1 (Gurobi Optimization, 2012) to a relative optimality tolerance of 1 percent and an absolute optimality tolerance of 1. Experiments were performed on a computer cluster where each node has 32–64 cores with AMD Opteron 2.2 gigahertz or AMD Interlagos 2.6 “bulldozer” processors and 128–256 gigabytes of memory. When solving instances of the AwRL, Gurobi was given a time limit of 3600 seconds. All computational times reported are in seconds.

We give the instance sizes we consider (in terms of 
                        
                           I
                           ,
                           J
                           ,
                           T
                        
                     ) in Table 1
                     .

We only consider instances where there are at least as many tasks as workers (
                        
                           |
                           J
                           |
                           ≥
                           |
                           I
                           |
                        
                     ) and at least as many periods as tasks (
                        
                           |
                           T
                           |
                           ≥
                           |
                           J
                           |
                        
                     ). We initially report results for instances where the initial inventory levels are set as 
                        
                           
                              b
                              
                                 1
                              
                              1
                           
                           =
                           
                              |
                              T
                              |
                           
                           ,
                           
                              b
                              
                                 j
                              
                              1
                           
                           =
                           5
                           ,
                           j
                           ≥
                           2
                           ,
                        
                      but study the impact of this parameter on instance solve time later. We chose 
                        
                           
                              b
                              
                                 1
                              
                              1
                           
                           =
                           
                              |
                              T
                              |
                           
                        
                      because productivity rates in most instances would typically be less than one and thus with this much raw material the production line will not be starved.

Along with studying the time required to solve instances of the AwRL of varying sizes, we also consider different workforce compositions with respect to the learning factors Iij, Kij, Fij
                     , and Lij
                     . We derive six different workforce composition cases from the four learning curves depicted in Fig. 1 a
                     , with parameter values detailed in Fig. 1 b, and describe these cases in Table 2
                     .

Our primary purpose for constructing these learning curves is to see the performance of the reformulation both in settings that are amenable to approximation techniques and those that are not. For example, in learning curves 1 and 4, the number of times an individual performs a task has little or no impact on future productivity. Thus, one way to deal with the non-linearity of the learning function would be to simply ignore learning and fix each individual’s productivity rates a priori. In curve 3, learning occurs, but in a way that is nearly linear, suggesting that a piecewise linear approximation could be used (and very accurate). Finally, in curve 2, learning occurs in a way that a piecewise linear approximation would not be as accurate.

Symmetry is an issue that often plagues branch-and-bound-based solution methods for integer programming formulations of scheduling problems. Thus, we have chosen these six workforce compositions to see whether our reformulated model exhibits similar behavior. Specifically, Cases 1 through 4 and 6 represent homogeneous workforces, wherein symmetry could be an issue. Case 5 represents a heterogenous workforce, but assumes that the learning rate is independent of the task. Case 6 represents a homogenous workforce, but assumes that the learning rate does depend on the task. Thus, one would expect that symmetry will be less of an issue with Case 5.


                        Table 3
                         reports the average solution times (Solve time) and absolute optimality gaps (Abs. Gap) reported by Gurobi. We focus on absolute gaps because the objective function values in our instances are often small enough that we believe relative gaps do not give an accurate picture of the quality of solutions produced. We report these results by number of workers and worker composition cases, averaging over instances with different numbers of tasks and periods. We observe that Gurobi is able to produce high-quality solutions and is particularly effective with homogeneous workforces, suggesting that symmetry is not an issue when solving instances of the reformulated model. We also see that the approach is robust with respect to the underlying learning curve. However, instances that represent a heterogeneous workforce (Case 5) are the hardest to solve.


                        Table 4
                         reports solver performance by number of periods (
                           
                              |
                              T
                              |
                           
                        ), where we average over instances with different numbers of tasks, and Table 5 reports solver performance by number of tasks (
                           
                              |
                              J
                              |
                           
                        ), where we average over instances with different numbers of periods. We see that with 10, 15, or 20 workers we are able to solve all instance sizes to within our tolerances. While solve time grows much more rapidly with respect to number of tasks than number of periods this growth is likely due to the nature of our set of instances, i.e. for instances with 30 tasks we only consider planning horizons of 30, 35, or 40 periods, whereas for instances with 40 periods we consider all numbers of tasks given in Table 1
                        .

We next examine the impact of initial buffer levels on instance solve time. Specifically, we consider the same set of instances but with the initial buffer levels 
                           
                              
                                 b
                                 
                                    1
                                 
                                 0
                              
                              =
                              
                                 |
                                 T
                                 |
                              
                           
                         (to not starve the line), and for later stations, 
                           
                              
                                 b
                                 
                                    j
                                 
                                 0
                              
                              =
                              1
                              ,
                              j
                              ≥
                              2
                              .
                           
                         We report aggregate solve times and absolute gaps over all instances in Table 6
                        . We see that initial buffer levels have a significant impact on solve time and solution quality.

Ultimately, recalling our computational study with KNITRO, wherein KNITRO was unable to produce a feasible solution in two hours for instances with five workers, 10 tasks, and 10 periods, we conclude from Tables 4, 5, and 6 that solving instances of the AwRL is much less computationally intensive than the original non-linear program.

We next seek to understand why initial buffer levels and the number of workers have such an impact on solution time. One diagnostic for the difficulty in solving an integer program is the gap between the optimal value of the linear programming relaxation solved at the root node of a branch-and-bound-based algorithm and the final optimal solution, as this gives a sense of how often branching is likely to be required to solve the integer program. Thus, Table 7
                         presents averages over all instances for each initial buffer level of the absolute gap (Root gap) between the bound produced at the root node and the final primal solution produced. These two parameters (initial buffer levels and the number of workers) partially determine the production capability for an instance. Comparing the two rows, we conclude that the greater the production capability of an instance the closer the root node bound is to the value of the optimal solution. A similar observation can be made when comparing the columns of the row containing results for an initial buffer equal to five for stations after the first.

We next compare the effectiveness of the CS-AwRL to solving the AwRL for both initial buffer levels. To do so, we execute the CS-AwRL for 30 minutes (the only stopping criteria) for each instance and report the results, again for different initial buffer levels, in Tables 8
                         and 9
                        . First, because the CS-AwRL is an exact algorithm, we present the percentage of instances the CS-AwRL solves to optimality in the time limit (Pct. solved). Next, we report the average absolute optimality gap (Abs opt gap) of the best solution produced by the CS-AwRL as measured against the dual bound produced when solving the AwRL and the time required to find that solution (Time best). The results show that CS-AwRL is able to produce high-quality solutions quickly and solve some instances to optimality.

We also compare in Tables 8 and 9 the performance of the CS-AwRL with solving the AwRL. Specifically, we present the percentage of instances for which the CS-AwRL produces an equivalent or better solution (Pct. beat/tie AwRL), the average of the time required to produce an equivalent or better solution (Time beat/tie AwRL), and the absolute gap in the two solutions (Abs gap AwRL). Across all instances, the CS-AwRL beats or ties the reformulation alone 88 percent of the time in both the one and five buffer cases. Further, CS-AWRL is able to achieve these results faster than is possible for the reformulation alone.

Finally, we note that, at any iteration, the CS-AwRL works with a limited set of potential experience levels, with new levels added at each iteration until the algorithm can conclude that all necessary levels have been enumerated or the time limit has been reached. We report in Table 10
                         the average number of iterations executed by the CS-AwRL (Number iterations), the average number of the percentage of all possible experience levels generated at termination (Pct. exp. levels), and the average number of the percentage of experience levels generated when the best solution was found (Pct. exp. levels for best). We again report these results by initial buffer level. We conclude from these results that the CS-AwRL is able to produce high quality solutions with very few potential experience levels.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper, we adapt a technique for modeling a (non-linear) function with binary variables and linear constraints to a case where the function has a finite and discrete domain. We show that, in this case, solving the resulting mixed integer program yields an optimal solution to the original non-linear program (unlike the case for general, non-convex optimization problems wherein the resulting MIP is an approximation). With this technique, workforce planning models that contain non-linear models of human learning can be reformulated as mixed integer programs. Our computational study indicates that the resulting instances are much easier to solve and thus much larger instances can be solved than when the original non-linear program is solved with commercial software. We also use the resulting mixed integer program to develop an integer programming-based exact algorithm that can quickly produce a high quality solution.

While this reformulation technique does reduce solve times and enable larger instances to be solved, there is room for improvement. Our results indicate that strengthening the formulation with valid inequalities may greatly reduce solution times for instances that are tightly capacitated. Further, this paper is intended to demonstrate the general value of the reformulation technique. We have not addressed any particular workforce planning problem, and future studies demonstrating the impact of the reformulation on solving such practical problems would be valuable. Also, we are developing models that are similar to the AwRL, but that recognize there may be uncertainty with respect to a worker’s learning parameters.

@&#ACKNOWLEDGMENTS@&#

We would like to thank the Associate Editor and two anonymous referees for their helpful comments. This material is based upon work supported by the National Science Foundation under Grant No. CMMI-1266010.

@&#REFERENCES@&#

