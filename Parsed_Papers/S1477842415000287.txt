@&#MAIN-TITLE@&#Grammar-based model transformations: Definition, execution, and quality properties

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Approach uses grammar-based definition of languages to create quality transformations.


                        
                        
                           
                           It simplifies transformation development using structural mappings between languages.


                        
                        
                           
                           We define sufficient conditions on grammar-based transformations for their quality.


                        
                        
                           
                           Such transformations are by-construction terminating, sound, complete and deterministic.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Model transformations

Graph grammars

Quality properties

@&#ABSTRACT@&#


               
               
                  Model transformation is a key concept in model-driven software engineering. The definition of model transformations is usually based on meta-models describing the abstract syntax of languages. While meta-models are thereby able to abstract from superfluous details of concrete syntax, they often loose structural information inherent in languages, like information on model elements always occurring together in particular shapes. As a consequence, model transformations cannot naturally re-use language structures, thus leading to unnecessary complexity in their development as well as in quality assurance.
                  In this paper, we propose a new approach to model transformation development which allows to simplify the developed transformations and improve their quality via the exploitation of the languages׳ structures. The approach is based on context-free graph grammars and transformations defined by pairing productions of source and target grammars. We show that such transformations have important properties: they terminate and are sound, complete, and deterministic.
               
            

@&#INTRODUCTION@&#

Model transformations are key to model driven engineering (MDE). Surveys on model transformations [1,2] show their expanding application areas: model translation, model composition, refinement, abstraction, and others.

In an MDE setting, the syntax of models is given in terms of meta-models which themselves conform to their own meta-models (e.g., MOF [3]). Meta-models define the abstract syntax of languages and omit the details of concrete syntax, like keywords and ordering of elements. While meta-models describe model elements and their direct relations, they often fall short of describing model elements always occurring together in particular shapes/structures (e.g., decision/merge blocks in UML Activity diagrams [4]). In some cases, meta-models are enriched with OCL [5] constraints to enforce such shapes in models. Model transformations are defined on meta-models and thus operate on abstract syntax.

In contrast to MDE, traditional approaches to language definition (and translation) define languages by grammars, often given in an Extended Backus–Naur Form (EBNF) [6]. These translation techniques operate on concrete syntax. While the details of concrete syntax are in general unimportant (and thus make translation definition unnecessarily confusing), the meta structural information contained in the grammar-based language definitions is highly useful for defining translations. The productions of the grammars define the structures available in the languages, and by relating productions of grammars (as done in syntax-directed translation [7]) we can naturally specify how languages׳ structures are mapped onto each other.

An ideal approach for model transformation should thus combine these two approaches, taking the best of both: use language definitions with the abstract syntax of meta-models and the structures of grammars, and build model transformations on these definitions. An early approach following this idea, although not in the area of model transformations and not with meta-models but with graphs, is the one proposed by Pratt [8]. Pratt defines pair grammars as a way of relating the grammars of two languages, thus obtaining a natural structure-oriented way of relating languages and building translations between them.

The objective of this paper is to bring the pair grammar based translation to the world of MDE model transformations, lifting it to the level of abstract syntax while preserving its advantages. It also presents several ideas to extend this approach to cover a broader variety of model transformations, and provides formalization of both the basic approach and of these extensions. This paper is an extended version of our earlier work [9] with additional sections on the formal aspects of the definition, execution, and quality properties of the transformations defined using the proposed approach.


                     Fig. 1
                      gives an overview of our approach. The transformations we focus on are model-to-model transformations. Our models are given in abstract syntax and are generated by grammars. For this generation purpose we use a type of context-free graph grammars – hyperedge replacement graph grammars 
                     [10] – typed and constrained by meta-models. Grammar-based rules – like pair grammars – relate productions of the source with those of the target grammar. We refer to the resulting transformations as grammar-based model transformations (GBMTs). GBMTs are executed on derivation trees: given a source model 
                        
                           
                              M
                           
                           
                              s
                           
                        
                     , its derivation tree in the source grammar is obtained by parsing, and used by the GBMT to produce a derivation tree in the target grammar and the corresponding target model 
                        
                           
                              M
                           
                           
                              t
                           
                        
                     .

We exemplify our approach on a transformation from activity diagrams to the Communicating Sequential Processes (CSP) algebra [11]. On this example we see how the definition of transformation rules between language structures (e.g., decision/merge and if-then-else blocks) can be simplified using their explicit definition in productions in our grammar-based approach. For comparison, in Section 6, we provide a typical more complex rule created for the same purpose using existing state-of-the-art methods (here ATL). Furthermore, in Section 7, we highlight further benefits of our grammar-based approach. It is concerned with automatic implicit connection of the results of grammar-based transformation rules, compared to the more complex explicit, and often imperative, one in the existing approaches in MDE.

We also show important qualities of the transformations developed with our approach – termination, soundness, completeness, and determinism. Showing these quality properties for a transformation described using current meta-model based state-of-the-art techniques is usually hard [12], as discussed in Section 8.

First, in Section 2 we give background on grammar-based language definition and show our source and target grammars. Then, we introduce our grammar-based approach using an example transformation in Section 3 and provide its formalization in Section 4. In Section 5, we consider the quality of the transformations developed using our approach. In Section 6, we evaluate it in comparison with the most closely related approaches in the MDE context. In Section 7, we evaluate the application of our grammar-based approach to a further example. Finally, we survey related work in Section 8 and conclude in Section 9.

@&#BACKGROUND@&#

There are two fundamentally different ways of specifying the syntax of a given language: with (context-free) grammars, and with meta-models. Our approach is built on grammars generating instances of meta-models, i.e., graphs. In the following, we introduce the main concepts of grammar-based language definition and show how they can be lifted to graph-based languages, enabling grammar-based definition of modeling languages and model transformations utilizing these definitions. We show how our example of modeling languages for activity diagrams and CSP can be described using grammars. Finally, we introduce the transformation example used later to demonstrate our approach.

In their original usage, grammars define languages of strings via a set of generative rules. We briefly review main definitions of grammars for string languages from [7], since the graph grammars we use are their natural extension. 
                           Definition 2.1
                           Grammar


                           A grammar 
                              
                                 G
                                 =
                                 (
                                 N
                                 ,
                                 Σ
                                 ,
                                 P
                                 ,
                                 S
                                 )
                               consists of a set of non-terminal symbols N, a set of terminal symbols Σ, a set of productions P and a designated start symbol 
                              
                                 S
                                 ∈
                                 N
                              . Each production 
                                 p
                                 ∈
                                 P
                               is of the form 
                                 p
                                 =
                                 (
                                 l
                                 ,
                                 r
                                 )
                              , with 
                                 l
                                 ∈
                                 
                                    
                                       (
                                       Σ
                                       ∪
                                       N
                                       )
                                    
                                    
                                       ⁎
                                    
                                 
                                 N
                                 
                                    
                                       (
                                       Σ
                                       ∪
                                       N
                                       )
                                    
                                    
                                       ⁎
                                    
                                 
                              , i.e., a string of symbols with at least one non-terminal, and 
                                 r
                                 ∈
                                 
                                    
                                       (
                                       Σ
                                       ∪
                                       N
                                       )
                                    
                                    
                                       ⁎
                                    
                                 
                              .

A grammar 
                                 G
                                 =
                                 (
                                 N
                                 ,
                                 Σ
                                 ,
                                 P
                                 ,
                                 S
                                 )
                               is called context-free iff every production 
                                 p
                                 ∈
                                 P
                               has the form 
                                 p
                                 =
                                 (
                                 n
                                 ,
                                 r
                                 )
                               with 
                                 n
                                 ∈
                                 N
                              .

Applications of productions derive new strings from given ones by a process called rewriting. A string 
                           s
                           ∈
                           
                              
                                 (
                                 N
                                 ∪
                                 Σ
                                 )
                              
                              
                                 ⁎
                              
                           
                         is rewritten into a new string by a context-free production 
                           (
                           n
                           ,
                           r
                           )
                           ∈
                           P
                         by finding n in s and replacing it with r. In this way, a grammar defines the set of strings that can be derived from its start symbol S. This set is called the language of the grammar G. 
                           Definition 2.2
                           Language


                           Let 
                                 G
                                 =
                                 (
                                 N
                                 ,
                                 Σ
                                 ,
                                 P
                                 ,
                                 S
                                 )
                               be a grammar. A sentence of G is a string 
                                 s
                                 ∈
                                 
                                    
                                       Σ
                                    
                                    
                                       ⁎
                                    
                                 
                               of terminal symbols that can be derived from S using a finite sequence of applications of productions in P. The language 
                                 L
                                 (
                                 G
                                 )
                               of G is defined as 
                                 L
                                 (
                                 G
                                 )
                                 =
                                 {
                                 s
                                 ∈
                                 
                                    
                                       Σ
                                    
                                    
                                       ⁎
                                    
                                 
                                 |
                                 s
                                 
                                 is
                                 
                                 sentence
                                 
                                 of
                                 
                                 G
                                 }
                              .

The advantage of context-free grammars is that parsing can be done efficiently [7]. Parsing a sentence in a language using a context-free grammar gives us a derivation tree, i.e., a structure showing the application of productions from the start symbol leading to the derived sentence. A derivation tree for a sentence defines its structure and confirms its language membership in L(G) (i.e., syntactical correctness). The inner nodes of such a tree are labeled with productions. The root is labeled with a production that consumes the start symbol of the grammar. Every leaf of the tree is labeled with a terminal symbol. Fig. 2
                         shows an example derivation tree for the sentence 
                           
                              
                                 σ
                              
                              
                                 2
                              
                           
                           
                              
                                 σ
                              
                              
                                 1
                              
                           
                           
                              
                                 σ
                              
                              
                                 2
                              
                           
                           
                              
                                 σ
                              
                              
                                 3
                              
                           
                        .

In general, there can be multiple derivation trees for a sentence in one grammar that are not equivalent in their structure, making the grammar ambiguous. In our approach, we only consider unambiguous grammars for defining source and target languages, to ensure deterministic behavior of the developed transformations (see Section 5 for details). 
                           Definition 2.3
                           Unambiguous grammar


                           A grammar 
                                 G
                                 =
                                 (
                                 N
                                 ,
                                 Σ
                                 ,
                                 P
                                 ,
                                 S
                                 )
                               is called unambiguous iff, for every sentence 
                                 s
                                 ∈
                                 L
                                 (
                                 G
                                 )
                              , its derivation from S is unique if performed “leftmost derivation first”.

Because most models in MDE contexts are graph-based (since meta-models are graphs), we need context-free grammars producing graphs as sentences instead of strings. We use context-free hyperedge replacement graph grammars (HR grammars) [10] which fulfill these requirements. HR grammars operate on hypergraphs, a generalization of graphs where edges, called hyperedges, can have more than two end points (tentacles). These end points are called attachment points and their number is the arity of a hyperedge. Labeled hyperedges take the role of non-terminal and terminal symbols. For replacing hyperedges in graphs by sub-graphs during rewriting, we need to specify how these sub-graphs are to be embedded. To this end, the replacing sub-graphs are equipped with external nodes, and rewriting proceeds by replacing the hyperedge with the sub-graph gluing together each external node with the attachment node of its corresponding attachment point.

More precisely, a hyperedge replacement rule 
                        
                           
                              
                                 l
                              
                              
                                 1
                              
                           
                           ≔
                           H
                         has three parts: a single n-ary non-terminal hyperedge l
                        1, a hypergraph H with 
                           k
                           ≥
                           n
                         external nodes replacing the hyperedge, and an (injective) mapping g of the k external nodes of H onto the n attachment points of l
                        1. Unlike string productions, graph replacement rules need to explicitly define how the new graph is attached to the remaining context. In HR grammars this is done via the mapping g. Fig. 3
                         shows a sketch of the replacement process (for k=n). First, the hyperedge l
                        1 is found by matching (a) and removed (b). Then the graph H is inserted (c) by gluing all its external nodes with the attachment nodes of l
                        1 based on g.

All definitions of string grammars carry over to HR grammars: an HR grammar has the same parts as a string grammar (non-terminals, terminals, productions, and a start symbol) and its language is a set of hypergraphs (see formalization in Section 4). The membership problem for HR grammars is decidable [10] which guarantees the existence of the derivation trees, that we are going to use.

Now, we define both the source (activity diagrams) and target (CSP) language, that we use to demonstrate our GBMTs, in terms of HR grammars. The HR grammars that we use for these two languages are compliant with the respective meta-models, i.e., the graphs which our HR grammars generate are all instances of these meta-models. As meta-models we use a simplified version of the UML activity diagrams meta-model [4] (see Fig. 4
                        ) and the CSP meta-model from [13].

The meta-model of activity diagrams only contains basic diagram elements, their hierarchy, and associations with multiplicities. It does not describe syntactic structures of the language. For example, in a well-formed activity, each decision node should be eventually followed by the corresponding merge node for the decision branches. Although these kinds of inductive structures are intuitive to the transformation developer, they are usually not described in meta-models.


                        Fig. 5
                         shows six out of eleven productions of our source HR grammar. Productions are given in abstract (plus some in concrete) syntax, in the form 
                           l
                           ≔
                           H
                        , using bars to distinguish different right-hand sides of productions. Non-terminal hyperedges are depicted by dashed lines. Types and the number of attachment points of a non-terminal hyperedge are determined by the associations of the meta-model elements which it groups. The mapping between attachment points and external nodes is depicted by using the same numbers, one given in a diamond and the other in a circle. Multiple external nodes can be mapped to one attachment point. Not all external nodes have to be connected in the graph (see production 6).

This grammar describes well-formed activity diagrams containing zero or more activities (productions 1–3), each with exactly one initial and final node, and at most one recursively-defined high-level syntactic structure block called B connected to exactly one initial and final node (production 4). The non-terminal hyperedge of type B can be replaced by one of the following structures: a block sequence (production 5), a fork/join block, a decision/merge block, a loop, an internal action, or an action call (the latter by production 6). Note that our decision/merge constraint is now represented by the corresponding production which only allows to generate these elements together, connected in a specific shape. Other language structures are also produced in this systematic way.


                        Fig. 6
                         shows the relevant subset of our meta-model compliant HR grammar for CSP. A model described by this grammar can contain a set of processes (productions 1–3) generated from non-terminal edges labeled P. A process description represented by the non-terminal PE (production 4) can contain various expressions: a sequential or parallel process composition (productions 7 and 8), an if-then-else expression (production 9), an event followed by a process expression (production 10), another process (production 6), or a SKIP (production 5).

Both grammars we have defined are used to describe our example transformation, which is a transformation from activity diagrams to CSP, frequently employed for analysis purposes [14]. Alternatively, we could, for instance, use the activity diagrams to first-order logic transformation example from [15].


                        Fig. 7
                         shows our sample activity diagram of an enrollment and the corresponding CSP process. Here, we see the concrete syntax of CSP: 
                           −
                           >
                         is an event prefix, ; a sequential composition, SKIP an empty process, 
                           ∥
                         a parallel composition and if-then-else a conditional choice. We require every activity to be transformed into a process and every block sequence and fork/join block into a sequential and parallel process composition, respectively. A decision/merge block is to be transformed into an if-then-else expression and an action call into an event followed by a SKIP. Loops, although absent in this example, are transformed into recursive processes with conditions. Next, we show how this transformation logic can be structurally described using our approach.

Our main goal is to allow an intuitive transformation definition by mapping high-level syntactic structures in source and target languages onto each other. In terms of grammars, this means relating (or pairing) source and target productions creating corresponding structures. During transformation execution these relations are used to identify which target production is triggered for a source production. Both of these steps are considered in Sections 3.1 and 3.2 next.

Our GBMTs operate on derivation trees of source and target models. Given a derivation tree for a source model, we incrementally construct a derivation tree for the target model by applying corresponding productions. Thereby, 1-to-1 correspondences between non-terminal hyperedges in the source and target derivation trees help to keep track of related models׳ structures.


                        Fig. 8
                         shows a sample GBMT rule relating the source production for a sequence of activity blocks to the target production for a sequence of process expressions.
                           1
                        
                        
                           1
                           To simplify, we show GBMT rules without HR grammar details.
                         It states that when a block sequence is replacing a non-terminal hyperedge of type B (block) in a source derivation tree, a sequence of process expressions should replace the corresponding hyperedge of type PE (process expression) in the related target derivation tree. Additionally, the GBMT rule links source non-terminal hyperedges of type B and target non-terminal hyperedges of type PE via a 1-to-1 correspondence of type C. These correspondences determine which target edge will be replaced by the target production, when the linked source hyperedge is replaced by the related source production(s). The notion of correspondence is inspired by Triple Graph Grammars (TGGs) [16].


                        Fig. 9
                         shows further rules of a GBMT for our example:
                           
                              •
                              Rules 1 and 2: Productions for non-terminal (1) and terminal (2) hyperedges for models in the source and target grammars are related. Non-terminal hyperedges in rule 1 are linked via a correspondence required by 2 and 3.

Rule 3: Production of a non-terminal hyperedge of type A for an activity is related to the production of a non-terminal hyperedge of type P for a process. The correspondence between model non-terminal hyperedges is kept and other produced hyperedges are linked for application of rule 4.

Rule 4: Production of an activity containing a block represented by a hyperedge of type B, connected to the initial and final nodes, is related to the production of a process with a process expression represented by a hyperedge of type PE. The produced non-terminal hyperedges are linked via correspondences which are required for applying rules 5 – 7.

Rules 5 – 7 relate different types of activity blocks to different process expressions: A sequence of blocks is related to a sequence of process expressions (5), a fork/join block to a parallel composition of process expressions (6), a decision/merge block to an if-then-else expression (7). Correspondences are created on the same principle as before.

In each GBMT rule:
                                    
                                       (a)
                                       a source production 
                                             
                                                
                                                   p
                                                
                                                
                                                   s
                                                
                                             
                                             =
                                             (
                                             
                                                
                                                   n
                                                
                                                
                                                   s
                                                
                                             
                                             ,
                                             
                                                
                                                   r
                                                
                                                
                                                   s
                                                
                                             
                                             )
                                           is related to a target production 
                                             
                                                
                                                   p
                                                
                                                
                                                   t
                                                
                                             
                                             =
                                             (
                                             
                                                
                                                   n
                                                
                                                
                                                   t
                                                
                                             
                                             ,
                                             
                                                
                                                   r
                                                
                                                
                                                   t
                                                
                                             
                                             )
                                          ;

left-hand side non-terminals n
                                          
                                             s
                                           and n
                                          
                                             t
                                           are linked via a correspondence (start non-terminals 
                                             
                                                
                                                   S
                                                
                                                
                                                   s
                                                
                                             
                                             ,
                                             
                                                
                                                   S
                                                
                                                
                                                   t
                                                
                                             
                                           are always linked);

each non-terminal hyperedge in r
                                          
                                             t
                                           has exactly one corresponding non-terminal hyperedge in r
                                          
                                             s
                                          ,

For each source production 
                                    
                                       
                                          p
                                       
                                       
                                          s
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          n
                                       
                                       
                                          a
                                       
                                    
                                    ,
                                    
                                       
                                          r
                                       
                                       
                                          a
                                       
                                    
                                    )
                                  in P
                                 
                                    s
                                  and each correspondence between the hyperedges of type n
                                 
                                    a
                                  and n
                                 
                                    b
                                  in some GBMT rule (or initial S
                                 
                                    s
                                  to S
                                 
                                    t
                                  correspondence), there is exactly one GBMT rule relating p
                                 
                                    s
                                  to a target production p
                                 
                                    t
                                 , where 
                                    
                                       
                                          p
                                       
                                       
                                          t
                                       
                                    
                                    =
                                    (
                                    
                                       
                                          n
                                       
                                       
                                          b
                                       
                                    
                                    ,
                                    
                                       
                                          r
                                       
                                       
                                          t
                                       
                                    
                                    )
                                 , to cover all combinations of types of corresponding pairs 
                                    (
                                    
                                       
                                          n
                                       
                                       
                                          a
                                       
                                    
                                    ,
                                    
                                       
                                          n
                                       
                                       
                                          b
                                       
                                    
                                    )
                                 ,

Before a GBMT is executed on a source model, this model is parsed with respect to the source HR grammar to get its leftmost derivation tree.
                           2
                        
                        
                           2
                           Derivation tree representing leftmost derivation. See Section 4 for the detailed definition.
                         As HR grammar based parsing is decidable [10], for each source model we either get such a tree or a message that it is not parsable. In the second case, it is not in the source language, and hence is rejected as not applicable. Otherwise, the GBMT rules are applied on the tree to construct the target tree (and model).

During the execution, we build the target derivation tree by first initializing it with a hyperedge of type S
                        
                           t
                        , that has a correspondence to the hyperedge of type S
                        
                           s
                         in the source tree (initial correspondence). Next, we iteratively construct the target tree in the following way: we traverse the source tree to find the next non-terminal hyperedge e
                        
                           s
                         and the source production p
                        
                           s
                         that rewrites it. Then, we consider each correspondence c of e
                        
                           s
                         and find the GBMT rule that pairs some p
                        
                           t
                         with the source production p
                        
                           s
                        , and where the left-hand side non-terminals are equal to the types of the hyperedges linked by c. Finally, we apply the target production p
                        
                           t
                         to the target non-terminal hyperedge linked to e
                        
                           s
                         through c and create additional correspondences according to the GBMT rule. A GBMT terminates once the complete source derivation tree has been traversed and all correspondences have been considered. We can use any traversal order here [10].


                        Fig. 10
                         sketches the GBMT execution process, highlighting a single production in the source leftmost derivation tree for our example applied to a hyperedge of type B with the corresponding hyperedge PE in the already created target tree fragment. The dark grey rectangle frames the result of applying the suitable GBMT rule 5 (Fig. 9) to the corresponding hyperedge PE.

We still need to describe a couple of GBMT rules to complete the definition of our sample transformation from Section 2.2. The remaining rules need to transform: an action call (1) and an internal action (2) into an event followed by a SKIP process, and a loop (3) into an equivalent recursive process, since CSP does not natively support loops. In these cases we need to relate two or more target productions that form a derivation sub-tree, representing some structure, to a single source production. To support this, we extend our approach by relating derivation sub-trees instead of relating single productions in GBMT rules.


                        Fig. 11
                         shows such an extended GBMT rule for case 1 (2 is analogous): it relates the production for an action call to a sub-tree combining two target productions to create an event followed by a SKIP process. Since all non-terminal hyperedges created by these target productions (one of type PE) are also consumed in the sub-tree, we only require a correspondence for the left-hand side non-terminals of the first productions.


                        Fig. 12
                         shows a GBMT rule for case 3 and, thereby, the second extension of our approach – non-local GBMT rules. This type of rule allows the use of an additional correspondence between non-terminals, and uses its target non-terminal as a root of an additional derivation sub-tree. During the GBMT execution, when a correspondence of the defined additional type is found and the rule can be applied, the defined additional sub-tree is assigned to the target of this correspondence, replacing it.

Both extensions can be combined within one GBMT rule, as seen in Fig. 12: it relates the production for a loop to the production for a process reference L(c) and uses a correspondence between two model non-terminals M to create the referenced process L(x). This process consists of an if-then-else expression with the first non-terminal hyperedge of type PE in the then branch, linked to the body of the activity loop represented by the hyperedge of type B, followed by the recursive call to itself, which terminates when the condition x fails. The new process is placed directly under the target model hyperedge of type M which makes the result non-local w.r.t. the operations on the target tree.

As for the conditions we imposed on our GBMT for it to have the desired properties (see Section 5), they now need to be adjusted. Here, we only provide an idea of required adjustments and give their formalization in Section 4. First, for multiple properties, when a rule relates derivation sub-trees, all non-terminal leaves of the target sub-tree have to have corresponding non-terminal leaves in the source sub-tree. Next, for determinism, the absence of two simultaneously applicable rules need to be guaranteed: by disallowing rules with the same correspondence and one source sub-tree being a sub-tree of the other, or by introducing rule priorities. For completeness, the presence of rules covering all possible source model derivation steps must be guaranteed: either via coverage analysis or by forbidding to use source sub-trees with more than one production. In the case of non-local rules, to guarantee determinism, exactly one correspondence of the specified additional type must exist when the rest of the rule is applicable. Plus, the same correspondence condition as for the main target sub-tree must hold for non-terminal leaves of the additional sub-tree.

We now provide a formalization of our grammar-based approach. We start by recapitulating the main definitions for HR grammars that we use to specify the languages of the developed transformations in Section 2.1. The central notions here are: a hyperedge, a hypergraph, a derivation, an HR grammar itself, and its language – a hypergraph language. We give their definitions according to [10]. 
                        Definition 4.1
                        Hyperedge


                        A hyperedge e is an atomic item with a fixed number of tentacles, called the type of the hyperedge and denoted by type(e). It can be attached to a structure with a set of nodes by attaching each of its tentacles to a node, which then becomes an attachment node of e.

Additionally, there exists a fixed set of labels LB, a labeling function for hyperedges – 
                        lab
                        :
                        E
                        →
                        LB
                     , and a typing function for labels – 
                        type
                        :
                        LB
                        →
                        N
                     . The typing function maps labels to non-negative integers in such a way that, for each hyperedge e, the type of its label and the number of its tentacles coincide – 
                        type
                        (
                        lab
                        (
                        e
                        )
                        )
                        =
                        type
                        (
                        e
                        )
                     .

During an application of an HR grammar production, a hyperedge is replaced by a hypergraph. A hypergraph, in turn, is defined over an arbitrary finite number of nodes and hyperedges as follows. 
                        Definition 4.2
                        Hypergraph


                        A hypergraph H over a set of labels LB is a tuple 
                              H
                              =
                              (
                              
                                 
                                    V
                                 
                                 
                                    H
                                 
                              
                              ,
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                              
                              ,
                              
                                 
                                    att
                                 
                                 
                                    H
                                 
                              
                           , 
                              
                                 
                                    lab
                                 
                                 
                                    H
                                 
                              
                              ,
                              
                                 
                                    ext
                                 
                                 
                                    H
                                 
                              
                              )
                            where V
                           
                              H
                            is a finite set of nodes, E
                           
                              H
                            is a finite set of hyperedges, 
                              
                                 
                                    att
                                 
                                 
                                    H
                                 
                              
                              :
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                              
                              →
                              
                                 
                                    V
                                 
                                 
                                    H
                                 
                                 
                                    ⁎
                                 
                              
                            is a mapping assigning a sequence of pairwise distinct attachment nodes att
                           
                              H
                           (e) to each hyperedge 
                              e
                              ∈
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                              
                           , 
                              
                                 
                                    lab
                                 
                                 
                                    H
                                 
                              
                              :
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                              
                              →
                              LB
                            is a mapping that labels each hyperedge in H such that 
                              type
                              (
                              
                                 
                                    lab
                                 
                                 
                                    H
                                 
                              
                              (
                              e
                              )
                              )
                              =
                              |
                              
                                 
                                    att
                                 
                                 
                                    H
                                 
                              
                              (
                              e
                              )
                              |
                           , and 
                              
                                 
                                    ext
                                 
                                 
                                    H
                                 
                              
                              ∈
                              
                                 
                                    V
                                 
                                 
                                    H
                                 
                                 
                                    ⁎
                                 
                              
                            is a sequence of pairwise distinct external nodes.

For simplification, the above definition assumes that the attachment nodes of each hyperedge, as well as, the external nodes of each hypergraph are pairwise distinct. As pointed-out in [10], these restrictions are non-vital. They simplify the definition and lead to the equivalence of type(e) and 
                        |
                        
                           
                              att
                           
                           
                              H
                           
                        
                        (
                        e
                        )
                        |
                      that implies the equivalence: 
                        type
                        (
                        
                           
                              lab
                           
                           
                              H
                           
                        
                        (
                        e
                        )
                        )
                        =
                        |
                        
                           
                              att
                           
                           
                              H
                           
                        
                        (
                        e
                        )
                        |
                      used in Definition 4.2.

To keep later definitions concise, we introduce the following notations. Given a set 
                        X
                        ⊆
                        LB
                      of labels, we denote by E
                        H
                     
                     
                        X
                      the set 
                        {
                        e
                        ∈
                        
                           
                              E
                           
                           
                              H
                           
                        
                        |
                        
                           
                              lab
                           
                           
                              H
                           
                        
                        (
                        e
                        )
                        ∈
                        X
                        }
                      of hyperedges of H with labels in 
                        X
                     . The class of all hypergraphs over LB is denoted by 
                        
                           
                              H
                           
                           
                              LB
                           
                        
                     . Now, we can formalize the notion of an HR grammar. 
                        Definition 4.3
                        Hyperedge replacement grammar


                        A hyperedge replacement (HR) grammar 
                           
                              G
                              =
                              (
                              N
                              ,
                              T
                              ,
                              P
                              ,
                              S
                              )
                            consists of a set of non-terminals 
                           
                              N
                              ⊆
                              LB
                           , a set of terminals 
                           
                              T
                              ⊆
                              LB
                              \
                              N
                           , a finite set of productions P and a designated start symbol 
                           
                              S
                              ∈
                              N
                           . Each production 
                              p
                              ∈
                              P
                            is of the form 
                              p
                              =
                              (
                              A
                              ,
                              R
                              )
                           , with 
                              A
                              ∈
                              N
                           , 
                              R
                              ∈
                              
                                 
                                    H
                                 
                                 
                                    LB
                                 
                              
                           , and 
                              type
                              (
                              A
                              )
                              =
                              type
                              (
                              R
                              )
                            where 
                              type
                              (
                              R
                              )
                              =
                              |
                              
                                 
                                    ext
                                 
                                 
                                    R
                                 
                              
                              |
                           .

The last condition in the above definition 
                        type
                        (
                        A
                        )
                        =
                        type
                        (
                        R
                        )
                      together with the simplification, we have previously mentioned, states that the type of A and the number of attachment nodes of a hyperedge labeled by A should be equal to the number of external nodes of R.

By using an HR grammar G, one hypergraph can be obtained from another by applying a production 
                        p
                        ∈
                        
                           
                              P
                           
                           
                              G
                           
                        
                      to the latter and replacing a hyperedge labeled by A with the hypergraph R. This step is called direct derivation and a sequence of such steps is called derivation. Both notions are defined as follows. 
                        Definition 4.4
                        Direct derivation


                        A direct derivation written 
                              H
                              
                                 
                                    ⇒
                                 
                                 
                                    p
                                 
                              
                              H
                              [
                              e
                              /
                              R
                              ]
                            is an application of a production 
                              p
                              =
                              (
                              A
                              ,
                              R
                              )
                              ∈
                              P
                            to a graph 
                              H
                              ∈
                              
                                 
                                    H
                                 
                                 
                                    LB
                                 
                              
                            by choosing a hyperedge 
                              e
                              ∈
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                                 
                                    N
                                 
                              
                            such that 
                              
                                 
                                    lab
                                 
                                 
                                    H
                                 
                              
                              (
                              e
                              )
                              =
                              A
                            that is then cut out, and replaced by R by gluing it to the remainder of H. Thereby, each i-th external node of R is fused with the i-th attachment node of e (mapping g).

A sequence of direct derivations 
                              d
                              =
                              
                                 
                                    H
                                 
                                 
                                    0
                                 
                              
                              ⇒
                              ⋯
                              ⇒
                              
                                 
                                    H
                                 
                                 
                                    k
                                 
                              
                            is called a derivation of length 
                              k
                              ≥
                              0
                            from H
                           0 to H
                           
                              k
                            and is denoted by 
                              
                                 
                                    H
                                 
                                 
                                    0
                                 
                              
                              
                                 
                                    ⇒
                                 
                                 
                                    P
                                 
                                 
                                    ⁎
                                 
                              
                              
                                 
                                    H
                                 
                                 
                                    k
                                 
                              
                            or 
                              
                                 
                                    H
                                 
                                 
                                    0
                                 
                              
                              
                                 
                                    ⇒
                                 
                                 
                                    ⁎
                                 
                              
                              
                                 
                                    H
                                 
                                 
                                    k
                                 
                              
                           .

If the description of an HR grammar, besides the set of productions and the start symbol, contains specification of terminal symbols (
                        T
                        ≠
                        ∅
                     ), it can generate a language: the set of terminal hypergraphs 
                        {
                        H
                        ∈
                        
                           
                              H
                           
                           
                              T
                           
                        
                        }
                      derivable from the start hypergraph. The start hypergraph is the so-called handle graph induced by the start symbol S of the grammar G. It is defined as follows. 
                        Definition 4.6
                        Handle


                        A hypergraph H with m nodes, 
                              |
                              
                                 
                                    ext
                                 
                                 
                                    H
                                 
                              
                              |
                              =
                              m
                           , and a single hyperedge 
                              e
                              ∈
                              
                                 
                                    E
                                 
                                 
                                    H
                                 
                                 
                                    LB
                                 
                              
                            is a handle if 
                              
                                 
                                    att
                                 
                                 
                                    H
                                 
                              
                              (
                              e
                              )
                              =
                              
                                 
                                    ext
                                 
                                 
                                    H
                                 
                              
                           . If 
                              
                                 
                                    lab
                                 
                                 
                                    H
                                 
                              
                              (
                              e
                              )
                              =
                              A
                           , then H is said to be the handle induced by label A denoted by 
                              
                                 
                                    A
                                 
                                 
                                    •
                                 
                              
                           .

The hypergraph language generated by an HR grammar is formalized as follows. 
                        Definition 4.7
                        Hypergraph language


                        The hypergraph language L(G) generated by an HR grammar G is L
                           
                              S
                           (G), where for all 
                              A
                              ∈
                              N
                           , L
                           
                              A
                           (G) consists of all hypergraphs in H
                           
                              T
                            derivable from 
                              
                                 
                                    A
                                 
                                 
                                    •
                                 
                              
                            by applying productions of P:


                           
                              
                                 
                                    L
                                 
                                 
                                    A
                                 
                              
                              (
                              G
                              )
                              =
                              {
                              H
                              ∈
                              
                                 
                                    H
                                 
                                 
                                    T
                                 
                              
                              |
                              
                                 
                                    A
                                 
                                 
                                    •
                                 
                              
                              
                                 
                                    ⇒
                                 
                                 
                                    P
                                 
                                 
                                    ⁎
                                 
                              
                              H
                              }
                           .

Now, that we have formally defined HR grammars and the languages they describe, we can formalize definition (Section 3.1) and execution (Section 3.2) of GBMTs.

Let us consider a GBMT between a source and a target language defined by finite HR grammars G
                        
                           s
                         and G
                        
                           t
                        , respectively. It consist of a number of rules relating productions from these grammars in a specific way. In many cases, simple 1-to-1 relations are sufficient. Thus, we consider this basic type of GBMT rules first, and their extension to n-to-m production relations later.

To define a basic GBMT rule, we choose productions 
                           
                              
                                 p
                              
                              
                                 s
                              
                           
                           =
                           (
                           
                              
                                 A
                              
                              
                                 s
                              
                           
                           ,
                           
                              
                                 R
                              
                              
                                 s
                              
                           
                           )
                         and 
                           
                              
                                 p
                              
                              
                                 t
                              
                           
                           =
                           (
                           
                              
                                 A
                              
                              
                                 t
                              
                           
                           ,
                           
                              
                                 R
                              
                              
                                 t
                              
                           
                           )
                         from P
                        
                           s
                         and P
                        
                           t
                        , to relate. Furthermore, we relate their left-hand side non-terminals A
                        
                           s
                         and A
                        
                           t
                        , building a correspondence type relation, and we map some hyperedges from R
                        
                           s
                         and R
                        
                           t
                         onto each other via correspondence mappings. To describe types of correspondences we use a finite set of labels CT. It contains at least one label – default type label 
                           
                              
                                 t
                              
                              
                                 c
                              
                              
                                 default
                              
                           
                         – that is always used to type the initial correspondence mapping c
                        
                           d
                        , created during the execution (see Section 3.2). We formalize a basic GBMT rule as follows. 
                           Definition 4.8
                           GBMT rule


                           A GBMT rule 
                              
                                 tr
                                 =
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       p
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 )
                               between languages defined by HR grammars G
                              
                                 s
                               and G
                              
                                 t
                               consists of productions 
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 ∈
                                 
                                    
                                       P
                                    
                                    
                                       s
                                    
                                 
                               and 
                                 
                                    
                                       p
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 ∈
                                 
                                    
                                       P
                                    
                                    
                                       t
                                    
                                 
                              , a correspondence type pre-condition relation 
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                 
                                 )
                               between A
                              
                                 s
                               and A
                              
                                 t
                              , where 
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                 
                                 ∈
                                 CT
                              , and a correspondence function 
                              
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       
                                          
                                             R
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                                 →
                                 CT
                                 ×
                                 
                                    
                                       E
                                    
                                    
                                       
                                          
                                             R
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                               for non-terminal hyperedges of R
                              
                                 t
                               mapping them to the non-terminal hyperedges of R
                              
                                 s
                               and types in CT. Furthermore, the following conditions hold:
                                 
                                    1.
                                    
                                       
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                          =
                                          
                                             
                                                S
                                             
                                             
                                                s
                                             
                                          
                                          ⟺
                                          
                                             
                                                A
                                             
                                             
                                                t
                                             
                                          
                                          =
                                          
                                             
                                                S
                                             
                                             
                                                t
                                             
                                          
                                       , with 
                                          
                                             
                                                t
                                             
                                             
                                                st
                                             
                                          
                                          =
                                          
                                             
                                                t
                                             
                                             
                                                c
                                             
                                             
                                                default
                                             
                                          
                                       ,


                                       C
                                       
                                          post
                                        is total.

The relation c
                        
                           pre
                         is called the correspondence type pre-condition, due to its role during the GBMT execution: a correspondence mapping of its type has to exist between some hyperedges of the source and the target derivation trees, before a GBMT rule with such a pre-condition can be applied. Formally, this type of relation is defined as follows. 
                           Definition 4.9
                           Correspondence mapping type


                           A correspondence mapping 
                                 c
                                 =
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       ts
                                    
                                 
                                 ,
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 )
                              
                              is of the type defined by a correspondence type relation 
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                 
                                 )
                              , when 
                                 lab
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                              , 
                                 lab
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                 
                              , and 
                                 
                                    
                                       t
                                    
                                    
                                       ts
                                    
                                 
                                 =
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                 
                              .

Furthermore, by requiring the C
                        
                           post
                         relation to be a function in Definition 4.8, we forbid 1–to–n correspondence mappings of non-terminal hyperedges in R
                        
                           t
                         to non-terminal hyperedges in R
                        
                           s
                         and, thereby, prevent the defined transformation from being non-deterministic. A complete basic GBMT is defined as follows. 
                           Definition 4.10
                           GBMT


                           A GBMT 
                              
                                 T
                                 =
                                 {
                                 
                                    
                                       tr
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       tr
                                    
                                    
                                       n
                                    
                                 
                                 }
                               is a finite set of GBMT rules 
                              
                                 
                                    
                                       tr
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 1
                                 ≤
                                 i
                                 ≤
                                 n
                              , fulfilling the following conditions:
                                 
                                    1.
                                    There are no 
                                          
                                             
                                                tr
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                tr
                                             
                                             
                                                2
                                             
                                          
                                          ∈
                                          T
                                        such that 
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                1
                                             
                                          
                                          =
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                2
                                             
                                          
                                       , 
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                             
                                                1
                                             
                                          
                                          =
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                             
                                                2
                                             
                                          
                                       , and 
                                          
                                             
                                                p
                                             
                                             
                                                t
                                             
                                             
                                                1
                                             
                                          
                                          ≠
                                          
                                             
                                                p
                                             
                                             
                                                t
                                             
                                             
                                                2
                                             
                                          
                                       .

For each production 
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          ∈
                                          
                                             
                                                P
                                             
                                             
                                                s
                                             
                                          
                                        and for each correspondence mapping 
                                          c
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                ts
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          )
                                          ∈
                                          
                                             
                                                
                                                   ⋃
                                                
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                n
                                             
                                          
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                             
                                                i
                                             
                                          
                                          ∪
                                          {
                                          
                                             
                                                c
                                             
                                             
                                                d
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                c
                                             
                                             
                                                default
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          )
                                          |
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                S
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                S
                                             
                                             
                                                s
                                             
                                          
                                          }
                                       , where 
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                        and 
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                A
                                             
                                             
                                                t
                                             
                                          
                                        for some 
                                          
                                             
                                                A
                                             
                                             
                                                t
                                             
                                          
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                
                                                   
                                                      G
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                       , there exists a rule 
                                          tr
                                          =
                                          (
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                p
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                          
                                          ,
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                          
                                          )
                                          ∈
                                          T
                                        such that 
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                ts
                                             
                                          
                                          ,
                                          
                                             
                                                A
                                             
                                             
                                                t
                                             
                                          
                                          )
                                       .

The conditions stated in the above definition ensure that the defined GBMT has the quality properties, that we discuss in Section 5. The first one prohibits multiple GBMT rules with the same source production and correspondence type pre-condition, and different target productions, since they are applicable at the same time. If that were allowed, it would make GBMT execution non-deterministic.

The second condition ensures that for each source production and each type of correspondence mapping a hyperedge labeled with its left-hand side non-terminal A
                        
                           s
                         can be involved in, there is a GBMT rule in T with these source production and correspondence type pre-conditions. The types of correspondence mappings a hyperedge can be involved in during the execution are defined by C
                        
                           post
                         functions of all GBMT rules in T and by the initial mapping 
                           
                              
                                 c
                              
                              
                                 d
                              
                           
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 d
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 c
                              
                              
                                 default
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                              
                                 d
                              
                           
                           )
                           )
                         created during the execution. These C
                        
                           post
                         functions and c
                        
                           d
                         mapping define actual mappings and, thereby, also their type that is fully determined by the combination of labels of e
                        
                           s
                         and e
                        
                           t
                         in LB, and the correspondence type label t
                        
                           ts
                         in CT.

Now, we define the extended type of GBMT rules with n-to-m relations between productions, introduced in Section 3.3. An extended GBMT rule relates: a derivation of length n in G
                        
                           s
                         to a derivation of length m in G
                        
                           t
                        , where 
                           n
                           ,
                           m
                           ≥
                           1
                        . Due to the context-freeness of HR grammars, we can and do use derivation trees to represent these derivations in our rules. Thus, we provide a definition of a derivation tree, taken from [10] and extended by a set of non-terminal hyperedges E
                        
                           N
                        
                        
                           t
                         of a tree t (analogous to those of a hypergraph). 
                           Definition 4.11
                           Derivation tree


                           The set TREE(P) of derivation trees over productions P in grammar G is recursively defined as follows:
                                 
                                    •
                                    
                                       
                                          A
                                          ∈
                                          TREE
                                          (
                                          P
                                          )
                                        with 
                                          root
                                          (
                                          A
                                          )
                                          =
                                          A
                                       , 
                                          result
                                          (
                                          A
                                          )
                                          =
                                          
                                             
                                                A
                                             
                                             
                                                •
                                             
                                          
                                       , and 
                                          
                                             
                                                E
                                             
                                             
                                                A
                                             
                                             
                                                N
                                             
                                          
                                          =
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      •
                                                   
                                                
                                             
                                             
                                                N
                                             
                                          
                                        for all 
                                          
                                          A
                                          ∈
                                          N
                                       .

For every production 
                                          p
                                          =
                                          (
                                          A
                                          ,
                                          R
                                          )
                                          ∈
                                          P
                                        and every mapping 
                                          branch
                                          :
                                          
                                             
                                                E
                                             
                                             
                                                R
                                             
                                             
                                                N
                                             
                                          
                                          →
                                          TREE
                                          (
                                          P
                                          )
                                        such that 
                                          lab
                                          (
                                          e
                                          )
                                          =
                                          lab
                                          (
                                          root
                                          (
                                          branch
                                          (
                                          e
                                          )
                                          )
                                          )
                                        for all 
                                          e
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                R
                                             
                                             
                                                N
                                             
                                          
                                       , the triple 
                                          t
                                          =
                                          (
                                          A
                                          ,
                                          R
                                          ,
                                          branch
                                          )
                                          ∈
                                          TREE
                                          (
                                          P
                                          )
                                       . Furthermore, we let 
                                          root
                                          (
                                          t
                                          )
                                          =
                                          A
                                       , 
                                          result
                                          (
                                          t
                                          )
                                          =
                                          R
                                          [
                                          
                                             
                                                e
                                             
                                             
                                                1
                                             
                                          
                                          /
                                          result
                                          (
                                          branch
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                1
                                             
                                          
                                          )
                                          )
                                          ]
                                          ⋯
                                          [
                                          
                                             
                                                e
                                             
                                             
                                                |
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      R
                                                   
                                                   
                                                      N
                                                   
                                                
                                                |
                                             
                                          
                                          /
                                          result
                                          (
                                          branch
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                |
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      R
                                                   
                                                   
                                                      N
                                                   
                                                
                                                |
                                             
                                          
                                          )
                                          )
                                          ]
                                        where 
                                          
                                             
                                                e
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                R
                                             
                                             
                                                N
                                             
                                          
                                       , and 
                                          
                                             
                                                E
                                             
                                             
                                                t
                                             
                                             
                                                N
                                             
                                          
                                          =
                                          
                                             
                                                E
                                             
                                             
                                                R
                                             
                                             
                                                N
                                             
                                          
                                          ∪
                                          
                                             
                                                
                                                   ⋃
                                                
                                             
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      R
                                                   
                                                   
                                                      N
                                                   
                                                
                                             
                                          
                                          
                                             
                                                E
                                             
                                             
                                                branch
                                                (
                                                e
                                                )
                                             
                                             
                                                N
                                             
                                          
                                       .

This definition distinguishes two types of derivation trees: a non-terminal tree A in N and a production based tree for a production 
                           p
                           =
                           (
                           A
                           ,
                           R
                           )
                        . The second type of tree is recursively constructed through sub-trees connected via branch mappings to non-terminal hyperedges e in R. Furthermore, a derivation tree t
                        
                           p
                         can be a prefix of another derivation tree t, when t can be constructed from t
                        
                           p
                         by mapping some hyperedges e in 
                           
                              
                                 E
                              
                              
                                 
                                    
                                       t
                                    
                                    
                                       p
                                    
                                 
                              
                              
                                 N
                              
                           
                         with non-terminal sub-trees 
                           branch
                           (
                           e
                           )
                           ∈
                           N
                        , to new production based sub-trees such that 
                           branch
                           (
                           e
                           )
                           ∈
                           TREE
                           (
                           P
                           )
                           \
                           N
                        . This notion of prefix is used in the execution for the application of GBMT rules.

Instead of single productions, an extended GBMT rule relates derivation sub-trees over P
                        
                           s
                         and P
                        
                           t
                         and, like in the basic GBMT rule type, it specifies correspondence mappings, but in an extended way. It requires each target leaf – a non-terminal hyperedge which is produced and not consumed (rewritten) by the target derivation sub-tree – to have exactly one corresponding leaf non-terminal hyperedge in the related source derivation sub-tree. This condition is formalized as part of the following extended GBMT rule definition. 
                           Definition 4.12
                           Extended GBMT rule


                           An extended GBMT rule 
                              
                                 tr
                                 =
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 )
                               is constructed from a GBMT rule (Definition 4.8) by extending its source and target productions p
                              
                                 s
                               and p
                              
                                 t
                               to finite derivation sub-trees 
                                 
                                    
                                       t
                                    
                                    
                                       s
                                    
                                 
                                 ∈
                                 TREE
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 \
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                               and 
                                 
                                    
                                       t
                                    
                                    
                                       t
                                    
                                 
                                 ∈
                                 TREE
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 \
                                 
                                    
                                       N
                                    
                                    
                                       t
                                    
                                 
                              , and by extending the domain and co-domain of its correspondence function: 
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 :
                                 
                                    
                                       E
                                    
                                    
                                       result
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                                 →
                                 CT
                                 ×
                                 
                                    
                                       E
                                    
                                    
                                       result
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             s
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                              .

Since a single production 
                           p
                           =
                           (
                           A
                           ,
                           R
                           )
                         can be represented as a one-production derivation tree 
                        
                           t
                           =
                           (
                           A
                           ,
                           R
                           ,
                           {
                           branch
                           (
                           e
                           )
                           =
                           lab
                           (
                           e
                           )
                           |
                           ∀
                           e
                           ∈
                           
                              
                                 E
                              
                              
                                 R
                              
                              
                                 N
                              
                           
                           }
                           )
                        , Definition 4.8 is a special case of the above Definition 4.12.

Now, our GBMT can contain extended rules. Thus, we need to refine its definition, and adjust the conditions stated in Definition 4.10 to ensure the desired quality properties. The possibility to use non-trivial source derivation sub-trees with (potentially) multiple productions in rules can compromise the completeness of the defined GBMT. To avoid this, we require a well-formed rule set for each combination of a source production 
                           
                              
                                 p
                              
                              
                                 s
                              
                           
                           =
                           (
                           
                              
                                 A
                              
                              
                                 s
                              
                           
                           ,
                           
                              
                                 R
                              
                              
                                 s
                              
                           
                           )
                         and a correspondence type pre-condition relation c
                        
                           pre
                        . Such a rule set for each p
                        
                           s
                         and c
                        
                           pre
                         contains all extended GBMT rules tr with c
                        
                           pre
                         whose source derivation sub-trees start with p
                        
                           s
                         such that 
                           
                              
                                 t
                              
                              
                                 s
                              
                           
                           =
                           (
                           
                              
                                 A
                              
                              
                                 s
                              
                           
                           ,
                           
                              
                                 R
                              
                              
                                 s
                              
                           
                           ,
                           
                              
                                 branch
                              
                              
                                 s
                              
                           
                           )
                        . A well-formed rule set then either: (1) uses rule priorities and contains a special rule with the lowest priority (more concise solution), or (2) it fulfills the coverage criterion we formulate (if all options are considered explicitly).

In case 1, the set must contain one special rule with a one-production source sub-tree. This rule must have the lowest priority in the set to guarantee its use only when no other rules of the set can be applied. The presence of this special rule gives us guarantee that the defined GBMT will transform each application of production p
                        
                           s
                         to a non-terminal hyperedge with the correspondence of the type c
                        
                           pre
                        , regardless of the productions applied later to the hyperedges in R
                        
                           s
                        .

In case 2, the rules in the set for p
                        
                           s
                         and c
                        
                           pre
                         together must fulfill the coverage criterion. This coverage criterion requires rules of the set together to describe all replacement alternatives available in G
                        
                           s
                         for their source derivation sub-trees. For one rule tr in a rule set 
                           
                              
                                 RS
                              
                              
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                              
                           
                         such replacement alternatives for its source sub-tree t
                        
                           s
                         are defined as follows. 
                           Definition 4.13
                           Replacement alternative


                           A derivation sub-tree t
                              
                                 alt
                               is a replacement alternative for a sub-tree 
                                 t
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 
                                    
                                       branch
                                    
                                    
                                       t
                                    
                                 
                                 )
                               in grammar G if and only if
                                 
                                    1.
                                    
                                       
                                          t
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                alt
                                             
                                          
                                          ∈
                                          TREE
                                          (
                                          P
                                          )
                                        and 
                                          
                                             
                                                t
                                             
                                             
                                                alt
                                             
                                          
                                          =
                                          (
                                          A
                                          ,
                                          R
                                          ,
                                          
                                             
                                                branch
                                             
                                             
                                                alt
                                             
                                          
                                          )
                                       .

For all hyperedges 
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                             
                                                N
                                             
                                          
                                       : if there is a hyperedge 
                                          e
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                t
                                             
                                             
                                                N
                                             
                                          
                                        in t at the same position as e
                                       
                                          alt
                                        in t
                                       
                                          alt
                                        then, 
                                          
                                             
                                                branch
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                          
                                          )
                                          ∈
                                          N
                                        iff 
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                          
                                          (
                                          e
                                          )
                                          ∈
                                          N
                                       ; otherwise, 
                                          
                                             
                                                branch
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                          
                                          )
                                          ∈
                                          N
                                       .

There exists a hyperedge 
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                             
                                                N
                                             
                                          
                                        with 
                                          
                                             
                                                branch
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∉
                                          N
                                        at the same position as some hyperedge 
                                          
                                             
                                                e
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                t
                                             
                                             
                                                N
                                             
                                          
                                          :
                                          
                                             
                                                branch
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      alt
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                alt
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ≠
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                       .

The first condition of this definition requires a replacement alternative sub-tree t
                        
                           alt
                         to start with the same production as t, and to be from TREE(P) for G.

The second condition requires that all non-terminal hyperedges from t and t
                        
                           alt
                         which appear at the same position in both trees are mapped to the same (non-terminal or production based) type of sub-tree by the corresponding branch mappings. Thereby, two non-terminal hyperedges are considered to appear at the same position in their trees, when the roots of the trees are the same and the paths to the hyperedges in these trees are the same, i.e. contain the same
                           3
                        
                        
                           3
                           Every hyperedge has a unique identification label (id) in a hypergraph. Hyperedges in hypergraphs with the same position in trees and with the same ids are considered equivalent.
                         hyperedges in the same order. Formally, a path is defined as follows. 
                           Definition 4.14
                           Hyperedge path


                           A path from root A to a hyperedge e in a tree 
                                 t
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 branch
                                 )
                               is a sequence 
                                 
                                    
                                       e
                                    
                                    
                                       1
                                    
                                 
                                 ⋯
                                 
                                    
                                       e
                                    
                                    
                                       n
                                    
                                 
                                 ∈
                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             t
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       ⁎
                                    
                                 
                              , where 
                                 
                                    
                                       e
                                    
                                    
                                       1
                                    
                                 
                                 ∈
                                 
                                    
                                       E
                                    
                                    
                                       R
                                    
                                    
                                       N
                                    
                                 
                              , 
                                 
                                    
                                       e
                                    
                                    
                                       n
                                    
                                 
                                 =
                                 e
                              , 
                                 
                                    
                                       e
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 ∈
                                 
                                    
                                       E
                                    
                                    
                                       
                                          
                                             R
                                          
                                          
                                             branch
                                             (
                                             
                                                
                                                   e
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       N
                                    
                                 
                               for 
                                 1
                                 ≤
                                 i
                                 <
                                 n
                              . Its length is then equal to n.

The position of a hypergraph in a tree can then be defined by the position of the edge mapped onto it via branch.

The second condition means that a hyperedge has a non-terminal 
                           A
                           ∈
                           N
                         as a sub-tree, if and only if, the other hyperedge at the same position has it as well. If a hyperedge only appears in t
                        
                           alt
                        , its sub-tree must be assigned to a non-terminal. This keeps the number of alternative replacement sub-trees finite. Finally, the last condition of the Definition 4.13 requires the sub-tree t
                        
                           alt
                         to differ from t in at least one branch mapping for a non-terminal hyperedge, that has an equivalent in t and whose mapped sub-tree is not a non-terminal.

From these conditions, one can infer the following propositions. The first one is concerned with the length of a replacement alternative tree, where the length of a tree is defined as the length of the longest path in the tree. 
                           Proposition 1
                           Length of replacement alternative


                           
                              Given a derivation tree 
                              
                                 t
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 branch
                                 )
                               
                              and its replacement alternative 
                              
                                 
                                    
                                       t
                                    
                                    
                                       alt
                                    
                                 
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 
                                    
                                       branch
                                    
                                    
                                       alt
                                    
                                 
                                 )
                              , the length of t
                              
                                 alt
                               
                              is less or equal to the length of t.

Thus, each replacement alternative of a tree is at most as long as this tree and, therefore, the set of replacement alternatives for one tree stays finite. The second proposition considers the relation between two replacement alternatives. 
                           Proposition 2
                           Replacement alternative distinction


                           
                              Given a sub-tree 
                              
                                 t
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 branch
                                 )
                               
                              and its replacement alternative 
                              
                                 
                                    
                                       t
                                    
                                    
                                       alt
                                    
                                 
                                 =
                                 (
                                 A
                                 ,
                                 R
                                 ,
                                 
                                    
                                       branch
                                    
                                    
                                       alt
                                    
                                 
                                 )
                              , t
                              
                                 alt
                               
                              is not equal, nor an extension or prefix of t.

In both cases (1 and 2) considered before, only a single combination of a source production p
                        
                           s
                         and a correspondence type pre-condition c
                        
                           pre
                         have to be determined to build the so-called well-formed rule set for p
                        
                           s
                         and c
                        
                           pre
                        , defined as follows. 
                           Definition 4.15
                           Well-formed GBMT rule set


                           A rule set 
                                 
                                    
                                       RS
                                    
                                    
                                       
                                          
                                             p
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             pre
                                          
                                       
                                    
                                 
                                 ⊆
                                 T
                               for a production 
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 ∈
                                 
                                    
                                       P
                                    
                                    
                                       s
                                    
                                 
                               and a correspondence type pre-condition relation 
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                 
                                 )
                               in GBMT T consists of rules with 
                                 
                                    
                                       t
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       branch
                                    
                                    
                                       s
                                    
                                 
                                 )
                               and correspondence type pre-condition c
                              
                                 pre
                              . 
                                 
                                    
                                       RS
                                    
                                    
                                       
                                          
                                             p
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             pre
                                          
                                       
                                    
                                 
                               is well-formed iff it is not empty and one of the following holds:
                                 
                                    1.
                                    
                                       Special rule: There exists exactly one GBMT rule 
                                          tr
                                          ∈
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                        such that 
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          {
                                          
                                             
                                                branch
                                             
                                             
                                                s
                                             
                                          
                                          (
                                          e
                                          )
                                          =
                                          lab
                                          (
                                          e
                                          )
                                          |
                                          ∀
                                          
                                          e
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                          }
                                          )
                                        is a one-production derivation sub-tree and its priority is the lowest in 
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                       .


                                       Coverage criteria: For each GBMT rule 
                                          tr
                                          ∈
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                        and each replacement alternative t
                                       
                                          alt
                                        for t
                                       
                                          s
                                        available in G
                                       
                                          s
                                        (see Definition 4.13), there exists a GBMT rule 
                                          
                                             
                                                tr
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                        such that 
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          
                                             
                                                t
                                             
                                             
                                                alt
                                             
                                          
                                       . Furthermore, for all distinct 
                                          tr
                                          ,
                                          
                                             
                                                tr
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                       , 
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                             
                                                ′
                                             
                                          
                                        is a replacement alternative of t
                                       
                                          s
                                       .

The first condition of this definition states requirements for the case 1, with a special rule of lower priority in the set. The second condition states requirements for the case 2, with the coverage criterion we have introduced. This condition demands that for each GBMT rule in the set, this set also contains GBMT rules with source derivation sub-trees equal to replacement alternatives of the source derivation sub-tree of that rule. This way, we cover all alternative derivation paths starting with an application of p
                        
                           s
                        . Plus in the second condition, we also demand that the source derivation sub-trees of all rules in the set are replacement alternatives of each other. This is done to make use of Proposition 2, and avoid having multiple GBMT rules applicable at the same execution point. The adjustments described above requires a new extended GBMT definition. 
                           Definition 4.16
                           Extended GBMT


                           A GBMT 
                                 T
                                 =
                                 {
                                 
                                    
                                       tr
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       tr
                                    
                                    
                                       n
                                    
                                 
                                 }
                               is extended iff it contains extended
                              
                                 4
                              
                              
                                 4
                                 Basic GBMT rule type (Definition 4.8) is a special case of an extended GBMT rule.
                               GBMT rule(s) and fulfills these additional conditions:
                                 
                                    1.
                                    There are no 
                                          
                                             
                                                tr
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                tr
                                             
                                             
                                                2
                                             
                                          
                                          ∈
                                          T
                                        with the same priority value such that 
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                1
                                             
                                          
                                          =
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                2
                                             
                                          
                                       , and 
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                             
                                                1
                                             
                                          
                                        is a prefix of (or equal to) 
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                             
                                                2
                                             
                                          
                                       .

For each production 
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          ∈
                                          
                                             
                                                P
                                             
                                             
                                                s
                                             
                                          
                                        and each correspondence mapping 
                                          c
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                ts
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          )
                                          ∈
                                          
                                             
                                                
                                                   ⋃
                                                
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                n
                                             
                                          
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                             
                                                i
                                             
                                          
                                          ∪
                                          {
                                          
                                             
                                                c
                                             
                                             
                                                d
                                             
                                          
                                          }
                                          :
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                A
                                             
                                             
                                                s
                                             
                                          
                                       , there exists exactly one well-formed rule set 
                                       
                                          
                                             
                                                RS
                                             
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      s
                                                   
                                                
                                                ,
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      pre
                                                   
                                                
                                             
                                          
                                          ⊆
                                          T
                                        (Definition 4.15): c
                                       
                                          pre
                                        is the type of c.

The above definition requires T to be finite, yet contain a well-formed rule set 
                           RS
                         for each combination of a production and correspondence type used. When a rule set contains a special rule, it automatically fulfills well-formedness criterion 1 of Definition 4.15, and, hence, can be finite. In the case when a rule set fulfills well-formedness criterion 2 of Definition 4.15, we need to show that it is finite (Proposition 3), and, thus, it is possible to build a finite T with such rule sets. 
                           Proposition 3
                           Finite well-formed GBMT rule set


                           
                              Given a well-formed GBMT rule set 
                              
                                 
                                    
                                       RS
                                    
                                    
                                       
                                          
                                             p
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             pre
                                          
                                       
                                    
                                 
                                 ⊆
                                 T
                               
                              for a production 
                              
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       s
                                    
                                 
                                 )
                               
                              and a correspondence type c
                              
                                 pre
                               
                              that fulfills coverage criterion (
                                 Definition 4.15 (2)), and a finite source HR grammar G
                              
                                 s
                               
                              of T, then 
                              
                                 
                                    
                                       RS
                                    
                                    
                                       
                                          
                                             p
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             pre
                                          
                                       
                                    
                                 
                               
                              is always finite.

Now, with the above definition of an extended GBMT, we can relate source and target derivation sub-trees in our GBMT rules. However, in some cases, we require non-local GBMT rules, introduced in Section 3.3, to define our example transformation. Next, we formalize this type of GBMT rules. 
                           Definition 4.17
                           Non-local GBMT rule


                           A non-local GBMT rule 
                              
                                 tr
                                 =
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 )
                               is an extended GBMT rule with an additional correspondence type pre-condition relation 
                              
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       s
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       st
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 )
                              , an additional finite target derivation sub-tree 
                              
                                 
                                    
                                       t
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       A
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       branch
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 )
                              , and a correspondence function with an extended domain and co-domain 
                                 
                                    
                                       C
                                    
                                    
                                       post
                                    
                                 
                                 :
                                 {
                                 
                                    
                                       E
                                    
                                    
                                       result
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                                 ∪
                                 
                                    
                                       E
                                    
                                    
                                       result
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             t
                                          
                                          
                                             a
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                                 }
                                 →
                                 CT
                                 ×
                                 {
                                 
                                    
                                       E
                                    
                                    
                                       result
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             s
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                                 ∪
                                 {
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                    
                                       a
                                    
                                 
                                 }
                                 }
                               with 
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                    
                                       a
                                    
                                 
                                 ∈
                                 
                                    
                                       E
                                    
                                    
                                       
                                          
                                             A
                                          
                                          
                                             s
                                          
                                          
                                             a
                                             •
                                          
                                       
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                               where these additional conditions hold:
                                 
                                    1.
                                    
                                       
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                a
                                             
                                          
                                          ≠
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                          
                                       .

There exists exactly one 
                                          
                                             
                                                c
                                             
                                             
                                                a
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                st
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                a
                                             
                                          
                                          )
                                          )
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                          
                                        of type c
                                       
                                          a
                                       
                                       
                                          pre
                                        such that 
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                result
                                                (
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      t
                                                   
                                                   
                                                      a
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                        and is identified with the 
                                          root
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          )
                                        via a hyperedge identity mapping. This mapping states that, when the top production 
                                          (
                                          
                                             
                                                A
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          )
                                        of t
                                       
                                          a
                                       
                                       
                                          t
                                        is applied to a hyperedge with label A
                                       
                                          a
                                       
                                       
                                          t
                                       , this hyperedge is kept as e
                                       
                                          a
                                       
                                       
                                          t
                                        in the replacing hypergraph R
                                       
                                          a
                                       
                                       
                                          t
                                       .

The first condition of this definition forbids a non-local rule to use the same main and additional correspondence type, to avoid concurrent branch mapping assignments for one hyperedge, which could lead to non-deterministic results.

The second condition ensures that each non-local rule propagates the additional correspondence mapping that it requires. This is done through the leaf hyperedge e
                        
                           a
                        
                        
                           t
                         of t
                        
                           a
                        
                        
                           t
                        , that is identified with the 
                           root
                           (
                           
                              
                                 t
                              
                              
                                 t
                              
                              
                                 a
                              
                           
                           )
                         via a hyperedge identity mapping (dashed line in Fig. 12), and its correspondence mapping c
                        
                           a
                         to some e
                        
                           a
                        
                        
                           s
                        . When such a non-local rule is applied, e
                        
                           a
                        
                        
                           s
                         and e
                        
                           a
                        
                        
                           t
                         (through identity mapping) become hyperedges of the new additional correspondence mapping of type c
                        
                           a
                        
                        
                           pre
                        . This way, we ensure that, after an application of a non-local GBMT rule, the additional correspondence mapping it has used, still exists for other rules. Now, we re-visit the definition of GBMTs to add non-local rules. 
                           Definition 4.18
                           Non-local GBMT


                           An extended GBMT 
                                 T
                                 =
                                 {
                                 
                                    
                                       tr
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       tr
                                    
                                    
                                       n
                                    
                                 
                                 }
                               is non-local iff it contains non-local GBMT rule(s) and additionally fulfills:
                                 
                                    1.
                                    For each non-local GBMT rule 
                                          tr
                                          =
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                a
                                             
                                          
                                          ,
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                          
                                          )
                                          ∈
                                          T
                                       , there is a local GBMT rule 
                                          
                                             
                                                tr
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          T
                                        with 
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                ′
                                             
                                          
                                          ≠
                                          
                                             
                                                c
                                             
                                             
                                                pre
                                             
                                             
                                                a
                                             
                                          
                                        and 
                                          
                                             
                                                c
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                             
                                                ′
                                             
                                          
                                        of type c
                                       
                                          a
                                       
                                       
                                          pre
                                       .

For each non-local GBMT rule 
                                          tr
                                          ∈
                                          T
                                       , there is no rule 
                                          
                                             
                                                tr
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          T
                                        such that there exist distinct 
                                          
                                             
                                                c
                                             
                                             
                                                1
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                2
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                post
                                             
                                             
                                                ′
                                             
                                          
                                        of type c
                                       
                                          a
                                       
                                       
                                          pre
                                       .

Condition 1 of this definition ensures that a non-local GBMT T contains a non-local rule 
                           
                              
                                 tr
                              
                              
                                 ′
                              
                           
                         that creates (and does not require as 
                           
                              
                                 c
                              
                              
                                 pre
                              
                              
                                 ′
                              
                           
                        ) an additional correspondence c
                        
                           a
                        
                        
                           pre
                         for each non-local rule tr. Condition 2 ensures that c
                        
                           a
                        
                        
                           pre
                         for a non-local rule is created at most once in a GBMT rule application.

A GBMT T can contain multiple rules fulfilling condition 1 and creating a correspondence of type c
                        
                           a
                        
                        
                           pre
                         for some tr in T. To guarantee that a GBMT rule that requires this type of additional correspondence (i.e. tr) is deterministically applicable, we need to state the following extra condition on T for each of its non-local rule tr. This condition is not always easy to show. 
                           Definition 4.19
                           Additional correspondence creation condition (ACCC)


                           Given a non-local GBMT T, for each non-local rule 
                                 tr
                                 ∈
                                 T
                               and each source model 
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                                 ∈
                                 L
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       s
                                    
                                 
                                 )
                              : Only one and the same 
                                 
                                    
                                       tr
                                    
                                    
                                       ′
                                    
                                 
                                 ∈
                                 T
                               fulfilling 1 of Definition 4.18 for tr is always applied exactly once and before tr during an execution
                                 5
                              
                              
                                 5
                                 Formalization of GBMT rule applicability and the execution process are given in Section 4.2.
                               of T on M
                              
                                 s
                              .

This additional condition considers all possible executions of T on all possible source models. In general, it might not be possible to show this condition due to an infinite number of models in a language. Its depends both on the way GBMT rules are defined, as well as, on the productions available in the source and target grammars G
                        
                           s
                         and G
                        
                           t
                         for their definition. Furthermore, depending on the chosen additional correspondence type and productions in G
                        
                           s
                         and G
                        
                           t
                         that create elements involved in this type of mapping, definition of the desired non-local GBMT fulfilling the ACCC condition may not be possible. For our example this is, however, not the case.


                        Definition 4.18 combined with the ACCC condition ensures that for each non-local GBMT rule 
                           tr
                           ∈
                           T
                        , when it is applicable to a hyperedge e
                        
                           s
                         with a correspondence mapping 
                           c
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           )
                         during the execution, there exists exactly one suitable additional correspondence mapping c
                        
                           a
                         of type c
                        
                           a
                        
                        
                           pre
                         in the structure already created during the execution of T. A mapping 
                           
                              
                                 c
                              
                              
                                 a
                              
                           
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 a
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                              
                                 a
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                              
                                 a
                              
                           
                           )
                           )
                         is suitable when: no rule has yet been applied to e
                        
                           a
                        
                        
                           s
                         with this mapping i.e., 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 a
                              
                           
                           )
                           ∈
                           
                              
                                 N
                              
                              
                                 t
                              
                           
                        , or the rule 
                           
                              
                                 tr
                              
                              
                                 ′
                              
                           
                        , that has been applied to e
                        
                           a
                        
                        
                           s
                         in c
                        
                           a
                        , does not keep (re-produce) a correspondence mapping of type c
                        
                           a
                        
                        
                           pre
                         i.e., 
                           {
                           
                              
                                 c
                              
                              
                                 ′
                              
                           
                           ∈
                           
                              
                                 C
                              
                              
                                 post
                              
                              
                                 ′
                              
                           
                           |
                           
                              
                                 c
                              
                              
                                 ′
                              
                           
                         is of type 
                           
                              
                                 c
                              
                              
                                 pre
                              
                              
                                 a
                              
                           
                           }
                           =
                           ∅
                        . Formal description of a suitable additional correspondence mapping is given next as part of the execution formalization.

Transformation of a source model M
                        
                           s
                         is executed on its derivation tree over productions of the source grammar G
                        
                           s
                        . Since a source model can have more than one derivation tree in G
                        
                           s
                        , we need to chose one in a way that lets us avoid non-deterministic results. Thus, we use the so-called leftmost derivation of M
                        
                           s
                         and its tree representation as an input of our GBMTs.

The notion of leftmost derivation for hypergraphs defined here is analogous to the one for strings (see [10]). Since hyperedges in a hypergraph have no natural ordering such as symbols in a string, we impose such an ordering, as suggested in [8]. For a hypergraph H we define an ordering 
                        
                           
                              
                                 O
                              
                              
                                 H
                              
                           
                           =
                           (
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 e
                              
                              
                                 n
                              
                           
                           )
                         such that e
                        
                           i
                         are distinct hyperedges in E
                        
                           H
                        
                        
                           N
                         and 
                           n
                           =
                           |
                           
                              
                                 E
                              
                              
                                 H
                              
                              
                                 N
                              
                           
                           |
                        . For an HR grammar G, for each 
                           p
                           =
                           (
                           A
                           ,
                           R
                           )
                         in P we define an ordering O
                        
                           R
                         for its hypergraph R. Now, we define leftmost direct derivation and leftmost derivation sequence for an HR grammar. 
                           Definition 4.20
                           Leftmost direct derivation


                           Given a hypergraph H with an ordering O
                              
                                 H
                               for E
                              
                                 H
                              
                              
                                 N
                               and a hypergraph K with an ordering O
                              
                                 K
                               for E
                              
                                 K
                              
                              
                                 N
                              . Then K is leftmost direct derived from H iff
                                 
                                    1.
                                    
                                       
                                          H
                                          
                                             
                                                ⇒
                                             
                                             
                                                p
                                             
                                          
                                          K
                                        by rewriting the leftmost non-terminal hyperedge 
                                          
                                             
                                                e
                                             
                                             
                                                1
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                H
                                             
                                             
                                                N
                                             
                                          
                                        in the ordering O
                                       
                                          H
                                       .


                                       O
                                       
                                          K
                                        is derived from O
                                       
                                          H
                                        by substituting for 
                                          
                                             
                                                e
                                             
                                             
                                                1
                                             
                                          
                                          ∈
                                          
                                             
                                                O
                                             
                                             
                                                H
                                             
                                          
                                        the sequence O
                                       
                                          R
                                        of hyperedges E
                                       
                                          R
                                       
                                       
                                          N
                                        introduced into K by the rule 
                                          p
                                          ∈
                                          P
                                       .

To distinguish from normal direct derivation, we denote leftmost direct derivation by 
                           
                              
                                 ⇒
                              
                              
                                 l
                              
                           
                        . Next, we define leftmost derivation sequence. 
                           Definition 4.21
                           Leftmost derivation


                           A sequence of leftmost direct derivations 
                                 d
                                 =
                                 
                                    
                                       H
                                    
                                    
                                       0
                                    
                                 
                                 
                                    
                                       ⇒
                                    
                                    
                                       l
                                    
                                 
                                 ⋯
                                 
                                    
                                       ⇒
                                    
                                    
                                       l
                                    
                                 
                                 
                                    
                                       H
                                    
                                    
                                       k
                                    
                                 
                               is called a leftmost derivation of length 
                                 k
                                 ≥
                                 0
                               from H
                              0 to H
                              
                                 k
                               and is denoted by 
                                 
                                    
                                       H
                                    
                                    
                                       0
                                    
                                 
                                 
                                    
                                       
                                          
                                             ⇒
                                          
                                          
                                             l
                                             ⁎
                                          
                                       
                                    
                                    
                                       P
                                    
                                 
                                 
                                    
                                       H
                                    
                                    
                                       k
                                    
                                 
                               or 
                                 
                                    
                                       H
                                    
                                    
                                       0
                                    
                                 
                                 
                                    
                                       ⇒
                                    
                                    
                                       l
                                       ⁎
                                    
                                 
                                 
                                    
                                       H
                                    
                                    
                                       k
                                    
                                 
                              .

For a GBMT execution, we use tree-based representation of such a leftmost derivation (leftmost derivation tree). Source HR grammars, where an input model can have more than one leftmost derivation, could compromise determinism of the developed GBMT through this ambiguity. Thus, we only consider unambiguous HR grammars as source grammars for our development method. 
                           Definition 4.22
                           Unambiguous graph grammar


                           A graph grammar G is unambiguous if for each hypergraph (model) 
                                 M
                                 ∈
                                 L
                                 (
                                 G
                                 )
                               exists exactly one leftmost derivation 
                                 
                                    
                                       S
                                    
                                    
                                       •
                                    
                                 
                                 
                                    
                                       
                                          
                                             ⇒
                                          
                                          
                                             l
                                             ⁎
                                          
                                       
                                    
                                    
                                       P
                                    
                                 
                                 M
                              .

We prepare for the GBMT execution by parsing the input model M
                        
                           s
                         using the given unambiguous source grammar G
                        
                           s
                        . If the parsing process was not successful, then the input model M
                        
                           s
                         is not in the language of G
                        
                           s
                         and there is no leftmost derivation for M
                        
                           s
                         in P
                        
                           s
                        . Then, the process terminates and returns not-applicable for this model, indicating that it is out of scope. This way, we ensure that only models from the language defined by G
                        
                           s
                         are transformed.

When the parsing process is successful, we obtain the leftmost derivation tree 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                           
                         for M
                        
                           s
                        . This tree is related to the non-terminal hyperedge e
                        
                           s
                         of the source start hypergraph 
                           
                              
                                 S
                              
                              
                                 s
                              
                              
                                 •
                              
                           
                        . To make this connection explicit, we add a production 
                           
                              
                                 p
                              
                              
                                 s
                              
                              
                                 ϵ
                              
                           
                        
                        
                           6
                        
                        
                           6
                           
                              ϵ denotes an empty hypergraph.
                         that produces 
                           
                              
                                 S
                              
                              
                                 s
                              
                              
                                 •
                              
                           
                         such that 
                           
                              
                                 p
                              
                              
                                 s
                              
                              
                                 ϵ
                              
                           
                           =
                           (
                           ϵ
                           ,
                           
                              
                                 S
                              
                              
                                 s
                              
                              
                                 •
                              
                           
                           )
                         to the source productions – 
                           
                              
                                 P
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                           =
                           
                              
                                 P
                              
                              
                                 s
                              
                           
                           ∪
                           {
                           
                              
                                 p
                              
                              
                                 s
                              
                              
                                 ϵ
                              
                           
                           }
                        . Then, we build an extended source derivation tree 
                        
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                              
                                 ′
                              
                           
                           =
                           (
                           ϵ
                           ,
                           
                              
                                 S
                              
                              
                                 s
                              
                              
                                 •
                              
                           
                           ,
                           
                              
                                 branch
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                           )
                         such that 
                           
                              
                                 branch
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           =
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                           
                        . This way, e
                        
                           s
                         is explicitly related with 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                           
                         via its branch mapping like all non-terminal hyperedges in the tree (
                           
                              
                                 E
                              
                              
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       N
                                    
                                    
                                       s
                                    
                                 
                              
                           
                        ). This extension allows us to describe the execution of GBMTs in a uniform way, while keeping the original definition of a derivation tree (Definition 4.11).

On the target side, we also extend the target productions P
                        
                           t
                         with an analogous 
                           
                              
                                 p
                              
                              
                                 t
                              
                              
                                 ϵ
                              
                           
                         production creating 
                           
                              
                                 P
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                         and build an initial extended target derivation tree 
                        
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                           =
                           (
                           ϵ
                           ,
                           
                              
                                 S
                              
                              
                                 t
                              
                              
                                 •
                              
                           
                           ,
                           ∅
                           )
                        , that produces a target start graph 
                           
                              
                                 S
                              
                              
                                 t
                              
                              
                                 •
                              
                           
                         with a hyperedge e
                        
                           t
                        .

Finally, we create an initial correspondence mapping c
                        
                           d
                        , as we have previously discussed, connecting hyperedges e
                        
                           s
                         and e
                        
                           t
                         of the start hypergraphs – 
                           
                              
                                 c
                              
                              
                                 d
                              
                           
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 c
                              
                              
                                 default
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           )
                        . This correspondence together with derivation trees 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                              
                                 ′
                              
                           
                         and 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                         forms the initial state of the tree correspondence structure (TCS) that our GBMTs operate on. With each rule application, a GBMT creates new sub-tree(s) in the extended target derivation tree and adds correspondence mappings between non-terminal hyperedges of the derivation trees to the TCS structure. 
                           Definition 4.23
                           Tree correspondence structure


                           A tree correspondence structure (TCS) 
                              
                                 tcs
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 =
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 C
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 )
                               created during an execution of a GBMT T on an input model M
                              
                                 s
                              
                              
                                 7
                              
                              
                                 7
                                 To simplify, we shorten ‘execution on leftmost derivation of M
                                    
                                       s
                                    ’ to ‘execution on M
                                    
                                       s
                                    ’.
                               consists of an extended source derivation tree 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 ∈
                                 TREE
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       s
                                    
                                    
                                       ′
                                    
                                 
                                 )
                               for M
                              
                                 s
                              , an extended target derivation tree 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 ∈
                                 TREE
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       t
                                    
                                    
                                       ′
                                    
                                 
                                 )
                               for the generated output target model M
                              
                                 t
                              , and a set of correspondence mappings 
                                 C
                                 ⊆
                                 
                                    
                                       (
                                       
                                          
                                             E
                                          
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                          
                                             
                                                
                                                   N
                                                
                                                
                                                   t
                                                
                                             
                                          
                                       
                                       ×
                                       (
                                       CT
                                       ×
                                       
                                          
                                             E
                                          
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                          
                                             
                                                
                                                   N
                                                
                                                
                                                   s
                                                
                                             
                                          
                                       
                                       )
                                       )
                                    
                                    
                                       ⁎
                                    
                                 
                               between non-terminal hyperedges of 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                               and 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                              .

To apply GBMT rules, we traverse the 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                              
                                 ′
                              
                           
                         part of 
                           TCS
                           (
                           
                              
                                 M
                              
                              
                                 s
                              
                           
                           )
                         to find the next non-terminal hyperedge e
                        
                           s
                         that is in one or more correspondence mapping(s) 
                           c
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           )
                           ∈
                           C
                         with some hyperedges e
                        
                           t
                         from 
                           
                              
                                 E
                              
                              
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                              
                              
                                 
                                    
                                       N
                                    
                                    
                                       t
                                    
                                 
                              
                           
                        . Next, we consider each of these correspondence mappings c separately, and find a set of GBMT rules 
                           
                              
                                 RS
                              
                              
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                              
                           
                         such that correspondence type pre-condition c
                        
                           pre
                         is equal to the type of c and p
                        
                           s
                         is the first production in the sub-tree assigned to e
                        
                           s
                         through 
                           
                              
                                 branch
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                        . Finally, we select a rule tr with the highest priority from the set 
                           
                              
                                 RS
                              
                              
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 ,
                                 
                                    
                                       c
                                    
                                    
                                       pre
                                    
                                 
                              
                           
                         such that its t
                        
                           s
                         forms a prefix of (or equal to) the sub-tree assigned to e
                        
                           s
                         in 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                              
                                 ′
                              
                           
                         via 
                           
                              
                                 branch
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                        . This rule is said to be applicable to the combination of a hyperedge e
                        
                           s
                         (and its sub-tree in 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                              
                              
                                 ′
                              
                           
                        ) and a correspondence mapping c in 
                           C
                        . Formally, the rule applicability for GBMT rules is defined as follows. 
                           Definition 4.24
                           GBMT rule applicability


                           A GBMT
                                 8
                              
                              
                                 8
                                 From now on, for brevity, we refer to a (non-local) extended GBMT simply as a GBMT.
                               rule tr is applicable in TCS 
                                 
                                    
                                       tcs
                                    
                                    
                                       T
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 =
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 C
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 )
                               to a combination of a hyperedge e
                              
                                 s
                               such that 
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                 
                                 ∈
                                 
                                    
                                       E
                                    
                                    
                                       
                                          
                                             t
                                          
                                          
                                             
                                                
                                                   M
                                                
                                                
                                                   s
                                                
                                             
                                          
                                          
                                             ′
                                          
                                       
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                               and a correspondence mapping 
                                 c
                                 ∈
                                 C
                               such that 
                                 c
                                 =
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       t
                                    
                                 
                                 ,
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       ts
                                    
                                 
                                 ,
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                 
                                 )
                                 )
                              , if its c
                              
                                 pre
                               is the type of c (Definition 4.9) and its t
                              
                                 s
                               forms a prefix of (or equal to) the sub-tree assigned to e
                              
                                 s
                               via the mapping 
                                 
                                    
                                       branch
                                    
                                    
                                       s
                                    
                                    
                                       ′
                                    
                                 
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                 
                                 )
                               in 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             s
                                          
                                       
                                    
                                    
                                       ′
                                    
                                 
                              . If tr is non-local, there exists a correspondence mapping 
                                 
                                    
                                       c
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       t
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       ts
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       e
                                    
                                    
                                       s
                                    
                                    
                                       a
                                    
                                 
                                 )
                                 )
                                 ∈
                                 C
                               of type c
                              
                                 a
                              
                              
                                 pre
                               with either
                                 
                                    (a)
                                    
                                       
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                a
                                             
                                          
                                          )
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                t
                                             
                                          
                                        or

for all 
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      
                                                         
                                                            branch
                                                         
                                                         
                                                            t
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            e
                                                         
                                                         
                                                            t
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                          :
                                          {
                                          
                                             
                                                c
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                ts
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          )
                                          ∈
                                          
                                             
                                                C
                                             
                                             
                                                
                                                   
                                                      tcs
                                                   
                                                   
                                                      T
                                                   
                                                
                                                (
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                                )
                                             
                                          
                                          |
                                          
                                             
                                                c
                                             
                                             
                                                ′
                                             
                                          
                                        of type c
                                       
                                          a
                                       
                                       
                                          pre
                                       
                                       
                                          }
                                          =
                                          ∅
                                       .

An application of a GBMT rule tr is then performed by assigning its t
                        
                           t
                         via 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                         mapping of 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                         to the hyperedge e
                        
                           t
                         of the correspondence mapping c. This creates a new sub-tree at 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           )
                           =
                           
                              
                                 t
                              
                              
                                 t
                              
                           
                         in the extended tree 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                        . Additionally, all correspondence mappings defined in tr by its function C
                        
                           post
                         are created between the corresponding hyperedges of the newly added 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           )
                         and the hyperedges of the sub-tree 
                           
                              
                                 branch
                              
                              
                                 s
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                         which are at the same positions as hyperedges in t
                        
                           s
                         used in C
                        
                           post
                        . If tr is non-local, an additional sub-tree t
                        
                           a
                        
                        
                           t
                         is also added at e
                        
                           a
                        
                        
                           t
                         of the additional correspondence mapping c
                        
                           a
                         via 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                        . Depending on the case from Definition 4.24: e
                        
                           a
                        
                        
                           t
                         is either directly mapped to t
                        
                           a
                        
                        
                           t
                         via 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                         (a), or the already existing 
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 a
                              
                           
                           )
                         sub-tree is restructured to add t
                        
                           a
                        
                        
                           t
                         (b). Both alternatives are described in detail below. A GBMT terminates when all combinations of a hyperedge from 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       S
                                    
                                 
                              
                              
                                 ′
                              
                           
                         and a correspondence mapping 
                           c
                           ∈
                           C
                         involving it, in the created TCS, has been considered.

The correspondence mappings for each non-terminal hyperedge e
                        
                           s
                         are considered in a specific order, defined based on orderings of individual elements in the containing hypergraphs. A mapping 
                           c
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           )
                           ∈
                           C
                         is placed before 
                        
                           
                              
                                 c
                              
                              
                                 ′
                              
                           
                           =
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           ,
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                              
                                 ′
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 s
                              
                           
                           )
                           )
                           ∈
                           C
                         in the correspondence ordering relation O
                        
                           c
                         – 
                           
                              
                                 O
                              
                              
                                 c
                              
                           
                           (
                           c
                           )
                           <
                           
                              
                                 O
                              
                              
                                 c
                              
                           
                           (
                           
                              
                                 c
                              
                              
                                 ′
                              
                           
                           )
                         – when 
                           O
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           )
                           <
                           O
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           )
                        , or when 
                           O
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                           
                           )
                           =
                           O
                           (
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           )
                         and 
                           
                              
                                 O
                              
                              
                                 t
                              
                           
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                           
                           )
                           <
                           
                              
                                 O
                              
                              
                                 t
                              
                           
                           (
                           
                              
                                 t
                              
                              
                                 ts
                              
                              
                                 ′
                              
                           
                           )
                        . Here, the ordering 
                           O
                         of e
                        
                           t
                         and 
                           
                              
                                 e
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                         is defined based on the ordering 
                           O
                         transferred from productions to 
                           result
                           (
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                           )
                         in 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                              
                                 ′
                              
                           
                        , created up-to this point, and the ordering O
                        
                           t
                         of 
                           
                              
                                 t
                              
                              
                                 c
                              
                           
                           ∈
                           CT
                         is an arbitrary fixed ordering on CT of T. Formally, the complete GBMT execution process is defined as follows. 
                           Definition 4.25
                           GBMT execution


                           An execution of a GBMT T between 
                                 L
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       s
                                    
                                 
                                 )
                               and 
                                 L
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       t
                                    
                                 
                                 )
                               on a finite input model 
                                 
                                    
                                       M
                                    
                                    
                                       s
                                    
                                 
                                 ∈
                                 L
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       s
                                    
                                 
                                 )
                               that produces a target derivation tree 
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                               and an output model 
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 result
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             M
                                          
                                          
                                             t
                                          
                                       
                                    
                                 
                                 )
                                 ∈
                                 L
                                 (
                                 
                                    
                                       G
                                    
                                    
                                       t
                                    
                                 
                                 )
                               consists of
                                 
                                    1.
                                    Extend 
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                        to 
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          (
                                          ϵ
                                          ,
                                          
                                             
                                                S
                                             
                                             
                                                s
                                             
                                             
                                                •
                                             
                                          
                                          ,
                                          
                                             
                                                branch
                                             
                                             
                                                s
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∈
                                          TREE
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                s
                                             
                                          
                                          ∪
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                s
                                             
                                             
                                                ϵ
                                             
                                          
                                          =
                                          (
                                          ϵ
                                          ,
                                          
                                             
                                                S
                                             
                                             
                                                s
                                             
                                             
                                                •
                                             
                                          
                                          )
                                          }
                                          )
                                        with 
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                d
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      s
                                                   
                                                   
                                                      •
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                        and 
                                          
                                             
                                                branch
                                             
                                             
                                                s
                                             
                                             
                                                ′
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                       . Set 
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          (
                                          ϵ
                                          ,
                                          
                                             
                                                S
                                             
                                             
                                                t
                                             
                                             
                                                •
                                             
                                          
                                          ,
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∈
                                          TREE
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                t
                                             
                                          
                                          ∪
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                t
                                             
                                             
                                                ϵ
                                             
                                          
                                          =
                                          (
                                          ϵ
                                          ,
                                          
                                             
                                                S
                                             
                                             
                                                t
                                             
                                             
                                                •
                                             
                                          
                                          )
                                          }
                                          )
                                        with 
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      t
                                                   
                                                   
                                                      •
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                        and 
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          =
                                          lab
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          )
                                       , and initialize 
                                          C
                                          =
                                          {
                                          
                                             
                                                c
                                             
                                             
                                                d
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                t
                                             
                                             
                                                d
                                             
                                          
                                          ,
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                c
                                             
                                             
                                                default
                                             
                                          
                                          ,
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          )
                                          }
                                        with 
                                          
                                             
                                                t
                                             
                                             
                                                c
                                             
                                             
                                                default
                                             
                                          
                                          ∈
                                          CT
                                       .

Construct TCS of T such that 
                                          
                                             
                                                tcs
                                             
                                             
                                                T
                                             
                                          
                                          (
                                          
                                             
                                                M
                                             
                                             
                                                s
                                             
                                          
                                          )
                                          =
                                          (
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          C
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                       .

Traverse 
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                       , visiting its non-terminal hyperedges 
                                          
                                             
                                                e
                                             
                                             
                                                s
                                             
                                          
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      
                                                         
                                                            M
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                       :
                                          
                                             (a)
                                             Consider all correspondence mappings 
                                                   c
                                                   =
                                                   (
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   ,
                                                   (
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         ts
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   )
                                                   )
                                                 in 
                                                   C
                                                 for e
                                                
                                                   s
                                                 in the ordering O
                                                
                                                   c
                                                . Find a rule 
                                                   tr
                                                   ∈
                                                   T
                                                 applicable (Definition 4.24) to a e
                                                
                                                   s
                                                ,c combination. If tr is non-local (Definition 4.17), find a correspondence mapping 
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                   =
                                                   (
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         t
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                   ,
                                                   (
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         ts
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         s
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                   )
                                                   )
                                                 in 
                                                   C
                                                 of type c
                                                
                                                   a
                                                
                                                
                                                   pre
                                                 fulfilling a or b of Definition 4.24. When tr and, if applicable, c
                                                
                                                   a
                                                 were found:

Apply tr:
                                                   
                                                      (i)
                                                      Assign 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                            )
                                                            =
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                          in 
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  
                                                                     
                                                                        M
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                         .

For each correspondence mapping 
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            =
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            (
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  ts
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            )
                                                            )
                                                          in C
                                                         
                                                            post
                                                         : 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                            
                                                         , add a correspondence mapping 
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            =
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            (
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  ts
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                                  p
                                                               
                                                            
                                                            )
                                                            )
                                                          to 
                                                            C
                                                            =
                                                            C
                                                            ∪
                                                            {
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            }
                                                          with 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        branch
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  (
                                                                  
                                                                     
                                                                        e
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                            
                                                          added to 
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  
                                                                     
                                                                        M
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                          within the sub-tree t
                                                         
                                                            t
                                                          in step i, and hyperedge 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        
                                                                           
                                                                              M
                                                                           
                                                                           
                                                                              s
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        s
                                                                     
                                                                  
                                                               
                                                            
                                                          is at the same position in 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                            
                                                            )
                                                          as e
                                                         
                                                            p
                                                         
                                                         
                                                            s
                                                          in the t
                                                         
                                                            s
                                                          of rule tr.

If tr is non-local
                                                   
                                                      (i)
                                                      If 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                            )
                                                            ∉
                                                            
                                                               
                                                                  N
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                          (b), find 
                                                            e
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        a
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                            
                                                          with a hyperedge identity mapping to 
                                                            root
                                                            (
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                            )
                                                         , and assign 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                            (
                                                            e
                                                            )
                                                            =
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                            )
                                                          in t
                                                         
                                                            a
                                                         
                                                         
                                                            t
                                                         .

Assign 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                            )
                                                            =
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                         .

For each correspondence mapping 
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            =
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            (
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  ts
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            )
                                                            )
                                                          in C
                                                         
                                                            post
                                                         : 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        a
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                            
                                                          add a correspondence mapping 
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            =
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            (
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  ts
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ,
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                                  p
                                                               
                                                            
                                                            )
                                                            )
                                                          to 
                                                            C
                                                            =
                                                            C
                                                            ∪
                                                            {
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  p
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            }
                                                          where 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  t
                                                               
                                                               
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        branch
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  (
                                                                  
                                                                     
                                                                        e
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        a
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                            
                                                          added to 
                                                            
                                                               
                                                                  t
                                                               
                                                               
                                                                  
                                                                     
                                                                        M
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                          within the sub-tree t
                                                         
                                                            a
                                                         
                                                         
                                                            t
                                                          in step ii, and hyperedge 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                                  p
                                                               
                                                            
                                                            ∈
                                                            
                                                               
                                                                  E
                                                               
                                                               
                                                                  
                                                                     
                                                                        t
                                                                     
                                                                     
                                                                        
                                                                           
                                                                              M
                                                                           
                                                                           
                                                                              s
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        N
                                                                     
                                                                     
                                                                        s
                                                                     
                                                                  
                                                               
                                                            
                                                          is at the same position in 
                                                            
                                                               
                                                                  branch
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                               
                                                            
                                                            (
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                            
                                                            )
                                                          as e
                                                         
                                                            p
                                                         
                                                         
                                                            s
                                                          in the t
                                                         
                                                            s
                                                          of rule tr or 
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  ′
                                                                  p
                                                               
                                                            
                                                            =
                                                            
                                                               
                                                                  e
                                                               
                                                               
                                                                  s
                                                               
                                                               
                                                                  a
                                                               
                                                            
                                                         .

When all e
                                       
                                          s
                                        are visited, return 
                                          
                                             
                                                branch
                                             
                                             
                                                t
                                             
                                             
                                                ′
                                             
                                          
                                          (
                                          e
                                          )
                                        of 
                                          
                                             
                                                t
                                             
                                             
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                             
                                                ′
                                             
                                          
                                        where 
                                          e
                                          ∈
                                          
                                             
                                                E
                                             
                                             
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      t
                                                   
                                                   
                                                      •
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                       .

The returned target derivation tree 
                           
                              
                                 t
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                              
                           
                           =
                           
                              
                                 branch
                              
                              
                                 t
                              
                              
                                 ′
                              
                           
                           (
                           e
                           )
                         contains the sought target model M
                        
                           t
                         (also referred to as 
                           T
                           (
                           
                              
                                 M
                              
                              
                                 s
                              
                           
                           )
                        ), that can be extracted as a final output through a simple flattening of the derivation tree. Next, we consider quality properties of GBMTs based on the above formalizations.

Our grammar-based method for building model transformations exhibits some important properties. A GBMT T, defined using our approach and fulfilling the criteria formalized in Section 4, is by construction: terminating, sound, complete, and deterministic. For the last property, we require an unambiguous (Definition 2.3) source grammar G
                     
                        s
                     . Next, we give definitions and proof sketches for these properties and emphasize the sufficient conditions to guarantee them. 
                        Definition 5.1
                        Termination


                        A GBMT T terminates iff any of its executions on any input model M
                           
                              s
                            is performed in a finite number of finite steps.

Based on this definition and the formalization of GBMTs, provided in Section 4, we formulate the following Theorem and give a proof sketch for it. 
                        Theorem 5.1
                        
                           Let T be a GBMT. Then, for all input models 
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                            
                           execution of T on M
                           
                              s
                            
                           by 
                           
                              Definition 4.25 
                           is done in a finite number of finite steps.

As described before, T is executed on the leftmost derivation tree 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                      of M
                     
                        s
                     . We traverse this tree in a pre-defined order and visit each non-terminal hyperedge that has correspondences, including the initial one (see Section 3.1). A finite number of productions (finite target derivation sub-trees) of G
                     
                        t
                      is applied by T for every finite derivation sub-tree formed by productions of G
                     
                        s
                      in 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                      and a correspondence c of the hyperedge mapped onto it. Since these derivation sub-trees are finite, and the set of created correspondences and 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                      are finite, the whole execution process is guaranteed to have a finite number of finite steps.

To consider soundness and completeness properties, we first need to define the notions of valid input and valid output models in the GBMT context. 
                        Definition 5.2
                        Valid input model


                        A model M
                           
                              s
                            is a valid input model for a GBMT T if it belongs to the language defined by G
                           
                              s
                            of T – 
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                           .

A model M
                           
                              t
                            is a valid output model for a GBMT T if it belongs to the language defined by G
                           
                              t
                            of T – 
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    t
                                 
                              
                              )
                           .

We also explicitly define when a GBMT can transform an input model as follows. 
                        Definition 5.4
                        Transformable


                        A GBMT T can transform an input model M
                           
                              s
                            (M
                           
                              s
                            
                           is transformable by T), when none of the execution steps of T (see Definition 4.25) fail on M
                           
                              s
                           .

A GBMT T is complete if it can transform any valid input model 
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                           .


                           Let T be a GBMT that, if non-local, fulfills the ACCC (
                              Definition 4.19). Then, T is complete (
                              Definition 5.5).

Thus, for completeness, we have to show that if 
                        
                           
                              M
                           
                           
                              s
                           
                        
                        ∈
                        L
                        (
                        
                           
                              G
                           
                           
                              s
                           
                        
                        )
                     , 
                        T
                        (
                        
                           
                              M
                           
                           
                              s
                           
                        
                        )
                      does not fail. In Section 4.1, we have demanded that T contains a GBMT rule (set) for every production in G
                     
                        s
                      and every correspondence type a hyperedge rewritten by it might have. The ACCC ensures applicability in the case when such rules are non-local. Hence, we can transform every production application (direct derivation) in 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                      into a derivation sub-tree application in the target tree 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                     .

Next, we look at the derivation of the target model M
                     
                        t
                      via 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                     . We need to show that this derivation does not fail, i.e., that all target productions are applicable at the place where T wants to apply them. Both G
                     
                        s
                      and G
                     
                        t
                      are context-free, so the existence of the non-terminal hyperedges ensured by the correspondences is all that is needed to ensure applicability of the target productions. When considering the next source production application, we apply the related target productions to the non-terminal hyperedge corresponding to the hyperedge rewritten by the first source production. Therefore, since the source productions are applicable and T contains applicable (with ACCC also non-local) GBMT rules for every type of correspondence that a non-terminal hyperedge rewritten by it might have, the target productions are applicable too. Thus, T always returns a model for a valid M
                     
                        s
                      and is complete. 
                        Definition 5.6
                        Soundness


                        A GBMT T is sound if its result 
                              T
                              (
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              )
                            on a valid input model M
                           
                              s
                            is a valid output model.


                           Let T be a GBMT that, if non-local, fulfills the ACCC (Definition 
                           4.19), and 
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                            
                           an input source model. Then, an execution of T on M
                           
                              s
                            
                           returns a target tree 
                           
                              
                                 
                                    t
                                 
                                 
                                    
                                       
                                          M
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                              ∈
                              TREE
                              (
                              
                                 
                                    P
                                 
                                 
                                    t
                                 
                              
                              )
                            
                           and a model 
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                              =
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    
                                       
                                          M
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                              )
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    t
                                 
                              
                              )
                           .

Thus, we need to show that 
                        
                           
                              M
                           
                           
                              t
                           
                        
                        ∈
                        L
                        (
                        
                           
                              G
                           
                           
                              t
                           
                        
                        )
                     . This can be reduced to the question whether the target tree 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                      is complete, meaning that no non-rewritten non-terminal hyperedges are left after the application of T. From Definition 4.8 of a GBMT rule, every non-terminal hyperedge produced (and not consumed) by target sub-tree(s) is linked by a correspondence to a non-terminal hyperedge in 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                     . And since 
                        
                           
                              M
                           
                           
                              s
                           
                        
                        ∈
                        L
                        (
                        
                           
                              G
                           
                           
                              s
                           
                        
                        )
                     , all source non-terminal hyperedges produced are eventually rewritten. This implies that all leaf target non-terminal hyperedges produced are also eventually rewritten, since T is complete, by the related target productions, i.e., 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                      is complete. Thus, we have 
                        
                           
                              M
                           
                           
                              t
                           
                        
                        ∈
                        L
                        (
                        
                           
                              G
                           
                           
                              t
                           
                        
                        )
                      and T is sound. 
                        Definition 5.7
                        Determinism


                        A GBMT T is deterministic if its result 
                              T
                              (
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              )
                            on a valid input model 
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                            is the same in each execution.


                           Let T be a GBMT that has an unambiguous G
                           
                              s
                            
                           and, if non-local, fulfills the ACCC (
                              Definition 4.19). Then, for an input source model 
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              ∈
                              L
                              (
                              
                                 
                                    G
                                 
                                 
                                    s
                                 
                              
                              )
                           , each execution of T on M
                           
                              s
                            
                           returns the same result 
                           
                              T
                              (
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                              )
                           .

When the source grammar G
                     
                        s
                      
                     is unambiguous, then we always obtain the same leftmost derivation tree 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                     . Based on T, 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                      fully determines which rules are applied to construct the target tree 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                      (target sub-trees), and where (correspondences). This is because each production in 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                      is uniquely determined by the productions in 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    s
                                 
                              
                           
                        
                     , the correspondence of the source non-terminal hyperedge they rewrite, and the suitable additional correspondence (non-local rules, unique by ACCC). The target side of these correspondences uniquely determines where the related main and additional target productions of the chosen GBMT rule are applied. We, thus, obtain exactly one 
                        
                           
                              t
                           
                           
                              
                                 
                                    M
                                 
                                 
                                    t
                                 
                              
                           
                        
                      and exactly one target model M
                     
                        t
                     . Hence, no two different models can be the result of T for a single M
                     
                        s
                     .

We have defined all rule types used in our example GBMT transformation in Section 3. All that is left is to ensure that its rules fulfill the conditions stated above. We start with the basic GBMT rules and discuss in detail why one example rule of this type is conform with the respective definitions and conditions.

We consider the basic rule 9 shown in Fig. 8. It has to comply with Definition 4.8 – it has to consist of a source and a target HR production, a correspondence type pre-condition relation between their left-hand sides, and a correspondence function with certain properties. Our example rule 5 contains all of the four parts. We just need to ensure that its correspondence function has the desired properties and maps each non-terminal hyperedge of the right-hand side of the target production onto a pair of a correspondence type and a non-terminal hyperedge of the right-hand side of the source production. This last requirement is met by this rule – it maps both produced non-terminal hyperedges of type PE onto the non-terminal hyperedges of type B and a correspondence type C. Since the left-hand sides of the productions in rule 5 are not start symbols of the source and target HR grammars, the first condition of Definition 4.8 is fulfilled. Finally, the correspondence function defined in rule 5 is a total function, since it relates each target hyperedge of type PE to a correspondence type C and a hyperedge of type B, and none of them are mapped onto more than one such pair. Thus, GBMT rule 5 complies with Definition 4.8. For all other basic rules of example GBMT the compliance with Definition 4.8 can be shown in the same way.

Now, we consider the extended rule 8 of the example GBMT that is shown in Fig. 11. This rule has to comply with Definition 4.12 – it has to consist of two finite production based sub-trees (
                        ∉
                        N
                     ), one in the source and one in the target HR grammar, a correspondence type pre-condition relation between their roots, and a correspondence function with certain properties inherited from Definition 4.8. Our rule 8 contains all four parts (the function is not visualized). The correspondence function has to map each non-terminal leaf hyperedge of the target derivation sub-tree (
                        
                           
                              E
                           
                           
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    t
                                 
                              
                              )
                           
                           
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        
                     ) onto a pair of a correspondence type and a non-terminal leaf hyperedge of the source derivation sub-tree (
                        
                           
                              E
                           
                           
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    s
                                 
                              
                              )
                           
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                           
                        
                     ). This requirement is met by rule 8, since both of these sets are empty.

The roots of the related sub-trees in rule 8 are not the start symbols of the HR grammars. Thus, the first condition of Definition 4.8 on the correspondence function is fulfilled. Furthermore, the correspondence function defined in rule 8 is trivially total. Thus, the extended GBMT rule 8 complies with Definition 4.12.

Finally, we consider the example non-local GBMT rule 9 shown in Fig. 12. This rule has to comply with Definition 4.17 – like an extended GBMT rule, it has to consist of two finite derivation production based sub-trees (
                        ∉
                        N
                     ) and a correspondence type pre-condition relation between their roots. It also has to have an additional correspondence type pre-condition, an additional finite production based target derivation sub-tree (
                        ∉
                        N
                     ), and an extended correspondence function with certain properties, those inherited from Definition 4.12 and new ones.

Our non-local GBMT rule 9 contains the following six parts: a finite production based source sub-tree for a loop with a body represented by a block hyperedge of type B, a finite production based target sub-tree for a process L(c), a correspondence type C pre-condition relation B-to-PE between their roots, an additional correspondence type C pre-condition relation M-to-M linked to the root of an additional finite production based target sub-tree for a recursive process L(x), and a correspondence function that relates the leaf hyperedge of type PE of the additional target sub-tree to the leaf hyperedge of type B of the source sub-tree. We need to ensure that this correspondence function maps each non-terminal leaf hyperedge of both target derivation sub-trees (
                        
                           
                              E
                           
                           
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    t
                                 
                              
                              )
                           
                           
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        
                        ∪
                        
                           
                              E
                           
                           
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    t
                                 
                                 
                                    a
                                 
                              
                              )
                           
                           
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        
                     ) onto a pair of a correspondence type and a non-terminal leaf hyperedge of the source derivation sub-tree (
                        
                           
                              E
                           
                           
                              result
                              (
                              
                                 
                                    t
                                 
                                 
                                    s
                                 
                              
                              )
                           
                           
                              
                                 
                                    N
                                 
                                 
                                    s
                                 
                              
                           
                        
                     ) or the hyperedge (e
                     
                        a
                     
                     
                        s
                     ) of the handle (
                        
                           
                              A
                           
                           
                              s
                           
                           
                              a
                              •
                           
                        
                     ), induced by the source non-terminal (
                        
                           
                              A
                           
                           
                              s
                           
                           
                              a
                           
                        
                     ) of the additional correspondence type pre-condition.

This last mapping requirement is met by rule 9 – it maps the leaf non-terminal hyperedge of type PE of the additional target sub-tree onto the leaf non-terminal hyperedge of type B and a correspondence type C. It maps the leaf non-terminal hyperedge of type M with the identity mapping from the same sub-tree onto the hyperedge (e
                     
                        a
                     
                     
                        s
                     ) of the handle graph (
                        
                           
                              M
                           
                           
                              •
                           
                        
                     ), induced by the source non-terminal M and a correspondence type C, and none of these leafs is mapped onto more than one such pair. Thus, the correspondence function of rule 9 is total. Furthermore, the roots of the main sub-trees in rule 9 are not the start symbols of the involved HR grammars and, thus, the first condition on the correspondence function inherited from Definition 4.8 is fulfilled.

As for the additional conditions stated in Definition 4.17, the main correspondence type pre-condition B-to-PEof type C is different from the additional M-to-M of one type C, and there is only one mapping of the leaf hyperedge of type M of the additional target sub-tree with the type described in condition 2 of Definition 4.17. Thus, the non-local GBMT rule 9 complies with Definition 4.17.

Additionally to the individual GBMT rule types, we have also formalized the definitions of GBMTs containing them. Now, we need to show that our example GBMT is conform with these definitions. Since the definitions are nested and the basic and extended rules are special cases of non-local rules, we can consider Definition 4.18 for GBMTs with non-local rules directly.


                     Definition 4.18 describes a GBMT as a finite set of extended and non-local rules that fulfills conditions 1 and 2. Our GBMT fulfills condition 1, since its non-local rule 9 (tr) uses the additional correspondence type pre-condition M-to-M of type C (c
                     
                        a
                     
                     
                        pre
                     ), that is first created by the basic rule 1 (
                        
                           
                              tr
                           
                           
                              ′
                           
                        
                      with 
                        
                           
                              c
                           
                           
                              pre
                           
                           
                              ′
                           
                        
                        ≠
                        
                           
                              c
                           
                           
                              pre
                           
                           
                              a
                           
                        
                      and 
                        
                           
                              c
                           
                           
                              ′
                           
                        
                        ∈
                        
                           
                              C
                           
                           
                              post
                           
                           
                              ′
                           
                        
                      of type c
                     
                        a
                     
                     
                        pre
                     ) of the GBMT. It also fulfills condition 2, since there is no rule (
                        
                           
                              tr
                           
                           
                              ′
                           
                        
                     ) in our GBMT that produces two or more correspondence mappings of type M-to-M with the type C (no distinct 
                        
                           
                              c
                           
                           
                              1
                           
                           
                              ′
                           
                        
                        ,
                        
                           
                              c
                           
                           
                              2
                           
                           
                              ′
                           
                        
                        ∈
                        
                           
                              C
                           
                           
                              post
                           
                           
                              ′
                           
                        
                      of type c
                     
                        a
                     
                     
                        pre
                     ).

Now we need to consider the conditions of Definition 4.16 for extended GBMTs, that our GBMT also has to fulfill by Definition 4.18. Definition 4.16 states two conditions on a GBMT. Our GBMT fulfills its condition 1, since all its rules have the same priority, and their source sub-trees are distinct and none of them is a prefix of the other. Its condition 2 is more complex and requires detailed consideration.

This condition requires our GBMT to contain exactly one well-formed rule set (
                        
                           
                              RS
                           
                           
                              
                                 
                                    p
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                                 
                                    c
                                 
                                 
                                    pre
                                 
                              
                           
                        
                     ) for each combination of a source production (
                        
                           
                              p
                           
                           
                              s
                           
                        
                        =
                        (
                        
                           
                              A
                           
                           
                              s
                           
                        
                        ,
                        
                           
                              R
                           
                           
                              s
                           
                        
                        )
                     ) and a type of correspondence mapping (c
                     
                        pre
                     ), that a hyperedge of the type of its left-hand side (A
                     
                        s
                     ) has in that GBMT. Since the rules of our GBMT only have simple source sub-trees with one production, by Definition 4.15, such rule sets in our example only contain single and, thus, special rules. We do not have to consider any replacement alternatives and just need to show that there is exactly one special rule for each combination (p
                     
                        s
                     , c
                     
                        pre
                     ) in this GBMT.

In our GBMT there are the following types of correspondence mappings: the initial mapping type S-to-S with the correspondence type C
                     
                        d
                     , and the mapping types M-to-M, A-to-P, and B-to-PE all with the correspondence type C. There is exactly one rule for each combination of these types with each source production applicable to its source non-terminal (see Section 3). Thus, our GBMT fulfills condition 2 of Definition 4.16. Since the basic GBMT rule type is a special case of the extended one, we have shown all the conditions required by Definition 4.18.

Now, to guarantee the above properties for our example GBTM, we just need to show the ACCC condition (Definition 4.19) for it. The non-local rule of our example uses an M-to-M correspondence as an additional correspondence type pre-condition (see e.g. Fig. 12). A correspondence of this type is created the first time by rule 1 (see Fig. 9), that fulfills condition 1 of Definition 4.18. This rule 
                        
                           
                              tr
                           
                           
                              ′
                           
                        
                      is a basic GBMT rule with a correspondence type pre-condition S-to-S different from M-to-M (
                        
                           
                              c
                           
                           
                              pre
                           
                           
                              ′
                           
                        
                        ≠
                        
                           
                              c
                           
                           
                              pre
                           
                           
                              a
                           
                        
                     ), and it creates a correspondence mapping of type M-to-M (
                        
                           
                              c
                           
                           
                              ′
                           
                        
                        ∈
                        
                           
                              C
                           
                           
                              post
                           
                           
                              ′
                           
                        
                      of type c
                     
                        a
                     
                     
                        pre
                     ).

We need to show that rule 1 is (1) the only such rule, that is (2) always applied exactly once and (3) before the non-local GBMT rule, during an execution of the GBMT on an source model. Point 1 is always true, since this is the only rule in our GBMT that fulfills condition 1 of Definition 4.18. Point 2 is also true, since this rule is defined for the source production S ≔M, that consumes a hyperedge that is never re-created by any other production. Thus, this rule can only be applied once and it is always applied, since each source model is derived using this production from the start graph and its hyperedge always has the correspondence mapping of type S-to-S. Finally, point 3 is also true, since this rule is applied before any other rule of this GBMT can become applicable.

To support the approach we have designed a tool chain involving existing state-of-the-art tools: the graph grammar parser of the AGG [17] framework and the EMorF [18] transformation engine. The chain requires source and target grammars modeled as instances of our HR grammar meta-model extended with grammar-specific non-terminal and terminal type classes. All meta-models are specified in the ECore meta-modeling language of the Eclipse Modelling Framework 
                     [19]. The specified source and target grammars are used as input of our Eclipse based Grammar-Based Model Transformation Framework that allows the definition of GBMT rules and validates their compliance with the conditions from Section 3. The framework makes use of existing transformation languages and engines like TGGs [16] and the EMorF engine by translating the created transformation into its declarative, language (and engine) specific implementation operating on trees. Other combinations of languages and engines like ATL [20] with its engine can also be used. Fig. 13
                      shows the described tool chain with the artifacts used for the case when TGGs and the TGG engine (here EMorF) are chosen as the target execution platform for the developed transformation.

To evaluate our approach, we compare it on our running example with the most common transformation development practices in MDE, where meta-models are used in combination with declarative, imperative, and hybrid transformation languages. Meta-models may contain additional classes (e.g., StructuralActivityNode in UML [4]) to group (other) classes.

When a source meta-model does not include such structural classes, then the transformations that require this structural information defined on it have to use imperative constructs. Often they are also combined with recursion. In our example, such constructs are required to locate the related decision and merge activity nodes to build the corresponding sequence of processes in CSP. 
                        Listing 1
                        ATL code fragment: decision/merge block to if-then-else process sequence. 
                              
                           
                        


                     Listing 1 shows an implementation of this transformation step in the widely used general-purpose hybrid model transformation language ATL [20], which relies on meta-model based language definition. We use the meta-models from Section 2.1 to define the source and target languages of the ATL transformation. We use an ATL matching rule to transform a decision node d to an if-then-else process expression pe (rule Decision2IfThenElse). But to link the target expression pe to the next process expression, which should be the result of transforming the merge node corresponding to the decision node d, we have to use recursion to find that merge node. For this purpose, we implement a recursive search helper findMrg that follows the path starting in d and skips intermediate decision/merge pairs until it finds the right merge node.

To use this recursive search in ATL, we have to assume well-formedness of activity diagrams, ensured by extra OCL constraints. Such OCL constraints are not always defined and, if they are, they contain recursion and considerably complicate the complete meta-model based language definition. Furthermore, the need for imperative constructs forbids the use of declarative languages and significantly complicates readability and analysis of the transformations. In fact, most techniques aiming to guarantee transformation quality [21,22] only consider declarative rules and are not applicable here.

Another solution to build structure-based transformations is to use transformation rules to create the required structures in a suitably defined (by meta-model containing structural classes) correspondence model as done in [23] using TGGs. As the previous imperative solution, the correspondence-based solution does not guarantee quality of the developed transformations, and it complicates their understandability and analysis. Furthermore, in both solutions we have to explicitly connect the results of the individual rules to the rest of the generated target model. This is not required in our grammar-based approach, since we can rely on the connection (replacement) mechanism of the individual HR productions contained in the transformation rules.

If meta-models include structural classes, it is possible to define declarative structure-based rules in a TGG-like format with better readability than in the previous solutions, and with more analysis possibilities. Still, as far as we know, there are no approaches showing completeness and determinism even for such declarative transformations. Unlike these common practices, our approach natively supports structure-based transformations, keeping their rules graphical and concise (see Fig. 9, rule 7), and guarantees their quality.


                     Discussion: Transformation rules defined using our approach stay declarative (see Fig. 9) which brings multiple advantages: simpler and more intuitive transformation rules that are easier to understand and maintain, especially, when grammar productions are represented in concrete syntax and the specific details
                        9
                     
                     
                        9
                        Information about the attachment and replacement nodes, and their mapping.
                      of HR grammars are hidden; and the guaranteed transformation quality properties discussed in Section 5. The transformation rules defined using our approach have a declarative and domain (source and target language) specific form, whose definition does not require any knowledge of a specific model transformation language.

The only part of the approach that stays imperative is the source model parsing. Parsing causes most of the complexity in our method, but its mathematical foundations for HR grammars [10] guarantee termination and predictable worst-case run-time.

The conditions we currently put on transformations defined by our approach to guarantee their quality (Section 3) might be too restrictive even with the use of extensions (Section 3.3) for some purposes. In such cases, a developer can still define structure-based declarative transformations using our approach and employ existing testing and verification techniques to check their quality.

The choice of HR grammars for meta-model compliant language definition currently limits our approach to the transformations between context-free graph-based languages. We plan to address this limitation and take context-sensitive languages into consideration using grammars proposed in [24].

HR graph grammars, which we use to define source and target languages, in general, are more restrictive and complex than pure meta-models (with structural classes). However, when compared to meta-models with OCL constraints enforcing (when possible) the same structural well-formedness constraints on e.g., activity diagrams, HR grammars typed over meta-models present a more concise, intuitive, and structure-oriented way to graphically describe such constraints. By using such graph grammars we enrich the meta-model based definition of modeling languages with explicit structural information, described by productions in a graphical way. The domain expert is usually aware of this information but unable to describe it in pure meta-models, especially, when the same language elements are used differently in various structures.

As a meta-model, an HR grammar only needs to be created once per language and, can then be used by any developer for any grammar-based transformation involving this language. The complexity of an HR grammar can affect the complexity of the GBMTs using it but that is also the case with meta-models.

Now, we provide another transformation example to demonstrate further benefits of our grammar-based approach apart from the quality properties, that it guarantees for the developed transformations. We consider the case when the developed transformation does not require structure-based mappings, as in our activity diagrams to CSP transformation (e.g., decision/merge to if-then-else expression mapping), but only relatively simple transformation mappings. Such mappings are easier to develop using the existing methods and languages like ATL and TGGs than the structure-based ones. Yet, this example shows further advantages of our approach even for such mappings.

We consider the event splitting transformation in CSP from [14] (without parameters), that creates two events e_start and e_end for each prefix event e. Its result for prefix 
                        submitForm
                        →
                      are two prefixes – 
                        submitForm
                        _
                        start
                        →
                        submitForm
                        _
                        end
                        →
                     .

To develop such transformation in ATL or TGGs the developer needs to define at least one rule to map an event prefix onto two prefixes with appropriately named events. Furthermore, (s)he has to explicitly specify how the result of this rule is connected to the rest of the target model. In ATL such a connection often involves iteration and resolution, making the rules imperative and, thus, more difficult to analyze and maintain. With TGGs such explicit connections of the results also complicate the resulting transformation rules.

In our grammar-based approach we, on the other hand, do not require such explicit connection logic and employ the mechanism of the HR productions of the rules for this purpose. Thus, we only require one non-trivial rule, shown in Fig. 14
                     , to define the complete splitting transformation. The rest of the rules are trivial – they simply copy model elements through pairing the productions with themselves. Similar copy rules also need to be created, when other approaches like TGGs or ATL are used. Their creation does not significantly influence the complexity of the resulting transformation in either approaches, since it can be automated (e.g., refinement mode of ATL).

The advantages of such declarative, connection-logic free, and domain-specific rules become even more valuable when structure-based mappings are also required in the developed transformation, as we have seen in the example transformation between activity diagrams and CSP. In such cases the complexity of the resulting transformations can be reduced even further compared to other techniques, as discussed in Section 6.

@&#RELATED WORK@&#

For decades, compiler construction has benefited from syntax-directed translation [7]. This technique relates single string grammar productions via 1-to-1 relations and requires both grammars to have the same non-terminals, building a very basic version of our approach. Pratt [8] was the first to propose to apply this technique to graphs and show that the resulting transformations are deterministic and reversible (under conditions). Our approach extends [8] to n-to-m relations between productions, n-to-m correspondences between non-terminals, and shows additional properties for the developed transformations. Thus, we consider a much larger scope of transformations than the approach from [8].

TGGs proposed in [16] were also inspired by Pratt [8] and were the first to contain explicit correspondence nodes. However, the focus of TGGs was on relating context-sensitive productions to support data integration without the consideration of transformation quality properties. In MDE today, TGGs are defined on meta-models and relate model patterns gradually matched during the execution instead of grammar productions. The only approach we are aware of, that uses TGGs with meta-models to define structure based transformation in [23], has already been considered in our evaluation in Section 6.

Halfway between grammars, as in our approach, and meta-models is the transformation development and validation approach proposed in [25]: it relates source model patterns with target productions and states extensive criteria for transformation quality assurance. The target language in this approach is defined through graph grammar productions. However, it is unclear how the target grammars used there are defined and whether the related target productions can always be applied when the source pattern is found during the transformation execution. In [25], the transformation execution strategy is defined manually whereas, in our approach it is automatically obtained during the source model parsing making it less error prone. Like us, the authors of [25] consider transformation characteristics: termination and confluence; however, they do not consider soundness and completeness.

Further existing approaches [26–30] are primarily concerned with the quality properties of model transformations based on meta-models and TGGs or similar graph-based formalisms. In [26], the authors address termination of transformations based on algebraic graph transformations [31]. They define criteria for transformation rules based on the deleting and non-deleting layers they are assigned to. These criteria enforce a certain precedence relation over the rules creating and matching/deleting the same elements. Based on these criteria the authors inductively prove termination of all transformations fulfilling them.

Other works [28,29], closely related to [26], consider transformations defined using TGGs and prove their termination, soundness, and completeness. In the authors׳ definition of these properties, the source and target models of the transformations are those generated by the respective (source/target) parts of the defining TGGs with no additional conformance to some source/target meta-models, like in our approach. In [30], the authors extend the work from [28,29] by an approach to guarantee determinism of TGG based transformations. They show determinism through local confluence.

In [27], the authors prove termination of (a special class of) graph-based model transformations by translating them into Petri nets. Thereby, they re-use the existing termination proofs for this formalism. If they can prove that the Petri net runs out of tokens in finitely many steps regardless of the initial marking, then the transformation terminates. By solving algebraic inequalities, the authors also obtain sufficient criteria to either prove that a transformation is terminating or get a ‘maybe’ answer which, however, might be insufficient.

Other approaches like [32–34] advocate transformation development by-example and by-demonstration, and do not directly focus on structure based transformations. Like us, these approaches recognize the problem of over-abstraction of language definition through meta-models, but deal with it using examples to describe corresponding structures of the source and target languages, whereas we use graph grammar productions. By such example-based approaches it is not always clear whether the examples or the transformation should be adapted when the result is not yet satisfactory, or how many examples are needed. Whether the developed transformation has desirable properties is, as far as we know, not addressed by any of these approaches.

Several other approaches [35,36] directly apply classic techniques to model transformations. Unfortunately, non of them consider properties of the developed transformations.

In [35], the authors attempt to use TXL [37] – a generic source transformation framework – to develop model transformations. They consider meta-model based languages, and transform them into TXL string grammars. TXL string grammars do not have the expressiveness and visualization advantages of the graph grammars we use, leading to very limited applicability of the TXL-based approach. Transformations described in TXL are fine-grained with explicit execution policy, which makes them flexible, but also complex and difficult to understand and maintain. This method can be placed halfway between the syntax-directed translation and our approach.

In [36] the authors attempt to simplify transformation development by eliminating the need to learn specialized languages. They regard models and meta-models as abstract data types – abstract structures with operations. On top of the types they define a minimal imperative model transformation language with formal semantics. This approach brings models and transformations into the world of programming, whereas our approach lifts translation techniques to graphs. Both of the latter approaches use meta-models and none of them directly considers high-level structures in languages and transformations based on these structures, as we do. Transformation quality is not considered either.

We consider our approach as the next step towards efficient and quality-aware transformation development that can be realized based on existing state-of-the-art including some approaches described above and the commonly used technologies like ATL [20] and TGGs [16].

In general, the use of alternative notations for modeling language definition – meta-model vs. graph grammar – raises the issue of integration and interoperability of the approaches and tools based on them. Various methods address this issue by defining automatic and semi-automatic transformations between the alternatives [38–43], applying inference to obtain graph grammars from meta-model conform models [44], or combining the alternatives as different complementary views in multi-level modeling [45]. In our approach, we follow the latter direction and envision its combination with the promising graph grammar generation approaches mentioned above. In general, the grammars generated from meta-models by such approaches might require some re-factoring to introduce the language structures, which are not directly described by meta-models, like activity blocks in our example source language.

Finally, we want to point out that a simpler version of the idea used in our method has been recently used in [46] for semantic-based machine translation in the field of computational linguistics.

@&#CONCLUSION@&#

In this paper, we have presented a grammar-based approach to the development of model transformations that allows to naturally consider structures of the languages involved and use them in the rules. We have employed meta-model compliant HR grammars to specify source and target languages, and defined transformation rules by relating their productions and adding correspondences between the non-terminals. We have also presented extensions of the approach including extended (relating sub-trees) and non-local rules.

After describing the grammar-based approach on a conceptual level, we have also provided its formalization and sketched how the quality properties of the resulting transformations can be proven based on this formalization. We have shown that model transformations defined using our approach always terminate and are sound, complete, and deterministic. Furthermore, we have shown that our example grammar-based transformation from activity diagrams to CSP complies with this formalization and, thus, has the desired properties.

The presented advantages of the approach are accompanied by the requirements on the form of the developed transformations and on the used grammars. Its application in the context of certain grammars and transformation logic might fail to fulfill some of these requirements to guarantee the properties. Nevertheless, the developed transformation can still be used, and analyzed and tested by the existing methods. Furthermore, not all of the requirements are strict and some can be weakened in the future, like those on replacement alternatives.


                     Future work: Currently, we are working on the extension of initial case studies to evaluate our approach and continue improving the tool support. In the future, we look to support computation of attributes, while still keeping the desired transformation properties. When expressiveness of HR grammars is not sufficient, we plan to explore the decidable contextual graph grammars proposed by Drewes in [24]. For the generation of the initial form of such grammars from meta-models one can build upon the ideas for their automatic generation from meta-models proposed in [38–40,43].

@&#ACKNOWLEDGMENTS@&#

This work was partially supported by the German Research Foundation (DFG) within the Collaborative Research Centre “On-The-Fly Computing” (SFB 901) (Grant number SFB 901/1).

@&#REFERENCES@&#

