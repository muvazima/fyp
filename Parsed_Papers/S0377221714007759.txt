@&#MAIN-TITLE@&#Integrating tabu search and VLSN search to develop enhanced algorithms: A case study using bipartite boolean quadratic programs

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We develop efficient heuristic algorithms based on tabu search, VLSN search, and a hybrid algorithm that integrates the two.


                        
                        
                           
                           The computational study establishes that effective integration of simple tabu search with VLSN search results in superior outcomes.


                        
                        
                           
                           We obtain solutions better than the best previously known for almost all medium and large size benchmark instances.


                        
                        
                           
                           Landscape analysis of benchmark instances is given and this offers additional insights into the structure of these problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Quadratic programming

Boolean variables

Metaheuristics

Tabu search

Worst-case analysis

@&#ABSTRACT@&#


               
               
                  The bipartite boolean quadratic programming problem (BBQP) is a generalization of the well studied boolean quadratic programming problem. The model has a variety of real life applications; however, empirical studies of the model are not available in the literature, except in a few isolated instances. In this paper, we develop efficient heuristic algorithms based on tabu search, very large scale neighborhood (VLSN) search, and a hybrid algorithm that integrates the two. The computational study establishes that effective integration of simple tabu search with VLSN search results in superior outcomes, and suggests the value of such an integration in other settings. Complexity analysis and implementation details are provided along with conclusions drawn from experimental analysis. In addition, we obtain solutions better than the best previously known for almost all medium and large size benchmark instances.
               
            

@&#INTRODUCTION@&#

Local search (also called neighborhood search) is typically incorporated as a fundamental component within metaheuristic methods such as evolutionary algorithms, simulated annealing, particle swarm optimization and (more directly) tabu search, producing methods of choice for solving many complex applied optimization problems. Traditional local search algorithms use exhaustive search over small neighborhoods or employ candidate list strategies as proposed in tabu search to handle large neighborhoods. In addition a number of recent local search algorithms use neighborhoods of exponential size that often can be searched for improving solutions in polynomial time. To distinguish between the use of exhaustive search over small neighborhoods and the use of polynomial time methods for searching large neighborhoods we call the former simple neighborhood search (SN search) and the latter very large-scale neighborhood search (VLSN search) (Ahuja et al., 2002). SN search algorithms are generally faster in exploring neighborhoods but take a large number of iterations to reach a locally optimal solution. Many VLSN search algorithms on the other hand take longer to search a neighborhood for an improving solution but often reach a locally optimal solution quickly within a relatively small number of iterations. In this paper we consider an integration of SN search and VLSN search within a tabu search framework to develop enhanced algorithms for an important combinatorial optimization problem called the bipartite boolean quadratic programming problem (BBQP). Our computational outcomes suggest the merit of such an integration in other settings.

Let Q = (qij
                        ) be an m × n matrix, c = (c
                        1, c
                        2, …, cm
                        ) be a row vector in Rm
                         and d = (d
                        1, d
                        2, …, dn
                        ) be a row vector in Rn
                        . Then, the problem (BBQP) can be stated mathematically as

                           
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             BBQP
                                             
                                             :
                                             Maximize
                                             
                                             
                                                f
                                                
                                                   (
                                                   x
                                                   ,
                                                   y
                                                   )
                                                
                                                =
                                                
                                                   x
                                                   T
                                                
                                                Q
                                                y
                                                +
                                                c
                                                x
                                                +
                                                d
                                                y
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             
                                                subject
                                                
                                                to
                                             
                                             
                                             
                                                x
                                                ∈
                                                
                                                   
                                                      {
                                                      0
                                                      ,
                                                      1
                                                      }
                                                   
                                                   m
                                                
                                                ,
                                                y
                                                ∈
                                                
                                                   
                                                      {
                                                      0
                                                      ,
                                                      1
                                                      }
                                                   
                                                   n
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        An instance of BBQP is completely defined by the matrix Q and vectors c and d and hence may be represented by 
                           
                              P
                              (
                              Q
                              ,
                              c
                              ,
                              d
                              )
                           
                        .

The problem can be viewed as a generalization of the well-studied boolean quadratic programming problem (BQP) (Glover et al., 1998; Glover and Hao, 2010; Lü et al., 2010; Wang et al., 2012)

                           
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             BQP
                                             
                                             :
                                             Maximize
                                             
                                             
                                                f
                                                
                                                   (
                                                   x
                                                   )
                                                
                                                =
                                                
                                                   x
                                                   T
                                                
                                                
                                                   Q
                                                   ′
                                                
                                                x
                                                +
                                                
                                                   c
                                                   ′
                                                
                                                x
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                                subject
                                                
                                                to
                                             
                                             
                                             
                                                x
                                                ∈
                                                
                                                   
                                                      {
                                                      0
                                                      ,
                                                      1
                                                      }
                                                   
                                                   n
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Q′ is an n × n matrix and c′ is a row vector in Rn
                        . As pointed out in Punnen et al. (2012a); 2012b), by choosing

                           
                              (1)
                              
                                 
                                    Q
                                    =
                                    
                                       Q
                                       ′
                                    
                                    +
                                    2
                                    M
                                    I
                                    ,
                                    
                                    c
                                    =
                                    
                                       1
                                       2
                                    
                                    
                                       c
                                       ′
                                    
                                    −
                                    M
                                    e
                                    
                                    and
                                    
                                    d
                                    =
                                    
                                       1
                                       2
                                    
                                    
                                       c
                                       ′
                                    
                                    −
                                    M
                                    e
                                    ,
                                 
                              
                           
                        where I is an n × n identity matrix, e ∈ Rn
                         is an all one vector and M is a very large number, BQP can be formulated as a BBQP. In Eq. (1), the penalty parameter M forces xi
                         = yi
                         in an optimal solution of this modified BBQP. This transformation is important since it provides additional flexibility in developing algorithms for BQP through BBQP formulations.

Since BBQP is a generalization of BQP, various applications studied in the context of BQP are also relevant to BBQP. Applications of the BQP model are very diverse, ranging from solving fundamental graph theoretic problems, to solving the Ising model of ferromagnetism in statistical mechanics, to designing special types of quantum computers. Rather than elaborating the details of such applications here, we discuss some applied problems that can be directly modeled as BBQP. Notably, many problems in pattern recognition and correlation clustering can be formulated as the problem of approximating a matrix by a rank-one binary matrix and this can be accomplished by solving a BBQP (Gillis and Glineur, 2011; Shen et al., 2009; Lu et al., 2011). This can be accomplished as follows. Suppose A = (aij
                        ) is a given m × n matrix and B is a rank-one binary matrix approximation of A. B is of size m × n and can be written as B = xyT
                         for some x ∈ {0, 1}
                           m
                         and y ∈ {0, 1}
                           n
                        . Thus B can be identified by minimizing 
                           
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 m
                              
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 
                                    (
                                    
                                       a
                                       
                                          i
                                          j
                                       
                                    
                                    −
                                    
                                       x
                                       i
                                    
                                    
                                       y
                                       j
                                    
                                    )
                                 
                                 2
                              
                           
                        . Since 
                           
                              
                                 x
                                 i
                                 2
                              
                              =
                              
                                 x
                                 i
                              
                           
                         and 
                           
                              
                                 y
                                 j
                                 2
                              
                              =
                              
                                 y
                                 j
                              
                           
                         for all i and j, we have

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   (
                                                   
                                                      a
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   −
                                                   
                                                      x
                                                      i
                                                   
                                                   
                                                      y
                                                      j
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                (
                                                
                                                   a
                                                   
                                                      i
                                                      j
                                                   
                                                   2
                                                
                                                −
                                                2
                                                
                                                   a
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   x
                                                   i
                                                
                                                
                                                   y
                                                   j
                                                
                                                +
                                                
                                                   x
                                                   i
                                                   2
                                                
                                                
                                                   y
                                                   j
                                                   2
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                a
                                                
                                                   i
                                                   j
                                                
                                                2
                                             
                                             −
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                x
                                                i
                                             
                                             
                                                (
                                                2
                                                
                                                   a
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                −
                                                1
                                                )
                                             
                                             
                                                y
                                                j
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             K
                                             −
                                             
                                                x
                                                T
                                             
                                             W
                                             y
                                          
                                       
                                    
                                 
                              
                           
                        where wij
                         = 2aij
                         − 1 and W = (wij
                        )
                           m × n
                        . Thus, minimizing 
                           
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 m
                              
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 
                                    (
                                    
                                       a
                                       
                                          i
                                          j
                                       
                                    
                                    −
                                    
                                       x
                                       i
                                    
                                    
                                       y
                                       j
                                    
                                    )
                                 
                                 2
                              
                           
                         is equivalent to solving a BBQP with Q = W, c = 0 and d = 0. If the components of B are required to belong to the set { − 1, 1} as in the case of some clustering applications, we can still model the problem as a BBQP using the above approach by converting the variables to binary using a linear transformation.

The BBQP model can be used to solve some graph theoretic optimization problems (Ambühl et al., 2011; Tan, 2008). For this, consider the bipartite graph G = (U, V, E) and let aij
                         > 0 be the weight of the edge (i, j) ∈ E. Then the maximum weight biclique problem (MWBP) is to find a biclique in G of maximum total edge-weight. Define

                           
                              
                                 
                                    
                                       q
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   a
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                   (
                                                   i
                                                   ,
                                                   j
                                                   )
                                                   ∈
                                                   E
                                                
                                             
                                          
                                          
                                             
                                                
                                                   −
                                                   M
                                                
                                             
                                             
                                                
                                                   otherwise
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where M is a large positive number. Further, choose c and d as zero vectors. Then the solution to the resulting BBQP yields a solution to the MWBP. The problem MWBP has applications in data mining, clustering and bioinformatics (Chang et al., 2012; Tanay et al., 2002).

Finally, we note that BBQP can also be used to solve the maximum weight cut problem in a bipartite graph and the maximum weight bipartite spanning subgraph problem in a general graph (Punnen, Sripratak, and Karapetyan, 2012a). The model can also be used to approximate the cutnorm of a matrix (Alon and Naor, 2006).

Despite its unifying role and various practical applications, BBQP has not been investigated thoroughly from an experimental analysis point of view. The only systematic study that we are aware of is by Karapetyan and Punnen (2012) who generated a class of test instances and provided experimental results with various heuristic algorithms. Some limited experimental study using a specific algorithm, called the alternating algorithm (Karapetyan and Punnen, 2012; Lu et al., 2011) is also available in the context of specific applications. After we released a preliminary version of our paper, Duarte et al. (2014) reported experimental results with exact and heuristic algorithms for BBQP. They compared their algorithm with ours and reported that both algorithms perform well and neither dominates the other. We report additional analytical and experimental results in the current version of our work that provide new findings. We also suggest new directions for future research.

The focus of this paper is to develop efficient heuristic algorithms for solving BBQP. The major contributions can be summarized as follows:

                           
                              •
                              We present two neighborhood structures, a classic one-flip neighborhood and a new flip-float neighborhood, and based on them propose a one-flip move based tabu search algorithm, a flip-float move based coordinate method and a hybrid algorithm that combines the two. While the specific optimization problem addressed in this paper is BBQP, our approach for integrating tabu search (TS) and VLSN search is applicable to other settings to obtain hybrid algorithms that inherit individual properties of these algorithmic paradigms.

We evaluate and analyze the proposed algorithms through computational experiments on a set of 85 benchmark instances (Karapetyan and Punnen, 2012). The experimental results show that the hybrid method is able to improve almost all the previous best-known solutions on the medium and large size instances, demonstrating its effectiveness and efficiency. They also disclose that the new flip-float neighborhood is the key reason for effectively solving the Bicluque and BMaxCut instances, and that the hybrid TS/VLSN method shows better performance in terms of both solution quality and robustness than either of its component methods in isolation.

We compare our algorithms with the approach of using state-of-the-art mixed integer programming software by solving an integer programming formulation of BBQP using CPLEX (IBM, 2010). Because of the difficulty of obtaining exact (verifiably optimal) solutions, we focused on using appropriate parameter settings to guide the solver to seek good heuristic solutions within a prescribed time limit. For small size instances, this approach produced solutions comparable to those of our algorithms (but at the cost of additional time). For medium and large size instances, however, this approach proved to be impractical, reinforcing the need for special purpose algorithms to solve BBQP.

We provide landscape analysis of the benchmark instances to identify the inherent difficulty of these instances for local search algorithms. Such a study has not previously been undertaken in the literature and provides additional insights into the structure of the benchmark instances.

The rest of the paper is organized as follows. Section 2 presents two neighborhood structures and describes in detail three heuristic algorithms. Section 3 reports and discusses computational statistics of the proposed algorithms on the standard benchmark instances. Landscape analysis of the benchmark instances is also discussed in this section. Finally, concluding remarks are provided in Section 4.

We propose three heuristic algorithms for solving BBQP. The first algorithm adopts a classic one-flip neighborhood structure and a tabu search strategy. The second algorithm employs a new flip-float neighborhood structure and a coordinate ascent strategy. The third integrates the first and second algorithms to produce a hybrid method.

The classic one-flip move performed on a binary vector consists of changing the value of a component of the vector to its complementary value (i.e., flipping a component of the vector). Thus, by flipping the ith component of vector x = (x
                        1, x
                        2, …, xm
                        ), we get a new vector x′ = (x
                        1, …, x
                        
                           i − 1, 1 − xi, x
                        
                           i + 1, …, xm
                        ). This flip process can be denoted as:

                           
                              (2)
                              
                                 
                                    
                                       x
                                       ′
                                    
                                    ←
                                    x
                                    ⊕
                                    F
                                    l
                                    i
                                    p
                                    
                                       (
                                       i
                                       )
                                    
                                    .
                                 
                              
                           
                        For a solution (x, y) of BBQP, we can perform one-flip moves on both x and y and hence the number of all possible one-flip moves is m + n.

In local search algorithms, we usually need to rapidly determine the effect of a one-flip move on the objective function. To achieve this, we adapt a fast incremental evaluation technique, widely used for the BQP problem (Glover et al., 1998; Glover and Hao, 2010; Glover et al., 2010; Lü et al., 2010; Wang et al., 2011; 2012), to the BBQP problem. Specifically, we use two arrays to store the contribution of each possible move, and employs a streamlined calculation for updating the arrays after each move.

Let Δxi
                         (i = 1, 2, …, m) denote the change in the objective function value caused by flipping the ith component of x and let x′ = x⊕Flip(i), then

                           
                              (3)
                              
                                 
                                    Δ
                                    
                                       x
                                       i
                                    
                                    =
                                    f
                                    
                                       (
                                       
                                          x
                                          ′
                                       
                                       ,
                                       y
                                       )
                                    
                                    −
                                    f
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    =
                                    
                                       (
                                       
                                          x
                                          i
                                          ′
                                       
                                       −
                                       
                                          x
                                          i
                                       
                                       )
                                    
                                    
                                       (
                                       
                                          c
                                          i
                                       
                                       +
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          y
                                          j
                                       
                                       
                                          q
                                          
                                             i
                                             j
                                          
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        Similarly, let Δyj
                         (j = 1, 2, …, n) denote the change in the objective function value caused by flipping the jth component of y and let y′ = y⊕Flip(j). Then

                           
                              (4)
                              
                                 
                                    Δ
                                    
                                       y
                                       j
                                    
                                    =
                                    f
                                    
                                       (
                                       x
                                       ,
                                       
                                          y
                                          ′
                                       
                                       )
                                    
                                    −
                                    f
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    =
                                    
                                       (
                                       
                                          y
                                          j
                                          ′
                                       
                                       −
                                       
                                          y
                                          j
                                       
                                       )
                                    
                                    
                                       (
                                       
                                          d
                                          j
                                       
                                       +
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          x
                                          i
                                       
                                       
                                          q
                                          
                                             i
                                             j
                                          
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

In our implementation, we use two arrays to store all the Δxi
                         and Δyj
                         values. These arrays can be initialized using Eqs. (3) and (4) with time complexity O(mn). After a move is performed, the Δxi
                         and Δyj
                         arrays are updated efficiently. Note that we just need to update the elements affected by the move and the new values can be determined incrementally. A detailed description of the algorithm for updating the Δxi
                         and Δyj
                         values with time complexity O(m + n) is given in Algorithm 1
                        .

Based on the one-flip neighborhood, we can formulate a simple tabu search algorithm as described in Algorithm 2
                        . When a component of x or y is flipped in the current step, it is declared tabu for the next TabuTenure steps, i.e., one-flip moves (either from 0 to 1 or from 1 to 0) involving this component are forbidden for the next TabuTenure iterations. Using a simple default setting, the TabuTenure for xi
                         (i = 1, 2…, m) is set to m/20 + rand(0, 10), where rand(0, 10) denotes a random integer between 0 and 10. For yj
                         (j = 1, 2, …, n), the TabuTenure is set to n/20 + rand(0, 10). The use of a random range of TabuTenure has been similarly incorporated in tabu search algorithms for the BQP problem (Glover et al., 1998; Glover and Hao, 2010; Glover et al., 2010; Lü et al., 2010; Wang et al., 2011; 2012), as a means of enhancing the robustness of the algorithm over a variety of landscapes. We also used a simple aspiration criterion, allowing a tabu move to be performed if it leads to a solution better than the best-found one. Our rudimentary tabu search algorithm starts from a randomly generated initial solution. In each iteration, it executes the best admissible one-flip move and repeats until the incumbent (best-found) solution has not been improved in the last TabuDepth steps.

The resulting algorithm is depicted as Algorithm 2 below. We use an array of size m + n for the tabu list, whose initialization requires O(m + n) time complexity. The time complexity of step 2 is O(mn). Step 4 is realized by scanning the Δxi
                         and Δyj
                         arrays and looking up the tabu list with time complexity O(m + n). Steps 5 and 6 can be done in O(1) time. The complexity of Step 7 is O(m + n), as indicated in the previous section. Therefore, for the one-flip move based tabu search algorithm, the complexity of each search step is O(m + n).

Note that when x is fixed, there exists a y which maximizes fx
                        (y) = f(x, y). Specifically, for a fixed x = (x
                        1, x
                        2, …, xm
                        ), we can choose the best y = y*(x) which maximizes fx
                        (y) by the following equation (Karapetyan and Punnen, 2012):

                           
                              (5)
                              
                                 
                                    
                                       y
                                       *
                                    
                                    
                                       
                                          (
                                          x
                                          )
                                       
                                       j
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      d
                                                      j
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      m
                                                   
                                                   
                                                      x
                                                      i
                                                   
                                                   
                                                      q
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   >
                                                   0
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise.
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Similarly, we can choose a best x = x*(y) for a fixed y = (y
                        1, y
                        2, …, yn
                        ) which maximizes fy
                        (x) = f(x, y) by the equation:

                           
                              (6)
                              
                                 
                                    
                                       x
                                       *
                                    
                                    
                                       
                                          (
                                          y
                                          )
                                       
                                       i
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   if
                                                   
                                                   
                                                      c
                                                      i
                                                   
                                                   +
                                                   
                                                      ∑
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   
                                                      y
                                                      j
                                                   
                                                   
                                                      q
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   >
                                                   0
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise.
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The Flip-x-Float-y move consists of flipping one component of x and then choosing the best (floating) y with respect to the flipped x. Similarly, the Flip-y-Float-x move is defined as flipping one component of y and then choosing the best (floating) x with respect to the flipped y. The number of all possible Flip-x-Float-y and Flip-y-Float-x moves is, respectively, m and n.

Let 
                           
                              
                                 F
                                 
                                    y
                                    *
                                 
                              
                              
                                 (
                                 x
                                 )
                              
                              =
                              f
                              
                                 (
                                 x
                                 ,
                                 
                                    y
                                    *
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 )
                              
                              ,
                           
                        
                        
                           
                              
                                 F
                                 
                                    x
                                    *
                                 
                              
                              
                                 (
                                 y
                                 )
                              
                              =
                              f
                              
                                 (
                                 
                                    x
                                    *
                                 
                                 
                                    (
                                    y
                                    )
                                 
                                 ,
                                 y
                                 )
                              
                           
                        . Then the change of objective function value caused by flipping the ith component of x and floating y is given by:

                           
                              (7)
                              
                                 
                                    Δ
                                    Flip
                                    −
                                    x
                                    −
                                    Float
                                    −
                                    y
                                    
                                       (
                                       i
                                       )
                                    
                                    =
                                    
                                       F
                                       
                                          y
                                          *
                                       
                                    
                                    
                                       (
                                       x
                                       ⊕
                                       Flip
                                       
                                          (
                                          i
                                          )
                                       
                                       )
                                    
                                    −
                                    
                                       F
                                       
                                          y
                                          *
                                       
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    .
                                 
                              
                           
                        Similarly, the change in the objective function value caused by flipping the jth component of y and floating x is given by

                           
                              (8)
                              
                                 
                                    Δ
                                    Flip
                                    −
                                    y
                                    −
                                    Float
                                    −
                                    x
                                    
                                       (
                                       j
                                       )
                                    
                                    =
                                    
                                       F
                                       
                                          x
                                          *
                                       
                                    
                                    
                                       (
                                       y
                                       ⊕
                                       Flip
                                       
                                          (
                                          j
                                          )
                                       
                                       )
                                    
                                    −
                                    
                                       F
                                       
                                          x
                                          *
                                       
                                    
                                    
                                       (
                                       y
                                       )
                                    
                                    .
                                 
                              
                           
                        
                     

In the local search, we need to find a fast way to identify the value of 
                           
                              Δ
                              Flip
                              −
                              x
                              −
                              Float
                              −
                              y
                              (
                              i
                              )
                           
                         and 
                           
                              Δ
                              Flip
                              −
                              y
                              −
                              Float
                              −
                              x
                              (
                              j
                              )
                           
                        . In the following, we only describe how to determine 
                           
                              Δ
                              Flip
                              −
                              x
                              −
                              Float
                              −
                              y
                              (
                              i
                              )
                           
                        . Computation of 
                           
                              Δ
                              Flip
                              −
                              y
                              −
                              Float
                              −
                              x
                              (
                              j
                              )
                           
                         can be done in an analogous way by simply exchanging the symbols (1) x and y, (2) i and j, (3) ci
                         and dj
                        , and (4) m and n.

Let

                           
                              (9)
                              
                                 
                                    S
                                    u
                                    m
                                    
                                       (
                                       x
                                       ,
                                       j
                                       )
                                    
                                    =
                                    
                                       d
                                       j
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       
                                          x
                                          i
                                       
                                       
                                          q
                                          
                                             i
                                             j
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        Then we have

                           
                              (10)
                              
                                 
                                    
                                       F
                                       
                                          y
                                          *
                                       
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       c
                                       i
                                    
                                    
                                       x
                                       i
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       m
                                       a
                                       x
                                       (
                                       0
                                       ,
                                       S
                                       u
                                       m
                                       (
                                       x
                                       ,
                                       j
                                       )
                                       )
                                    
                                 
                              
                           
                        
                     

Let x′ = x⊕Flip(i) (i = 1, 2, …, m). Then

                           
                              (11)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                F
                                                
                                                   y
                                                   *
                                                
                                             
                                             
                                                (
                                                
                                                   x
                                                   ′
                                                
                                                )
                                             
                                             −
                                             
                                                F
                                                
                                                   y
                                                   *
                                                
                                             
                                             
                                                (
                                                x
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                c
                                                k
                                             
                                             
                                                
                                                   
                                                      x
                                                      ′
                                                   
                                                
                                                k
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                m
                                                a
                                                x
                                                (
                                                0
                                                ,
                                                S
                                                u
                                                m
                                                
                                                   (
                                                   
                                                      x
                                                      ′
                                                   
                                                   ,
                                                   j
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             −
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                c
                                                k
                                             
                                             
                                                x
                                                k
                                             
                                             −
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                m
                                                a
                                                x
                                                (
                                                0
                                                ,
                                                S
                                                u
                                                m
                                                (
                                                x
                                                ,
                                                j
                                                )
                                                )
                                             
                                             =
                                             
                                                c
                                                i
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         x
                                                         ′
                                                      
                                                   
                                                   i
                                                
                                                −
                                                
                                                   x
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                (
                                                
                                                   m
                                                   a
                                                   x
                                                   
                                                      (
                                                      0
                                                      ,
                                                      S
                                                      u
                                                      m
                                                      
                                                         (
                                                         
                                                            x
                                                            ′
                                                         
                                                         ,
                                                         j
                                                         )
                                                      
                                                      )
                                                   
                                                   −
                                                   m
                                                   a
                                                   x
                                                   
                                                      (
                                                      0
                                                      ,
                                                      S
                                                      u
                                                      m
                                                      
                                                         (
                                                         x
                                                         ,
                                                         j
                                                         )
                                                      
                                                      )
                                                   
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

From Eq. (11), we observe that computing the value of 
                           
                              Δ
                              Flip
                              −
                              x
                              −
                              Float
                              −
                              y
                              (
                              i
                              )
                           
                         requires knowledge of the Sum(x, j) values. Thus, in our calculations we use an array of size n to store Sum(x, j) (j = 1, 2, …, n). From Eq. (9), the Sum(x, j) array can be initialized with O(mn) time complexity. In each search step, we use the followingalgorithm (Algorithm 3
                        ) of complexity O(n) to compute 
                           
                              Δ
                              Flip
                              −
                              x
                              −
                              Float
                              −
                              y
                              (
                              i
                              )
                           
                        . After performing move Flip-x-Float-y(i), the Sum(x, j) array can be updated by adding (x'
                           i
                         − xi
                        )*qij
                         to each element. It is clear that each updating requires O(n) time complexity. Note that before applying Flip-x-Float-y(i), we make sure that y = y*(x). Likewise, before applying Flip-y-Float-x(j), we make sure x = x*(y).

Based on the Flip-float neighborhood, we get a coordinate method as described in Algorithm 4
                        which alternatively uses Flip-x-Float-y and Flip-y-Float-x moves to improve a solution. Starting from a given initial solution, the algorithm first chooses the optimal y for the given x. Then it progressively uses the Flip-x-float-y moves to improve the incumbent solution. At each search step, the algorithm scans all possible Flip-x-Float-y moves. Once it encounters an improving move with ΔFlip-x-Float-y (i) > 0, it performs that move. If all Flip-x-Float-y moves cannot improve the incumbent solution, the algorithm tries to improve the incumbent solution using the Flip-y-Float-x move in a similar manner as described above. If the solution has been improved by Flip-y-Float-x move, it will go back to the beginning and tries to improve it using the Flip-x-Float-y moves again. The algorithm terminates when the solution cannot be improved by both Flip-x-Float-y and Flip-y-Float-x moves.

The one-flip move based tabu search algorithm and the flip-float move based coordinate method represent two kinds of algorithmic paradigms. For the one-flip move based tabu search algorithm, each move is simple and fast, but the tabu search strategy is very powerful, making it possible to escape from small local minimum traps and iterate for large number of steps. In the flip-float move based coordinate method, each move examines a large number of candidate solutions and therefore is more powerful and more expensive, but the coordinate ascent strategy is simple and allows only a few number of iterations in each local search.

The hybrid method integrates the one-flip tabu search algorithm and the flip-float coordinate method to yield the schema given in Algorithm 5
                        . The integrating strategy is simple. It alternatively uses the one-flip tabu search algorithm and the flip-float coordinate method to improve the incumbent solution, until no improvement can be achieved using both methods.

This section provides experimental results of the described algorithms on a set of 85 benchmark instances. We analyze their computational statistics in the aim of assessing their performance and disclosing their individual properties.

We adopt the standard testbed generated by Karapetyan and Punnen (2012) in our experiments. This testbed consists of 85 test instances which can be classified into five categories: Random instances, Max Clique instances which model the problem of finding a biclique of the maximum weight in a bipartite graph, Max Induced Subgraph instances which model the problem of finding a subset of nodes in a bipartite graph that maximizes the total weight of the resulting induced subgraph, Max Cut instances which model the MaxCut problem, and Matrix Factorization instances which model the problem of producing a rank one approximation of a binary matrix. Each category contains three kinds of instances: small instances of size from 20 × 50 to 50 × 50, medium instances of size from 200 × 1000 to 1000 × 1000, and large instances of size from 1000 × 5000 to 5000 × 5000. A detailed description of the problem generator can be found in Karapetyan and Punnen (2012). All these instances are available in public from the website http://www.cs.nott.ac.uk/~dxk/.

The algorithms are coded in C++ and complied using GNU GCC. All the computational experiments are carried out on a PC with two 3.1 gigahertz Intel Xeon E5-2687W CPUs and 128 GB memory. The computer can run 32 computing threads at the same time, so we use multiple threads to compute multiple instances. No parallel computing techniques are used. During the experiments, all the parameters used in the algorithms are fixed for all instances considered.

The algorithms are run in a multi-start fashion. The initial solutions are randomly generated to provide a simple form of diversification. A time limit is set for each small, medium and large instance respectively at 100, 1000 and 10000 seconds. Thus during the given time period, each algorithm will try a number of different initial solutions. To capture the performance of each algorithm on each instance, we record the following values: the best-found solution, the number of initial solutions tried during the given time period, the number of times the best-found solution is repeatedly hit, and the average elapsed time for detecting the best-known solution (calculated as dividing the number of hit times into the elapsed time the best-found solution is last detected).


                        Tables 1
                        , 2
                        and 3
                        respectively present the computational statistics of the three algorithms on the small, medium and large instances. In each table, columns 1 and 2 give the instance name and the previous best-known solution obtained by Karapetyan and Punnen (2012). Columns 3–17 report the computational statistics of the three algorithms: the deviation between our best-found solution and the previous best-known solution (Dev), the number of initial solutions tried during the given time period (#Init), the number of times our best-found solution is repeatedly detected (#Hit), the success rate defined as #Hit/#Init (Ratio), and the average time needed to reach the best-found solution (t).


                        Table 1 reports the computational statistics on the 35 small instances. For all the instances, each algorithm can reach the best-known solutions efficiently and consistently. For each small instance, the needed computing time is usually less than 1 millisecond. We also conjecture that for all these 35 small instances the current best-known solutions are already optimal. (Each of them usually is repeatedly hit more than 100,000 times.)


                        Table 1 also reveals some individual properties of each algorithm. For the seven Biclique instances, the performance of the hybrid method and the flip-float coordinate ascent method is roughly the same. They have significantly higher success rate than the one-flip tabu search algorithm. For the other 28 instances, the performances of the hybrid method and the one-flip tabu search algorithm are at the same level and are better than the flip-float coordinate method in terms of success rate. These observations show that the hybrid method inherits good properties from both the one-flip tabu search algorithm and the flip-float coordinate method.


                        Table 2 gives the computational statistics of the three algorithms on the 25 medium sized instances. The hybrid method and the one-flip tabu search algorithm successfully improve the previous best-known solutions on 12 instances and 11 instances respectively. The flip-float coordinate method fails to reach the previous best-known solutions on most instances within the given time limit. However, on the five Biclique instances where the one-flip tabu search algorithm’s performance is relatively poor, the flip-float coordinate method can improve the previous best-known solutions on two instances, demonstrating that its behavior in some sense complements that of the one-flip tabu search algorithm. Compared with the one-flip tabu search method, the hybrid method usually finds better solutions on the 10 Biclique and BMaxCut instances. For the other 15 instances, the best-found solutions are the same on each instance. However, the hybrid method is generally more robust because it usually has a smaller #Init value but a larger #Hit value.

As shown in Table 3, the hybrid method and the one-flip tabu search algorithm can improve most of the previous best-known solutions within the given time limit on the 25 large instances. The flip-float coordinate method performs best on the five Biclique instances; improving four previous best-known solutions. However, it fails to improve 18 out of the other 20 instances. Compared with the one-flip tabu search algorithm, the hybrid method usually has a smaller #Init value on each instance but is able to find better solutions on 21 out of the 25 instances. In addition, we conjecture that for these 25 large instances, most of the current best-found solutions are not optimal, because the #Hit value is usually 1. If the time limit is set to larger values, it may be possible to find better solutions.

In summary, our experimental results reveal that the one-flip tabu search algorithm performs well on most of the instances except the Biclique instances (as opposed to our hybrid method incorporating the TS approach, which does well on all problems). The flip-float coordinate method is generally inferior to the one-flip tabu search algorithm but performs significantly better on the Biclique instances. The hybrid method which integrates the one-flip tabu search algorithm and the flip-float coordinate ascent method shows better performance than both of them in the following three ways: (1) it has good performance regardless of the problem instance; (2) it is more robust; (3) its solution quality is generally better.

Since BBQP can be formulated as a mixed integer program (MIP), one can use any MIP solver as a heuristic by restricting its running time. To compare the performance of our heuristics to such a ready-made heuristic algorithm we used the general purpose MIP solver CPLEX (IBM, 2010). We express the BBQP problem as an MIP problem using the formulation of Karapetyan and Punnen (2012):

                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             Maximize
                                             
                                          
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   
                                                      q
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      z
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                
                                                   c
                                                   i
                                                
                                                
                                                   x
                                                   i
                                                
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   d
                                                   j
                                                
                                                
                                                   y
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             Subject
                                             
                                             to
                                          
                                       
                                       
                                       
                                          
                                             
                                                z
                                                
                                                   i
                                                   j
                                                
                                             
                                             ≤
                                             
                                                x
                                                i
                                             
                                             
                                             
                                             for
                                             
                                             
                                             i
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             m
                                             ;
                                             j
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             n
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                z
                                                
                                                   i
                                                   j
                                                
                                             
                                             ≤
                                             
                                                y
                                                j
                                             
                                             
                                             
                                             for
                                             
                                             
                                             i
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             m
                                             ;
                                             j
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             n
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                z
                                                
                                                   i
                                                   j
                                                
                                             
                                             ≥
                                             
                                                x
                                                i
                                             
                                             +
                                             
                                                y
                                                j
                                             
                                             −
                                             1
                                             
                                             
                                             for
                                             
                                             
                                             i
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             m
                                             ;
                                             j
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             n
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                x
                                                i
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                             
                                             for
                                             
                                             
                                             
                                                i
                                                =
                                                1
                                                ,
                                                ⋯
                                                ,
                                                m
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             0
                                             ≤
                                             
                                                y
                                                j
                                             
                                             ≤
                                             1
                                             
                                             
                                             for
                                             
                                             
                                             
                                                j
                                                =
                                                1
                                                ,
                                                ⋯
                                                ,
                                                n
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             0
                                             ≤
                                             
                                                z
                                                
                                                   i
                                                   j
                                                
                                             
                                             ≤
                                             1
                                             
                                             
                                             for
                                             
                                             
                                             i
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             m
                                             ;
                                             j
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             n
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The results are summarized in Tables 4
                        and 5
                        , clearly establishing that our metaheuristic algorithms possess significant advantages over this ready-made general purpose heuristic in terms of efficiency as well as solution quality. In our experiments, we set the time limit of CPLEX the same as the time limit given to the three metaheuristic algorithms. We also tested CPLEX as a heuristic by doubling this time limit. It may be noted that based on the experiments reported by Karapetyan and Punnen (2012) the CPLEX solver failed to find optimal solutions on most instances of size larger than 40 × 50 in 5 hours. In our experiments, we set the CPLEX parameter MIPEmphasis to 1, so that CPLEX put more emphasis on finding good feasible solutions and less emphasis on proof of optimality.

For small instances, CPLEX obtained optimal solutions within the allowed time (with proof of optimality) for 16 out of 35 problems and obtained the best known solutions for 27 out of 35 instances. For this class of instances, all our metaheuristic procedures obtained the best known solutions for all problems (including guaranteed optimal ones) and hit the first such solution in almost negligible time. By doubling the allowed running time, CPLEX matched the best known solutions for three additional instances.


For medium size instances, CPLEX obtained only the trivial solutions x = 0, y = 0 in 18 out of 25 cases and by doubling the allowed running time, it obtained non-trivial solutions for two additional (9 out of 25) instances. The quality of all these solutions is significantly lower than the quality obtained by our metaheuristic algorithms. For large scale instances, CPLEX reached allowed memory limit very quickly and hence we discontinued experiments with large instances.

The computational experiments demonstrate that the one-flip tabu search algorithm’s performance is significantly worse on the Biclique and BMaxCut instances than on the other instances. In order to obtain some insight into this phenomenon, we employ a fitness distance analysis on some representative instances to show their different landscape properties.

This analysis is performed on five medium instances: Biclique1000 × 1000, BMaxCut1000 × 1000, MatrixFactor1000 × 1000, MaxInduced1000 × 1000, Rand1000 × 1000. During our previous experiments, we have recorded one best-known solution for each instance. Here, we run the one-flip tabu search 1000 times from randomly generated starting points and obtain 1000 local minima. We get a sample point from each solution by calculating the gap between its objective value and the corresponding best-known value, and also the Hamming distance from the recorded best-known solution. For each instance, we then plot the 1000 sampled points to estimate the distribution of local optima.


                        Fig. 1
                        gives the fitness distance scatter plots for the five representative instances. Fig. 1 shows that, for the Biclique and BMaxCut instances, all the sampled local minima are far away from the corresponding best-known solutions. This phenomenon suggests that the best-known solutions may be located in a very narrow valley and are therefore hard to find. Especially for the Biclique instances, it seems that all the sampled points fall within two distinct regions. For the other three instances, the best-known solution is usually surrounded by many local optima whose objective values deteriorate with the increase of distance from the optimum. This kind of property makes the best-known solution relatively easier to detect, because the one-flip tabu search algorithm is able to escape from small local optimum traps and this property enables the algorithm to reach the best-known solution through a sequence of local minima with ascending objective value.

@&#CONCLUSION@&#

In this work, we developed three metaheuristic algorithms for BBQP. The first algorithm employs a classic one-flip neighborhood and a simple tabu search strategy. The second one is based on a new powerful flip-float neighborhood and a simple coordinate ascent method. The third algorithm integrates the first and second algorithms to create a hybrid method with the aim of inheriting good properties from each.

To assess the performance characteristics of the proposed algorithms, we have conducted systematic computational experiments on a set of 85 test instances. Our findings demonstrate that the hybrid method outperforms both the one-flip tabu search algorithm and the flip-float coordinate method: It generally finds better solutions than either component method on a wide range of test instances, and overall is more robust. In addition, the hybrid method is able to improve most of the previous best-known solutions on instances of medium and large size. We also compared our algorithms with CPLEX running in heuristic mode and all our algorithms generated superior outcomes in terms of solution quality and running time compared to this ready-made heuristic approach. In addition to the development and comparison of heuristics, we also performed a landscape analysis to compare the relative difficulty levels of the benchmark instances. This study revealed interesting properties of the structure of these problems.

Our findings suggest the potential value of algorithmic enhancements for future research: (1) introducing two-flip moves in the procedures currently studied; (2) combining the resulting methods to produce new hybrids; (3) using more advanced forms of tabu search for the direct one-flip and two-flip methods; (4) likewise using tabu search to exploit the flip-float neighborhood (in both one-flip and two-flip versions).

@&#ACKNOWLEDGMENTS@&#

We thank the anonymous reviewers whose detailed and valuable suggestions have significantly improved the manuscript.

@&#REFERENCES@&#

