@&#MAIN-TITLE@&#R-peaks detection based on stationary wavelet transform

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This work makes a R-peaks detection based on stationary wavelet transform (SWT).


                        
                        
                           
                           It has the same sampling time of the signal.


                        
                        
                           
                           It inherently leads to more accurate estimation of the QRS fiducial points.


                        
                        
                           
                           It detect R peaks over different types of arrhythmias and types of noise.


                        
                        
                           
                           Only one scale of SWT is applied, in order to reduce the computational complexity.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

ECG

Wavelet transform

R-peaks detection

Stationary wavelet transform (SWT)

@&#ABSTRACT@&#


               
               
                  Automatic detection of the QRS complexes/R-peaks in an electrocardiogram (ECG) signal is the most important step preceding any kind of ECG processing and analysis. The performance of these systems heavily relies on the accuracy of the QRS detector. The objective of present work is to drive a new robust method based on stationary wavelet transform (SWT) for R-peaks detection. The decimation of the coefficients at each level of the transformation algorithm is omitted, more samples in the coefficient sequences are available and hence a better outlier detection can be performed. Using the information of local maxima, minima and zero crossings of the fourth SWT coefficient detail, the proposed algorithm identifies the significant points for detection and delineation of the QRS complexes, as well as detection and identification of the QRS individual waves peaks of the pre-processed ECG signal.
                  Various experimental results show that the proposed algorithm exhibits reliable QRS detection as well as accurate ECG delineation, achieving excellent performance on different databases, on the MIT-BIH database (Se
                     =99.84%, P
                     =99.88%), on the QT Database (Se
                     =99.94%, P
                     =99.89%) and on MIT-BIH Noise Stress Test Database, (Se
                     =95.30%, P
                     =93.98%). Reliability and accuracy are close to the highest among the ones obtained in other studies. Experiments results being satisfactory, the SWT may represent a novel QRS detection tool, for a robust ECG signal analysis.
               
            

@&#INTRODUCTION@&#

The electrocardiogram (ECG) is one of the most important tools in the diagnosis of heart diseases. In the ECG, QRS complex may be the most significant feature among all ECG features. This explains the fact that its automatic detection is the most important step preceding any kind of ECG processing and analysis (classification, some denoising algorithm, etc.). The performances of these systems heavily rely on the accuracy of the QRS complexes/R-peaks detector. However, due to the non-stationary of the ECG signal, the physiological conditions and the presence of many artifacts, finding a robust and general algorithm for ECG feature detection is a tough task. Therefore, many researchers have proposed a number of methods of the QRS complexes detection in the ECG in the past years, but none of them proves universally acceptable accuracy. Thus, efforts are constantly deployed for their enhancement. For instance, methods based on the wavelet transform (WT) [1–7].

The wavelet transformation is used for the signal decomposition, localized simultaneously in time and frequency by inducing a change of basis for the signal in question. Generally, in this approach, the R peak is located at a point being the local maxima of several consecutive dyadic wavelet scales [2]. Based on this principle, many other researches were published on the beat detection using a WT filtering step [1,3–7].

There are two kinds of wavelet transform, the Continuous Wavelet Transform (CWT) and the Discrete Wavelet Transform (DWT). The continuous wavelet transform contains redundant signal information. In addition, a consumption calculation of the CWT made in [8] showed that it is four times more power consuming than the digital wavelet computing. Although this fact would give priority to the use of the discrete wavelet transform in real-time automatic R peaks detection applications, DWT suffers from three major limitations; (1) shift sensitivity, (2) poor directionality, and (3) absence of phase information. In addition, when employing the wavelet transform for detection purposes, this approach has two important drawbacks, the lack of shift invariance and the loss of resolution at coarse scales. These problems can be avoided by using an overcomplete wavelet transform. The so-called stationary wavelet transform 
                     [9] achieves this by taking timeshifts equal to all integer values instead of two. Even if the use of the stationary wavelet transform (SWT) in the ECG signal denoising is subject of particular interest in recent research [10,11]. Its use in the ECG signal waves detection was rarely investigated. Hence, we propose in this paper, a robust method based on SWT for QRS complex detection. The obtained results are promising the algorithm is able to detect R peaks over different databases and outperforms the other algorithms evaluated on the same database, according to recent publications.

The paper is organized as follows: Section 2 provides details on the proposed algorithm, including an accurate description of the choice of the decision parameters such as the choice of the wavelet, the desired level of signal decomposition and the coefficients detail selection. This section also includes presentation of the SWT based QRS/R-peaks detection method. The proposed method is tested in Section 3, followed by the results discussion in Section 4. Finally, Section 5 concludes the paper.

To further evaluate the proposed algorithm and allow comparison with other studies, manually annotated ECG signals from various databases are used. The MIT-BIH Arrhythmia Database (MITDB) [12], the QTDB [14] and the MIT-BIH Noise Stress Test Database (NSTDB) [13]. In addition to the 48 records (109,494 beats) as in [1] from MITDB and the 12 records (25,590 beats) from NSTDB, 105 records (86,892 beats) from the QTDB are used. Each record of QTDB contains 2 ECG channels digitalized with a sampling frequency of 250Hz.

The SWT is also known by a variety of names in the literature including the dyadic wavelet transform (i.e. dyadic in scales), maximal overlap transform and the redundant wavelet transform. SWT is an offshoot of DWT whereby the scales are dyadic but the time steps are not subsampled at each level and hence are not dyadic. In terms of redundancy, the SWT is an intermediate representation of the high redundancy CWT and the nonredundant DWT. It maintains a dyadic sampling of the scales, and therefore maintains a non-redundancy frequency, but carries an almost continuous and uniform sampling time [15]. It has an interest in our study because; unlike the DWT, the redundant representation of SWT makes it shift-invariant and suitable for applications such as edge detection, denoising and data fusion. Since the decimation of its coefficients at each level of the transformation algorithm is omitted, more samples in the coefficient sequences are available, with equal length wavelet coefficients at each level, and hence a better detection can be performed. The DWT cannot provide this feature. Which is critical for a robust detection of the QRS complexes. The SWT has a similar tree structured implementation as DWT [16], without any decimation (sub-sampling) step as shown in Fig. 1
                        . We can write a general transformation equation of SWT based on the coefficients c
                        
                           j,k
                         calculated as follows:
                           
                              (1)
                              
                                 
                                    
                                       c
                                       
                                          j
                                          ,
                                          k
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          n
                                          ∈
                                          z
                                       
                                    
                                    
                                       x
                                       (
                                       n
                                       )
                                       
                                          
                                             ψ
                                             ′
                                          
                                          
                                             j
                                             ,
                                             k
                                          
                                       
                                       (
                                       n
                                       )
                                       ,
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    ψ
                                    ′
                                 
                                 
                                    j
                                    ,
                                    k
                                 
                              
                              (
                              l
                              )
                           
                         is the discrete wavelet defined by:
                           
                              (2)
                              
                                 
                                    
                                       
                                          ψ
                                          ′
                                       
                                       
                                          j
                                          ,
                                          k
                                       
                                    
                                    (
                                    l
                                    )
                                    =
                                    
                                       2
                                       
                                          −
                                          (
                                          j
                                          /
                                          2
                                          )
                                       
                                    
                                    
                                       ψ
                                       
                                          0,0
                                       
                                    
                                    (
                                    
                                       2
                                       
                                          −
                                          j
                                       
                                    
                                    (
                                    l
                                    −
                                    k
                                    )
                                    )
                                    ,
                                 
                              
                           
                        
                     

The wavelet coefficients are given by ca
                        
                           j,k
                         
                        and cd
                        
                           j,k
                        , which represent the approximate (scaling) coefficients and detail (wavelet) coefficients respectively, generated through the convolution chain of the original signal sequence x(n) and level-adaptive size-varying highpass filter h
                        1 and lowpass filter g
                        1 respectively, as shown in Fig. 1.

Thus, the first scale and detail coefficients ca
                        1,k
                         and cd
                        1,k
                         of the SWT can be calculated from a convolution of the input signal x(n) with highpass filter h
                        1 and lowpass filter g
                        1 respectively, as:
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                c
                                                
                                                   a
                                                   
                                                      1
                                                      ,
                                                      k
                                                   
                                                
                                                (
                                                n
                                                )
                                                =
                                                ∑
                                                
                                                   
                                                      h
                                                      1
                                                   
                                                   (
                                                   n
                                                   −
                                                   τ
                                                   )
                                                   x
                                                   (
                                                   τ
                                                   )
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                c
                                                
                                                   d
                                                   
                                                      1
                                                      ,
                                                      k
                                                   
                                                
                                                (
                                                n
                                                )
                                                =
                                                ∑
                                                
                                                   
                                                      g
                                                      1
                                                   
                                                   (
                                                   n
                                                   −
                                                   τ
                                                   )
                                                   x
                                                   (
                                                   τ
                                                   )
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This can be generalized to the different coefficients scales by:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                c
                                                
                                                   a
                                                   
                                                      j
                                                      ,
                                                      k
                                                   
                                                
                                                (
                                                n
                                                )
                                                =
                                                
                                                   
                                                      ↑
                                                      
                                                         2
                                                         
                                                            j
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               h
                                                               1
                                                            
                                                         
                                                      
                                                      *
                                                      c
                                                      
                                                         a
                                                         
                                                            j
                                                            −
                                                            1
                                                            ,
                                                            k
                                                         
                                                      
                                                   
                                                
                                                =
                                                ∑
                                                
                                                   
                                                      h
                                                      j
                                                   
                                                   (
                                                   n
                                                   −
                                                   τ
                                                   )
                                                   c
                                                   
                                                      a
                                                      
                                                         j
                                                         −
                                                         1
                                                         ,
                                                         k
                                                      
                                                   
                                                   (
                                                   τ
                                                   )
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                c
                                                
                                                   d
                                                   
                                                      j
                                                      ,
                                                      k
                                                   
                                                
                                                (
                                                n
                                                )
                                                =
                                                
                                                   
                                                      ↑
                                                      
                                                         2
                                                         
                                                            j
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               g
                                                               1
                                                            
                                                         
                                                      
                                                      *
                                                      c
                                                      
                                                         a
                                                         
                                                            j
                                                            −
                                                            1
                                                            ,
                                                            k
                                                         
                                                      
                                                   
                                                
                                                (
                                                k
                                                )
                                                =
                                                ∑
                                                
                                                   
                                                      g
                                                      j
                                                   
                                                   (
                                                   n
                                                   −
                                                   τ
                                                   )
                                                   a
                                                   
                                                      d
                                                      
                                                         j
                                                         −
                                                         1
                                                         ,
                                                         k
                                                      
                                                   
                                                   (
                                                   τ
                                                   )
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              ↑
                              
                                 2
                                 
                                    j
                                    −
                                    1
                                 
                              
                              
                                 
                                    
                                       h
                                       1
                                    
                                 
                              
                              =
                              
                                 h
                                 j
                              
                              (
                              n
                              )
                           
                         is the over-sampling of the low-pass filter h
                        
                           j−1(n) coefficients and 
                           
                              ↑
                              
                                 2
                                 
                                    j
                                    −
                                    1
                                 
                              
                              
                                 
                                    
                                       g
                                       1
                                    
                                 
                              
                              =
                              
                                 g
                                 j
                              
                              (
                              n
                              )
                           
                         is the over-sampling of the high-pass filter g
                        
                           j−1(n) coefficients, which are given by:
                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     g
                                                                     i
                                                                  
                                                                  (
                                                                  2
                                                                  n
                                                                  )
                                                                  =
                                                                  
                                                                     g
                                                                     
                                                                        i
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                                  (
                                                                  n
                                                                  )
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     g
                                                                     i
                                                                  
                                                                  (
                                                                  2
                                                                  n
                                                                  +
                                                                  1
                                                                  )
                                                                  =
                                                                  0
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     h
                                                                     i
                                                                  
                                                                  (
                                                                  2
                                                                  n
                                                                  )
                                                                  =
                                                                  
                                                                     h
                                                                     
                                                                        i
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                                  (
                                                                  n
                                                                  )
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     h
                                                                     i
                                                                  
                                                                  (
                                                                  2
                                                                  n
                                                                  +
                                                                  1
                                                                  )
                                                                  =
                                                                  0
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

One can clearly see from the previous equation, that the highpass filter h
                        1 and lowpass filter g
                        1 are upsampled by a factor of two at each stage. Therefore, the decomposition coefficients (approximation and detail) have the same length Nc as the original signal x(n), where Nc
                        =2
                           j
                        , making the output signal more accurate than the one obtained with DWT.

Although a large variety of wavelets, are available, not all of them are suitable for peaks detection. There is no absolute rule for the choice of wavelets, but it is of utmost importance that the wavelet function corresponds closely to the processed signal [17].

In this work, the Daubechies2 wavelet is chosen because of its similar shape to the QRS complex and because of its energy spectrum is concentrated around the low frequencies [18]. The wavelet decomposition structure of MITDB record 100 up to 8 detail coefficients using Daubechies2 wavelet performed in [11] for denoising, is shown in Fig. 2
                           .

A comparison between the original ECG signal and the reconstructed signal is also shown in Fig. 4.

The level of the wavelet transform affects the number and location of peaks in a signal. Choosing the desired level of decomposition is connected to the frequency components necessary for the signal analysis over a given number of samples. Since SWT requires that the number of signal sample is a power of two, the following relationship must be satisfied:
                              
                                 
                                    
                                       
                                          2
                                          N
                                       
                                       =
                                       n
                                    
                                 
                              
                           where N
                           =the total number of decomposition levels and n is the total number of the signal samples. Since most of the ECG signal energy is located within the first and fifth scale [11], the eighth scale is chosen in this study.

While the mother wavelet can easily be chosen based on its characteristics and resemblance with a QRS wave, the ideal scale(s) at which the QRS are matched is harder to guess a priori. Thus, the several selections of detail coefficients for the detection of QRS complexes were proposed in the literature. In [19] Mahmoodabadi suggests the selection of details d3–d5 for R peaks detection. Saxena [18] in turn, uses the detail signal d4 for QRS peak detecting, while in the work of [20,1] five levels of wavelet, d1–d5, were used with a dyadic decomposition. Note that in all these works, DWT is used. In our case, the choice of detail coefficients is based on the following analysis.

Most of the normal ECG signal energy is concentrated in a time interval of the QRS complex of about 80ms, and in a frequency band ranging from 3Hz to 40Hz [19].


                              Fig. 3
                              
                               shows the plot of the mean energy of the eight scales of the entire MITDB record database. One can see that it has a maximum at the level of the detail coefficient cd4, which means that cd4 detail coefficient is a good candidate to be used in QRS complex detection.

Here, we look for the frequency components of the detail signals that is correlated with that of the QRS complex. For this, the Fourier transform of each detail signal is carried out. From Fig. 4, we observe that the bandwidth of the cd4 detail signal happens to be within 2.5–39.5Hz, which is similar to that of the QRS complex.

According to this frequency distribution of the ECG signal, it can be noted that the high-frequency components of the ECG signal decreases as the lower order details removed from the original signal.

In addition to the above two analyses, the mean cross-correlation analysis between all detail signals and the original ECG signal of the entire MITDB record database was performed. This gives us a relationship in the time domain between the original QRS and the decomposed signals (signal details). The results are shown in Fig. 5
                              .

From this figure, we can notice that the cross-correlation coefficient of detail cd4 has the highest value, which means that the detail coefficient signal cd4, is the best placed to approximated the QRS signal in the time domain. Finally, we can conclude that the detail coefficient cd4 is the best choice to be used for QRS detection.

@&#METHODOLOGY@&#

The objective of present work is to drive an algorithm for the detection of the QRS complex and the locating of the R peaks, using SWT. To achieve this objective the following processing are performed.

ECG signals can be affected by various types of noise, such as motion artifacts, baseline drift, electromyogram (EMG), electrode motion artifact of even power-line interferences. These have to be suppressed during the analog data acquisition or afterwards in a digital signal preprocessing. Wavelet transform, due to its sparsity, locality, and multi-resolution nature, has emerged as a simply yet effective de-noising tool [1,3–5,7]. However, the disadvantage of filtering with WT with down sampling is that the result is dependent on the choice of the beginning of the filtering and the need for interpolation in reverse transform, which is always a source of errors. Thus, in this work the SWT, which preserves the length of the decomposed signal in all detail and approximation coefficient signals, is used. Based on [10,21], our ECG signals denoising algorithm, involves four main steps:
                              
                                 1.
                                 Removing the baseline wandering using DWT [7], by decomposition down to level 9, and using the wavelet filter Symlet 4.

Calculating the SWT for the noisy signal with a Symlet4 wavelet as basis function and decomposition up to 6 levels.

Zeroing or modifying certain coefficients by hard shrinkage function with Empirical Bayes posterior median thresholding.

Reconstructing the signal from the modified coefficients, with the aid of the Inverse Stationary Wavelet Transform (ISWT) to produce a denoised signal.

Performance of this algorithm is tested on NSTDB and evaluated based on Signal to Noise Ratio (SNR) and Mean Square Error (MSE) [22]:
                              
                                 (6)
                                 
                                    
                                       SNR
                                       =
                                       10
                                       log
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                N
                                                
                                                   i
                                                   =
                                                   1
                                                
                                             
                                             x
                                             
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                2
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                N
                                                
                                                   i
                                                   =
                                                   1
                                                
                                             
                                             
                                                
                                                   (
                                                   x
                                                   (
                                                   i
                                                   )
                                                   −
                                                   
                                                      x
                                                      ¯
                                                   
                                                   (
                                                   i
                                                   )
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (7)
                                 
                                    
                                       MSE
                                       =
                                       
                                          1
                                          N
                                       
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          N
                                       
                                       
                                          
                                             (
                                             x
                                             (
                                             i
                                             )
                                             −
                                             
                                                x
                                                ¯
                                             
                                             (
                                             i
                                             )
                                             )
                                          
                                          2
                                       
                                    
                                 
                              
                           where N is the length of the ECG signal, x(i) is the simulated signal before noise is added and 
                              
                                 
                                    x
                                    ¯
                                 
                                 (
                                 i
                                 )
                              
                            is the filtered signal with added noise. Fig. 6
                            shows the signal on record number 118e24 added with Gaussian noise, along with the denoised ECG signal. SNR value of noisy signals 118e24, was found to be 25.21dB. Upon denoising with our approach, SNR value get enhanced to 34.4dB and MSE value to 0.00073.

From above results, we can see that our de-noising algorithm provides a good noise suppression not only by mean of visual inspection, but also by mean of SNR and MSE. Higher value of SNR and lower value of MSE shows that, the reconstructed ECG signal contains minimum distortion and depicts better noise suppression respectively.

Our algorithm, although based on the multiscale approach proposed by Li in [2] is quite different. One of the novelties with respect to [2] is that in our algorithm, a single scale (cd4) is taken into account. This scale was found to be the optimal common scale for the QRS complex detection. Using the information of local maxima, minima and zero crossings of the SWT at this scale, the algorithm identifies the significant points for detection and delineation of the QRS complexes, as well as detection and identification of the QRS individual waves (Q, R, S). From this representation, a decision rule is applied, defined as a search for a maxima modulus lines exceeding an adaptively threshold t
                           
                              QRS
                           . This threshold is proportional to RMS (root mean square) value of SWT squared detail coefficients cd4. Thus for the QRS complex detection, of each 211 samples set we take:
                              
                                 (8)
                                 
                                    
                                       
                                          t
                                          
                                             Q
                                             R
                                             S
                                          
                                       
                                       =
                                       0.25
                                       R
                                       M
                                       S
                                       (
                                       c
                                       d
                                       
                                          4
                                          2
                                       
                                       )
                                    
                                 
                              
                           
                        

This amplitude threshold is used to define an evaluation window f
                           
                              QRS
                           . This window allows us to determine whether a pair of maxima modulus of opposite sign represent a QRS (see Fig. 7
                           ).

The size of the evaluation window f
                           
                              QRS
                           , is chosen equal to 40ms in order to detect the most abrupt transitions in the ECG, i.e. the passage characteristic of the R-wave to S-wave in the QRS. In addition, in our context, a new detection of the signal is allowed only 200ms after the previously detected QRS complex. This value corresponds to the duration of the refractory phase of the potential action. Another step in our approach is to eliminate the redundant or isolated maxima and minima by defining the new thresholds named 
                              
                                 
                                    γ
                                    
                                       Q
                                       R
                                       
                                          S
                                          n
                                       
                                    
                                 
                              
                           , 
                              
                                 
                                    γ
                                    
                                       Q
                                       R
                                       
                                          S
                                          P
                                       
                                    
                                 
                              
                           :
                              
                                 (a)
                                 The 
                                       
                                          
                                             γ
                                             
                                                Q
                                                R
                                                
                                                   S
                                                   n
                                                
                                             
                                          
                                       
                                     threshold is used to find negative significant slopes. It is proportional to the RMS value of SWT squared detail coefficients cd4 within the search window f
                                    
                                       QRS
                                    :
                                       
                                          (9)
                                          
                                             
                                                
                                                   γ
                                                   
                                                      Q
                                                      R
                                                      
                                                         S
                                                         n
                                                      
                                                   
                                                
                                                =
                                                0.4
                                                R
                                                M
                                                S
                                                (
                                                c
                                                d
                                                4
                                                
                                                   
                                                      (
                                                      n
                                                      )
                                                   
                                                   2
                                                
                                                )
                                                ,
                                                 
                                                n
                                                ∈
                                                
                                                   f
                                                   
                                                      Q
                                                      R
                                                      S
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

The 
                                       
                                          
                                             γ
                                             
                                                Q
                                                R
                                                
                                                   S
                                                   P
                                                
                                             
                                          
                                       
                                     threshold is used to find significant slopes of the S wave. It is proportional to RMS value of SWT squared detail coefficients cd4 within the search window f
                                    
                                       QRS
                                    
                                    :
                                 

Thus, after rejecting all isolated or redundant (not significant) maxima modulus, the zero crossing of the SWT at the fourth scale between a positive maximum-negative minimum pair is marked as a QRS (Fig. 10). The QRS onset (end) is also defined by the zero crossing before (after) the first (last) significant slope of the QRS (Fig. 8
                           ).

In Fig. 9
                           
                           , some excerpts of the MITDB ECG records representing different kinds of QRS morphologies, have been chosen to illustrate the robustness of the proposed detector.

The algorithm departs from the position given by the QRS complex detector. The R-peak position of the original preprocessed signal is detected in the adjacent zero crossing located between the previously detected pair of maximum modulus with opposite signs at scale cd4 (see Fig. 10). This principle may also be used to detect the Q and S peaks. Since the detection of Q and S peaks is directly associated to the R-peak detection, the thresholds 
                              
                                 
                                    γ
                                    
                                       Q
                                       R
                                       
                                          S
                                          n
                                       
                                    
                                 
                              
                           , 
                              
                                 
                                    γ
                                    
                                       Q
                                       R
                                       
                                          S
                                          P
                                       
                                    
                                 
                              
                            being proportional to the maximum slope of the R wave, they are used to identify other significant slopes of the Q and S peaks.

In a normal QRS the locals minima of the Q and S peaks are located around the R-wave in the range of 0.12 millisecond (43 samples for a sampling rate of 360Hz). This cannot be generalized to the pathological QRS. In this case the QRS complex is wide and has a length greater than 0.12 milliseconds; hence we increase of the interval search to 0.16 milliseconds. A last step of the R-peaks detection makes sure that Q and S spikes have not been wrongly labeled as a R. If two or more R spikes were detected in a window smaller than 250ms (two heartbeats cannot physiologically happen in less than 250ms [20]), the algorithm keeps only the peak which has the highest value on the original ECG.

@&#RESULTS@&#

To evaluate the performance of the R peak detection algorithm we use rates including false negative (FN), which means failing to detect a true beat (QRS complexes have not been detected as QRS complexes), and false positive (FP), which represents a false beat detection (non-QRS complexes detected as QRS complexes). By using FN and FP the sensitivity (SE), positive prediction (+P) and detection error (DER) can be calculated using the following equations respectively, as suggested in [1]:
                        
                           •
                           The sensitivity measured by:

the positive predictivity (+P) defined as:

Detection error (DER) defined as:

These measures were determined by the decision-making rule that a beat is true when it is detected within a search window in our case 100ms as in [23], from the annotated time for each record, otherwise false (in compliance with ANSI/AAMI-EC57:1998 standard).


                     Figs. 11–14
                     
                     
                     
                      show an example of the Q, R and S peaks detection. The annotated and the detected waves are reported. Thus, a false positive occurs when the delineation process locates a characteristic point, which was not annotated. A false negative is considered when the delineation process fails to locate the annotated fiducial point within the above-mentioned tolerance.

The R-peak detection rates for the first-channel (each) of 48 ECG recordings of the MITDB by our algorithm are summarized in Table 1
                     .

The proposed method produces 178 FN beats and 126 FP beats for a total detection failure of 304 beats, and succeeded in detecting correctly 99.72% of the ECG beats. However, the individual detection accuracies of the ECG records vary from 98.64% to 100% depending on the characteristics of normal and pathological ECG signals, and different noises. In detail, we were able to achieve very high results such as the sensitivity of 99.84% and the positive predictive rate of 99.88%. Generally, detection problems may occur for the MITDB, ECG records 104, 105, 108, 200, 203, 210, and 228 containing, high-grade noise and artifact. Records 108, 111, 112, 116, 201, 203, 205, 208, 210, 217, 219, 222, and 228 including, severe baseline drifts and abrupt changes. Records 201, 202, 203, 219 and 222 exhibit various irregular rhythmic patterns. Records 201, 219 and 232 include long pauses up to 6s in duration. Records 108 and 222 contain tall sharp P waves. Record 113 has tall sharp T waves. For these recordings, most algorithms have a quite high number of false positive detections. However, the proposed algorithm achieves a significant improvement in the detection of R-peak under time-varying QRS complex morphology and different kinds of noise and artifacts.

Thus, for the noisy records 104, 105, and 108. The proposed method has a total detection failure of 73 beats (33 FP beats and 40 FN beats). The Rec 201 has a detection failure rate of 0.87% (17 beats), and the Rec 203 has a detection failure rate of 0.87% (26 beats).

Next, a quantitative study of the noise tolerance test is performed. The performance of the proposed method with the presence of the noise was evaluated for the QRS-complex detection with the NSTDB [13], on records 118exx (2278 annotated beats) and records 119exx (1987 annotated beats) respectively (xx, being the SNR value). The performance of our detector is quit good for SNR as low as 6dB with high sensitivity values (above 95%) as well as high positive prediction (about 95%). The results are depicted Table 2
                     .

In compliance with [24] and to allow the use of the proposed algorithm on QTDB with the same sampling frequency, each record was re-sampled to 360Hz using the “xform” program available from [13]. Table 3
                      shows the performance of the QRS detection algorithm on MITDB and QTDB. Moreover, it summarizes the performances across these databases and compares them to other reported results.

Referring to Table 3, it can be noticed that even if the performance of current R-peaks detection algorithms is not completely assessed in terms of parameter choice, and numerical efficiency, the performance of our algorithm, is located in a good enough position compared to the other methods, which used MITDB, NSTDB and QTDB ECG databases respectively.

Moreover, many of the QRS algorithms were not tested against a standard database or any database at all. Many researchers have excluded records from the MITDB [12] for the sake of reducing noise in the processed ECG signals; consequently, their algorithms appeared to achieve improved performance. This issue makes difficult to compare and evaluate the performance results of the proposed algorithm, with previously published algorithms. For example, it is worth noting that Li et al. [2] scored higher performance, a sensitivity of 99.89% and a specificity of 99.94%, than the proposed algorithm. This is because Li et al. excluded files 214 and 215 from the MITDB; the same can be formulated for the four methods that precede ours it can be noticed that their TB number is less than ours (see Table 3), and therefore their algorithm is not superior in terms of performance.

Here is an example based on the proposed detector: If records 105, 104 and 108 are excluded from this study, the proposed detector scores SE of 99.88% and VPP of 99.91%, which does not reflect the real performance of the algorithm. Thus, as discussed above, the number of records affects the overall accuracy of all detection algorithms.

In addition, the QTDB where the detector scored an SE of 99.94% and a +P of 99.89%, over 86,892 beats. The QRS detection accuracy is an important factor to be considered. Because the QRS contains most of information about cardiac and it is the basis of the complete delineation of ECG waveform. Thus, the performance of the detection and delineation of the QRS-complexes of the described methods was evaluated with the QTDB [14], according the metrics proposed in [1,4]. The mean μ and standard deviation σ (STD) of the differences between automatic detection and cardiologists annotations are computed in order to quantify the performance of the QRS detection algorithm (QRS onset and offset detection), in each ECG record. Moreover, as QTDB is widely used in the literature, the results using this database enable direct comparisons with state-of-the-art ECG delineation algorithms as shown in Table 4
                     . The final row lists the tolerance limits for automatic feature extraction algorithms as were defined by the CSE Working party in [36].

@&#DISCUSSION@&#

In this paper, the ECG records from three different databases are used to evaluate the proposed method. The MITDB is used to evaluate proposed methods for the R peaks detection. In particular, the sensitivity was used for evaluating the ability of the algorithm to detect true beats, the positive predictivity was used for evaluating the ability of the algorithm to discriminate between true and false beats, and the detection error rate was used for evaluating the accuracy of the algorithm. Unlike previous DWT based methods [1,2,4], the present only uses one scale (24), for QRS detection. Since the decimation of the coefficients at each level of the transformation algorithm is omitted, more samples in the coefficient sequences are available and hence a better outlier detection can be performed. The R-peaks detection showed an excellent performance on the MITDB, achieving a sensitivity of 99.84% and a positive predictive value of 99.88% on 109,494 annotated beats, as shown in Table 1.

In addition, the NSTDB is used to evaluate the noise sensitivity of the proposed R peaks detection method, and as expected, the results on the noise-stress test presented in Table 2, shows its immunity to the noise. This is mainly due to the effectiveness of the denoising algorithm used in this work [10], since it is known that a good pre-processing technique can basically help to improve the QRS peak detection [39].

As summarized in Table 2, our method indicate a good success rate for an SNR of more than or equal to 12dB, where both the Se and the +P values are above 99%. The presented method still demonstrates an acceptable sensitivity and positive predictivity for an SNR of less than 12dB, where Se value dropped below 96% and the +P value dropped below 95%.

As shown in Table 3, the algorithm was able to achieve very high results comparable to [33–35] indicating a sensitivity of 95.30% and positive predictive rate of 93.98% on 25,590 annotated beats. One can notice, that even the second method proposed by Li [34] indicate the best sensitivity value (98.64%), its shows also the worst positive predictivity value (77.61%). From these results, it can be concluded that our algorithm achieves the best results for noisy ECG signals, while reasonably preserving the clinical features of ECG signals at the same time.

Furthermore, in order to check the reliability of our algorithm, we tried to compare our work with other works on the QTDB. The QRS detection performance of four selected algorithms together with our algorithm are summarized in Table 3. With a sensitivity about 99.94%, positive predictive equal to 99.89% and detection error rate of (0.18%), the proposed algorithm among the compared algorithms shows the second best detection error rate behind the algorithm proposed by Ghaffari et al. [5] (0.12%). Here, we should mention that the underling result is very encouraging since each of the 105 records were re-sampled from 250Hz to 360Hz.

In the present work, the width of the search window adopted in the computation of TP was set to 100ms [22]. The use of this window gave similar result to those with a wider windows (for instance, in [4] the width of the search window was set to 320ms), since the SWT preserves the important time aspect of the non-stationary ECG signal.

Sensitivity and positive predictive value of the ECG R-peak detector were comparable to the values reported by others, as shown in Table 3. Previous DWT-based methods [1,2], compute the adaptive thresholds in QRS detection t
                     
                        QRS
                      based on the root mean square of d
                     
                        n
                      coefficients at the scales of interest. In [1] RMS is computed over N
                     =216 samples excerpts, for the first three scales (21, 22, 23). In [2] RMS is emulated over N
                     =29 samples excerpts for the first four scales. RMS is computationally demanding, as it requires squaring and summing N coefficients and calculating a square root. Although the square root was emulated in [2], a considerable amount of computations is required for squaring large data excerpts. In the present method, which uses only one scale, all thresholds are calculated from few (local) coefficients, which dramatically reduce the computational effort. In particular, the computation of t
                     
                        QRS
                      by (6) only requires N
                     =24 data-points, compared to N
                     =29 in [2] and N
                     =216 in [1]. This observation also applies to 
                        
                           
                              γ
                              
                                 Q
                                 R
                                 
                                    S
                                    n
                                 
                              
                           
                        
                      and 
                        
                           
                              γ
                              
                                 Q
                                 R
                                 
                                    S
                                    P
                                 
                              
                           
                        
                     .


                     Table 4 lists accuracy results for QRS delineation attained from executing the proposed algorithm on 105 records from the QTDB. It shows that, in terms of standard deviation σ and mean error μ, which were around 4.5ms (1.6 samples, at F
                     
                        s
                     
                     =360 samples/s), and lower than 2ms (0.7 samples) respectively, the proposed algorithm, is around tolerances accepted by cardiologists [36], and slightly outperforms the other compared algorithms, when evaluated on the QT database, except the one proposed by [5].

Furthermore, in order to check the accuracy of the proposed algorithm for localization of the main deflection (either R peak or Q, S peak) and of the QRS boundaries. We design two algorithms: select the same wavelet basic, decomposition level, and thresholding method, but different transforms (DWT and SWT) respectively, and compare the QRS fiducial points estimation results, as shows in Fig. 15
                     .

The result depicted in Fig. 15 was expected. Since the temporal resolution on the 24 scale of the DWT is diminished (by a factor of 16) compared to the original timescale, this coupled with fact that we operate on a single resolution scale, and the need for interpolation in reverse transform, may inherently lead to less accurate estimation of the QRS fiducial points. In addition, since the SWT preserve the length of the decomposed signal in all detail and approximation coefficient signals, it lead to more accurate localization of R, Q and S peaks, as the QRS boundaries.

@&#CONCLUSIONS@&#

In this paper, a discrete stationary wavelet transform for the automatic detection of R-Peaks in ECG is introduced. The algorithm exploits the translations invariance of the SWT, which preserves the important time aspect of the non-stationary ECG signal, and is effective because it takes into account the nonstationarity of the signal. In order to reduce the computational complexity, only the coefficients at scale 24 obtained by the SWT is applied to detect the R-Peaks. It has the advantage, to have a same sampling time of the signal with respect to the DWT.

The performance of the proposed method is promising. It has been tested on different databases, with the MITDB and the QTDB for the R-peaks detection and QRS-complex delineation and the NSTDB for the noise sensitivity. The presented method achieved excellent performance on the MITDB (Se
                     =99.84%, P
                     =99.88%). The validation results with QTDB are good enough to meet the demand for QRS-complex detection (Se
                     =99.94%, P
                     =99.89%). Evaluation results on the NSTDB indicate that the algorithm is effective (Se
                     =95.30%, P
                     =93.98%). This confirms that the SWT filtering is sufficient for effective QRS detection in signals contaminated with higher noise amplitudes. Thus, this reliable robustness against strong noise, artifacts and probable severe arrhythmia(s) of NSTDB can be mentioned as important merits and capabilities of the proposed algorithm.

This new algorithm also exhibited very good accuracy in QRS delineator on QTDB, where the mean error between automatic and manual annotations was lower than 1 samples for all the characteristic points, and the associated average standard deviations outperforms the other algorithms evaluated on the same database, according to recent publications.

@&#REFERENCES@&#

