@&#MAIN-TITLE@&#Fully automated diabetic retinopathy screening using morphological component analysis

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper provides a fully automated diabetic retinopathy screening system.


                        
                        
                           
                           This system has the ability of retinal image quality assessment.


                        
                        
                           
                           The image quality assessment method is based on the visibility of retinal vessels.


                        
                        
                           
                           The DR detection method is capable of identifying different DR-related lesions.


                        
                        
                           
                           This method does not rely on any specific size or color of lesions.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Diabetic retinopathy screening

Retinal image quality assessment

Morphological component analysis (MCA) algorithm

@&#ABSTRACT@&#


               
               
                  Diabetic retinopathy is the major cause of blindness in the world. It has been shown that early diagnosis can play a major role in prevention of visual loss and blindness. This diagnosis can be made through regular screening and timely treatment. Besides, automation of this process can significantly reduce the work of ophthalmologists and alleviate inter and intra observer variability. This paper provides a fully automated diabetic retinopathy screening system with the ability of retinal image quality assessment. The novelty of the proposed method lies in the use of Morphological Component Analysis (MCA) algorithm to discriminate between normal and pathological retinal structures. To this end, first a pre-screening algorithm is used to assess the quality of retinal images. If the quality of the image is not satisfactory, it is examined by an ophthalmologist and must be recaptured if necessary. Otherwise, the image is processed for diabetic retinopathy detection. In this stage, normal and pathological structures of the retinal image are separated by MCA algorithm. Finally, the normal and abnormal retinal images are distinguished by statistical features of the retinal lesions. Our proposed system achieved 92.01% sensitivity and 95.45% specificity on the Messidor dataset which is a remarkable result in comparison with previous work.
               
            

@&#INTRODUCTION@&#

Diabetes mellitus (DM) has been identified as one of the leading causes of death, disability, and blindness in the world. According to World Health Organization (WHO) statistics, more than 285 million people around the world have DM and it is predicted to reach 439 million people by 2030 [1]. Diabetic retinopathy (DR) is the most common eye disease that affects patients with DM. DR is usually asymptomatic at its early stage which may only be recognized when changes in the retina have progressed to the level that makes the treatment impossible. Accurate and early detection of diabetic retinopathy is essential to reduce the blindness around the world. Therefore, maximum screening and timely re-screening uptake is highly recommended to diabetic patients. While a majority of diabetic patients do not receive regular eye examination, the diagnosis is often made after beginning of partial vision loss. There are some factors preventing patients from getting regular follow-up, including the high costs of examination and treatment combined with the shortage of ophthalmologists, especially in rural areas [2]. Normally, eye examination should be carried out every 12 months and it includes capturing and analyzing retinal images to observe the early changes of spots [3]. Recent investigations have demonstrated that diabetic retinopathy can be measured from retinal fundus images. Fig. 1
                      shows normal and abnormal retinal images containing various abnormal signs. Microaneurysms that appear as small red spots may lead to the hemorrhages. The so-called bright lesions like hard exudates appear as bright yellow lesions in the fundus images. As diabetic retinopathy can only be diagnosed after analyzing retinal lesions, automated image analysis, not requiring the diagnosis of an ophthalmologist, appears as an attractive option. The perceived benefits of automated diagnosis are rapid, accurate, quantified, and cost-effective processing of a large number of images.

Nevertheless, there are some problems that hinder the development of a fully automated retinal image analysis system, including the need for assessing retinal images to ensure that their quality is higher than the grading standards [4]. In a DR system, a retinal image is considered to have a poor quality if it is difficult to provide any meaningful information for passing a reliable judgment [5]. Automated analysis of retinal images with poor quality may produce unreliable results. Therefore, evaluation of the image quality is a prerequisite for the development of automatic diabetic retinopathy screening system. The main factors that may affect the quality of retinal images are the patient's head or eye movement, poorly dilated pupils, blinking, and media opacity. Head or eye movement may lead to the generation of out-of-focus and unevenly illuminated images. Poorly dilated pupils may also affect image illumination, creating dark low-contrast images [6]. In 2006, Zimmer-Galler [7] reported that 11% of the images in their study were unreadable. It was estimated that 25% of the poor quality images were produced by the lack of patients’ fixation, 25% by the lack of focus and pupil centering, and 25% by small pupil size, media opacity and instrument failure. A specific cause could not be identified for the rest of unreadable images. Some examples of poor and good quality retinal images are shown in Fig. 2
                     .

In this paper, a fully automated diabetic retinopathy screening system with the ability of image quality assessment is developed. In the proposed system, a pre-screening algorithm is used to assess the quality of retinal images. If the quality of the image is not satisfactory, it is examined by an ophthalmologist and reacquired if necessary. Otherwise, the image is processed for DR detection. Most of the existing DR detection algorithms require the development of a specific segmentation technique for each abnormality found in the retina [8]. An algorithm that allows multiple lesions detection without requiring different segmentation algorithms is important in the development of a screening system. The main contribution of this paper is providing a novel DR detection method that is effective in dealing with the mentioned problem. This solution is based on Morphological Component Analysis (MCA) algorithm [9] which is effective in separating the contents of images. The proposed DR detection algorithm is capable of identifying different DR-related lesions such as microaneurysms, hemorrhages, and exudates using only one algorithm. This algorithm does not rely on any specific size or color of lesions, as required by some of the current lesion detectors in the literature. Extensive experiments have been conducted to demonstrate the effectiveness of this new algorithm with the experimental results on the Messidor [10] dataset showing that the proposed method is comparable to the state-of-the-art DR detection approaches.

The remainder of this paper is organized as follows. Section 2 summarizes the state-of-the-art automatic retinal image quality assessment and diabetic retinopathy detection algorithms. In Section 3, multi-scale geometric analysis algorithm is briefly described and then the Shearlet and Contourlet transforms are elaborated. The proposed system is presented in Section 4. Extensive experimental validation is reported in Section 5. Finally, concluding remarks and suggestions for future studies are given in Sections 6 and 7, respectively.

@&#RELATED WORKS@&#

The first part of this section is devoted to the review of literature on the retinal image quality assessment algorithms. The second part also reviews the diabetic retinopathy detection methodologies.

Several approaches have been developed to automatically determine the quality of retinal images. These approaches can be classified into two categories. The first category is based on generic image quality parameters such as sharpness and contrast. In 2001, Lalondey [11] proposed a method based on the histogram of edge magnitude and the local histogram of pixel gray-scale values to evaluate image focus and illumination. In this method, the quality of a given image is determined through the difference of its histogram and the mean histogram of a set of high quality images as a reference. In 2009, Davis et al. [12] focused their quality assessment on contrast and luminance features. In the same year, Bartling [13] demonstrated the application of sharpness and illumination parameters. The illumination was measured by an evaluation of contrast and brightness and the degree of sharpness was calculated from the spatial frequencies of the image. Moreover, Paulus et al. [14] employed a combination of image structure clustering, Heralick features and sharpness measures based on image gradient magnitudes for classifying poor quality retinal images. In 2012, Dias et al. [4] developed a quality assessment method based on a fusion of generic image quality indicators such as image color, focus, contrast, and illumination.

The second category of the approaches being made so far relies on the structural information of retinal images. This information requires segmentation of anatomical landmarks in the image. A combination of the field definition and image clarity was employed by Fleming el al. [15]. The clarity analysis was carried out by the vasculature of a circular area around the macula. In 2006, Niemeijer [16] introduced an algorithm based on the clustering of filter bank response vectors in order to obtain a compact representation of the image structures. The compact representation and image histograms were used to design a statistical classifier capable of distinguishing retinal images with a high or low quality. In 2008, Giancardo et al. [17] assessed the quality of retinal images based on the eye vasculature. Vessels’ density in the local patches were used as feature vectors for quality assessment. In 2011, Hunter et al. [6] proposed a method based on the clarity of retinal vessels within the macula region as well as the contrast between fovea area and background of the retina.

The main goal of the approaches in the first category is to use simple image measurements to estimate the image quality. These measurements avoid eye structure segmentation procedures which reduces the computational complexity [4]. On the other hand, approaches in the second category require anatomical landmarks segmentation which is both complex and error prone, especially in case of poor quality images. Although this is the main drawback of such approaches, the use of retinal structures rather than generic parameters can be helpful for evaluating the quality of retinal images. In this paper, we propose an automated retinal image quality assessment based on the visibility of retinal blood vessels, which is not solely dependent on segmentation algorithms.

As a challenging issue, diabetic retinopathy detection has been widely studied in the literature. Generally, diabetic retinopathy detection methods can be categorized into two groups: (1) bottom-up methods and (2) top-down approaches. In the former, accurate segmentation of retinal lesions is the basis for correct DR detection. These techniques acquire high accuracy rates. Furthermore, normally a technique developed for the detection of one kind of lesion cannot be directly used to detect another lesion. Thus, a combination of different segmentation algorithms is required to detect diabetic retinopathy. Yun et al. [18] proposed a method based on detecting and analyzing microaneurysms and hemorrhages for diabetic retinopathy detection. Nayak et al. [19] used a combination of hard exudates area and blood vessels by morphological techniques for diabetic retinopathy detection. Reza [20] also developed a rule-based algorithm based on hard exudates and cotton wool spots for DR screening. These pathological regions were segmented by some image processing techniques such as thresholding, morphological reconstruction and boundary tracing. In another research, Fadzil et al. [21] demonstrated the application of Foveal Avascular Zone (FAZ) area with Bayesian classifier for determining DR stages. Kumar [22] also classified normal and abnormal retinal images with the aid of blood vessels and optic disc parameters. A grading of the severity level of DR based on detection and analysis of microaneurysms and hemorrhages was proposed in Ref. [3]. In the same year, Hejab et al. [23] introduced a method based on the blood vessels area, FAZ area, the number of microaneurysms, and exudates area to determine diabetic retinopathy stages.

The top-down approaches aim to detect diabetic retinopathy with respect to the textural features of retinal images. These approaches typically do not require any segmentation algorithms. In a research, Khademi [24] introduced a method based on extraction of textural features from Wavelet coefficients in which described the relative homogeneity of localized areas of retinal images. Acharya et al. [25] also employed a combination of non-linear features of the higher-order spectra and SVM classifier for DR staging. Agurto et al. [8] used multi-scale Amplitude-Modulation–Frequency-Modulation (AM–FM) algorithm to discriminate between normal and abnormal retinal images. In another research, Esnaashari et al. [26] developed an algorithm based on Gabor features to classify normal and pathological retinal images. A year later, Acharya et al. [27] focused their DR detection algorithm on the features extracted from co-occurrence matrix and Run–Length–Matrix.

One of the disadvantages of bottom-up approaches is that they rely on the accurate segmentation of retinal lesions for DR grading. While lack of effective segmentation methods can negatively affect lesion detection, development of specialized segmentation algorithms can be a challenging issue [28]. However, the use of statistical features of DR lesions can increase the algorithm's precision. On the other hand, top-down approaches employ textural features of retinal images that not only are less complicated, but also do not require any segmentation algorithm. However, it is not easy to differentiate the texture of retinal vessels from DR lesions. For this reason, the mere use of textural features may affect the performance of the DR screening system. In this paper, we proposed a DR detection algorithm which shares the advantages of both categories while lacking their disadvantages.

The purpose of this section is to provide a brief review of the concepts that will be discussed in the next sections. The first subsection is devoted to the MCA algorithm, the second subsection to the Shearlet Transform, and the last one to the Contourlet Transform.

Signal representation in the transform domain is an interesting subject as it offers simplicity and efficiency in various applications [29]. Recent advances in modern harmonic analysis have shown that different novel representation systems such as Wavelet, Curvelet, Contourlet and Shearlet Transforms are highly effective in representing certain signal singularities [30]. The basic idea behind sparse representation of a signal is to construct the signal as a linear combination of atoms from a redundant dictionary in which the number of atoms is larger than the signal dimension. There are several ways to represent a signal by a redundant dictionary, among which we tend to represent the signal with a minimum number of non-zero coefficients (sparsest) as the simplest method [29]. Recently, Morphological Component Analysis (MCA) concept, which is commonly used for signal separation on the basis of sparsity, has been introduced [9,29]. Drawing on the morphological diversity of different structures of an image is the main idea behind the MCA algorithm. This algorithm assumes that each signal can be modeled as a linear mixture of several morphologically distinct layers. These layers can be sparsely represented by redundant dictionaries. Moreover, image separation has a wide range of applications in science and technology, including biomedical engineering, medical imaging, speech processing, astronomical imaging, remote sensing, and etc. [31].

Suppose that image y, which is represented as a 1D vector of size N
                        2, is the linear combination of K components, possibly containing noise ε as follows:
                           
                              (1)
                              
                                 
                                    
                                       y
                                    
                                    =
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       K
                                    
                                    
                                       
                                          
                                             x
                                          
                                          k
                                       
                                       +
                                       ε
                                    
                                    ,
                                     
                                    
                                       σ
                                       ε
                                       2
                                    
                                    =
                                    Var
                                    
                                       ε
                                    
                                       
                                    〈
                                       
                                    +
                                    ∞
                                 
                              
                           
                        
                     

MCA algorithm is employed to recover the morphological components x
                        
                           k
                         from the observed linear mixture. In this algorithm, it is assumed that each component (x
                        
                           k
                        ) can be sparsely represented in an associated basis ϕ
                        
                           k
                         as indicated in the following expression:
                           
                              (2)
                              
                                 
                                    
                                       
                                          x
                                       
                                       k
                                    
                                    =
                                    
                                       φ
                                       k
                                    
                                    
                                       α
                                       k
                                    
                                     
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    K
                                 
                              
                           
                        where α
                        
                           k
                         is a sparse vector of coefficients. Another assumption is that for each component k, the representation of x
                        
                           k
                         in ϕ
                        
                           k
                         is sparse, but not as sparse as other ϕ
                        
                           l
                        , l
                        ≠
                        k. Thus, amalgamating several dictionaries 
                           
                              
                                 ϕ
                              
                              =
                              
                                 
                                    
                                       
                                          ϕ
                                       
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          ϕ
                                       
                                       K
                                    
                                 
                              
                           
                         generates a dictionary that plays a discriminating role between components [9]. Since the resulting dictionary ϕ provides an overcomplete representation of x, the sparsity can be employed to obtain a unique solution. The MCA algorithm solves this undetermined system and recovers the morphological components 
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             k
                                          
                                       
                                    
                                 
                                 
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    K
                                 
                              
                           
                         by solving the following optimization problem [13]:
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             min
                                          
                                       
                                       
                                          
                                             α
                                             1
                                          
                                          ,
                                          ...
                                          ,
                                          
                                             α
                                             k
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   α
                                                   k
                                                
                                             
                                          
                                       
                                       p
                                       p
                                    
                                    such
                                       
                                    that
                                       
                                    
                                       
                                          
                                             
                                                y
                                                −
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   K
                                                
                                                
                                                   
                                                      ϕ
                                                      k
                                                   
                                                   
                                                      α
                                                      k
                                                   
                                                
                                             
                                          
                                       
                                       2
                                    
                                    ≤
                                     
                                    σ
                                 
                              
                           
                        where 
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                α
                                             
                                             k
                                          
                                       
                                    
                                 
                                 p
                                 p
                              
                              =
                              
                                 ∑
                                 i
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    p
                                 
                              
                           
                         is the penalty quantifying sparsity (the most interesting regime is for 0≤
                        p
                        ≤1), and 
                           
                              
                                 
                                    α
                                 
                                 0
                              
                              =
                              
                                 
                                    lim
                                 
                                 
                                    p
                                    →
                                    0
                                 
                              
                              
                                 
                                    α
                                 
                                 p
                                 p
                              
                           
                         is the l
                        0 pseudonorm, which is the number of non-zero components. The constraint in this optimization problem accounts for the presence of noise. In the absence of any noise (σ
                        =0), the equality constraint can be substituted for the inequality constraint. In general, it is difficult to solve this optimization problem. It has been suggested that hard thresholding of marginal residuals in forms of r
                        
                           k
                        
                        =
                        y
                        −∑
                           l≠k
                        
                        ϕ
                        
                           l
                        
                        α
                        
                           l
                        , when all the morphological components ϕ
                        
                           l
                        
                        α
                        
                           l
                         except for the Kth are fixed, presents the solution of α
                        
                           k
                        . The marginal residuals r
                        
                           k
                         contain the salient information of the component x
                        
                           k
                        . Dictating the coordinate relaxation algorithm [32] that iterates through all morphological components, applies the hard thresholding to the marginal residual in each iteration [31].

The choice of dictionary plays an important role in separating morphological components. The best dictionary is the one that provides the sparsest representation. In this study, we used known transforms instead of learning the dictionaries. In the following subsections, a brief description of the chosen transforms is given.

Important information of an image is often located around its edges which separate image objects from the background. These features correspond to the anisotropic structures in the image [33]. Since Wavelets have isotropic support, they fail to capture image geometric information such as lines and curves. If the bases of a transform are nearly parallel to the image edges, they can exploit the anisotropic regularity of a surface along edges [34]. Shearlet Transform is designed to efficiently encode such anisotropic features [33].

Shearlets are scaled according to a parabolic scaling law encoded in matrices 
                           
                              
                                 
                                    A
                                 
                                 
                                    
                                       2
                                       j
                                    
                                 
                              
                           
                         or 
                           
                              
                                 
                                    
                                       A
                                    
                                    ˜
                                 
                                 
                                    
                                       2
                                       j
                                    
                                 
                              
                           
                        , and exhibit directionality by parameterizing slope encoded in the shear matrices S
                        
                           k
                         or 
                           
                              
                                 
                                    
                                       S
                                    
                                    ˜
                                 
                                 k
                              
                           
                        , defined by (4) and (5) for j
                        ≥0, k
                        ∈
                        Z:
                           
                              (4)
                              
                                 
                                    
                                       
                                          A
                                       
                                       
                                          
                                             2
                                             j
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         2
                                                         j
                                                      
                                                   
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      
                                                         2
                                                         
                                                            
                                                               j
                                                               /
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       k
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             A
                                          
                                          ˜
                                       
                                       
                                          
                                             2
                                             j
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         2
                                                         
                                                      
                                                   
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      
                                                         2
                                                         j
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       k
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   k
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        for 
                           
                              
                                 ϕ
                              
                              ,
                              
                                 ψ
                              
                              ,
                              
                                 
                                    ψ
                                 
                                 ˜
                              
                              ∈
                              
                                 L
                                 2
                              
                              
                                 
                                    
                                       R
                                       2
                                    
                                 
                              
                           
                        , the cone-adapted discrete Shearlet system 
                           
                              SH
                              
                                 
                                    
                                       ϕ
                                    
                                    ,
                                    
                                       ψ
                                    
                                    ,
                                    
                                       
                                          ψ
                                       
                                       ˜
                                    
                                    ;
                                    c
                                 
                              
                           
                         is defined by (6). The parameter c is a positive constant which will control the sampling density.
                           
                              (6)
                              
                                 
                                    SH
                                    
                                       
                                          
                                             φ
                                          
                                          ,
                                          
                                             ψ
                                          
                                          ,
                                          
                                             
                                                ψ
                                             
                                             ˜
                                          
                                          ;
                                          c
                                       
                                    
                                    =
                                    
                                       Φ
                                    
                                    
                                       
                                          
                                             φ
                                          
                                          ;
                                          c
                                       
                                    
                                    
                                       Ψ
                                    
                                    
                                       
                                          
                                             ψ
                                          
                                          ;
                                          c
                                       
                                    
                                    
                                       
                                          Ψ
                                       
                                       ˜
                                    
                                    
                                       
                                          
                                             
                                                Ψ
                                             
                                             ˜
                                          
                                          ;
                                          c
                                       
                                    
                                    ,
                                 
                              
                           
                        where Φ is referred to as a scaling function and ψ and 
                           
                              
                                 ψ
                              
                              ˜
                           
                         as Shearlets which are defined as follows:
                           
                              (7)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Φ
                                                
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      ;
                                                      c
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            φ
                                                         
                                                         m
                                                      
                                                      =
                                                      
                                                         φ
                                                      
                                                      
                                                         
                                                            .
                                                            −
                                                            c
                                                            m
                                                         
                                                      
                                                      :
                                                      m
                                                      ∈
                                                      
                                                         Z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Ψ
                                                
                                                
                                                   
                                                      
                                                         Ψ
                                                      
                                                      ;
                                                      c
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            Ψ
                                                         
                                                         
                                                            j
                                                            ,
                                                            k
                                                            ,
                                                            m
                                                         
                                                      
                                                      =
                                                      
                                                         2
                                                         
                                                            3
                                                            j
                                                            /
                                                            4
                                                         
                                                      
                                                      
                                                         Ψ
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  S
                                                               
                                                               k
                                                            
                                                            
                                                               
                                                                  A
                                                               
                                                               
                                                                  
                                                                     2
                                                                     j
                                                                  
                                                               
                                                            
                                                            .
                                                            −
                                                            c
                                                            m
                                                         
                                                      
                                                      :
                                                      j
                                                      ≥
                                                      0
                                                      ,
                                                      
                                                         k
                                                      
                                                      ≤
                                                      
                                                         
                                                            
                                                               2
                                                               
                                                                  j
                                                                  /
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      m
                                                      ∈
                                                      
                                                         Z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      Ψ
                                                   
                                                   ˜
                                                
                                                
                                                   
                                                      
                                                         
                                                            Ψ
                                                         
                                                         ˜
                                                      
                                                      ;
                                                      c
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               Ψ
                                                            
                                                            ˜
                                                         
                                                         
                                                            j
                                                            ,
                                                            k
                                                            ,
                                                            m
                                                         
                                                      
                                                      =
                                                      
                                                         2
                                                         
                                                            3
                                                            j
                                                            /
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            Ψ
                                                         
                                                         ˜
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     S
                                                                  
                                                                  ˜
                                                               
                                                               k
                                                            
                                                            
                                                               
                                                                  
                                                                     A
                                                                  
                                                                  ˜
                                                               
                                                               
                                                                  
                                                                     2
                                                                     j
                                                                  
                                                               
                                                            
                                                            .
                                                            −
                                                            c
                                                            m
                                                         
                                                      
                                                      :
                                                      j
                                                      ≥
                                                      0
                                                      ,
                                                      
                                                         k
                                                      
                                                      ≤
                                                      
                                                         
                                                            
                                                               2
                                                               
                                                                  j
                                                                  /
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                      m
                                                      ∈
                                                      
                                                         Z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The matrices 
                           
                              
                                 
                                    A
                                 
                                 
                                    
                                       2
                                       j
                                    
                                 
                              
                           
                         and S
                        
                           k
                         lead to windows which can be elongated along arbitrary directions, and the geometric structures of singularities in images can be efficiently represented using them [34]. Fig. 3
                         shows the tiling of frequency plane with the aid of Shearlet system ψ. It was shown that Shearlet ψ can provide nearly optimal approximation for a piecewise smooth function f with C
                        2 smoothness except at points laying on C
                        2 curves [34].

The main objective of the Contourlet Transform is to obtain an optimal approximation rate of piecewise smooth functions with discontinuities along twice continuously differentiable curves. Accordingly, it covers areas with smooth subsection contours [35]. The Contourlet Transform employs the low-pass filter bank for multi-scale decomposition, and the directional filter bank for directional decomposition. In order to achieve the shift-invariance property and get rid of frequency aliasing, the Non-Subsampled Contourlet Transform (NSCT) was introduced, which eliminated the down-samplers and the up-samplers during the decomposition and reconstruction of the image. The NSCT is built based on the Non-Subsampled Pyramids Filter Banks (NSPFB) and the Non-Subsampled Directional Filter Banks (NSDFB) [36,37], which is shown in Fig. 4
                        .

@&#PROPOSED METHOD@&#

In this section, a novel fully-automated diabetic retinopathy screening system is proposed. Fig. 5
                      illustrates a complete flow diagram for the proposed system which is devided into three steps: preprocessing, quality assessment and DR detection. The first step extracts the green channel of retinal images and removes their useless parts to accelerate further processing stages. The second step evaluates the quality of retinal images using a novel algorithm which exploits structural information of the image without any segmentation algorithm. In this stage, quality of the retinal images are assessed according to the visibility of retinal vessels represented by the Shearlet Transform. If the quality of the image is not satisfactory, it is examined by an ophthalmologists or reaquiered if necessary. Otherwise, the image is directed to the next step for diabetic retinopathy detection. In this stage, retinal vessels and lesions are initially separated by the MCA algorithm. Then, a feature vector is assigned to the test images by a dictionary of retinal blocks that were created in the training stage. Finally, normal and abnormal retinal images are distinguished by employing the SVM classifier. In the following subsections, a detailed description of the proposed system is given.

For the detection of diabetic retinopathy, the green channel I
                        
                           G
                         is first extracted from the RGB images, since this channel exhibits the most contrast of the RGB-representation in the retinal images. Then, useless parts of retinal images are removed by finding Retinal Region of Interest (ROI) which is surrounded by a dark background. Given that only ROI pixels are used for diabetic retinopathy detection, these useless parts are removed from retinal images to accelerate further processing stages. In order to find the retinal ROI, Otsu thresholding algorithm [38] is applied to the green channel of the retinal image. The resulting binary image is represented by one large connected region, which is the retinal FOV. However, some missed labeled pixels on the retinal background and foreground are created. These noisy regions are removed through morphological opening and closing, respectively. Empirically, the size of the structuring element is assumed to be 7. Useless parts of the retinal image are removed by finding the bounding box which only contains retinal FOV. Finally, the cropped retinal image is resized to 512×512pixel to accelerate further processing steps.

This subsection discusses the methodology used in the proposed retinal image quality assessment. The quality evaluation is based on the level of retinal vessels visibility. As shown in Fig. 2, the visibility of retinal structures in the poor quality images is extremely lower than that of good quality images. Therefore, this feature can be used in the quality assessment. Broadly speaking, the proposed quality assessment algorithm is characterized by the vessel representation by Shearlet Transform and the vessel density computation in the local patches aimed at creating feature vectors. A detailed description of the algorithm stages is given in the following subsections.

Given the low visibility of retinal structures in poor quality images compared to that of good quality ones, this feature can be used to evaluate retinal image quality. To this end, Shift Invariant Shearlet Transform (SIST), a proper transform to represent curved-like structures, is employed for vessel representation. The SIST decomposes images into several frequency and directional subbands. Since this transform has shift invariant property, the coefficients in the directional subbands have the same position as their corresponding pixels. In the SIST decomposition, if a Shearlet of the scale j, angle s and location (x,y) is approximately aligned with a curve, its Shearlet coefficient c
                           
                              j,s,x,y
                            will be large; otherwise, it approximates zero. Thus, for an edge pixel in location (x,y), the variance of the corresponding coefficients in all directions will be higher than the variance of a non-edge pixel. Moreover, for a noise pixel, the magnitude values in every directional subband will be high. Therefore, the variance of coefficients in that pixel will be low. And as a result, the Variance of Shearlet Coefficients (VSC) is an ideal candidate to represent edges in the image while having higher values of the corresponding VSC map for the stronger image edges. Thus, the value of VSC map would be negligible in poor quality images. For a pixel at location (x,y) and level j, the VSC value is computed as follows:
                              
                                 (8)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      σ
                                                      
                                                         j
                                                         ,
                                                         x
                                                         ,
                                                         y
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        1
                                                                        
                                                                           
                                                                              D
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        ∑
                                                                        
                                                                           d
                                                                           =
                                                                           1
                                                                        
                                                                        
                                                                           
                                                                              D
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 
                                                                                    
                                                                                       c
                                                                                       
                                                                                          j
                                                                                          ,
                                                                                          d
                                                                                          ,
                                                                                          x
                                                                                          ,
                                                                                          y
                                                                                       
                                                                                    
                                                                                    −
                                                                                    
                                                                                       m
                                                                                       
                                                                                          j
                                                                                          ,
                                                                                          x
                                                                                          ,
                                                                                          y
                                                                                       
                                                                                    
                                                                                 
                                                                              
                                                                           
                                                                           2
                                                                        
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     ,
                                                                     
                                                                        m
                                                                        
                                                                           j
                                                                           ,
                                                                           x
                                                                           ,
                                                                           y
                                                                        
                                                                     
                                                                     ≤
                                                                     0
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  0
                                                               
                                                               
                                                                  
                                                                     ,otherwise
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      m
                                                      
                                                         j
                                                         ,
                                                         c
                                                         ,
                                                         y
                                                      
                                                   
                                                   =
                                                   
                                                      1
                                                      
                                                         
                                                            D
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      ∑
                                                      
                                                         d
                                                         =
                                                         1
                                                      
                                                      
                                                         
                                                            D
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         c
                                                         
                                                            j
                                                            ,
                                                            d
                                                            ,
                                                            x
                                                            ,
                                                            y
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where c
                           
                              j,s,x,y
                            is the value of the SIST coefficients in pixel (x,y) at the dth direction of the jth level, D
                           
                              j
                            is the number of directions of the jth level and m
                           
                              j,x,y
                            is the mean directional subband coefficients in point (x,y). The sign of coefficients indicates whether the edge pixel is located in the light or dark area. If an edge pixel is in the light area, the value of corresponding coefficients will be positive and vice versa. To represent the blood vessels, only pixels with a negative mean for all directional subband coefficients (m
                           
                              j,x,y
                           
                           ≤0) are considered. Some instances of retinal images with different quality levels and their corresponding VSC images are depicted in Fig. 6
                           . In this figure the SIST with three scales and 8 directions was employed to decompose retinal images. As can be seen, the visibility of retinal structures is restricted in poor quality images, which reduces the magnitude of their coefficients variance.

A global visibility measure is insufficient for quality evaluation as uneven illumination might make the only part of the retinal vessels invisible. The use of global measure could be tricked by the high density of visible structures, misclassifying poor quality images as the ones with high quality. In this paper, local VSC value has been used for retinal image quality assessment. To this end, local windows are created in the polar coordinate system (θ,r) by dividing radial (r) and angular (θ) coordinates to equal parts. A feature vector composing of the average value of VSC under each window is employed as an input for the classifier to assess the quality of retinal images. Some examples of polar partitioning are depicted in Fig. 6. In these examples the angular coordinate is divided into 8 equal parts with 45 degree. If the radius of the retinal FOV is considered R, the radial coordinate is divided into three equal parts with each part equal to 
                              
                                 
                                    R
                                    /
                                    3
                                 
                              
                           . As shown in Fig. 6, the VSC map of poor quality images is extremely low under some windows. Thus, by employing such local features, poor quality images can be distinguished from the good ones.

Recently, several approaches have been adopted for automatic detection of diabetic retinopathy. In bottom-up algorithms, the detection of pathological structures is critical for DR screening. The use of statistical features of DR lesions can improve the performance of screening algorithm. Nevertheless, detection of different DR lesions depends on several segmentation algorithms. On the other hand, top-down methods, which use textural features of retinal images for DR screening, are less complicated and do not require any segmentation algorithm. However, it is not easy to differentiate the texture of retinal vessels from DR lesions. For this reason, the use of textural features may negatively affect the performance of the DR screening system. Exploiting the property of morphological diversity of retinal structures and the advantages of the MCA algorithm, we propose a novel DR detection algorithm which not only includes the advantages of both categories, but also lacks their disadvantages. In this algorithm, normal and pathological retinal structures are initially separated with the aim of MCA algorithm. Afterward, a dictionary containing normal and abnormal words is created from the lesion parts of retinal images, and finally the abnormal images are detected by the created dictionary. In the following subsections, the proposed DR detection algorithm is discussed in details.

Abnormal retinal images contain both normal and pathological anatomical structures which are morphologically distinct. As shown in Fig. 7
                           , blood vessels with normal structures appear as curved-like components, whereas DR related lesions such as microaneurysms, hemorrhages, and exudates appear as spot-like components in retinal images. Given the morphological differences between normal and abnormal retinal structures, these components can be separated by MCA [9] algorithm for an independent analysis. In order to separate these components perfectly, it is necessary to choose appropriate dictionaries which can sparsely represent each component. Our approach in dictionary selection is to use transforms known for sparse representation of either curved-like or spot-like structures, rather than designing the dictionaries. In the next subsections, a description of the chosen transforms and the MCA algorithm for vessels and lesions separation is given.

Blood vessels appear as curved-like structures in retinal images. The curved-like features correspond to the anisotropic structures of the image, which can be distinguished by their location and direction. Thus, efficient representation of vessel parts requires a directional transform, which is optimal for representing these structures in the image. Among many directional representation systems, Shearlet Transform is the most versatile and successful one [33]. In this paper, Shift Invariant Shearlet Transform (SIST) is employed to represent retinal vessels. Using SIST, retinal images are decomposed into 4 scales and 8 orientations in each level. After SIST decomposition, one lowpass image and 24 bandpass images are obtained, all of which are the same size as the input image.

Lesions, on the other hand, appear as spot-like structures in the images. Efficient representation of these structures requires a directional transform, which is optimal for representing areas. The Contourlet Transform achieves an optimal approximation rate for piecewise smooth functions, which is characterized with discontinuities along continuously differentiable curves. Therefore, this transform is able to capture areas with subsection smooth contours [35]. And hence, NSCT is used to represent the lesion part of retinal images. It utilizes Laplacian pyramid [39] to capture point discontinuities and directional filter banks (DFB) to link point discontinuities into linear structures. In the DFB stage, we use the McClellan Transform of filter from the VK book [40]. Based on these filters, images are decomposed into 4 scales with 8 orientations in each level. After 4-level NSCT decomposition, one lowpass subband image and 24 bandpass directional subband images are obtained, which are the same size as the input retinal image.

As discussed in the previous subsection, SIST and NSCT provide optimally sparse expansions for curved-like and spot-like structures, respectively. Steps of the MCA algorithm which are required for vessel and lesion separation and are based on the selected dictionaries are given in Algorithm 1.
                                 
                                    
                                       
                                       
                                          
                                             
                                                Algorithm 1: MCA decomposition algorithm.
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             1. Parameters: The image I
                                                
                                                   E
                                                 which is represented as a 1D vector, the dictionary Φ
                                                =[Φ
                                                
                                                   S
                                                , Φ
                                                
                                                   C
                                                ], number of iterations per layer Niter
                                                , stopping threshold λ
                                                   min
                                                .
                                          
                                          
                                             2. Initialize: number of sub-dictionaries K=
                                                2, Φ
                                                =[Φ
                                                
                                                   S
                                                , Φ
                                                
                                                   C
                                                ] where Φ
                                                
                                                   S
                                                 and Φ
                                                
                                                   C
                                                 correspond to NSST and NSCT, respectively. 
                                                   
                                                      
                                                         
                                                            Φ
                                                         
                                                         S
                                                         +
                                                      
                                                   
                                                 and 
                                                   
                                                      
                                                         
                                                            Φ
                                                         
                                                         C
                                                         +
                                                      
                                                   
                                                 are also pseudo-inverse of sub-dictionaries. let 
                                                   
                                                      
                                                         k
                                                         *
                                                      
                                                      =
                                                      arg
                                                      
                                                         
                                                            max
                                                         
                                                         k
                                                      
                                                      
                                                         
                                                            
                                                               Φ
                                                               k
                                                            
                                                            
                                                               y
                                                               ∞
                                                            
                                                         
                                                      
                                                      k
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      K
                                                   
                                                ; set 
                                                   
                                                      λ
                                                      =
                                                      
                                                         λ
                                                         0
                                                      
                                                      =
                                                      
                                                         
                                                            max
                                                         
                                                         
                                                            k
                                                            ≠
                                                            
                                                               k
                                                               *
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  Φ
                                                               
                                                               k
                                                            
                                                            
                                                               y
                                                               ∞
                                                            
                                                         
                                                      
                                                   
                                                ; set y
                                                =
                                                I
                                                
                                                   E
                                                 and initial solution 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      =
                                                      0
                                                   
                                                , 
                                                   x
                                                
                                                
                                                   l
                                                
                                                =0.
                                          
                                          
                                             3. Perform N
                                                iter times:
                                          
                                          
                                             Part A - Update of 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                   
                                                 assuming x
                                                
                                                   l
                                                 is fixed:
                                          
                                          
                                             
                                                – Calculate the residual 
                                                   
                                                      
                                                         r
                                                      
                                                      =
                                                      
                                                         y
                                                      
                                                      −
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      −
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                – Calculate the NSST of 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      +
                                                      
                                                         r
                                                      
                                                   
                                                 and obtain 
                                                   
                                                      
                                                         
                                                            α
                                                         
                                                         S
                                                      
                                                      =
                                                      
                                                         Φ
                                                         S
                                                         +
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      +
                                                      
                                                         r
                                                      
                                                      )
                                                   
                                                .
                                          
                                          
                                             
                                                – Hard threshold the coefficient vector α
                                                
                                                   S
                                                 with the λ threshold and obtain 
                                                   
                                                      
                                                         
                                                            
                                                               α
                                                            
                                                            ˆ
                                                         
                                                         S
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                – Reconstruct 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                   
                                                 by 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         S
                                                      
                                                      
                                                         
                                                            
                                                               α
                                                            
                                                            ˆ
                                                         
                                                         S
                                                      
                                                   
                                                .
                                          
                                          
                                             Part B - Update of x
                                                
                                                   l
                                                 assuming 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                   
                                                 is fixed:
                                          
                                          
                                             
                                                – Calculate the residual 
                                                   
                                                      
                                                         r
                                                      
                                                      =
                                                      
                                                         y
                                                      
                                                      −
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                      −
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                – Calculate the NSCT of x
                                                
                                                   l
                                                
                                                +
                                                r and obtain 
                                                   
                                                      
                                                         
                                                            α
                                                         
                                                         C
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         C
                                                         +
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                      +
                                                      
                                                         r
                                                      
                                                      )
                                                   
                                                .
                                          
                                          
                                             
                                                – Hard threshold the coefficient vector α
                                                
                                                   C
                                                 with the λ threshold and obtain 
                                                   
                                                      
                                                         
                                                            
                                                               α
                                                            
                                                            ˆ
                                                         
                                                         C
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                – Reconstruct x
                                                
                                                   l
                                                 by 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         C
                                                      
                                                      
                                                         
                                                            
                                                               α
                                                            
                                                            ˆ
                                                         
                                                         C
                                                      
                                                   
                                                .
                                          
                                          
                                             4. Update the threshold 
                                                   
                                                      λ
                                                      =
                                                      λ
                                                      ×
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           λ
                                                                           0
                                                                        
                                                                     
                                                                     
                                                                        τ
                                                                        
                                                                           σ
                                                                           ε
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               1
                                                               
                                                                  
                                                                     
                                                                        1
                                                                        −
                                                                        
                                                                           N
                                                                           
                                                                              i
                                                                              t
                                                                              e
                                                                              r
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             5. If λ
                                                >
                                                λ
                                                min, return to Step 2. Else, finish.
                                          
                                          
                                             6. Output: Morphological components 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                   
                                                 and 
                                                   x
                                                
                                                
                                                   l
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

In this algorithm, 
                                 
                                    
                                       
                                          x
                                       
                                       v
                                    
                                 
                               and x
                              
                                 l
                               are vessel and lesion parts of retinal image which were initialized to zero and N
                              iter is the number of iterations fixed in 20. Since MCA is an iterative coarse-to-fine operation, it is able to handle noise by ceasing the iteration when the residual is at the noise level. Thus, λ
                              min was set to k
                              ×
                              σ as the stopping threshold, where σ is the noise standard deviation and k is a constant empirically set to 3. The threshold λ
                              
                                 t
                               decreases exponentially through iterations as follows:
                                 
                                    (9)
                                    
                                       
                                          
                                             λ
                                             t
                                          
                                          =
                                          
                                             λ
                                             
                                                t
                                                −
                                                1
                                             
                                          
                                          ×
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               λ
                                                               0
                                                            
                                                         
                                                         
                                                            k
                                                            σ
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   1
                                                   /
                                                   
                                                      
                                                         
                                                            1
                                                            −
                                                            
                                                               N
                                                               
                                                                  iter
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              where λ
                              0 is the first threshold set to the maximum magnitude in all coefficients 
                                 
                                    
                                       λ
                                       0
                                    
                                    =
                                    max
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         S
                                                         T
                                                      
                                                      
                                                         x
                                                      
                                                   
                                                
                                             
                                             ∞
                                          
                                          ,
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         C
                                                         T
                                                      
                                                      
                                                         x
                                                      
                                                   
                                                
                                             
                                             ∞
                                          
                                       
                                    
                                 
                               and N
                              iter is the number of iterations. This algorithm recovers vessels and lesions, where 
                                 
                                    
                                       
                                          Φ
                                       
                                       S
                                    
                                    
                                       
                                          
                                             α
                                          
                                          ˆ
                                       
                                       S
                                    
                                 
                               and 
                                 
                                    
                                       
                                          Φ
                                       
                                       C
                                    
                                    
                                       
                                          
                                             α
                                          
                                          ˆ
                                       
                                       C
                                    
                                 
                               contain salient information of vessels and lesions, respectively. The success of vessels and lesions separation relies on the effectiveness of Φ
                              
                                 S
                               and Φ
                              
                                 C
                               in sparsely representing vessels and lesions. Fig. 8
                               shows the result of vessel and lesion separation using Algorithm 1. As can be seen, the DR-related lesions are completely separated from the vessels. Additional contents of the image, not sparsely represented by these dictionaries, are allocated to the noise part. More examples of vessel and lesion separation are shown in Fig. 9
                              .

After separating vessels from lesions, some parts of the optic disc area are misidentified as lesions. These false positives degrade the performance of the DR detection algorithm and may misclassify normal retinal images as abnormal. To remove these artifacts, we localize the optic disc area using the algorithm proposed in [41]. This algorithm, using the specialized correlation filter that matches the optic disc structure, gives an approximation center of this area. False positive pixels on the lesion images are then removed using a square mask with a pixel size of 50×50 at the center of the optic disc.

A dataset of the training set which includes normal and abnormal blocks is created by randomly selecting 3000 regions with a pixel size of n
                           ×
                              n from the lesion parts of retinal images. Then, a set of highly extensible features including inhomogeneity, entropy, and standard deviation are assigned to each block. In order to obtain inhomogeneity features, the inhomogeneity map is first created. To do so, each block is partitioned into disjoint sub-images of w
                           ×
                              w pixel size. For each pixel of the sub-images, sum of the absolute intensity differences larger than a given threshold T is computed. The inhomogeneity values are then normalized with respect to the size of each sub-image. Algorithm 2 presents the steps of inhomogeneity map creation algorithm. In this algorithm, size of the sub-images w is set empirically to 15 and the optimal values for block size n and threshold T is determined in the experimental results. Finally, a combination of average, standard deviation, and kurtosis values of inhomogeneity map are considered as inhomogeneity features.
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm 2. Computing inhomogeneity image map
                                       
                                       
                                          
                                             for i=1+w/2 to row-w/2 do
                                          
                                       
                                       
                                          
                                             
                                                for j=1+w/2 to col-w/2 do
                                          
                                       
                                       
                                          
                                             
                                             H=0
                                       
                                       
                                          
                                             
                                             
                                             for all m in [i-w/2:i+w/2] and all n in [j-w/2:j+w/2] do
                                          
                                       
                                       
                                          
                                             
                                             
                                             Temp=|image(i,j)-image(m,n)|
                                       
                                       
                                          
                                             
                                             
                                             if(Temp>T)
                                       
                                       
                                          
                                             
                                             
                                             
                                             H=H+Temp
                                       
                                       
                                          
                                             
                                             
                                             end if
                                          
                                       
                                       
                                          
                                             
                                             
                                             end for
                                          
                                       
                                       
                                          
                                             
                                             inhomogeneity(i,j)=H/((w/2)*(w/2))
                                       
                                       
                                          
                                             
                                             
                                             end for
                                          
                                       
                                       
                                          
                                             
                                             end for
                                          
                                       
                                    
                                 
                              
                           
                        

The procedure used in our tests is as follows. Test images are partitioned to disjoint blocks of n
                           ×
                              n pixel size and all of the discussed features are computed for them. Feature vector of each block is projected on the training set and the most similar block is retrieved. Then, label of the retrieved block (normal or abnormal) is assigned to the test block and finally the histogram of the labels is computed as the feature vector of each image.

@&#EXPERIMENTAL RESULTS@&#

To develop and test the proposed diabetic retinopathy screening system, the public available dataset Messidor [10] was used. Messidor is the largest dataset, which contains 1200 online retinal images. These images were captured with a color video 3CCD camera on Topcon TRC NW6 non-mydriatic retinograph with a 45 degree field of view and the resolution of 1440×960, 2240×1488 or 2304×1536pixel stored in TIFF format. This dataset contains the grading for diabetic retinopathy and the risk of macular edema in each image.

In order to evaluate the proposed algorithm, three performance measures, namely: sensitivity, specificity, and accuracy were used. Sensitivity is the percentage of abnormal retinal images classified as abnormal, and specificity is the percentage of normal images classified as normal by the screening algorithm. Diagnosis is a function of the specificity and sensitivity; that is, the higher the sensitivity and specificity values, the better the diagnosis has been made. These performance measures can be calculated by (8–10), respectively, where TP is the number of abnormal fundus images identified as abnormal, TN is the number of normal images identified as normal, FP is the number of normal images identified as abnormal, and FN is the number of abnormal images identified as normal.

@&#EVALUATION@&#

In this subsection, an extensive experiment for evaluating the performance of the proposed system is reported. All experiments are performed on MATLAB R2012a platform. We first test the general classification ability of the proposed algorithms, and then compare the experiments with the state-of-the-art methods. The following subsections are adopted to evaluate the quality assessment and DR detection algorithms.
                           
                              (10)
                              
                                 
                                    sensitivity
                                    =
                                    
                                       
                                          TP
                                       
                                       
                                          TP+FN
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    specificity
                                    =
                                    
                                       
                                          TN
                                       
                                       
                                          TN+FP
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    accuracy
                                    =
                                    
                                       
                                          TP+TN
                                       
                                       
                                          TP+FP+TN+FN
                                       
                                    
                                 
                              
                           
                        
                     

To evaluate the proposed quality assessment algorithm, first optimal values of the part numbers for (θ,r) coordinates are obtained. To do so, the VSC map of retinal images is created in two levels and the proposed quality assessment algorithm is evaluated with different part numbers for θ and r coordinates. Table 1
                            shows the quality assessment results for 1200 images obtained from the Messidor dataset with different parameters using SVM classifier and 5-fold cross validation. All images were manually graded by a team of ophthalmologists from Khatam-Al-Anbia Eye Hospital of Mashhad by the image annotation software. Values of the parameters that yielded the highest sensitivity were at the first level with part numbers of 4 and 3 for angular and radial coordinates, respectively.

Using the selected parameters, we drew an analogy between the proposed method and the state-of-the-art algorithms. It should be noted that none of the approaches in the literature reported the results of their algorithm on standard datasets. Thus we compared our proposed algorithm only with the one proposed by Niemeijer et al. [16]. The results of this paper were provided by the authors on the Messidor dataset. In their algorithm, the image structures were represented by clustering the filter bank response vectors. Then, a histogram of the represented structures was employed as a feature vector for quality evaluation. Table 2
                            compares the performance of the proposed method with the algorithm presented in [16] in terms of sensitivity and specificity on the Messidor dataset. As mentioned earlier, a global visibility measure is insufficient for quality evaluation as uneven illumination might make the only part of the retinal structures invisible. The use of global measure can be tricked by the high density of visible structures, misclassifying poor quality images as the ones with high quality. Therefore, this paper employs local vessels visibility to assess the quality of retinal images. As shown in Table 2, results of the proposed algorithm is comparable to the method introduced by Niemeijer et al. and the application of local visibility of retinal structures can significantly improve the results of quality assessment algorithm.

We first evaluated the effect of using different values of block size n and threshold T on the performance of the proposed DR detection algorithm. In this experiment, 930 retinal images taken from the Messidor dataset were used. To obtain the optimal value for these parameters, we evaluated the proposed algorithm with different values of n and T, as shown in Table 3
                           . The results were achieved using SVM classifier and 10-fold cross validation. The parameter value that produced the highest sensitivity was at n
                           =64 and T
                           =25. Using the selected parameters, we compared the results of DR detection method with and without employing quality assessment pre-screening, as illustrated in Table 4
                           . The results were achieved using SVM classifier with different kernels and 10-fold cross validation. As shown in this table, the best results were obtained using quadratic and polynomial kernels. The results showed effective performance of the quality assessment stage on the DR screening system. As mentioned earlier, poor quality images degraded the performance of the DR detection algorithm. Thus, retinal image quality assessment can be considered as one of the critical stages in a diabetic retinopathy screening system.

To emphasize the capability of the proposed DR screening system, it was compared with other approaches that employed the Messidor dataset in their evaluations. For this reason, the methods proposed by Agurto et al. [8], Esnaashari et al. [26], and Acharya et al. [27] were selected. Table 5
                            compares the performance of the proposed method with the mentioned approaches in terms of sensitivity, specificity, and accuracy on the Messidor dataset. Values of the performance measures shown in this table were reported by the authors of each paper. If the values of performance measures were not available in the papers, it is indicated by a gap in the table. Agurto et al. [8] reported the sensitivity, specificity, and accuracy of 92%, 54% and 84%, respectively, for 367 images taken from the Messidor dataset. The method proposed in [26] was evaluated on 346 retinal images of the Messidor dataset, yielding a sensitivity of 95%, specificity of 89%, and accuracy of 91%. The algorithm proposed by Acharya et al. [27] achieved a sensitivity and specificity of 98% and 89.5%, respectively, on 180 images of the Messidor dataset. As shown in Table 5, the authors did not use the same number of images for their evaluation. Thus, we tried to evaluate our method on a larger number of images compared to other approaches. The comparison of the proposed method with other approaches on the Messidor dataset demonstrates the superior performance of the proposed DR screening system to other algorithms. However, in our experiment, the number of retinal images was larger than other approaches. As mentioned earlier, the use of statistical features of retinal lesions provides better results in comparison with textural features. Since it is not easy to distinguish the texture of normal and abnormal retinal structures, the proposed DR detection algorithm identified different DR-related lesions such as microaneurysms, hemorrhages, and exudates using only one algorithm. Thus, a closer look at the data in Table 5 indicates the superior performance of the proposed algorithm compared to other algorithms which are based on only textural features.

@&#CONCLUSION@&#

This paper provides a fully automated diabetic retinopathy screening system with the ability of assessing retinal image quality. In the pre-screening stage, quality of retinal images is evaluated in terms of the retinal vessels visibility. In contrast to the previous approaches, the proposed quality assessment algorithm is independent of any segmentation algorithm. If the images have sufficient quality, they are processed for diabetic retinopathy screening. The recent diabetic retinopathy detection methods are mainly based on lesion segmentation or textural parameters of the images. The DR related lesions appeared as spots with different shapes, colors, and sizes in the abnormal retinal images. Nevertheless, the use of statistical features of DR lesions increases the precision of the algorithm. However, detecting lesions with different shapes require different segmentation algorithms which is a time consuming task. On the other hand, the mere use of textural features may reduce the algorithm precision, as it is not easy to distinguish the texture of the lesions and vessels. Exploiting the property of morphological diversity of retinal structures and the advantages of the MCA algorithm, a novel DR detection method was proposed in this paper, which not only has the advantages of both categories, but also lacks their disadvantages. In this algorithm, the retinal vessels and lesions are initially separated using the MCA algorithm. Then, the statistical features of the lesion parts are computed for DR detection. The proposed algorithm is capable of identifying different DR-related lesions such as microaneurysms, hemorrhages, and exudates using MCA algorithm. This algorithm is not dependent on any specific size or color of the lesions, as required by some of the current lesion detectors in the literature. Moreover, the proposed method is robust to noise, since the MCA algorithm besides morphological components, is able to separate noises from the image too.

@&#FUTURE WORK@&#

Despite the success of the MCA algorithm in separating vessels and lesions using selected dictionaries, there may be some cases in which the performance of the selected transforms is not satisfactory. To overcome this limitation, learned dictionaries can be used instead of global transforms to separate lesions and vessels. The trained dictionaries would enhance the precision of vessels and lesions separation. Furthermore, these dictionaries can help separating different lesions from each other, which will be beneficial for detecting different stages of diabetic retinopathy.

@&#REFERENCES@&#

