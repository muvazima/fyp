@&#MAIN-TITLE@&#Robust scheduling of wireless sensor networks for target tracking under uncertainty

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper addresses a target tracking robustness problem in Wireless Sensor Networks.


                        
                        
                           
                           A maximum stability radius schedule is computed with a pseudo-polynomial algorithm.


                        
                        
                           
                           Two classes of upper bounds are exploited to speed up convergence.


                        
                        
                           
                           Large problem instances with up to 1000 sensors can be solved in less than 20 seconds.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Target tracking

Uncertainty

Stability radius

Robustness

@&#ABSTRACT@&#


               
               
                  An object tracking sensor network (OTSN) is a wireless sensor network designed to track moving objects in its sensing area. It is made of static sensors deployed in a region for tracking moving targets. Usually, these sensors are equipped of a sensing unit and a non-rechargeable battery. The investigated mission involves a moving target with a known trajectory, such as a train on a railway or a plane in an airline route. In order to save energy, the target must be monitored by exactly one sensor at any time. In our context, the sensors may be not accessible during the mission and the target can be subject to earliness or tardiness. Therefore, our aim is to build a static schedule of sensing activities that resists to these perturbations. A pseudo-polynomial two-step algorithm is proposed. First, a discretization step processes the input data, and a mathematical formulation of the scheduling problem is proposed. Then, a dichotomy approach that solves a transportation problem at every iteration is introduced; the very last step is addressed by solving a linear program.
               
            

@&#INTRODUCTION@&#

Since wireless sensors are becoming more and more affordable, more and more applications are now possible such as traffic control or battlefield surveillance (Akyildiz, Su, Sankarasubramaniam, & Cayirci, 2002; Yick, Mukherjee, & Ghosal, 2008). Low-cost sensors are usually autonomous, equipped with a sensing unit and a battery. Their typical purpose is to track targets in their sensing range. They can be randomly deployed from an airplane or an helicopter in places lacking monitoring infrastructures. Sensors relying on technologies like drones and radars are suitable in military or humanitarian assistance contexts, where the infrastructures are destroyed or non-existent. In this paper, the investigated mission is to monitor a target with a known trajectory, such as a train on a railway, a vehicle on a road or a plane in an airline route. Since accessing sensors can be difficult in some environments, we may have no control on them during the mission. Then, in order to save battery lifetime, sensors can be switched off and waken up later. To minimize the energy consumption, the target is monitored by only one sensor at a time. Moreover, the target is subject to perturbations on its path, that may cause advances and delays. Consequently, our challenge is to find a static schedule of sensing activities, able to monitor the target at any time, without target loss despite perturbation. A target loss happens when the target is outside the range of any active sensor. A sensing activity is identified by a sensor, a starting date and a duration, to be computed offline, before the mission. During an activity, the corresponding sensor wakes up, collects information about the target for a certain amount of time, and then gets back to sleep status. Our aim is to find the most robust schedule, i.e. the one that resists to the largest possible earliness and tardiness.

@&#RELATED WORK@&#

There are plenty of WSN protocols for target tracking proposed in the literature, designed to achieve one or more goals. Usually, these protocols are dedicated to the optimization or management of different criteria. We present below a non-exhaustive list of the criteria addressed by those protocols:

                           
                              •
                              
                                 Energy consumption: this is one of the most critical aspects since the sensors generally have a non-rechargeable battery. For example, the framework designed in Zhang and Cao (2004) configures min-cost convoy trees using dynamic programming in order to save energy. Many protocols that focus on this aspect are based on LEACH (Handy, Haase, & Timmermann, 2002; Jindal & Gupta, 2013) or HEED (Younis & Fahmy, 2004).


                                 Tracking precision: can be achieved by selecting more sensors or by predicting the target location. A good precision technique can help deciding which sensors to wake up and make a better use of the energy. Yang and Sikdar (2003) and Xu, Winter, and Lee (2004) propose protocols based on prediction.


                                 Scalability: a WSN protocol should scale to different network sizes since a dense network can significantly increase the communication cost. Scalable protocols typically use cluster-based or distributed approaches instead of centralized ones. The authors in Kung and Vlah (2003) focus particularly on this aspect.


                                 Fault tolerance: target tracking may fail due to deficiencies or environmental events. This aspect has witnessed a growing interest recently (Jin, Ding, Hao, & Jin, 2014; Laoudias, Michaelides, & Panayiotou, 2014; Mannan & Rana, 2015; Oracevic & Ozdemir, 2014; Xie et al., 2012).

For a more exhaustive review on the criteria and the WSN protocols, the reader is referred to Naderan, Dehghan, Pedram, and Hakami (2012). A classification of target tracking algorithms from the security point of view is proposed in Oracevic and Ozdemir (2014). The problem investigated in this paper is related to track continuity. However, while WSN protocols generally assume that the target trajectory is random, our approach is based on a known trajectory. It could also be combined with a trajectory prediction method as in Xiao, Weirong, He, and Qin (2014), to be adapted to targets following a random trajectory, by periodically sending the prediction results as an input of our method. This procedure is also suggested by Demigha, Hidouci, and Ahmed (2013).

Only a few of these protocols are currently implemented using optimization techniques. The survey by Naderan et al. (2012) states that only one protocol, designed by Lee, Lin, and Wen (2006) and later extended by Yeong-Sung, Cheng-Ta, and Hsu (2010), is effectively using optimization techniques. This protocol configures an object tracking tree using a Lagrangian relaxation-based heuristic algorithm based on a 0/1 linear formulation. Their problem only handles communication mission and is frequency-based, i.e. frequencies of target movements from a sensor to another are supposed to be known.

In Atia, Veeravalli, and Fuemmeler (2011), the problem is to optimize the tradeoff between tracking performance and energy consumption. A scheduling problem is stated as a partially observable Markov decision process. The decision is to choose the set of sensors to activate at each time slot.

A distributed sensor activation algorithm DSA2 that relies on binary sensors is designed in Chen, Cao, Li, and Sun (2009). The algorithm activates the sensors according to probabilities to detect targets. A robustness study is provided by changing parameters, such as the maximum velocity of the targets, the sensing range or the sensor density.

One of the most studied WSN problems in the field of optimization is the network lifetime maximization. Assuming that the targets are static, the aim is to select and schedule a sequence of subsets of sensors, in order to maximize the time during which all the targets are covered. Many variants of this problem have been investigated, such as MNLB (Maximizing Network Lifetime under Bandwidth constraints) and MCBB (Minimizing Coverage Breach under Bandwidth constraints), solved using heuristics (Wang, Thai, Li, Wang, & Wu, 2008) and further using column generation (Rossi, Singh, & Sevaux, 2011). Column generation is also a flagship technique to solve network lifetime maximization problems. Carrabs, Cerulli, D’Ambrosio, Gentili, and Raiconi (2015) handle heterogeneous networks and speed up the column generation using a genetic algorithm. Castaño, Bourreau, Velasco and Rossi (2015) take into account communication and multi-roles sensors. To solve the pricing problem, they propose two approaches: constraint programming and Branch-and-Cut based on Benders’ decomposition. Singh and Rossi (2014) study some ways to schedule groups of active sensors after obtaining an optimal solution and propose a greedy heuristic and a genetic algorithm.

When the energy consumption of a sensor is variable, i.e. proportional to the number of monitored targets, the network lifetime maximization problem becomes polynomially solvable. Liu, Chu, Leung, Jia, and Wan (2011) provide a continuous linear formulation under this assumption.

In most of the research papers on WSNs, the notion of robustness is reduced to survivability, i.e. the ability to resist to unexpected failures such as enemy attacks or sensor deficiencies (Ellison, Fisher, Linger, Lipson, & Longstaff, 1997; Wang & Xiao, 2006; Wang, Lin, Chan, & Wang, 2013). This paper focuses on the ability of a sensor schedule to resist to target behavior perturbations, in order to reduce the risk of target loss. A prediction scheme proposed in (Pannetier, Dezert, & Sella, 2014) also aims at maintaining track continuity in ground battlefield surveillance, but supposes that the targets can move on and off a road.

Our previous study (Lersteau, Sevaux, & Rossi, 2014) proposes an exact approach to solve the minimization of energy consumption and the network lifetime maximization problems, whereas this paper addresses robustness issue of this problem.

For the sake of readability, the problem investigated in this paper is introduced step by step. Section 2 presents a preliminary step, called discretization, to transform the input data into a scheduling problem instance. Such a transformation is necessary to introduce the definition of stability radius, i.e. the measure of robustness, in Section 3. A diagram summarizes the different steps in Fig. 1. In Section 4, some upper bounds on the stability radius are provided. Sections 5 and 6 describe the proposed approach to solve the problem and the results of its implementation, respectively. Section 7 concludes the paper.

A set of m sensors
                        
                           
                              I
                              =
                              {
                              1
                              ,
                              ⋯
                              ,
                              m
                              }
                           
                         is randomly deployed in a two-dimensional region in order to monitor a single moving target. The positions of the sensors are known and static. Each sensor is able to monitor the target under its sensing range (disc of radius R). The action of monitoring is called a sensing activity. An activity consumes energy from sensor i, therefore the total activity duration cannot exceed its battery lifetime Ei
                        , for all i ∈ I.

Without loss of generality, the planned target position is supposed to be exactly known at any time t ∈ [0, H] where H is the monitoring horizon and defined by a continuous two-dimensional vector function 
                           
                              T
                              (
                              t
                              )
                           
                        .

                           
                              
                                 
                                    T
                                    :
                                    t
                                    ↦
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    
                                    
                                       where
                                    
                                    
                                    t
                                    ∈
                                    
                                       [
                                       0
                                       ,
                                       H
                                       ]
                                    
                                    ,
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    ∈
                                    
                                       R
                                       2
                                    
                                 
                              
                           
                        
                     


                        Table 1
                         describes the initial input data of the problem.

The goal of the problem is to find a robust schedule of sensing activities in order to avoid target loss. The requirements are the following:

                           
                              •
                              The target must be covered at any time in [0, H].

The target must be covered by exactly one sensor at a time.

Geometric data undergo a preprocessing called discretization before stating scheduling problem as a combinatorial optimization problem. The notion of robustness used in this problem is presented in Section 3.

First, the monitored space is partitioned into zones called faces. Since the sensing area of each sensor is assumed to be a disk of radius R, the monitored area can be seen as a planar graph (Berman, Calinescu, Shah, & Zelikovsky, 2004; Slijepcevic & Potkonjak, 2001) (Fig. 2
                        ). The vertices are the intersections between the boundaries of sensors’ disks. The edges connect vertices along the boundaries. The different surfaces bounded by the edges are the faces. In fact, all the points inside a given face are covered by the same set of sensors, and the number of faces is at most 
                           
                              m
                              (
                              m
                              −
                              1
                              )
                              +
                              2
                              ,
                           
                         as shown in (Berman et al., 2004). We define a face by a unique set of covering sensors. For example, in Fig. 2, the geometric faces 7 and 7′ are covered by the same set of sensors {s
                        2}, so they are considered as only one face numbered 7. So, multiple faces that have exactly the same set of candidate sensors are considered the same.

Let F be the set of all faces and 
                           
                              
                                 F
                                 ^
                              
                              ⊆
                              F
                           
                         be the subset of faces in which the target is moving. The target can be monitored by any candidate sensor covering the face where it is located. Hence, the target trajectory can be seen as a sequence 
                           
                              
                                 (
                                 
                                    f
                                    1
                                 
                                 ,
                                 
                                    f
                                    2
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    f
                                    p
                                 
                                 )
                              
                              ∈
                              
                                 
                                    F
                                    ^
                                 
                                 p
                              
                           
                         of the traversed faces. When the target leaves a face and enters into another one, the set of candidate sensors changes (Fig. 3
                        ).

A tick, denoted by tk
                        , is a date of transition from a face fi
                         to 
                           
                              f
                              
                                 i
                                 +
                                 1
                              
                           
                         and a time window the period between two consecutive ticks. The ticks are obtained by computing the intersections between the trajectory and the boundaries of the faces. Thus, the actual target trajectory shape is no longer needed since the time windows and the faces are sufficient to track the target. We denote by 
                           
                              K
                              =
                              {
                              1
                              ,
                              ⋯
                              ,
                              p
                              }
                           
                         the set of time windows, tk
                         the date of the k
                        th tick, and S(k)⊆I the set of candidate sensors able to monitor the target during time window k, i.e. for all t in the range 
                           
                              [
                              
                                 t
                                 k
                              
                              ,
                              
                                 t
                                 
                                    k
                                    +
                                    1
                                 
                              
                              ]
                           
                        . The duration of time window k is denoted by Δk
                         and defined by 
                           
                              
                                 t
                                 
                                    k
                                    +
                                    1
                                 
                              
                              −
                              
                                 t
                                 k
                              
                           
                        . Outside [0, H], there is no restriction and no tracking requirement. Therefore, before t
                        1 and after 
                           
                              
                                 t
                                 
                                    p
                                    +
                                    1
                                 
                              
                              ,
                           
                         the set of candidate sensors is I, i.e. 
                           
                              S
                              (
                              0
                              )
                              =
                              S
                              (
                              p
                              +
                              1
                              )
                              =
                              I
                           
                        . Such a convention will be convenient in the sequel, because it avoids handling the ticks t
                        1 and 
                           
                              t
                              
                                 p
                                 +
                                 1
                              
                           
                         as particular cases.

The ticks are partitioned in two classes: the entering and the leaving ticks. The moment when the target enters the sensing area of a sensor is called an entering tick. Whereas if it leaves a sensing area, it is a leaving tick. Consequently, tick tk
                         is an entering tick if 
                           
                              S
                              (
                              k
                              −
                              1
                              )
                              ⊂
                              S
                              (
                              k
                              )
                              ,
                           
                         and a leaving tick if 
                           
                              S
                              (
                              k
                              )
                              ⊂
                              S
                              (
                              k
                              −
                              1
                              )
                           
                        . Whenever the target enters a sensing area and simultaneously leaves another one, two distinct ticks, one leaving and one entering, are associated to the same date. This case can happen when the target passes through the intersection of two sensing area boundaries. It can be seen in Fig. 3 that t
                        2, t
                        3 and t
                        6 are entering ticks (they are shown as opening square brackets in Fig. 4
                        ), whereas t
                        1, t
                        4 and t
                        5 are leaving ticks (shown as closing square brackets). t
                        1 is considered as a leaving tick, since by convention 
                           
                              S
                              (
                              0
                              )
                              =
                              I
                              ,
                           
                         then S(1) ⊂ S(0). On the other hand, t
                        6 is an entering tick, because 
                           
                              S
                              (
                              p
                              +
                              1
                              )
                              =
                              I
                           
                         and 
                           
                              S
                              (
                              p
                              )
                              ⊂
                              S
                              (
                              p
                              +
                              1
                              )
                           
                        .

These definitions allow to introduce availability intervals. A sensor is said to be available at time t if the target is expected to be inside its sensing range. So, an availability interval of a sensor is a period of time during which the sensor is continuously able to monitor the target. Such an interval typically begins with an entering tick, and ends with a leaving tick, except for those intervals that start at time t
                        1 or end at time 
                           
                              t
                              
                                 p
                                 +
                                 1
                              
                           
                        . Since we cannot select more than one sensor at a time, a sensor cannot be selected outside its availability intervals, since its selection would cause a target loss. Fig. 4 shows the availability intervals of the sensors for the instance of Fig. 3. In general, a sensor may be associated to more than a single availability interval.

The aim of the scheduling problem is to build a schedule
                        
                           
                              S
                              ,
                           
                         composed by a set of sensing activities, denoted by 
                           A
                        . Each activity 
                           
                              a
                              ∈
                              A
                           
                         consists in activating a given sensor i at time sa
                         during da
                         units of time. A schedule 
                           S
                         is feasible if:

                           
                              •
                              All the time horizon [0, H] is covered by activites without overlap.

Each sensor is activated only inside its availability intervals.

Each sensor is not used more than its capacity.


                        Table 2
                         summarizes the input for the scheduling problem.

The notion of robustness is very popular in optimization, and in particular in scheduling (Billaut, Moukrim, & Sanlaville, 2008). But since this notion is very rich and may have different meanings according to the problem and the context, it is introduced in details in Section 3.2.

The purpose of the scheduling problem is to find a schedule that remains feasible despite target earliness or tardiness. In order to achieve this goal, the notion of robustness used in this work is introduced in the next section. Then, two upper bounds on the measure of robustness are proposed in Section 4.

We assume that the target cannot move outside its path, like a train on a railway. However, the arrival dates at given positions are subject to uncertainty. A tick tk
                         is the expected arrival date at the position 
                           
                              T
                              (
                              
                                 t
                                 k
                              
                              )
                           
                        . In other words, at time tk
                        , the target is supposed to be at the boundary of two faces, denoted by 
                           
                              f
                              
                                 k
                                 −
                                 1
                              
                           
                         and fk
                        . Face 
                           
                              f
                              
                                 k
                                 −
                                 1
                              
                           
                         is covered by the sensors in 
                           
                              S
                              (
                              k
                              −
                              1
                              )
                           
                         and fk
                         is covered by S(k). If the target arrives ρ units of time late in 
                           
                              T
                              (
                              
                                 t
                                 k
                              
                              )
                              ,
                           
                         then it leaves later 
                           
                              f
                              
                                 k
                                 −
                                 1
                              
                           
                        . Therefore, to avoid target loss, a sensor of 
                           
                              S
                              (
                              k
                              −
                              1
                              )
                              ∩
                              S
                              (
                              k
                              )
                           
                         should be active during the interval 
                           
                              [
                              
                                 t
                                 k
                              
                              ,
                              
                                 t
                                 k
                              
                              +
                              ρ
                              ]
                           
                        . Symmetrically, if the target is early in 
                           
                              T
                              (
                              
                                 t
                                 k
                              
                              )
                           
                         by ρ units of time, then it should be monitored by a sensor of 
                           
                              S
                              (
                              k
                              −
                              1
                              )
                              ∩
                              S
                              (
                              k
                              )
                           
                         during the interval 
                           
                              [
                              
                                 t
                                 k
                              
                              −
                              ρ
                              ,
                              
                                 t
                                 k
                              
                              ]
                           
                        . Consequently, in order to cope with both earliness and tardiness, sensors in 
                           
                              S
                              (
                              k
                              −
                              1
                              )
                              ∩
                              S
                              (
                              k
                              )
                           
                         should be selected to cover the target during the interval 
                           
                              [
                              
                                 t
                                 k
                              
                              −
                              ρ
                              ,
                              
                                 t
                                 k
                              
                              +
                              ρ
                              ]
                           
                        .

Earliness can also occur at the beginning of the mission. If the target appears at time 
                           
                              
                                 t
                                 1
                              
                              −
                              ρ
                              ,
                           
                         then the schedule should begin also at the same date. By symmetry, the schedule should end later than 
                           
                              t
                              
                                 p
                                 +
                                 1
                              
                           
                         to anticipate possible lateness occuring at the end of the mission.

Earliness and tardiness may create discrepancies between expected and actual ticks. Given a schedule 
                           
                              S
                              ,
                           
                         the aim in this section is to compute the greatest variation of the ticks tk
                         that do not compromize the feasibility of 
                           S
                        . This measure, denoted by ρ and introduced in Sotskov, Wagelmans, and Werner (1998) and Sotskov, Dolgui, and Portmann (2006), is called stability radius. A schedule with a stability radius of ρ is able to cover the target whenever it is early or late of at most ρ units of time.

In our context, the stability radius is defined by the minimal duration between the instant a sensor is active and the instant it is no longer a candidate. Thus, it is limited by the duration between the boundaries of an activity and the boundaries of its corresponding availability interval.


                        Fig. 5
                         presents a simple example of the problem with 2 sensors. Here, we assume that the battery lifetime of the sensors is unlimited. Figs. 6
                         and 7
                         show two valid schedules, respectively denoted by 
                           
                              S
                              1
                           
                         and 
                           
                              
                                 S
                                 2
                              
                              ,
                           
                         submitted to a perturbated scenario (shown as the second timeline on each figure). Schedule 
                           
                              S
                              1
                           
                         activates sensor s
                        1 in time interval [0, 4] and sensor s
                        2 in time interval [4, 6], whereas 
                           
                              S
                              2
                           
                         activates sensor s
                        1 in 
                           
                              [
                              −
                              1
                              ,
                              3
                              ]
                           
                         and sensor s
                        2 in [3, 7]. Both schedules are valid since they are able to cover the target if no perturbation occurs.

In our perturbated scenario, the target appears earlier and disappears 1 unit of time after the expected completion time of the mission. We can see that schedule 
                           
                              S
                              1
                           
                         is not designed to resist to these perturbations since it begins at 
                           
                              t
                              =
                              0
                           
                         and ends at 
                           
                              t
                              =
                              H
                           
                        . Moreover, the target arrives 1 unit of time early in 
                           
                              T
                              (
                              
                                 t
                                 3
                              
                              )
                           
                        . Since s
                        1 does not cover the face after t
                        3, 
                           
                              S
                              1
                           
                         fails to cover the target in this case. However, schedule 
                           
                              S
                              2
                           
                         resists to all of these perturbations and has a stability radius of 1, whereas 
                           
                              S
                              1
                           
                         has
                         a stability radius of 0.

In this paper, our aim is to find a schedule that maximizes the stability radius for the target tracking problem. The description of the solution approach is structured as follows. Section 4 provides upper bounds for the scheduling problem. Section 5 describes the decision version of the scheduling problem based on a Transportation Problem. Finally, the upper bounds are used for a dichotomy on the decision problem described in Section 5.1.

We propose two kinds of upper bounds on the stability radius that will be used in the solution approach in Section 5. They rely on the idea of expanding the length of the time windows until inevitable exhaustion of the sensors. The first one is based on the distances between pairs of time windows using the set of candidate sensors they have in common. The second one is computed by considering the energy limitation of the candidate sensors.

The following upper bound, denoted by UB1, is obtained by computing the closest distance between time windows having no candidate sensors in common.

                           
                              
                                 
                                    U
                                    B
                                    1
                                    =
                                    
                                       min
                                       
                                          k
                                          ,
                                          
                                             k
                                             ′
                                          
                                          ∈
                                          K
                                       
                                    
                                    
                                       {
                                       
                                          
                                             1
                                             2
                                          
                                       
                                       
                                          (
                                          
                                             t
                                             
                                                k
                                                ′
                                             
                                          
                                          −
                                          
                                             t
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          )
                                       
                                       ∣
                                       k
                                       <
                                       
                                          k
                                          ′
                                       
                                       
                                       
                                          and
                                       
                                       
                                       S
                                       
                                          (
                                          k
                                          )
                                       
                                       ∩
                                       S
                                       
                                          (
                                          
                                             k
                                             ′
                                          
                                          )
                                       
                                       =
                                       ∅
                                       }
                                    
                                 
                              
                           
                        If two time windows k and k′ have no candidate sensors in common, then there exists no sensor able to cover simultaneously the two faces corresponding to these time windows. From our requirements, only one sensor can be active at a time. At each instant, either we select a sensor in S(k), or we select one in S(k′), and only one of the two faces can be covered. Therefore, the expansion of the length of both time windows is limited by the half-distance between them (Fig. 8).

This upper bound can be generalized for all pairs of time windows. In fact, when two time windows have some candidate sensors in common, the stability radius is limited by the sum of their battery lifetime. The generalization of UB1, denoted by UB1′, relies on this idea.

                           
                              
                                 
                                    U
                                    B
                                    
                                       1
                                       ′
                                    
                                    =
                                    
                                       min
                                       
                                          k
                                          ,
                                          
                                             k
                                             ′
                                          
                                          ∈
                                          K
                                       
                                    
                                    
                                       {
                                       
                                          
                                             1
                                             2
                                          
                                       
                                       
                                          (
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                S
                                                
                                                   (
                                                   k
                                                   )
                                                
                                                ∩
                                                S
                                                
                                                   (
                                                   
                                                      k
                                                      ′
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                             E
                                             i
                                          
                                          +
                                          
                                             t
                                             
                                                k
                                                ′
                                             
                                          
                                          −
                                          
                                             t
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          )
                                       
                                       ∣
                                       k
                                       <
                                       
                                          k
                                          ′
                                       
                                       }
                                    
                                 
                              
                           
                        When two time windows k and k′ have no candidate sensors in common, then 
                           
                              
                                 ∑
                                 
                                    i
                                    ∈
                                    S
                                    
                                       (
                                       k
                                       )
                                    
                                    ∩
                                    S
                                    
                                       (
                                       
                                          k
                                          ′
                                       
                                       )
                                    
                                 
                              
                              
                                 E
                                 i
                              
                              =
                              0
                              ,
                           
                         and UB1′ reduces to UB1.

Each time window is associated a face, and also a set of candidate sensors. Then, the extra duration of stay of the target inside the face cannot exceed the sum of the battery lifetimes of its candidate sensors. This idea is used to design the upper bound UB2.

                           
                              
                                 
                                    U
                                    B
                                    2
                                    =
                                    
                                       min
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       {
                                       
                                          
                                             1
                                             2
                                          
                                       
                                       
                                          (
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                S
                                                (
                                                k
                                                )
                                             
                                          
                                          
                                             E
                                             i
                                          
                                          −
                                          
                                             (
                                             
                                                t
                                                
                                                   k
                                                   +
                                                   1
                                                
                                             
                                             −
                                             
                                                t
                                                k
                                             
                                             )
                                          
                                          )
                                       
                                       }
                                    
                                 
                              
                           
                        
                     

The generalization of this upper bound is based on the fact that a given face may be associated with different time windows. This situation typically arises when the target reenters a face. It is recalled that 
                           
                              F
                              ^
                           
                         is the set of traversed faces. For each face 
                           
                              f
                              ∈
                              
                                 F
                                 ^
                              
                              ,
                           
                         let Sf
                         be the set of sensors that cover it and ρf
                         the upper bound on the stability radius that will be deduced from this face. Initially, ρf
                         is set to zero. First, we compute 
                           
                              
                                 K
                                 f
                              
                              =
                              
                                 {
                                 k
                                 ∈
                                 K
                                 ∣
                                 S
                                 
                                    (
                                    k
                                    )
                                 
                                 ⊆
                                 
                                    S
                                    f
                                 
                                 }
                              
                           
                         as the set of all the time windows that are completely dependent on the sensors of Sf
                        . We compute the vector 
                           D
                         as the distance between two consecutive time windows in Kf
                        , hence 
                           D
                         has 
                           
                              
                                 |
                                 
                                    K
                                    f
                                 
                                 |
                              
                              −
                              1
                           
                         elements. We suppose that the elements of 
                           D
                         are sorted by increasing order. All the sensors of Sf
                         are used to cover |Kf
                        | time windows, which means that the stability radius is at most the time during which the sensors can be used after covering all the time windows of Kf
                         divided by 2|Kf
                        |.

In order to illustrate this idea, let us consider that a face is visited three times by the target. Time windows k, k′ and k′′ are the elements of Kf
                        . These time windows are shown in Fig. 9. We also assume that two sensors s
                        1 and s
                        2 cover f, with 
                           
                              
                                 E
                                 1
                              
                              =
                              5
                           
                         and 
                           
                              
                                 E
                                 2
                              
                              =
                              5
                           
                        . It can be seen in the figure that covering three time windows require 
                           
                              1
                              +
                              2
                              +
                              1
                              =
                              4
                           
                         units of time. The residual energy of s
                        1 and s
                        2 is then 
                           
                              
                                 E
                                 1
                              
                              +
                              
                                 E
                                 2
                              
                              −
                              4
                              =
                              6
                           
                        . Then, since 
                           
                              
                                 |
                                 
                                    K
                                    f
                                 
                                 |
                              
                              =
                              3
                              ,
                           
                         the stability radius is necessarily less than 
                           
                              
                                 ρ
                                 f
                              
                              =
                              
                                 6
                                 
                                    2
                                    
                                       |
                                       
                                          K
                                          f
                                       
                                       |
                                    
                                 
                              
                              =
                              1
                           
                        .

However, this figure shows that if the energy of the sensors in |Sf
                        | gets larger, then the stability radius can reach 1.5. In that case, the time windows k and k′ become adjacent, i.e. if ρf
                         ≥ 1.5, then it is no longer necessary to increase it in 6 directions, as only 4 directions are necessary. Fig. 10
                         illustrates the case where 
                           
                              
                                 ∑
                                 
                                    i
                                    ∈
                                    
                                       S
                                       f
                                    
                                 
                              
                              
                                 E
                                 i
                              
                              =
                              15
                           
                        .

Finally, if 
                           
                              
                                 E
                                 1
                              
                              +
                              
                                 E
                                 2
                              
                           
                         is large enough, ρf
                         becomes larger than 2.5, and the time windows k′ and k′′ become adjacent. It is no longer necessary to increase it in 4 directions, as only 2 directions are necessary (Fig. 11
                        ).

Consequently, the calculation of ρf
                         is performed stepwise. Let 
                           
                              
                                 k
                                 1
                              
                              <
                              
                                 k
                                 2
                              
                              <
                              ⋯
                              <
                              
                                 k
                                 
                                    |
                                    
                                       K
                                       f
                                    
                                    |
                                 
                              
                           
                         be the time windows in Kf
                        . For all 
                           
                              q
                              ∈
                              {
                              1
                              ,
                              ⋯
                              ,
                              
                                 |
                                 
                                    K
                                    f
                                 
                                 |
                              
                              −
                              1
                              }
                              ,
                           
                         we define 
                           
                              
                                 D
                                 
                                    k
                                    q
                                 
                              
                              =
                              
                                 t
                                 
                                    k
                                    
                                       q
                                       +
                                       1
                                    
                                 
                              
                              −
                              
                                 t
                                 
                                    k
                                    q
                                 
                              
                           
                         as the distance between two consecutive time windows in Kf
                        . Then, those 
                           
                              
                                 |
                                 
                                    K
                                    f
                                 
                                 |
                              
                              −
                              1
                           
                         distances are re-indexed by increasing order (
                           
                              
                                 D
                                 1
                              
                              ≤
                              ⋯
                              ≤
                              
                                 D
                                 
                                    
                                       |
                                       
                                          K
                                          f
                                       
                                       |
                                    
                                    −
                                    1
                                 
                              
                           
                        ). Algorithm 1
                         returns the tightest upper bound on the stability radius. For each face, it computes r, the residual energy after monitoring the time windows in Kf
                        . Whenever the residual energy to monitor the target between the closest time windows is sufficiently large, these time windows are merged by removing the corresponding distance 
                           
                              min
                              D
                           
                        . Then, the number of directions of expansion 
                           
                              2
                              (
                              
                                 |
                                 D
                                 |
                              
                              +
                              1
                              )
                           
                         is also decreased. The algorithm stops when the maximal expansion at each time window extremity, 
                           
                              
                                 r
                                 
                                    2
                                    (
                                    
                                       |
                                       D
                                       |
                                    
                                    +
                                    1
                                    )
                                 
                              
                              ,
                           
                         is less than or equal to the half-distance between the closest consecutive time windows 
                           
                              min
                              D
                           
                        .

                           Lemma 1
                           
                              UB1′ and UB2′ have no performance guarantee on the stability radius ρ.
                           

There exists an instance for which 
                                 
                                    ρ
                                    =
                                    0
                                    ,
                                 
                               
                              UB1′ > 0 and UB2′ > 0. Such an instance is given in Appendix.□

In this section, we introduce the decision problem associated to the scheduling problem. Afterwards, we exploit the decision problem to solve efficiently the scheduling problem.

Let ρ be an arbitrary positive value. The decision problem consists in answering the question: Does there exist a feasible schedule such that its stability radius is at least ρ? This problem can be reduced to the well-studied Transportation Problem (TP), that can be solved in polynomial time using a method based on the Kuhn’s combinatorial algorithm for the assignment problem (Ford & Fulkerson, 1956).

First of all, we consider the case where 
                           
                              ρ
                              =
                              0
                           
                        . An instance 
                           
                              I
                              0
                           
                         of TP is built as follows: sensors are the suppliers having capacity Ei
                         and time windows are the customers having demand Δk
                        . The decision variables are xik
                        , the amount of time during which sensor i monitors the target during time window k. To obtain a balanced transportation problem, the total demand should be equal to the total supply. We set 
                           
                              
                                 Δ
                                 
                                    p
                                    +
                                    1
                                 
                              
                              =
                              
                                 ∑
                                 
                                    i
                                    ∈
                                    I
                                 
                              
                              
                                 E
                                 i
                              
                              −
                              
                                 ∑
                                 
                                    k
                                    ∈
                                    K
                                 
                              
                              
                                 Δ
                                 k
                              
                              ,
                           
                         and the variables 
                           
                              x
                              
                                 i
                                 
                                    p
                                    +
                                    1
                                 
                              
                           
                         are the residual capacities of the sensors. The transportation costs cik
                         are the penalties on the use of infeasible activities, i.e. activities based on sensor i to cover some time window k such that 
                           
                              i
                              ∉
                              S
                              (
                              k
                              )
                           
                        . For all i ∈ I, 
                           
                              
                                 c
                                 
                                    i
                                    
                                       p
                                       +
                                       1
                                    
                                 
                              
                              =
                              0
                           
                        .

                           
                              
                                 
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    k
                                    ∈
                                    K
                                    :
                                    
                                       c
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                0
                                             
                                             
                                                
                                                   
                                                   
                                                      if
                                                   
                                                   
                                                   i
                                                   ∈
                                                   S
                                                   (
                                                   k
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   i
                                                   ∉
                                                   S
                                                   (
                                                   k
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Then the objective is to minimize the total time during which infeasible activities are used to cover the target. The problem can be stated as follows:

                           
                              (1)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                          ∪
                                          {
                                          p
                                          +
                                          1
                                          }
                                       
                                    
                                    
                                       c
                                       
                                          i
                                          k
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                          ∪
                                          {
                                          p
                                          +
                                          1
                                          }
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    
                                       E
                                       i
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    
                                       Δ
                                       k
                                    
                                    
                                    ∀
                                    k
                                    ∈
                                    K
                                    ∪
                                    
                                       {
                                       p
                                       +
                                       1
                                       }
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    k
                                    ∈
                                    K
                                    ∪
                                    
                                       {
                                       p
                                       +
                                       1
                                       }
                                    
                                 
                              
                           
                        
                     

Constraint (2) ensures that the total activity of a sensor does not exceed its battery lifetime. Constraint (3) imposes that the target is monitored during all the time windows.

First of all, there exists a feasible schedule if and only if the optimal objective value is zero. The transportation problem provides also a feasible schedule. It can be built using the xik
                         variables. These variables act as budgets spent for sensing activities. For each strictly positive value of xik
                        , we create an activity involving the sensor i during the time window k, of duration xik
                        . Then, in each time window, the activities are sequenced in an arbitrary order, without overlap.

In order to decide the existence of a feasible schedule for a given ρ > 0, we generate a new instance 
                           
                              I
                              ρ
                           
                        . The value of ρ must be such that any feasible solution for 
                           
                              I
                              ρ
                           
                         provides a feasible solution for the original problem such that the stability radius is greater than or equal to ρ. Since the stability radius is bounded by the durations between activities and the boundaries of their corresponding availability intervals, the procedure consists in restricting the availability intervals of the sensors to forbid any activity that would cause the stability radius to be less than ρ. In Section 2.2, we considered two classes of ticks: entering and leaving. The entering ticks are translated by ρ and the leaving ones by 
                           
                              −
                              ρ
                           
                        . As soon as an entering tick tk
                         and a leaving tick 
                           
                              t
                              
                                 k
                                 +
                                 1
                              
                           
                         meet together, their position in the ordered list of ticks are exchanged and the set of candidate sensors S(k) is updated as follows:

                           
                              
                                 
                                    S
                                    (
                                    k
                                    )
                                    ←
                                    S
                                    (
                                    k
                                    −
                                    1
                                    )
                                    ∩
                                    S
                                    (
                                    k
                                    +
                                    1
                                    )
                                 
                              
                           
                        The procedure is summarized in Algorithm 2
                        . If there exists k ∈ K such that 
                           
                              S
                              (
                              k
                              )
                              =
                              ∅
                           
                         and Δk
                         > 0, then the current instance is infeasible.


                        Fig. 12
                         shows an example with 3 sensors, where the target trajectory is represented by the straight line oriented from left to right. The instance 
                           
                              I
                              
                                 1.5
                              
                           
                         can be built in two steps. First, the entering ticks are moved by 
                           
                              +
                              1
                           
                         and the leaving ticks by 
                           
                              −
                              1
                           
                         (Fig. 13
                        ). At this point, ticks t
                        3 and t
                        4 meet together. Consequently, they are swapped, and the sensor s
                        3 is not a candidate anymore between these ticks. This is characterized in Fig. 14
                         by the 2 open square brackets connections to s
                        3. Note that this is not anymore an interval but rather a forbidden interval for s
                        3. Next, the same procedure is applied by moving the ticks by 0.5. Hence, the schedule shown in Fig. 14 achieves a stability radius of 1.5.

The scheduling problem is to find a schedule that maximizes the stability radius ρ. Algorithm 3 addresses this problem with dichotomy. It starts by testing the existence of a feasible schedule for 
                           
                              ρ
                              =
                              0
                           
                         and 
                           
                              ρ
                              =
                              U
                              B
                              ,
                           
                         where 
                           
                              U
                              B
                              =
                              min
                              {
                              U
                              B
                              
                                 1
                                 ′
                              
                              ,
                              U
                              B
                              
                                 2
                                 ′
                              
                              }
                           
                        . If there exists a feasible schedule for 
                           
                              ρ
                              =
                              U
                              B
                              ,
                           
                         then the problem is solved. If there does not exist a feasible schedule for 
                           
                              ρ
                              =
                              0
                              ,
                           
                         then the problem is infeasible. Otherwise, our algorithm computes an ordered list 
                           D
                         containing all the positive distances 
                           
                              
                                 t
                                 
                                    k
                                    ′
                                 
                              
                              −
                              
                                 t
                                 k
                              
                              <
                              U
                              B
                           
                         where tk
                         is an entering tick and 
                           
                              t
                              
                                 k
                                 ′
                              
                           
                         is a leaving tick. The elements of 
                           D
                         are indexed by increasing order. Then, the algorithm finds the maximal value 
                           
                              D
                              ℓ
                           
                         for which there exists a feasible schedule with a stability radius of 
                           
                              ρ
                              ≥
                              
                                 D
                                 ℓ
                              
                           
                         using the dichotomy method. At each iteration, the decision problem is solved using the transportation problem formulation (SolveTP). The bounds on ρ, 
                           
                              D
                              
                                 ℓ
                                 min
                              
                           
                         and 
                           
                              
                                 D
                                 
                                    ℓ
                                    max
                                 
                              
                              ,
                           
                         are updated according to the fact that the transportation problem has a zero optimal value or not. Then, since 
                           
                              ρ
                              ∈
                              [
                              
                                 D
                                 
                                    ℓ
                                    min
                                 
                              
                              ,
                              
                                 D
                                 
                                    ℓ
                                    max
                                 
                              
                              )
                              ,
                           
                         a linear program is solved to build an optimal solution. The variables of the linear program are the following:


                        
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          
                                             
                                                δ
                                                ≥
                                                0
                                             
                                          
                                       
                                       Improvement of 
                                             ρ
                                           over 
                                             
                                                D
                                                
                                                   ℓ
                                                   min
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   
                                                      i
                                                      k
                                                   
                                                
                                                ≥
                                                0
                                             
                                          
                                       
                                       Amout of sensing activity allocated to the sensor 
                                             
                                                i
                                                ∈
                                                I
                                             
                                           for the time window 
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective is to maximize the improvement δ. The LP model is described by:

                           
                              (5)
                              
                                 
                                    max
                                    
                                    δ
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                          ∣
                                          i
                                          ∈
                                          S
                                          (
                                          k
                                          )
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    ≤
                                    
                                       E
                                       i
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          S
                                          (
                                          k
                                          )
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    =
                                    
                                       Δ
                                       k
                                    
                                    +
                                    
                                       (
                                       
                                          σ
                                          
                                             k
                                             +
                                             1
                                          
                                       
                                       −
                                       
                                          σ
                                          k
                                       
                                       )
                                    
                                    δ
                                    
                                    ∀
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    δ
                                    ≥
                                    0
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       x
                                       
                                          i
                                          k
                                       
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    k
                                    ∈
                                    K
                                    ,
                                    i
                                    ∈
                                    S
                                    
                                       (
                                       k
                                       )
                                    
                                 
                              
                           
                        
                     

Where 
                           
                              
                                 σ
                                 k
                              
                              =
                              
                                 {
                                 
                                    
                                       
                                          1
                                       
                                       
                                          
                                             if
                                             
                                             
                                                t
                                                k
                                             
                                             
                                             is
                                             
                                             an
                                             
                                             entering
                                             
                                             tick
                                          
                                       
                                    
                                    
                                       
                                          
                                             −
                                             1
                                          
                                       
                                       
                                          
                                             if
                                             
                                             
                                                t
                                                k
                                             
                                             
                                             is
                                             
                                             a
                                             
                                             leaving
                                             
                                             tick
                                          
                                       
                                    
                                 
                              
                           
                        .

Constraint (6) limits the total activity duration of a sensor by its battery lifetime. Constraint (7) allocates a sufficient amount of sensing time between the candidate sensors to monitor the target during each time window.

Once the solution is obtained, the schedule is built as shown in Section 5.1. In the final schedule, the total amount of energy spent by the sensors is 
                           
                              H
                              +
                              2
                              ρ
                              ,
                           
                         since it begins ρ units of time before t
                        1 and ends ρ units of time after 
                           
                              t
                              
                                 p
                                 +
                                 1
                              
                           
                        . In the sequel, we define 3 lemmas that state the finiteness of ρ and the complexity status of the problem.

                           Lemma 2
                           
                              ρ is finite if and only if
                              
                                 
                                    
                                       ⋂
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    S
                                    
                                       (
                                       k
                                       )
                                    
                                    =
                                    ∅
                                 
                               
                              or
                              
                                 
                                    ∀
                                    i
                                    ∈
                                    
                                       ⋂
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    S
                                    
                                       (
                                       k
                                       )
                                    
                                    ,
                                 
                               
                              Ei is finite.
                           

First of all, if 
                                 
                                    
                                       ⋂
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    S
                                    
                                       (
                                       k
                                       )
                                    
                                    =
                                    ∅
                                    ,
                                 
                               then the target crosses at least two faces with no sensors in common. Therefore, there exists no set of sensors able to cover the whole trajectory and ρ must be finite. If for all i in  ∩ 
                                 k ∈ K
                              
                              S(k), Ei
                               is finite, then the stability radius is at most 
                                 
                                    U
                                    B
                                    
                                       1
                                       ′
                                    
                                    ≤
                                    
                                       
                                          1
                                          2
                                       
                                    
                                    
                                       (
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             
                                                ∩
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             S
                                             
                                                (
                                                k
                                                )
                                             
                                          
                                       
                                       
                                          E
                                          i
                                       
                                       +
                                       H
                                       )
                                    
                                 
                              . Conversely, if ρ is finite, then any sensor able to cover the whole trajectory, if such a sensor exists, has a finite capacity.□


                              The scheduling problem is solvable in a pseudo-polynomial number of operations, in
                              
                                 
                                    O
                                    (
                                    m
                                    p
                                    (
                                    m
                                    +
                                    p
                                    )
                                    log
                                    p
                                    )
                                 
                              
                              .
                           

The discretization algorithm, running in polynomial time, generates p time windows. The existence of a feasible schedule, stated as a Transportation Problem in Section 5.1, can be reduced to an equivalent Max Flow Problem by building a graph with vertices associated to sensors and time windows, and by comparing the flow value to the time horizon. The Max Flow Problem is solvable in 
                                 
                                    O
                                    (
                                    |
                                    V
                                    ∥
                                    E
                                    |
                                    )
                                 
                               (Orlin, 2013), where 
                                 
                                    |
                                    V
                                    |
                                    =
                                    O
                                    (
                                    m
                                    +
                                    p
                                    )
                                 
                               is the number of vertices and 
                                 
                                    |
                                    E
                                    |
                                    =
                                    O
                                    (
                                    m
                                    p
                                    )
                                 
                               is the number of arcs. Therefore, since the dichotomy processes a logarithmic number of iterations, the complexity is in 
                                 
                                    O
                                    (
                                    m
                                    p
                                    (
                                    m
                                    +
                                    p
                                    )
                                    log
                                    p
                                    )
                                 
                              .□

An example in which the number of ticks is as large as desired is shown in Appendix.

                           Lemma 4
                           
                              If the trajectory is a piecewise linear curve composed of q straight segments, then the problem is solvable in a polynomial number of operations, in
                              
                                 
                                    O
                                    (
                                    
                                       q
                                       2
                                    
                                    
                                       m
                                       3
                                    
                                    log
                                    
                                       (
                                       q
                                       m
                                       )
                                    
                                    )
                                 
                              
                              .
                           

The proof is based on the geometry resulting in the intersection of segments and discs. Each segment can cross at most twice each sensors circle. Consequently, the number of ticks is at most 2qm, so the number of time windows is at most 
                                 
                                    p
                                    =
                                    2
                                    q
                                    m
                                    −
                                    1
                                 
                              . The decision problem, stated as an equivalent Max Flow Problem, can be solved in 
                                 
                                    O
                                    (
                                    |
                                    V
                                    ∥
                                    E
                                    |
                                    )
                                 
                               (Orlin, 2013), where 
                                 
                                    |
                                    V
                                    |
                                    =
                                    O
                                    (
                                    q
                                    m
                                    )
                                 
                               is the number of vertices and 
                                 
                                    |
                                    E
                                    |
                                    =
                                    O
                                    (
                                    q
                                    
                                       m
                                       2
                                    
                                    )
                                 
                               is the number of arcs. Since the dichotomy processes a logarithmic number of iterations, the complexity is in 
                                 
                                    O
                                    (
                                    
                                       q
                                       2
                                    
                                    
                                       m
                                       3
                                    
                                    log
                                    
                                       (
                                       q
                                       m
                                       )
                                    
                                    )
                                 
                              .□

Let us process a simple example similar to the instance shown in Fig. 3. There are 3 sensors {s
                        1, s
                        2, s
                        3} having respective coordinates 
                           
                              (
                              −
                              3
                              ,
                              0
                              )
                              ,
                           
                        
                        
                           
                              (
                              0
                              ,
                              −
                              5
                              )
                              ,
                           
                         (3, 0). Each sensor has a sensing radius 
                           
                              R
                              =
                              6
                           
                         and an initial capacity 
                           
                              
                                 E
                                 i
                              
                              =
                              15
                           
                        . The target trajectory is a piecewise linear curve that passes through 5 control points described in Table 3
                        . The speed of the target is uniform along each segment, but is subject to change after passing a control point.

Because the trajectory is composed of segments, the discretization step is performed by solving quadratic equations representing intersections between segments and circles.

The target passes through the faces 
                           
                              
                                 f
                                 1
                              
                              =
                              
                                 {
                                 
                                    s
                                    1
                                 
                                 }
                              
                              ,
                           
                        
                        
                           
                              
                                 f
                                 2
                              
                              =
                              
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 
                                    s
                                    2
                                 
                                 }
                              
                              ,
                           
                        
                        
                           
                              
                                 f
                                 3
                              
                              =
                              
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 
                                    s
                                    2
                                 
                                 ,
                                 
                                    s
                                    3
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 f
                                 4
                              
                              =
                              
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 
                                    s
                                    3
                                 
                                 }
                              
                           
                        . The set of ticks and the sequence of faces obtained are given in the Table 4
                        . The two upper bounds UB1′ and UB2′ are computed as described in Section 4.

                           
                              
                                 
                                    
                                       
                                          
                                             U
                                             B
                                             
                                                1
                                                ′
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             min
                                             {
                                             7.5
                                             ,
                                             8.584
                                             ,
                                             10.595
                                             ,
                                             11.829
                                             ,
                                             15
                                             ,
                                             9.51
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             10.745
                                             ,
                                             15
                                             ,
                                             8.734
                                             ,
                                             7.5
                                             }
                                             =
                                             7.5
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    U
                                    B
                                    
                                       2
                                       ′
                                    
                                    =
                                    min
                                    
                                       {
                                       3.165
                                       ,
                                       9.5
                                       ,
                                       17
                                       ,
                                       9.5
                                       }
                                    
                                    =
                                    3.165
                                 
                              
                           
                        
                     

Thus, an upper bound on the stability radius is 
                           
                              U
                              B
                              =
                              3.165
                           
                        . The first step is to test whether there exists a feasible instance such that 
                           
                              ρ
                              =
                              U
                              B
                           
                        . Solving the transportation problem associated to the instance 
                           
                              I
                              
                                 3.165
                              
                           
                         gives a strictly positive value, so the optimal value of ρ is guaranteed to be strictly less than 3.165.

The second step is to test the feasibility for 
                           
                              ρ
                              =
                              0
                           
                        . Since 
                           
                              I
                              0
                           
                         is feasible, the dichotomy algorithm has to be applied. The ordered set of distances 
                           
                              
                                 t
                                 k
                                 ′
                              
                              −
                              
                                 t
                                 k
                              
                              <
                              U
                              B
                           
                         is 
                           
                              D
                              =
                              {
                              0
                              ,
                              2.01
                              ,
                              3.095
                              }
                           
                        . Table 5
                         gives the values of Δk
                         associated to the different instances according to the value of ρ.

The dichotomy processes for the values 
                           
                              ρ
                              =
                              2.01
                           
                         that gives a feasible instance, and 
                           
                              ρ
                              =
                              3.095
                           
                         that gives an infeasible instance. Then, the optimal value of ρ belongs to the interval [2.01, 3.095). Finally, the optimal objective value of the LP defined by Eqs. (5)–(9) is 
                           
                              δ
                              =
                              0.769
                           
                        . Thus, the optimal value of ρ is 2.779. The obtained schedule is shown in Fig. 15
                        . We observe that the stability radius is limited specifically by the capacity of the sensor s
                        1 which is totally consumed. The total energy spent by the sensors is 
                           
                              H
                              +
                              2
                              ρ
                              =
                              16.558
                           
                         units of energy.

The proposed approach is tested on a set of 200 randomly generated instances. The instance generator randomly generates a target path lying inside a 
                        
                           (
                           
                              
                                 10
                                 m
                              
                           
                           ×
                           
                              
                                 10
                                 m
                              
                           
                           )
                        
                      square region. This path is a piecewise linear curve composed of 9 segments joining 10 randomly chosen control points. To each control point is associated a date that is the date of passage of the target. The dates are uniformly dispatched along the time horizon. As the control points are completely random, the target can come back in the same face several times. Then, it randomly dispatches a set of m sensors (m ∈ {100, 200, 500, 1000}) such that each sensor is able to cover a part of the trajectory. Any part of the trajectory can also be covered by several sensors. The fixed parameters are 
                        
                           R
                           =
                           10
                        
                      (sensing radius) and 
                        
                           H
                           =
                           10
                           m
                        
                      (time horizon). Several values of initial sensor capacity (Ei
                      ∈ {12, 16, 20}) have been tested for each instance.

The implementation has been coded in C++ and executed on an Xeon processor W3520 (2.67 gigahertz × 8) with 8 gigabytes RAM under Linux (Ubuntu 14.04). The linear program defined by Eqs. (5)–(9) is solved using IBM CPLEX 12.6.1. The decision problem is solved with the LEMON library version 1.3.1 from COIN-OR (Dezső, Jüttner, & Kovács, 2011), after being reformulated as a maximum flow problem.


                     Table 6
                      presents results for the 4 classes of 50 instances grouped by number of sensors (m ∈ {100, 200, 500, 1000}). The second column p is the average number of ticks. Each line contains a quadruplet 
                        
                           #
                           U
                           B
                           1
                        
                     /
                        
                           #
                           U
                           B
                           2
                        
                     /
                        
                           #
                           ∅
                        
                     /
                        
                           #
                           I
                           n
                           f
                        
                      where 
                        
                           #
                           U
                           B
                           1
                        
                      (respectively 
                        
                           #
                           U
                           B
                           2
                        
                     ) is the number of instances for which UB1′ (respectively UB2′) is reached, n
                     ∅ is the number of instances for which none of the upper bounds is reached, and 
                        
                           #
                           I
                           n
                           f
                        
                      is the number of infeasible instances.

The upper bound UB1′ dominates UB2′ in 93.4percent of the feasible instances. UB2′ seems to be more efficient when the initial capacity of the sensors is critical, i.e. the capacity is just enough to ensure the feasibility of the instance. Thus, the initial capacity of the sensors is a significant factor in the computation time.

When one of the upper bounds is reached, the calculation of the upper bounds represents for 45.8 percent of the total computation time in average. The generation of the instances 
                        
                           I
                           ρ
                        
                      in Algorithm 3 runs for 37.6 percent of the time on average. For all other feasible instances, the calculation of the upper bounds is only 7.58 percent of the total computational time. The generation of the instances 
                        
                           I
                           ρ
                        
                      represents 62.3% of the total time, whereas solving the TP is about 22.6 percent of the time.

As expected, the problem difficulty increases with the instance size (where the instance size can be measured in terms of number of sensors, and also in terms of number of ticks). However, it can be seen in Table 6 that the initial energy also plays a major role in the problem. Indeed, for low initial energy, most of the instances are infeasible. This is particularly noticeable for large instances, where the target is moving in a large area. By contrast, when energy is abundant, most of the instances are feasible, and more specifically, UB1′ is reached in most cases (in particular for small instances). Again, this is due to the fact that when sensors have high initial energy, the stability radius is rarely limited by energy (as in UB2′), but mostly set by the minimum distance between two time windows having no (or few) candidate sensors in common. Intermediate cases (
                        
                           
                              E
                              i
                           
                           =
                           16
                        
                     ) are more interesting, since for a lot of instances, no bound is reached, even if feasible instances are most of the time feasible. In this case, the dichotomy approach of Algorithm 3 is actually used. So these results show that the problem is generally easy to solve for extreme cases (low of high sensor initial energy), and the gap between these two extreme cases is rather narrow.


                     Table 7
                      shows the average CPU time when UB1′ or UB2′ is met (second column) and when none of these bounds is met (third column). Feasible instances only are taken into account for building Table 7. This table shows the efficiency of the upper bounds in solving the problem. The feasible instances for which UB1′ or UB2′ is optimal are in average about 5–7 times faster to solve than the rest of the feasible instances. This is due to the fact that whenever one of the upper bounds is reached, Algorithm 3 stops before the dichotomy step.


                     Table 8
                      gives the average computation times and the average optimal values of ρ according to the number of sensors and the initial battery capacity. The column CPU0 contains the average time to reach the beginning of the loop of the dichotomy, i.e., the moment when the first feasible solution with 
                        
                           ρ
                           =
                           0
                        
                      is found. The column CPU
                        ρ
                      displays the average time to obtain an optimal solution.

A solution with a zero stability radius, such as the one found before the beginning of the dichotomy (see Table 8) consumes less energy than a maximum stability radius solution. This is due to the fact that the sensors have to be active ρ units of time before the target expected starting time, and ρ units of time after the arrival time. So the extra energy cost of a solution having a stability radius of ρ is equal to 2ρ. In our instances, the extra energy cost represents 4.1 percent of the time horizon in average, and 16.1 percent in the worst case.

The computational effort required to obtain an optimal solution highly depends on the instance. When the instance is infeasible, or the upper bound is reached by the optimal solution, CPU
                        ρ
                      is equal to CPU0, because the algorithm stops before the dichotomy. Otherwise, CPU
                        ρ
                      can be significantly larger because of the dichotomy. The value for CPU
                        ρ
                      shown in Table 8 accounts for situations that lie in between these two extreme scenarios.

In this paper, we investigated a robustness problem of target tracking using wireless sensor networks. To the best of our knowledge, this problem has not been previously studied in the literature. The method proposed finds a robust sensor activity schedule in two steps. The discretization step transforms the input data into a scheduling problem instance. Then a dichotomy algorithm processes the instance in order to maximize its stability radius. By this approach, we prove that the overall problem can be solved in a pseudo-polynomial number of iterations, and a polynomial number of iterations if the target trajectory is a piecewise linear curve. Computational experiments show that the approach is scalable and solves problem instances involving up to 1000 sensors in less than 15 seconds on average. The two proposed upper bounds, especially UB1′, contribute to significatively speed up the method, as they are often reached and avoid to run the dichotomy algorithm. We have also shown the impact of sensors initial energy capacity on the computational effort required by the approach.

As a perspective of our work, another alternative to this problem could be to select sensors in order to save sensor capacity in a particular area. Thus, considering an enemy target that wishes to escape monitoring or to exhaust the sensors in a specific area, a problem variant could be to compute how long and where to send a target in order to compromise monitoring. In this paper, we have not considered the problem of routing collected data to a base station using multi-hop communication. This first study establishes simple and efficient upper bounds, that could be more difficult when communication issues are taken into account. However, the proposed framework can easily be extended to multiple target tracking without communication. Finally, we could consider that the spatial trajectory of the targets is subject to uncertainty. This hypothesis may lead to consider problem variants where the time horizon is shorter, in order to cover the area in which the target is likely to be found, according to its speed and maneuverability. The robustness-based approach could also be complemented by a reactive approach, in order to cope with uncertainty on long trajectories.

@&#ACKNOWLEDGMENTS@&#

We thank Direction Générale de l’Armement (DGA) for a financial support to this work under the number 2013 - 126272 DGA/DS/MRIS.

An instance for which 
                        
                           ρ
                           =
                           0
                        
                      and min {UB1′, UB2′} > 0 can be built as follows. The instance is composed of 3 sensors: s
                     1, s
                     2 and s
                     3. Sensor s
                     1 is available during the interval [0, 5], s
                     2 during the interval [2, 10] and s
                     3 during [7, 12]. The initial capacity of each sensor is 
                        
                           
                              E
                              i
                           
                           =
                           4
                        
                     . The instance is illustrated in Fig. A.16
                     .

There exists a feasible schedule such that 
                        
                           ρ
                           =
                           0
                        
                     . The latter enables s
                     1 during [0, 4], s
                     2 during [4, 8] and s
                     3 during [8, 12]. The sum of the sensor capacities is 12, equal to the time horizon. Therefore, the stability radius cannot be larger than zero, and the proposed schedule is optimal.

The upper bound UB1′ is limited by the distance between the closest pair of time windows having no sensor in common, i.e. the time windows 1 and 3, or 3 and 5. Then 
                        
                           U
                           B
                           
                              1
                              ′
                           
                           =
                           
                              3
                              2
                           
                           =
                           1.5
                        
                     .

The total available capacity in the face composed of s
                     1 and s
                     2 (reached during the time window 2) is 8. As the candidate sensors of the time windows 1 and 3 are included in the set of candidate sensors of the time window 2, we assume that s
                     1 and s
                     2 will be used at least 7 units of time. Then the remaining capacity is 1 to extend the time windows, in 2 directions. Therefore, 
                        
                           U
                           B
                           
                              2
                              ′
                           
                           =
                           
                              1
                              2
                           
                           =
                           0.5
                        
                     .

The instance composed of 2 sensors in Fig. B.17
                      shows that the problem is solvable in a pseudo-polynomial number of operations.

The target trajectory is modeled as a sinusoid that moves along the boundary of the sensing area of one of the sensors. Since the period of the sinusoid can be as short as desired, the number of intersections with the boundary (also the number of time windows) can be as large as desired. Therefore, the number of iterations of the algorithm strongly depends on the period of the sinusoid.

@&#REFERENCES@&#

