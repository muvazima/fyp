@&#MAIN-TITLE@&#Sequential heuristic for the two-dimensional bin-packing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A heuristic for the 2D bin-packing problem is proposed.


                        
                        
                           
                           The sequential value correction method is applied to the problem.


                        
                        
                           
                           Both guillotine and free patterns can be used.


                        
                        
                           
                           The algorithm yields solutions better than those of the published algorithms.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Packing

2D bin-packing

Sequential value correction

@&#ABSTRACT@&#


               
               
                  A heuristic approach for the two-dimensional bin-packing problem is proposed. The algorithm is based on the sequential heuristic procedure that generates each pattern to produce some items and repeats until all items are produced. Both guillotine and non-guillotine patterns can be used. Each pattern is obtained from calling a pattern-generation procedure, where the objective is to maximize the pattern value. The item values are adjusted after the generation of each pattern using a value correction formula. The algorithm is compared with five published algorithms, using 50 groups of benchmark instances. The results indicate that the algorithm is the most efficient in improving solution quality.
               
            

@&#INTRODUCTION@&#

In the industries such as wood, metal and glass, it is often necessary to produce a set of rectangular items i
                     ∈
                     I
                     ={1,…,
                     m} with length l
                     
                        i
                      and height h
                     
                        i
                      (the demand of each item type is 1), from larger bins with length L and height H. This can be modeled as the two-dimensional bin-packing problem (2BP). The objective is to minimize material input (number of bins). It is assumed that each item must be packed parallel to the edge of a bin, in either the given orientation or 90 degrees rotated. A choice should be made between either using guillotine patterns or free (non-guillotine) ones.

The 2BP can be classified according to the following two rules (Lodi, Martello, & Daniele, 1999):
                        
                           (1)
                           Orientation: the items may have either a fixed orientation or 90 degrees rotated.

Type of cuts: whether or not the cutting patterns should meet the requirement of guillotine cuts.

Considering the combination of these two rules, the 2BP can be classified into four types:
                        
                           (1)
                           2BPOG: Items are oriented (O) and guillotine cuts are required (G).

2BPRG: Items may be rotated by 90 degrees (R) and guillotine cuts are required (G).

2BPOF: Items are oriented (O) and cutting is free (F).

2BPRF: Items may be rotated by 90 degrees (R) and cutting is free (F).

The solution of the 2BP is a cutting plan that contains a set of cutting patterns, each of which has specified items layout. The (usage) frequency of each pattern is one, or equivalently, the number of patterns is equal to the number of bins used.

In this paper, a sequential value correction heuristic (SVC2BPR) for 2BPR (both 2BPRG and 2BPRF) is presented. The algorithm is denoted as SVC2BPRG when guillotine patterns are used and as SVC2BPRF when free patterns are allowed. It generates a specified number of cutting plans, using different item values. The cutting plan that yields the minimum number of bins is selected as the solution. Each pattern in the current cutting plan is obtained from calling a pattern-generation procedure, where the objective is to maximize the pattern value, that is, the total value of the included items. Initially the item values are equal to their areas. To diversify the cutting plans, the values of the items included in the current pattern are corrected after each pattern being generated based on the size of the items and the material utilization of the pattern, using a formula similar to those in the literature (Belov & Scheithauer, 2007; Belov, Scheithauer, & Mukhacheva, 2008; Cui, Yang, & Chen, 2013). 500 benchmark instances in 50 groups are used to test the performance of the algorithm. The computational results show that the algorithm can achieve better solutions in a reasonable amount of time, compared to five algorithms published in the literature (Boschetti & Mingozzi, 2003; Charalambous & Fleszer, 2011; Harwig, Barnes, & James, 2006; Hayek, Moukrim, & Negre, 2008; Polyakovsky & M’Hallah, 2009).

The paper makes contributions possibly from the following aspects:
                        
                           (1)
                           It may be the first to solve the 2BPR with a sequential procedure that is based on value correction of the items

It may be the first to use the patterns with the specified geometric structure (described later in Section 3.1) to solve the 2BPRG. This type of patterns is easy to use in practice.

It proposes a look-ahead strategy adequate for improving the quality of the free patterns used in this paper.

The proposed algorithm is able to improve the average solution qualities of both 2BPRG and 2BPRF benchmark instances.

The next sections are arranged as follows. Literature is reviewed in Section 2. The SVC2BPR is presented in Section 3. In Section 4, benchmark instances are used to evaluate the algorithm’s effectiveness in material input minimization, and the computational results are compared with those of five published algorithms. Conclusions are given in the last section.

@&#LITERATURE REVIEW@&#

A thorough introduction to the 2BP can be seen in Lodi, Martello, and Vigo (2002A). Recent approaches on the 2BP can also be found in Wei, Oon, and Zhu (2013), Liao and Hsu (2013) and Han, Bennell, and Zhao (2013).

In Lodi et al. (1999), a new heuristic algorithm is introduced for each one of the four 2BP types. Also, a unified tabu search approach is adapted to a specific problem by changing the heuristic used to explore the neighborhood. The heuristic algorithm and the search are evaluated in the paper.

In Dell’Amico, Martello, and Vigo (2002) and Clautiaux, Jouglet, and Hayek (2007), lower bound for the 2BP is discussed. Lower bounds are useful in evaluating the efficiency of the algorithms. They can also be used to reduce the computation time because the searching process can be terminated once the solution value reaches the lower bound.

Algorithms for the 2BPO (2BPOG or 2BPOF) may be extended to deal with the 2BPR, but the extending may be not straightforward. Considering that the algorithm proposed in this paper deals with the 2BPR only. The review in this section is focused on those papers that involve the 2BPR.

From the comment on exact 2BP algorithms in the literature (Polyakovsky & M’Hallah, 2009), the following conclusions can be drawn. The 2BPR is NP-hard. Solving it exactly is generally impossible; especially when the instance contains a large number of items. The literature review in this paper will concentrate on heuristic algorithms. The reader is referred to Lodi, Martello, and Vigo (2002B) for more detailed descriptions of the exact methods.

Three constructive heuristics: first-fit insertion, best-fit insertion and critical-fit insertion are proposed in Fleszar (2013). The heuristics use tree structures to represent guillotine patterns and process by insertion one item at a time in a partial solution. Central to all heuristics are a new procedure for enumerating possible insertions and a new fitness criterion for choosing the best insertion. All new heuristics have quadratic worst-case computational complexity except for the critical-fit insertion heuristic that has a cubic complexity. The efficiency and effectiveness of the proposed heuristics are demonstrated by comparing their empirical performance on a standard benchmark data set against other published approaches.

Stochastic neighborhood structures (SNS) are combined with heuristic algorithm to solve two-stage and three-stage 2BP with guillotine cuts in Chan, Alvelos, Silva, and Carvalho (2011). The SNS comprises three random neighborhood structures based on modifying the current sequence of items. According to the computation results, the SNS provides solutions within a small percentage of the optimal values, and generally makes significant improvements in cutting stock instances and slight to moderate improvements in bin-packing instances.

The heuristic in Charalambous and Fleszer (2011) constructs a solution by packing a bin at a time. Central to the adopted solution scheme is the principle of average-area sufficiency proposed by the authors for guiding the selection of items to fill a bin. The algorithm is tested on a set of standard benchmark instances and compared with existing heuristics producing the best-known results. The results presented attest to the efficiency of the proposed scheme.


                        Polyakovsky and M’Hallah (2009) proposed a new guillotine bottom left (GBL) constructive heuristic and its agent-based (A-B) implementation to solve the 2BP with guillotine cuts. The A-B system consists of active agents dynamically interacting in real time to jointly fill the bins while each agent is driven by its own parameters, decision process and fitness assessment. The GBL is the basis of each agent. It places items in the bottom-left most available position of the bin and decides the direction of the first cut of the strip containing the packed item. It subsequently updates the two unoccupied areas of the bin and continues the filling process until no unpacked item fits in the bin. A new bin is created every time the current one is saturated. This process is repeated until all items are packed.

A straightforward heuristic is proposed in Mack and Bortfelt (2012). It is based on a method for the container loading problem following a wall building approach and on a method for the one-dimensional bin-packing problem.

The algorithm SVC2BPRG in this paper is based on the sequential value correction procedure that generates a specified number of cutting plans, from which the best one is selected as the solution. The patterns in a cutting plan are generated sequentially. This makes it convenient to consider practical restrictions and objectives when necessary. The guillotine patterns used may be useful to simplify the cutting/packing process because of their simple geometric structure. Compared to two published 2BPRG algorithms that produced the best known results, the SVC2BPRG proved to be more efficient (in improving solution quality) in most of the test instances.

In Bengtsson (1982), two 2BPRF problems are considered. One is finding a way to pack an arbitrary collection of rectangular pieces into an open-ended, rectangular bin so as to minimize the height to which the pieces fill the bin (referred to as the strip packing problem in the literature). The other is to allocate the rectangular pieces into given rectangular sheets, i.e. bins of fixed width and height. Approximation algorithms are given where the solutions are achieved with heuristic search methods.


                        Boschetti and Mingozzi (2003) described new lower and upper bounds for a general version of the 2BP problem, in which case, each item is associated with an input parameter specifying if it has a fixed orientation or it can be rotated by 90 degrees.


                        Harwig et al. (2006) implemented an adaptive tabu search procedure that controls the partitioning, ordering and orientation features of a two-dimensional orthogonal packing solution. They detailed an effective fine-grained objective function for cutting and packing problems, and presented effective move neighborhoods to find good answers in a short period of time.

In Hayek et al. (2008), the concept of dependent orientation items that have special characteristics is introduced, and the formulation that characterizes these items is given. Then three pretreatments for the non-oriented version of the problem are proposed. These pretreatments allow finding optimal packing of some items subsets of the given instance. They enable increasing the total area of the items and consequently the continuous lower bound. Finally, a new heuristic method based on a best-fit algorithm adapted to the 2BP problem is presented. Numerical experiments show that the method is competitive with the heuristic and meta-heuristic algorithms proposed in the literature in respect of both the quality of the solution and the computation time.

The proposed algorithm SVC2BPRF differs from the SVC2BPRG in the pattern-generation procedure that uses a beam search method and a greedy rule. Compared to three published 2BPRF algorithms which produced the best known results, the SVC2BPRF proved to be more efficient (in improving solution quality) in most of the test instances.

The following symbols are used in this section:
                        
                           
                              
                              
                              
                                 
                                    
                                       N
                                    
                                    Number of patterns/bins (solution value)
                                 
                                 
                                    
                                       G
                                    
                                    Number of generated cutting plans
                                 
                                 
                                    
                                       G
                                       max
                                    
                                    Max number of generated cutting plans
                                 
                                 
                                    
                                       v
                                       
                                          i
                                       
                                    
                                    Value of item i,i
                                       =1,…,
                                       m
                                    
                                 
                                 
                                    
                                       b
                                       
                                          i
                                       
                                    
                                    Remaining demand of item i, b
                                       
                                          i
                                       
                                       ∈{0,1}, i
                                       =1,…,
                                       m
                                    
                                 
                                 
                                    
                                       y
                                       
                                          i
                                       
                                    
                                    Number of item i in the current pattern, y
                                       
                                          i
                                       
                                       ∈{0,1}, i
                                       =1,…,
                                       m
                                    
                                 
                              
                           
                        
                     
                  

Algorithm SVC2BPR follows the following procedure, in which the function GetPattern () is to be described for guillotine patterns in Section 3.1 and for free patterns in Section 3.2; function ValueCorrection () is to be described in Section 3.3.
                        
                           
                              Step 1: Let G
                              =0, v
                              
                                 i
                              
                              =
                              l
                              
                                 i
                              
                              h
                              
                                 i
                              , b
                              
                                 i
                              
                              =1, i
                              =1,…,
                              m.


                              Step 2: Let G
                              =
                              G
                              +1. If G
                              >
                              G
                              
                                 max
                               or 
                                 
                                    N
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   m
                                                
                                             
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   h
                                                
                                                
                                                   i
                                                
                                             
                                             /
                                             (
                                             LH
                                             )
                                          
                                       
                                    
                                 
                               then go to step 9; otherwise initialize the current cutting plan.


                              Step 3: Call GetPattern () to obtain the current pattern.


                              Step 4: Add the pattern to the current cutting plan. Set b
                              
                                 i
                              
                              =
                              b
                              
                                 i
                              
                              −
                              y
                              
                                 i
                              , i
                              =1,…,
                              m.


                              Step 5: Call ValueCorrection () to correct the values of the items included in the current pattern.


                              Step 6: Go to step 3 if ∃b
                              
                                 i
                              
                              >0, i
                              =1,…,
                              m.


                              Step 7: If the solution value is smaller than that of the best solution obtained so far, save the current plan as the best one.


                              Step 8: Go to step 2.


                              Step 9: Output the best solution.

SVC2BPR generates G
                     
                        max
                      cutting plans, from which the best one is selected as the solution. Steps 3–6 show that the patterns in the current cutting plan are generated sequentially. Each pattern is used to produce some of the items. The current cutting plan is finished when all items are produced. It replaces the best solution obtained so far if an improvement is obtained (step 7). In step 5, the values of the items are corrected after the generation of each pattern so as to diversify the cutting plans.

The pattern-generation function is called in step 3 of SVC2BPR to generate each next pattern. Its effectiveness and efficiency are vital to those of the algorithm.

To generate the cutting patterns, a variety of item combinations have to be considered. However, considering all the possible combinations is not tolerable because of the computation time limit. To reduce the computation time and simplify the cutting/packing process, the patterns of specified geometric structure can be considered. We recursively generate patterns where each guillotine cut, horizontal or vertical, separates a strip having the width of one certain item from the remaining stock piece. In next sub-sections, the geometric structure of the patterns is introduced first, then the generation of strips is presented, and the pattern generation procedure is described at last.

The proposed patterns are based on strips. As shown in Fig. 1
                           , a strip can be either horizontal or vertical. A horizontal strip contains a row of items. The strip width is equal to the maximum of the vertical edges of the included items. A vertical strip contains a column of items. The strip width is the same as the maximum of the horizontal edges of the included items.

General guillotine patterns (G, Seong, & Kang, 2003) are generated without considering geometric constraints other than the guillotine cuts. Although they are useful to improve solution quality, the packing process may be complex and the generation time is often long. To simplify the packing process and reduce computation time, general-block patterns are used in this paper. They have the feature that each cut on the bin produces just one strip except the last one that yields two strips. The strip structure is useful to simplify the packing process, where items in the same strip can be placed one by one along the bottom edge of a horizontal strip or the left edge of a vertical strip. A general block pattern is shown in Fig. 2
                           , where the numbers at the ends of the arrows denote the cutting order of the strips. The pattern contains three horizontal (strips 2, 4 and 5) and four vertical (strips 1, 3, 6 and 7) strips.

It should be noted that general blocks have been used as elements to compose complex cutting patterns in Cui and Zhang (2007), where the number of cuts necessary to produce a strip is often larger than one. The procedure in Cui and Zhang (2007) for determining general blocks cannot be used to generate the patterns for the 2BPRG, because it does not consider the constraint on the number of copies of an item.

The strips must be determined before the generation of each pattern. One key characteristic of a strip is its width. The width of a strip can be equal to the length or height of an item. Suppose that there are m items available. Then 2m strip types can be considered. Let W
                           
                              j
                            be the width of strip type j, then W
                           
                              j
                           
                           =
                           h
                           
                              j
                            when j
                           ∈{1,…,
                           m} and W
                           
                              j
                           
                           =
                           l
                           
                              j−m
                            when j
                           ∈{m
                           +1,…,2m}.

The function GetStrip (L) generates all the strip types with length L. For a particular strip type with width W and length x, let z(i,
                           x) be the maximum value of the strip obtained from considering the first i items, where i
                           =1,…,
                           m, x
                           =0,…,
                           L, and the value of a strip denotes the total value of the included items. Initially let z(0,
                           x)=0 for x
                           =0,…,
                           L, then the z(i,
                           x) values can be obtained from the following standard recursion:
                              
                                 
                                    z
                                    (
                                    i
                                    ,
                                    x
                                    )
                                    =
                                    
                                       max
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      z
                                                      (
                                                      i
                                                      -
                                                      1
                                                      ,
                                                      x
                                                      )
                                                      ;
                                                   
                                                
                                                
                                                   
                                                      z
                                                      (
                                                      i
                                                      -
                                                      1
                                                      ,
                                                      x
                                                      -
                                                      
                                                         
                                                            l
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      +
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      |
                                                      
                                                         
                                                            l
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⩽
                                                      x
                                                      ,
                                                      
                                                         
                                                            h
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⩽
                                                      W
                                                      ;
                                                   
                                                
                                                
                                                   
                                                      z
                                                      (
                                                      i
                                                      -
                                                      1
                                                      ,
                                                      x
                                                      -
                                                      
                                                         
                                                            h
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      +
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      |
                                                      
                                                         
                                                            h
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⩽
                                                      x
                                                      ,
                                                      
                                                         
                                                            l
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⩽
                                                      W
                                                      ;
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           The recursion guarantees that each strip contains at most one copy of item i. It is based on the same idea as that of the recursion for 1D knapsack problem (Kellerer, Pferschy, & Pisinger, 2004). Define q(i,
                           x) as follows to record the solution path, i
                           =1,…,
                           m and x
                           =0,…,
                           L: q(i,
                           x)=0 if z(i,
                           x)=
                           z(i
                           −1,
                           x); q(i,
                           x)=1 if z(i,
                           x)=
                           z(i
                           −1,
                           x
                           −
                           l
                           
                              i
                           )+
                           v
                           
                              i
                           ; q(i,
                           x)=2 if z(i,
                           x)=
                           z(i
                           −1,
                           x
                           −
                           h
                           
                              i
                           )+
                           v
                           
                              i
                           . The complexity for obtaining all the strips is O(m
                           2
                           L).

Let K(j,
                           x,
                           i) be the number of item i in a type j strip with length x, where K(j,
                           x,
                           i)∈{0,1}, j
                           =1,…,2m, x
                           =0,…,
                           L and i
                           =1,…,
                           m. Let f(j,
                           x) be the value of strip x
                           ⊗
                           W
                           
                              j
                            (length ⊗ width), x
                           =0,…,
                           L and j
                           =1,…,2m. For a particular j, f(j,
                           x)=
                           z(m,
                           x) can be determined for x
                           =0,…,
                           L by solving the recursion with W
                           =
                           W
                           
                              j
                           . Meanwhile q(i,
                           x) is also obtained and can be used to determine K(j,
                           x,
                           i) through backtracking, i
                           =1,…,
                           m, x
                           =0,…,
                           L.

The following symbols are used to describe the pattern generation procedure.
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             F(x,
                                             y)
                                          Value of bin x
                                             ⊗
                                             y
                                          
                                       
                                       
                                          
                                             N(x,
                                             y,
                                             i)
                                          Number of item i in bin x
                                             ⊗
                                             y
                                          
                                       
                                       
                                          
                                             η
                                             
                                                i
                                             
                                          
                                          Number of item i in the current pattern
                                       
                                       
                                          
                                             j
                                          
                                          Index of the strip types, j
                                             =1,…,2m
                                          
                                       
                                    
                                 
                              
                           
                        

The following recursion determines the value of bin x
                           ⊗
                           y:
                              
                                 (1)
                                 
                                    F
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    =
                                    
                                       max
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         max
                                                      
                                                      [
                                                      F
                                                      (
                                                      x
                                                      ,
                                                      y
                                                      -
                                                      
                                                         
                                                            W
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                      +
                                                      
                                                         
                                                            U
                                                         
                                                         
                                                            sp
                                                         
                                                      
                                                      (
                                                      j
                                                      ,
                                                      x
                                                      )
                                                      |
                                                      
                                                         
                                                            W
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ⩽
                                                      y
                                                      ]
                                                   
                                                
                                                
                                                   
                                                      
                                                         max
                                                      
                                                      [
                                                      F
                                                      (
                                                      x
                                                      -
                                                      
                                                         
                                                            W
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ,
                                                      y
                                                      )
                                                      +
                                                      
                                                         
                                                            U
                                                         
                                                         
                                                            sp
                                                         
                                                      
                                                      (
                                                      j
                                                      ,
                                                      y
                                                      )
                                                      |
                                                      
                                                         
                                                            W
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      ⩽
                                                      x
                                                      ]
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where
                              
                                 (2)
                                 
                                    
                                       
                                          U
                                       
                                       
                                          sp
                                       
                                    
                                    (
                                    j
                                    ,
                                    x
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             |
                                             K
                                             (
                                             j
                                             ,
                                             x
                                             ,
                                             i
                                             )
                                             >
                                             0
                                          
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    K
                                    (
                                    j
                                    ,
                                    x
                                    ,
                                    i
                                    )
                                    -
                                    N
                                    (
                                    x
                                    ,
                                    y
                                    -
                                    
                                       
                                          W
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    i
                                    )
                                    ]
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    
                                       
                                          U
                                       
                                       
                                          sp
                                       
                                    
                                    (
                                    j
                                    ,
                                    y
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             |
                                             K
                                             (
                                             j
                                             ,
                                             y
                                             ,
                                             i
                                             )
                                             >
                                             0
                                          
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    [
                                    K
                                    (
                                    j
                                    ,
                                    y
                                    ,
                                    i
                                    )
                                    -
                                    N
                                    (
                                    x
                                    -
                                    
                                       
                                          W
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    y
                                    ,
                                    i
                                    )
                                    ]
                                 
                              
                           Recursion (1) indicates that for each strip type, two ways of placing it are considered. One is to place it horizontally along the upper edge of the sub-bin x
                           ⊗(y
                           −
                           W
                           
                              j
                           ) and the other is to place it vertically along the right edge of the sub-bin (x
                           −
                           W
                           
                              j
                           )⊗
                           y.

The incremental value U
                           
                              sp
                           (j,
                           x) obtained from placing strip type j along the upper edge of sub-bin x
                           ⊗(y
                           −
                           W
                           
                              j
                           ) is determined by formula (2). Let e
                           
                              i
                            be the effective frequency of item i used in computing the incremental value, then 
                              
                                 
                                    
                                       U
                                    
                                    
                                       sp
                                    
                                 
                                 (
                                 j
                                 ,
                                 x
                                 )
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                              
                           . The effective frequency is determined as follows to guarantee that the frequency of each item is at most 1:
                              
                                 (1)
                                 
                                    e
                                    
                                       i
                                    
                                    =0 if K(j,
                                    x,
                                    i)=0, because the item does not appear in the strip.


                                    e
                                    
                                       i
                                    
                                    =1 if K(j,
                                    x,
                                    i)=1 and N(x,
                                    y
                                    −
                                    W
                                    
                                       j
                                    ,
                                    i)=0. The item appears in the strip and not in the sub-bin.


                                    e
                                    
                                       i
                                    
                                    =0 if K(j,
                                    x,
                                    i)=1 and N(x,
                                    y
                                    −
                                    W
                                    
                                       j
                                    ,
                                    i)=1. The item appears in both the strip and sub-bin. The one in the strip is surplus and taken as waste.

The function GetPattern() for generating each pattern (see step 3 of the SVC2BPR) is based on recursion (1). Its contents are shown in the following box, where continue means that the next steps in the current loop are skipped and the next loop (related with the next value of the loop variable) should be started immediately; lines 6–7, 10, 11 and 13 indicate that the strips are skipped when:
                              
                                 (1)
                                 A smaller sub-bin has a higher value (lines 6–7).

The current strip has value 0 or its width is too large to be packed into the current bin (line 10).

The value of the bin cannot be improved when considering the strip (line 11).

The value of the bin cannot be improved when the surplus items are taken out of consideration (lines 12 and 13). Surplus items are generated when K(j,
                                    x,
                                    i)+
                                    N(x,
                                    y,
                                    i)>1 for some i.

Contents of function GetPattern ().
                              
                                 
                                    
                                    
                                    
                                       
                                          1
                                          
                                             Let F(x,
                                             y)=0, x
                                             =0,…,
                                             L, y
                                             =0,…,
                                             H.
                                       
                                       
                                          2
                                          
                                             Let N(x,0,
                                             i)=0 and N(0,
                                             y,
                                             i)=0, x
                                             =0,…,
                                             L, y
                                             =0,…,
                                             H, i
                                             =1,…,
                                             m.
                                       
                                       
                                          3
                                          
                                             Call GetStrip (max (L,
                                             H)) to generate the strips.
                                       
                                       
                                          4
                                          
                                             For x
                                             =0 to L
                                          
                                       
                                       
                                          5
                                          
                                             
                                             For y
                                             =0 to H
                                          
                                       
                                       
                                          6
                                          
                                             
                                             If x
                                             >0 and y
                                             >0 and F(x,
                                             y)⩽max {F(x
                                             −1,
                                             y),F(x,
                                             y
                                             −1)}
                                       
                                       
                                          7
                                          
                                             
                                             
                                             Let F(x,
                                             y)=max{F(x
                                             −1,
                                             y), F(x,
                                             y
                                             −1)} and continue.
                                       
                                       
                                          8
                                          
                                             // Consider placing a horizontal strip along the upper edge of the sub-bin
                                          
                                       
                                       
                                          9
                                          
                                             
                                             For j
                                             =1 to 2m
                                          
                                       
                                       
                                          10
                                          
                                             
                                             
                                             If f(j,x)=0 or y
                                             +
                                             W
                                             
                                                j
                                             
                                             >
                                             H then continue.
                                       
                                       
                                          11
                                          
                                             
                                             
                                             If F(x,
                                             y)+
                                             f(j,
                                             x)⩽
                                             F(x
                                             +
                                             W
                                             
                                                j
                                             ,
                                             y) then continue.
                                       
                                       
                                          12
                                          
                                             
                                             
                                             Let η
                                             
                                                i
                                             
                                             =min(1,
                                             K(j,
                                             x,
                                             i)+
                                             N(x,
                                             y,
                                             i)), i
                                             =1,…,
                                             m.
                                       
                                       
                                          13
                                          
                                             
                                             
                                             If 
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                   
                                                      
                                                         η
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ⩽
                                                   F
                                                   (
                                                   x
                                                   +
                                                   
                                                      
                                                         W
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ,
                                                   y
                                                   )
                                                
                                              
                                             then continue.
                                       
                                       
                                          14
                                          
                                             
                                             
                                             Let 
                                             
                                                
                                                   F
                                                   (
                                                   x
                                                   +
                                                   
                                                      
                                                         W
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ,
                                                   y
                                                   )
                                                   =
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                   
                                                      
                                                         η
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                              
                                             and N(x
                                             +
                                             W
                                             
                                                j
                                             ,
                                             y,
                                             i)=
                                             η
                                             
                                                i
                                             , i
                                             =1,…,
                                             m.
                                       
                                       
                                          15
                                          
                                             // Similarly consider placing a vertical strip along the right edge of the sub-bin.
                                       
                                    
                                 
                              
                           
                        

A greedy procedure is used to generate free patterns. It considers discrete positions to place the items. Given the current candidate positions and unpacked items, the procedure determines the item/position combination by a fitness level, places the selected item at the selected position, and updates the candidate positions and unpacked items. The process is repeated until one of the following cases appears: (1) all items have been packed; and (2) any unpacked item cannot be fitted into the bin.

At the beginning, the first item is packed with its left bottom corner coinciding with that of the bin. After that, a new item must be placed at a position where any packed item is below or to the left of it. The region where the remaining items can be packed in is called the envelope. The point where the slope of the envelope changes from vertical to horizontal is called a candidate position, at which items can be placed (that is, the left-bottom corner of an item must be placed at a candidate position). The slope of the envelope should be kept stair-shaped and go downward from left to right. An example is shown in Fig. 3
                         where the six items named 1–6 are packed into the bin one by one and the set of candidate positions is P
                        ={p
                        1,
                        p
                        2,
                        p
                        3,
                        p
                        4}. Envelops of such feature are also used in Wei, Zhang, and Chen (2009) and Martello, Pisinger, and Vigo (2000).

When a new item is placed at one of the candidate position, the set of the candidate positions and the shape of the envelope should be updated. Fig. 4
                         shows an example of the changes of the envelope and candidate positions after a new item is packed into the bin. Beginning from the envelope in Fig. 4(a), a new item is placed at position p2 and the new envelop is shown in Fig. 4(b). If the height of the region between the upper edge of the new item and the border of the bin (see the dark region in Fig. 4(c)) is less than the smallest edge-length of the remaining items, then none of the remaining items can be fitted into the region. Such regions are called bad regions. To reduce the complexity of the envelope, bad regions should be excluded from the envelope. The envelope in Fig. 4(c) is different from that in Fig. 4(b), because the bad region has been excluded. Fig. 5
                         shows another example for envelope update, where the bad region is along the right edge of the bin.

To decide which item to pack and which candidate position to place it at, a beam search method is used. Each combination of item and candidate position is a branch. By using a relatively simple strategy, we generate a pattern based on the current branch so as to obtain a lower bound for the value of the branch, where “value” denotes the total value of the items that are placed in the pattern. We assume that the branch with the largest lower bound has the greatest potential and should be selected.

Let U
                        
                           i
                        
                        =
                        v
                        
                           i
                        /(l
                        
                           i
                        
                        h
                        
                           i
                        ) be the unit value of item i, i
                        =1,…,
                        m. Assume that the remaining items have been arranged according to the non-increasing order of their unit values. The following symbols are used to describe the pattern-generation procedure:
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          Elop
                                       
                                       Current envelope. Initially it contains only one candidate position (the left-bottom corner of the bin)
                                    
                                    
                                       
                                          n
                                          
                                             F
                                          
                                       
                                       Number of candidate positions in ELop
                                       
                                    
                                    
                                       
                                          V
                                          
                                             LB
                                          
                                       
                                       Lower bound of the current branch
                                    
                                    
                                       
                                          maxLB
                                       
                                       Maximum value among the lower bounds of all branches
                                    
                                    
                                       
                                          optItem
                                       
                                       ID of the item to pack
                                    
                                    
                                       
                                          optPos
                                       
                                       ID of the position to pack item optItem
                                       
                                    
                                    
                                       
                                          optDir
                                       
                                       Orientation of item optItem
                                       
                                    
                                 
                              
                           
                        
                     

Let GetLB (I,
                        J,
                        itemDir,
                        Elop) be the function that estimates the lower bound of the branch, in which item I is at position J with orientation itemDir(HORIZONTAL or VERTICAL). The contents of the pattern-generation procedure are shown in the following box. The current pattern is finished when maxLB
                        =0, because then either all items have been packed 
                           
                              
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             m
                                          
                                       
                                       
                                          
                                             b
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       0
                                    
                                 
                              
                           
                         or none of the remaining items can be fitted into the bin.

Contents of the pattern-generation procedure.
                           
                              
                                 
                                 
                                    
                                       
                                          While true
                                       
                                    
                                    
                                       
                                          
                                          Let maxLB
                                          =0.
                                    
                                    
                                       
                                          
                                          For i
                                          =1 to m
                                       
                                    
                                    
                                       
                                          
                                          
                                          Skip item i if b
                                          
                                             i
                                          
                                          =0.
                                    
                                    
                                       
                                          
                                          
                                          For itemDir
                                          ∈{HORIZONTAL,VERTICAL}
                                    
                                    
                                       
                                          
                                          
                                          
                                          For j
                                          =1 to n
                                          
                                             F
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          Let V
                                          
                                             LB
                                          
                                          =
                                          GetLB(i,
                                          j,
                                          itemDir,
                                          Elop).
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          If V
                                          
                                             LB
                                          
                                          >
                                          maxLB then let maxLB
                                          =
                                          V
                                          
                                             LB
                                          , optPos
                                          =
                                          j, optItem
                                          =
                                          i and optDir
                                          =
                                          itemDir.
                                    
                                    
                                       
                                          
                                          If maxLB
                                          =0 then break.
                                    
                                    
                                       
                                          
                                          Put item optItem at position optPos in orientation optDir and update Elop.
                                    
                                    
                                       
                                          
                                          Let b
                                          
                                             optItem
                                          
                                          =0.
                                    
                                 
                              
                           
                        
                     

In the function GetLB (I,
                        J,
                        itemDir,
                        Elop), at first we put item I at position J with orientation itemDir, and then follow a maximum output first strategy to pack the remaining items. The remaining items are packed one by one according to the non-increasing order of their unit values, until no more items can be packed in. The pattern generated within this function is temporary (for obtaining a lower bound). It is dumped once the function ends.

The difference of the envelope’s area before and after packing an item can be regarded as the equivalent area (A
                        
                           e
                        ) the item occupied. Fig. 6
                         shows two examples of the equivalent area for the new item. When placing an item, according to the maximum output rule, the position with the minimum A
                        
                           e
                         should be selected.

When the current item (with length l and height h) is to be placed, the candidate positions on the slope are considered one by one to obtain the minimum A
                        
                           e
                        . If several positions lead to the same minimum A
                        
                           e
                        , the position that has the largest GN value is selected. Here GN denotes the goodness number (GN) that is determined as follows. Assume that the item is being placed at a candidate position formed by a horizontal line with length α and a vertical line with length β. If both l
                        =
                        α and h
                        =
                        β, GN of this pack is 2; if only one of them is equal, then GN
                        =1; otherwise GN
                        =0. An example for determining GN values is shown in Fig. 7
                        .

The following symbols are used to describe GetLB(I,
                        J,
                        itemDir,
                        Elop):
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          ElopC
                                       
                                       Current envelope retained within the function. Initially it is the same as Elop
                                       
                                    
                                    
                                       
                                          n
                                          
                                             C
                                          
                                       
                                       Number of positions in ELopC
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      e
                                                   
                                                   
                                                      ij
                                                   
                                                
                                             
                                          
                                       
                                       Equivalent area when item i is packed at position j
                                       
                                    
                                    
                                       
                                          GN
                                          
                                             ij
                                          
                                       
                                       
                                          GN value when item i is packed at position j
                                       
                                    
                                    
                                       
                                          bestPos
                                       
                                       ID of the position with the minimum equivalent area
                                    
                                    
                                       
                                          bestEA
                                       
                                       Minimum equivalent area
                                    
                                    
                                       
                                          bestDir
                                       
                                       Direction of the item related with bestPos
                                       
                                    
                                    
                                       
                                          bestGN
                                       
                                       
                                          GN value related with bestPos
                                       
                                    
                                 
                              
                           
                        
                     

If an item with given orientation can be fitted into the bin at a candidate position, then the position is a feasible one. The contents of GetLB (I,
                        J,
                        itemDir,
                        Elop) are shown in the following box. Lines 4–15 try to pack the remaining items one by one, until all items have been considered. Line 16 returns the lower bound to the host function GetPattern(). For the current item under consideration, bestEA and bestPos are initialized in line 6. Lines 8–12 try to find the best position for the current item when it is placed in itemDir. Line 13 indicates that a feasible position has been found because bestPos
                        >0; then line 14 places the current item at the selected position and orientation; Line 15 updates the lower bound and the envelope.

Contents of GetLB(I,
                        J,
                        itemDir,
                        Elop).
                        
                           
                              
                                 
                                 
                                 
                                    
                                       1
                                       
                                          Return zero if position J is not feasible for placing item I in orientation itemDir.
                                    
                                    
                                       2
                                       
                                          Let ELopC
                                          =
                                          ELop. Place item I at position J and update ELopC.
                                    
                                    
                                       3
                                       
                                          Let V
                                          
                                             LB
                                          
                                          =0.
                                    
                                    
                                       4
                                       
                                          For i
                                          =1 to m
                                       
                                    
                                    
                                       5
                                       
                                          
                                          Skip item i when b
                                          
                                             i
                                          
                                          =0.
                                    
                                    
                                       6
                                       
                                          
                                          Let bestEA
                                          =+∞ and bestPos
                                          =0.
                                    
                                    
                                       7
                                       
                                          
                                          For itemDir
                                          ∈{HORIZONTAL,
                                          VERTICAL}
                                    
                                    
                                       8
                                       
                                          
                                          
                                          For j
                                          =1 to n
                                          
                                             C
                                          
                                       
                                    
                                    
                                       9
                                       
                                          
                                          
                                          
                                          Skip position j if it is infeasible for placing the item in itemDir.
                                    
                                    
                                       10
                                       
                                          
                                          
                                          
                                          If 
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      e
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                ⩽
                                                bestEA
                                             
                                           
                                          or (
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      e
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                =
                                                bestEA
                                             
                                           
                                          and GN
                                          
                                             ij
                                          
                                          >
                                          bestGN)
                                    
                                    
                                       11
                                       
                                          
                                          
                                          
                                          
                                          Let 
                                          
                                             
                                                bestEA
                                                =
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      e
                                                   
                                                   
                                                      ij
                                                   
                                                
                                             
                                           
                                          and bestGN
                                          =
                                          GN
                                          
                                             ij
                                          .
                                    
                                    
                                       12
                                       
                                          
                                          
                                          
                                          
                                          Let bestPos
                                          =
                                          j and bestDir
                                          =
                                          itemDir.
                                    
                                    
                                       13
                                       
                                          
                                          If bestPos
                                          >0
                                    
                                    
                                       14
                                       
                                          
                                          
                                          Pack item i at position bestPos and in direction bestDir.
                                    
                                    
                                       15
                                       
                                          
                                          
                                          Let V
                                          
                                             LB
                                          
                                          =
                                          V
                                          
                                             LB
                                          
                                          +
                                          v
                                          
                                             i
                                           
                                          and update ELopC.
                                    
                                    
                                       16
                                       
                                          Return V
                                          
                                             LB
                                          .
                                    
                                 
                              
                           
                        
                     

After each pattern is generated, the value correction procedure (see step 5 of the SVC2BPR) corrects the values of the included items. The correction is based on the information of the current and previous patterns. The following formula is used:
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 Ω
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       (
                                       1
                                       -
                                       Ω
                                       )
                                       
                                          
                                             [
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   h
                                                
                                                
                                                   i
                                                
                                             
                                             ]
                                          
                                          
                                             p
                                          
                                       
                                    
                                    
                                       u
                                    
                                 
                              
                           
                        where u denotes the material utilization of the current pattern, that is:
                           
                              
                                 u
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             m
                                          
                                       
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       LH
                                    
                                 
                              
                           
                        
                        Ω
                        is a real number in [0,1], p is a real number larger than 1, y
                        
                           i
                         denotes the number of type i item in the current pattern. The information of previous patterns is considered by the first term Ωv
                        
                           i
                        , and that of the current pattern by the second term. As seen in the formula, the value of an item increases as u decreases, meaning that the item does not combine well in the current pattern; therefore it needs to be used in priority in the pattern generation procedure. Similarly, larger items are also given priority, because they are difficult to pack.

The idea of value correction has been used in solving the one-dimensional cutting stock problem (Belov & Scheithauer, 2007) and the strip packing problem (Belov et al., 2008; Cui et al., 2013).

The algorithm SVC2BPR was coded in C++ and executed on a PC (Intel Core2 Quad CPU Q9400 2.66gigahertz, RAM 4gigabyte). The following default parameter values are used in Sections 4.1 and 4.2: Ω
                     =0.5, p
                     =1.05, G
                     max
                     =200 and t
                     max
                     =2seconds (maximum computation time for an instance). A test on parameter sensitivity is available in Section 4.3.

In this sub-section, the SVC2BPRG is compared with two published algorithms for 2BPRG. One is the agent-based algorithm (referred to as the A-B) in Polyakovsky and M’Hallah (2009) and the other is that (referred to as the CHBP) in Charalambous and Fleszer (2011). These two algorihms are selected because the computational results in Fleszar (2013) indicate that they outperform other algorithms in solving 2BPRG instances. Ten classes of benchmark instances from Berkey and Wang (1987) (classes 1–6) and Lodi et al. (1999) (classes 7–10) are used.

In classes 1–6, the data are generated using the following rules:
                           
                              
                                 
                                 
                                 
                                    
                                       Class 1
                                       
                                          L
                                          =
                                          H
                                          =10,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,10].
                                    
                                    
                                       Class 2
                                       
                                          L
                                          =
                                          H
                                          =30,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,10].
                                    
                                    
                                       Class 3
                                       
                                          L
                                          =
                                          H
                                          =40,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,35].
                                    
                                    
                                       Class 4
                                       
                                          L
                                          =
                                          H
                                          =100,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,35].
                                    
                                    
                                       Class 5
                                       
                                          L
                                          =
                                          H
                                          =100,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,100].
                                    
                                    
                                       Class 6
                                       
                                          L
                                          =
                                          H
                                          =300,
                                          l
                                          
                                             i
                                           and h
                                          
                                             i
                                           uniformly in [1,100].
                                    
                                 
                              
                           
                        
                     

There are four different item types in classes 7–10:
                           
                              (1)
                              
                                 l
                                 
                                    i
                                  uniformly in [1,1/2L] and h
                                 
                                    i
                                  uniformly in [2/3H,
                                 H].


                                 l
                                 
                                    i
                                  uniformly in [2/3L,
                                 L] and h
                                 
                                    i
                                  uniformly in [1,1/2H].


                                 l
                                 
                                    i
                                  uniformly in [1/2L,
                                 L] and h
                                 
                                    i
                                  uniformly in [1/2H,
                                 H].


                                 l
                                 
                                    i
                                  uniformly in [1,1/2L] and h
                                 
                                    i
                                  uniformly in [1,1/2H].

The items in classes 7–10 are generated as following and the bin sizes are W
                        =
                        L
                        =100:
                           
                              
                                 
                                 
                                 
                                    
                                       Class 7
                                       70% of type 1 items and 10% each for types 2, 3 and 4.
                                    
                                    
                                       Class 8
                                       70% of type 2 items and 10% each for types 1, 3 and 4.
                                    
                                    
                                       Class 9
                                       70% of type 3 items and 10% each for types 1, 2 and 4.
                                    
                                    
                                       Class 10
                                       70% of type 4 items and 10% each for types 1, 2 and 3.
                                    
                                 
                              
                           
                        
                     

Each class contains 5 groups and each group includes 10 instances with the same number of items (m).


                        Table 1
                         shows the average solution value (number of bins) of an instance for all groups, where the results for each class occupy a block. The average solution value of an instance for the class is shown in the last line of the block. The lower bounds (LB) presented in Clautiaux et al. (2007) are also listed for comparison.

The lowest solution value of each group obtained by the three algorithms is regarded as the best solution (denoted in bold number in the table). The number of groups in which the SVC2BPRG achieves the best solution is 44 (out of 50). It is 32 for the A-B and 30 for the CHBP. The overall average solution value (counted over all groups) obtained by each algorithm is given in the last line of Table 1. The SVC2BPRG yields the smallest average solution value (14.07), followed by the CHBP (14.128) and A-B (14.132). The results indicate that the SVC2BPRG is the most efficient in improving solution quality. The detailed SVC2BPRG solution for the first instance in Group 2 of Class 1 is given in Appendix.


                        Table 2
                         shows the other results of the SVC2BPRG, where G
                        
                           best
                         is the number of solutions generated when the best solution is obtained (averaged over all instances in the class), G
                        
                           total
                         is the total number of solutions generated, t
                        
                           best
                         and t
                        
                           total
                         denote the corresponding computation times (in seconds). For a particular instance, the G
                        
                           best
                         value is in [1,174] and the G
                        
                           total
                         value in [1,200]. The average G
                        
                           best
                         value is 2.86, indicating that the best solutions can often be obtained in the early stage of the solution process.

The average computation time of an instance is 1.24seconds for SVC2BPRG. It is less than 3.5seconds for A-B (on a computer with processor Athlon XP 2800) and equal to 0.066seconds for CHBP (on a computer with processor core i3, 2.13gigahertz). The computation times may all be seen as reasonable.

In this section, algorithm SVC2BPRF is compared with three published algorithms for 2BPRF: the IMA (Hayek et al., 2008), HBP (Boschetti & Mingozzi, 2003) and ATS-BP (Harwig et al., 2006), using the benchmark instances in Section 4.1.


                        Table 3
                         shows the average solution value (number of bins) of an instance for all groups, where the results for each class occupy a block. The computational results of the other three algorithms are obtained from Hayek et al. (2008). The average solution value and the average computation time of an instance for the class are shown in the last two lines of the block.

The lowest solution value of each group obtained by the four algorithms is regarded as the best solution (denoted in bold number in the table). The number of groups in which the SVC2BPRF achieves the best solution is 42 (out of 50). It is 30 for the IMA, 25 for the HBP and 27 for the ATS-BP. The overall average solution value (counted over all 50 groups) obtained by each algorithm is given in the last row of Table 3. The SVC2BPRF yields the smallest average solution value (14.01), followed by IMA (14.072), ATS-BP (14.102) and HBP (14.156). The results indicate that the SVC2BPRF is the most efficient in improving solution quality.


                        Table 4
                         shows the other results of the SVC2BPRF. For a particular instance, the G
                        
                           best
                         value is in [1,157] and the G
                        
                           total
                         value in [1,200]. The average G
                        
                           best
                         value is 3.44, indicating that the best solutions can often be obtained in the early stage of the solution process.

The average computation time of an instance is 0.71seconds for SVC2BPRF, 0.319seconds for IMA (Intel Pentium 4 2.66gigahertz), 1.824seconds for HBP (Intel Pentium 3 933megahertz), and 70.21seconds for ATS-BP (unknown CPU). The computation time of the SVC2BPRF may be seen as reasonable.

In this section, the sensitivity of the SVC2BPRG to the parameters p, Ω and G
                        max is tested. Recall that the default values are Ω
                        =0.5, p
                        =1.05, G
                        max
                        =200. In testing the impact of a parameter on the quality of the solutions, this parameter is allowed to vary and the other parameters assume the default values.


                        Table 5
                         shows the impact of the p value. The total number of bins (sum of the solution values of all instances) related with each p value is listed in the last row of the table. It varies from 7031 to 7047. This indicates that the solution quality is slightly sensitive (not serious) to the p value when p
                        ∈[1.03,1.07].


                        Table 6
                         shows the impact of the Ω value. The total number of bins is between 7033 and 7039, indicating that the solution quality is slightly sensitive (not serious) to the Ω value when Ω
                        ∈[0.3,0.7].


                        Table 7
                         shows the impact of the G
                        max value. The total number of bins is between 7035 and 7356. It is seen that the solution quality is sensitive to G
                        max when G
                        max
                        <25, and not sensitive when G
                        max
                        ⩾25.

@&#CONCLUSIONS@&#

The sequential value correction heuristic SVC2BPR for the 2BPR is proposed in this paper. It is rely on the combination of pattern generation procedures and the value correction scheme. The computational results indicate that the algorithm is more efficient in improving solution quality than five published algorithms for the instances tested.

Future research direction may include the extending of the algorithm to solve the 2BPR with multiple bins and the two dimensional cutting stock problem.

@&#ACKNOWLEDGEMENTS@&#

This research is part of Projects 61363026 and 71371058 supported by National Natural Science Foundation of China. It is also supported by the scientific research project 201010LX003 of the universities in Guangxi.

The 2BPRG solution for the first instance in group 2 of class 1 is given in Fig. 8
                     . The bin has a dimension of 10×10. The dimensions of the items are listed in Table 8
                     . The solution is optimal because the number of bins is equal to the continuous lower bound 
                        
                           
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    /
                                    (
                                    LH
                                    )
                                 
                              
                           
                        
                     .

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2014.06.032.


                     
                        
                           Supplementary data 1
                           
                        
                     
                  

@&#REFERENCES@&#

