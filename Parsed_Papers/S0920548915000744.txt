@&#MAIN-TITLE@&#Routing protocol for k-anycast communication in rechargeable wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           
                              k-anycast communication technique is utilized for enhancing transmission reliability, load-balancing and security purpose by collecting multiple copies of a packet from a source and verifying the information of monitoring field. In r-WSNs, due to energy replenished continually and limited energy storage capacity, a sensor cannot be always beneficial to conserve energy when a network can harvest excessive energy from the environment. Therefore, the surplus energy of sensor can be used for strengthening data transmission. In this paper, a routing protocol for k-anycast communication based upon the anycast tree scheme is proposed for wireless sensor networks.


                        
                        
                           
                           Multiple-metrics are utilized for instructing the route discovery. A source initiates to create a spanning tree reaching any one sink with source node as the root.


                        
                        
                           
                           We introduce three schemes for k-anycast: a packet is transmitted to exact k sinks, at least k sinks, and at most k sinks, where, a packet can be transmitted to k or more than k sinks benefiting from broadcast technique without wasting the source energy for replicating it. Through extensive simulation and experiments, we demonstrate our algorithm is feasible and efficient to collect multiple copies of a packet from a source in rechargeable wireless sensor networks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Anycast

k-Anycast

Routing protocol

Rechargeable-WSNs

@&#ABSTRACT@&#


               
               
                  In this paper, a routing protocol for k-anycast communication based upon the anycast tree scheme is proposed for wireless sensor networks. Multiple-metrics are utilized for instructing the route discovery. A source initiates to create a spanning tree reaching any one sink with source node as the root. Subsequently, we introduce three schemes for k-anycast: a packet is transmitted to exact k sinks, at least k sinks, and at most k sinks, where, a packet can be transmitted to k or more than k sinks benefiting from broadcast technique without wasting the source energy for replicating it.
               
            

@&#INTRODUCTION@&#

Wireless sensor networks (WSNs), which are comprised of a large number of low-cost, low-power, small size, and multifunctional sensor nodes with finite battery life that can sense and process data and communicate with each other over a short distance [1,2], have been a topic of much interest to researchers due to their wide-ranging applications. For example, they have been used in military field [3], environmental field [4], health field [5], and smart home-field [6], to name a few. In these operations, sensors are utilized for collecting information on entities of their interest, where, efficient routing protocol and data transmission are usually required [7]. In WSNs, as the traffic of the network converges to the sink, nodes close to the sink consume their energy faster than farther nodes because they have to undertake the heavy workload for data forwarding and data collection.

Considering the packet delivery is restricted to the nodes around the sink and numerous packets will be accumulated in these nodes in a high data rate network, a solution to this problem is to deploy several sinks in a monitoring field, which poses a new challenge for routing protocol design. Currently, anycast becomes a very useful service for data transmission in multiple sinks. The paradigm of anycast communications [8,9], also termed one-to-any communications, is a newly designed communication service in IPv6, which is used to deliver a packet to any member of a group of designated recipients. Anycast technique plays an important role in the fields of DNS [10], etc. In WSNs, anycast technique can be used for neighbor and sink selection: when a sensor node produces data, it just needs to send it to any neighbor node or sink available.

In WSNs with multiple sinks deployed, for reliability, load-balancing and security purpose, it is then useful to ensure that at least k sinks receive a message whatever the k sinks, which is generally called k-anycast communication [11]. k-Anycast is an extension of anycast which delivers the packets sent by clients to at least or at most k member of an anycast group identified by an anycast address. k-Anycast communication technique is utilized for enhancing transmission reliability, load-balancing, and security purpose by collecting multiple copies of a packet from a source and verifying the information of monitoring field. Even though k-anycast scheme provides a high data transmission quality, it is easy for sensor nodes to deplete their energy due to limited and fixed energy supplement [12,13]. Note, it is generally accepted that the usefulness of a wireless sensor expires when its battery runs out. Therefore, there are scare works considering k-anycast communication for WSNs owing to the limited lifetime of sensor nodes.

Currently, an interesting approach to extend the lifetime of sensor nodes is to equip them with rechargeable technologies [14], which convert sources such as body heat [15], foot strike [16], finger strokes [17], and solar [18] into electricity. Assuming energy neutral operation [19], a sensor node can operate perpetually if the harvested energy is used at an appropriate rate. Note, a harvesting node is said to achieve energy-neutral operation if the energy used is always less than the energy harvested, and the desired performance level can be supported in a given harvesting environment. In these so called energy harvesting WSNs (EH-WSNs) or Rechargeable WSNs (R-WSNs), where sensors are equipped with rechargeable batteries or super-capacitor (in the order of a million recharge cycles [20]), although their lifetime is less of an issue, some new challenges appear due to the unique characteristics of R-WSNs.

For one thing, owing to the unpresentable nature of the environment and technology limitations, the available energy on nodes varies dramatically over time [21], which causes nodes to control energy utilization continually according to available energy. For another thing, the power storage capacity is limited [22], which means a node cannot be always beneficial to conserve energy when a network can harvest excessive energy from the environment [23]. In other words, reducing the power consumption below energy neutrality will not increase the lifetime further, but decrease the efficiency of the node utilization [24]. Since more energy can be extracted from the ambient environment, the harvested energy should be consumed as soon as possible in R-WSNs [25,26]. Therefore, rich power of sensors attribute to the application of k-anycast communication in R-WSNs.

In a nutshell, in the work, we propose a k-anycast routing protocol for data transmission. To the best of our knowledge, this is the first generic work that studies the routing protocol for k-anycast communication in R-WSNs. The remainder of this paper is organized as follows. In Section 2 we present a number of existing routing protocols about anycast and k-anycast communication, while in Section 3 the motivation is provided. In Section 4 we present our method and design. Section 5 contains experimental results. Conclusions are presented in Section 6.

@&#RELATED WORK@&#

The concept of anycast was studied in multiple contexts, including network type [27], communications model [28], and purpose of usage [29], etc. originally, anycast technique was used in the TCP/IP networks. For instance, anycast technique is used for directing DNS queries to the closest root name server [30] and for server selection in distributed systems [31]. Though anycast is originally designed for Internet service, it has been applied to routing protocol design for wireless ad hoc and sensor networks. The anycast communication is a quite important technique in a sensor network with multiple sinks. There are some anycast routing protocols which were improved to support anycast service and mainly come from current routing protocol, such as, the AODV (Ad hoc on-demand distance vector routing) protocol is modified to support anycast service [32].

Anycast can be an important paradigm for a wireless sensor network in terms of resource, robustness, and efficiency for replicated service applications [33–35]. Anycast routing protocols based on the tree structure [9,36,37] is in accordance with the agreement, the extended model usually in the tree by hop count, physical interval or time intervals for unit, to build an anycast tree. A query is transported along the most fitting anycast tree. The anycast scheme is utilized to cope with sink selection in routing protocol design for WSNs and improve the performance of routing protocol widely, whose ultimate goal is to prolong the network lifetime. Even though multiple sinks are deployed in R-WSNs and sensor should also select one sink from the sink group to deliver packets, network lifetime is not a problem and unique characteristics of R-WSNs pose a high challenge for routing protocol design for R-WSNs.

k-Anycast strategy is the extension of anycast technique and first introduced in reference [38]. It is proposed as that packet is sent to any k members out of particular communication destinations. In reference [39], a k-anycast routing scheme is proposed in a MANET. k-Anycast tree method is adopted in reference [40], which k servers cooperate with each other to accomplish a task. The research on the k-anycast communication model is still limited and mainly focused on IPv6 networks. In these TCP/IP networks, TCP/IP, as the basic configuration, is needed to support these models and every member is provided with an IP address. In WSNs, TCP/IP can’t be supported. Particularly, the energy and communication are limited for wireless sensor networks. Hence, the k-anycast protocols designed for TCP/IP networks do not adapt to sensor networks.

Different from earlier works, which either focus on the TCP/IP networks or static battery-powered network for anycast application, in this work, we present a routing protocol for k-anycast communication in R-WSNs. In summary, on observing the lack of k-anycast techniques consideration for data transmission in existing routing protocols, we introduce the first generic routing protocol algorithm of k-anycast scheme in R-WSNs.

@&#MOTIVATION@&#

For WSNs with single sink, all packets generated by source sensors will be transmitted to the sink through one or multiple hop transmission. Due to the limited transmission radius, the sensors around the sink undertake the heavy workload for data forwarding and are easy to run out of their energy, which causes these sensors to be separated from the WSNs and the WSNs can no longer fulfill its role, as the example shown in Fig. 1
                     . Especially, in a high-traffic network, it is a bottleneck for data flow to the sink, where the packet delivery is restricted to the nodes around the sink and numerous packets will be accumulated in their nodes.

As the network size grows, a packet has to be forwarded by more hop counts before reaching a sink and the E2E delay is intolerable. At the same time, it leads to packet dropped and retransmission seriously, which increase the E2E delay excessively in return. An interesting solution to this problem is to deploy several sinks in the monitoring field, and the monitoring area is divided into multiple regions depending on the sinks' distribution. For a source node, it just sends its packets to the nearest sink and the length of routing path can be reduced significantly. Therefore, multiple sinks deployment is recognized and used widely in WSNs, especially, in large-scale WSNs and high-traffic WSNs.

In WSNs with multiple sinks, for reliability, load-balancing, and security purpose, a source node tries to send its packet to as many as possible sinks (usually called k-anycast communication) benefiting from broadcast advantage. When a sensor broadcasts its signal, since all its neighbors can sense the information only if they locate in the sensor transmission radius, it doesn’t need to use extra energy to replicate its packet to other neighbors, which is shown in Fig. 2
                     . Therefore, in traditional-WSNs with the limited battery device, it doesn’t waste the energy of source for k-anycast communication. However, more sensors have to join in the data transmission for k-anycast scheme, and more energy will be consumed.

Therefore, k-anycast communication is used prudentially in traditional-WSNs.

In R-WSNs, for the intermediate sensors, which only undertake data forwarding task and don't generate signals, since their energy can be replenished continually, reducing the power consumption below energy neutrality will not increase the lifetime further, but decrease the utilization efficiency of a node. The surplus power of sensors can be utilized for strengthening data transmission. These characteristics indicate that k-anycast technique is just suitable for R-WSNs. Therefore, based on the previous analysis, in our work, we provide a routing protocol for k-anycast communication in R-WSNs.

Consider a static rechargeable wireless sensor network modeled as an undirected graph G
                        =(V, A), where V is the set of n rechargeable sensor nodes and sink nodes within the network. A is the set of links, A
                        ={A|(i, j)∈ A,
                        i,
                        j
                        ∈ V}. G consists of a finite nonempty vertex set V and edge set A of ordered pairs of distinct vertices of V. A graph is simple if it has no loops and no two of its links join the same pair of vertices. An acyclic graph is one that contains no cycles. A tree is a connected acyclic graph. A sink tree is a tree with a sink node as tree root and sensor nodes as tree leaves. G consists of a finite nonempty vertex set V and edge set A of ordered pairs of distinct vertices of V. A leaf is a vertex of degree 1.

Two nodes i and j are connected by a link if they can transmit a packet to each other with a transmission power less than the maximum transmission power at each node. Thus all links are assumed to be bi-directional. This assumption is not necessary for the convergence of the distributed algorithms however it can make the presentation clearer. We note that Si is the set of physical neighbors of node i, i.e. the set of nodes in communication range of node i. We assume that the network graph is connected, i.e. a path between any pair of nodes i and j in V always exists.

In wireless networks with multiple sinks, when a sensor gets ready to deliver its data, it has to face two challenges: next-hop node selection from neighbor candidates for data forwarding and sink selection from all destinations for packets received. In the work, we define a criterion for neighbor selection. A simple linear combination of different routing metrics is used to determine the path cost, which can be expressed as:
                           
                              (1)
                              
                                 ϕ
                                 =
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          i
                                          =
                                          k
                                       
                                    
                                    
                                       
                                          α
                                          i
                                       
                                    
                                 
                                 ∗
                                 M
                                 
                                 etri
                                 
                                    c
                                    i
                                 
                              
                           
                        where, ϕ denotes the accumulated cost of data transmission for two adjacent nodes. We assume that M etric denotes the factors, which will be considered or traded off in the neighbor and sink selection, for example, energy consumption and energy replenish rate. α is the weight factors (or called coefficients) for M etric to calculate the cost, which is a scaled value from [0, 1], ∑
                           i
                           =1
                        
                           i
                           =
                           k
                        
                        α
                        
                           i
                        
                        =1. High α value indicates that the M etric is more important in the process of a path created, vice versa. Basing on application requirement, these weight factors can be flexibly varied to change the importance of the metrics during route discovery. Our protocol adopts four path cost metrics (k
                        =4): hop counts (h), data delay (d), energy cost (c), and energy replenished rate (r). Therefore, the path cost equation for two adjacent nodes becomes:
                           
                              (2)
                              
                                 ϕ
                                 =
                                 α
                                 1
                                 ∗
                                 h
                                 +
                                 α
                                 2
                                 ∗
                                 d
                                 +
                                 α
                                 3
                                 ∗
                                 c
                                 +
                                 α
                                 4
                                 ∗
                                 r
                                 .
                              
                           
                        
                     

Here, the hop counts for two adjacent nodes is set to be 1, and energy cost denotes the normalized energy expenditure for the direct link from the previous hop node to the current node, and data transmission delay denotes the elapse time for data sent to be received by next-hop node, and energy replenished rate denotes the maximum energy recharged by a sensor per unit of time. A sensor with solar panel, whose energy replenished rate is affected by the environment condition, solar panel size, energy conversion rate, the angle of solar panel, etc. In our work, the detail contributions of energy replenished rate are not the main point considered in our routing protocol design. Different application's requirements can define distinct sets of weight factors. For example, it is might only data delay considered in some application, thus, (α1,
                        α2,
                        α3,
                        α4)=(0,1,0,0). In traditional-WSNs, due to limited energy supplement, minimum energy expenditure and maximum network lifetime are prior to be considered for establishing routing path, while in R-WSNs, data delay generally is considered firstly owing to low duty cycles for sensors. In the process of routing path established, a sensor preferentially chooses a neighbor to receive its packets with minimum forwarding data cost toward a sink, and the packets will be forwarded to another sensor until the sink is reached. Therefore, the packet's forwarding cost is the sum of data transmission cost for the path. We assume there are m sensors lying in the path, we have,
                           
                              (3)
                              
                                 
                                    ∏
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          j
                                          =
                                          m
                                       
                                    
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          i
                                          =
                                          k
                                       
                                    
                                    
                                       
                                          α
                                          i
                                       
                                       ∗
                                       M
                                       
                                       etri
                                       
                                          c
                                          i
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The core of anycast routing protocol for R-WSNs is to select a nearest sink as destination. The problem of optimal sink selection can be formulated as follows. Consider a case of n sensors containing m sources and a group of k sink nodes where 1≤
                        k
                        ≤
                        n. The problem is to assign each source from m sources to any sink from k sinks so that the total path cost of the network is minimized. The problem can be formulated as a 0–1 integer programming problem as follows:
                           
                              (4)
                              
                                 M
                                 i
                                 n
                                 
                                 f
                                 
                                    x
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 Subject
                                 
                                 t
                                 o
                                 :
                              
                           
                        
                        
                           
                              (6)
                              
                                 f
                                 
                                    x
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       k
                                    
                                    
                                       
                                          ϕ
                                          
                                             i
                                             ,
                                             j
                                             λ
                                             i
                                             ,
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    ϕ
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    α
                                    i
                                 
                                 ∗
                                 Metri
                                 
                                    c
                                    i
                                 
                                 ,
                                 1
                                 ≤
                                 i
                                 ≤
                                 n
                                 ,
                                 1
                                 ≤
                                 j
                                 ≤
                                 n
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    λ
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 0
                                 
                                 or
                                 
                                 1
                                 ,
                                 1
                                 ≤
                                 i
                                 ≤
                                 n
                                 ,
                                 1
                                 ≤
                                 j
                                 ≤
                                 n
                              
                           
                        where, ϕi,j is the path cost of the best route between node i and node j, which is explained in Eq. (2), and λi,j is a binary variable used for sink selection: if the best sink node chosen for node i passes through the node j, then λi,j
                        =1; otherwise λi,j
                        =0.

For explaining our routing protocol, we first introduce serval control packets utilized for building routing path before data transmission. There are four types of control packets designed for establishing routing path in our protocol, containing hello packet, route request, route reply, and error packet. Hello packet is a special type of packet, which is generated only by a sink and broadcasted intermittently to all sensor nodes. A Hello message is transmitted periodically to advertise the presence of a sink. A sink node usually has a large transmission range, which can cover all sensor nodes more than one hop away. Thus, there is no need to retransmit the Hello message by sensor nodes which is quite different from the case in TCP/IP networks. After a sensor receives the hello packet, it caches the information. The hello packet indicates the sink alive and will be used to waken-up some nodes for completing some tasks.

Other three control packets originate from traditional ad-hoc networks, which stripped of unnecessary fields, such as, flags for multicast, the reserved fields, prefix field, and life time field. Route request packet is usually generated for initializing the route discovery, which contains parent request (PRQ) and child request (CRQ). The parent request is utilized to discover a parent node and construct a route to sink by a source. Child request is used to discover a child node and initiates the route discovered by a parent node. Route error packet is the same as that of traditional AODV protocol. For the sake of simplicity, the format of request packet in our protocol is defined as follows:

(Route request type, Sink ID, Path cost, Next node's ID, Node's information).

If type=0, the packet is a child's request, while if type=1, it is a parent request. The sink id represents the sink address for distinguishing multiple sinks. If the next nodes ID is empty, it denotes the packet comes from a source and the sensor hasn't discovery a path to a sink. Nodes address represents the node's ID and position. Route reply packet is generated for corresponding route request packets by sinks or sensors. The path cost is the accumulative cost of the path from a source node to sink node or a sink to a source. In the work, it is not a realistic signal packet in physical layer for the format of route request packet and the practical packets for controlling data transmission are more complicated than that of our suppose. However, it does not affect that we explain our routing protocol for k-anycast in R-WSNs.

Any node can generate a route reply (RREP) after it receives a route request when it is in an idle state, and data transmission is resumed. As there is more than one neighbor available, multiple route replies may be received. In this case, based on the defined path selection metrics, the node will select one neighbor as its next-hop node to accept its data, the path selection metrics are explained in Eq. (4). In our work, link layer notifications (LLN) are used to detect link failures. If a node detects a link failure for a next hop, it initiates a limited route repair. If successful, it forwards the packet, otherwise it generates a route reply message for the neighbor.

Anycast technique provides an outstanding performance in one-to-anyone communication environment. In R-WSNs, the anycast technique is used for resolving two problems: sink selection from all destinations for packet collection and next-hop node selection from neighbor candidates for data forwarding. On the one hand, a sink selection strategy is to choose a sink for each source arbitrarily and a packet generally is routed to a closest sink. On the other hand, when packet transmission happens in two adjacent sensor nodes, the anycast technology is utilized to let a sensor choose the best neighbor from its neighbor's table. In this part, we will discuss how a sensor node selects one neighbor node from its neighbor's table to forward the packet and a sink from multiple destinations to collect the packet.

Assuming that all sensors and sinks are uniformly distributed in the network, an anycast tree from a sink to a source node or from a source to a sink will be established firstly for data delivery. Sensor nodes can get anycast services from the anycast tree. Our routing protocol starts with the creating of a number of spanning trees. In this model, if a sensor node wants to get anycast services, it must join in an anycast tree firstly. There are at least two different strategies for creating a spanning tree, such as, a sink initiates to establish a spanning tree with sink as the root and a source initiates to create a spanning tree with source node as the root.

In literatures, a sink is usually assumed that it has rich power with unlimited energy supplement. Since it is easy for a sink to broadcast a message to all sensors, it is not necessary to construct a tree for a sink to announce a command. In our work, when a sensor is required to collect information, as a source, it initiates to construct an anycast tree reaching any sink using the control packets (4.3) based on the neighbor and sink selection strategy, which is introduced in Section (4.2). An anycast tree is constructed through the following process: an anycast tree is established by a source:
                           
                              1)
                              A source node initiates to broadcast a query PRQ to its neighbor nodes with maximum transmission radius. The PRQ format is shown in the Section (4.3), which contains the packet type, the reachable sink id, the path cost ϕ from the sender to a receiver, the next-hop node ID, and the sender information (such as, id, location, working schedule). Since the packet originates from the source, the reachable sink id, path cost, and next-hop node id are empty and set to be 0. If the PRQ reaches a sink node, sink ID is non-empty and an anycast tree is established successfully, otherwise, execute (2);

If the neighbor nodes of the sender receive the PRQ and they have joined in any anycast trees, these nodes accept the PRQ and recalculate the path cost based on the information in PRQ, where, the path cost value reflects the points of parameters by the Eq. (2). Subsequently, these nodes send CRQs to the sender.

After sending a PRQ with a small time interval, the sender may receive more than one CRQ from its neighbors. If the sink id is non-empty of one CRQ, it indicates the CRQ from a sink and the sender selects the node as the parent neighbor. Otherwise, the sender checks all CRQs. Depending on these CRQs, the sender selects the neighbor node with the minimum path cost ϕ as its father node through comparing the size of the path costs ϕ in the CRQs. The neighbor node selection strategy meets the 0–1 integer programming problem, which is expressed in Eq. (4). At the same time, it records the information on its father node table and returns an RREP to its father node. If more than one the path costs ϕ of the CRQs received are equal, the node selects a neighbor node randomly. The process of a neighbor node selection is shown in the Fig. 3
                                 . An anycast tree is established successfully and operation terminates, otherwise, continue to execute the following process.

After the father node receives the RREP, a transport channel is created between the sender and its father node. Hereafter, the father node as a sender continues to broadcasts a query PRQ to its neighbor nodes, return (2) continues the process.

Depending on the characteristics of the algorithm, each node only needs to retain the information of its next-hop node. The parent node doesn't need to record the relevant information about the sender. This is different from the TCP/IP which will record the sender's IP. The sender replaces next node's ID in the PRQ with the receiver id, recalculates the path cost ϕ from the sender to the receiver and replaces the original path cost ϕ in the neighbor's table. The new path cost can be calculated by the Eq. (3). The receiver becomes a sender and continues to broadcast the PRQ to the next hop until it reaches a sink, which indicates an anycast tree is established successfully, as is shown in Fig. 4
                        , where two sources construct two anycast trees reaching two different sinks. After the anycast tree construction is over, each source node establishes an anycast tree to reach a sink and other common sensors (as intermediate nodes) lying in anycast trees for forwarding packets from the source sensor.

For reliability, load-balancing and security purpose, etc., a packet from a source is required to send to multiple sinks. Therefore, we propose a k-anycast routing protocol for R-WSNs, k
                        >1. The k-anycast communication for data transmission indicates at least three meanings: a packet is transmitted to exact k sinks, at least k sinks, and at most k sinks. Since a packet can be forwarded to at least k sinks, it can also be transmitted to exact k sinks. Therefore, we can use a strategy to achieve the first two communication requirements. If a packet is required to be delivered to at most k sinks, in fact, the packet maybe reaches p sinks, where, 1≤
                        p
                        ≤
                        k.

In special case, it is an anycast communication when p
                        =1. For the sake of simplicity, we first discuss the scheme for achieving that a packet can be delivered to at most k sinks.

In this section, we first present the main idea of the at most k-anycast communications, which lets the packets from a source node transmitted to p sinks, where, p
                           ≤
                           k. In the process of data delivery, there are two possibilities when a data flow to p sinks: several messages may follow the same path or messages lying in the same path may change targets, as is shown in Fig. 5
                           . These characteristics pose a high challenge for routing protocol design and cause that a source cannot control the number of targets which the packets can reach as generated by the source after they were departing from the source node. When several packets are along the same path, they have to form a queue and wait for an idle channel, which leads to a serious delay. Therefore, in our work, for the at most k-anycast communication, we only consider the case, where messages are forwarded to different intermediate sensors (only undertake packet forwarding task and cannot generate a signal).

Based on the consideration in the previous paragraph, if a packet from a source is delivered to p adjacent nodes benefitting from the broadcast characteristic, the duplication packets will be transmitted to p sinks finally. Hence, for the at most k-anycast communication, we just let a source deliver its packet to as many as possible p neighbors, where, p
                           ≤
                           k, and p-anycast trees are established from the source to p sinks with the source as the tree root and sinks as the tree leaves. The process of p-anycast trees is almost the same to that of an anycast tree constructed, as is shown in the previous section. We just change the third step and let that the sender selects p neighbor nodes with the small path costs ϕ as its next-hop nodes through comparing the size of the path costs ϕ in the CRQs only if it can receive k responses, k
                           ≥
                           p.

To further illustrate at most k-anycast or p-anycast scheme (p
                           ≤
                           k) for data delivery, a sample with 2 source nodes (s1 and s2) and 5 sinks is provided in Fig. 6
                           . When k is set to be 2, after the source s1 broadcast a control message to its neighbors, s1 receives three CRQs from nodes d, g, and h, and only selects two nodes d and g with small path cost as its receivers by comparing the cost from all neighbors to itself by Eq. (2). Firstly, the packet from source s1 will be transmitted to the nodes d and g. Subsequently, the two nodes d and g as the senders continue to forward the packet to next-hop node, and reach sink 1 and sink 3 finally along the path {s1, d, a, sink 1} and {s1, g, k, sink 3}, respectively, which is shown in the Fig. 6.

In this section, we discuss how to let a source delivers its data to at least or exact k sinks. Depending on the previous analysis, for achieving at least or exact k-anycast communication, a source should find at least k or exact k neighbors to accept its packets. We assume that a source can receive p responses from its neighbors, if p
                           ≥
                           k, it indicates that the requirements for the exact k-anycast and at least k-anycast communication are achieved, while if p
                           <
                           k, it indicates that a source cannot find enough neighbors to forward its packets to at least k sinks. Considering the characteristics of rechargeable sensor, whose energy can be replenished continually, we introduce a scheme to find more neighbors by controlling its transmission range.

A source node broadcasts the request with its maximum communication radius r1 to its neighbor nodes and receives the reply number which is p1. If p1<
                           k, the node continues to recharge itself for improving its remaining energy. After a time interval t, the sensor increases the broadcast radius to r2 and tries to receive k replies, as is shown in Fig. 7
                           . For simplicity, we assume that nodes are uniformly distributed in the network area, then we can estimate the next reply's number as below.
                              
                                 (9)
                                 
                                    
                                       
                                          π
                                          
                                             r
                                             i
                                             2
                                          
                                       
                                       
                                          p
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          π
                                          
                                             r
                                             
                                                i
                                                +
                                                1
                                             
                                             2
                                          
                                       
                                       
                                          p
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

Hence, the relations between radius and reply are
                              
                                 (10)
                                 
                                    
                                       r
                                       i
                                    
                                    +
                                    1
                                    =
                                    
                                       
                                          
                                             
                                                p
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             
                                                p
                                                i
                                             
                                          
                                          ∗
                                          
                                             r
                                             i
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

If k replies are expected, set pi
                           +1=
                           k. The communication radius will be
                              
                                 (11)
                                 
                                    
                                       r
                                       i
                                    
                                    +
                                    1
                                    =
                                    
                                       
                                          
                                             k
                                             
                                                p
                                                i
                                             
                                          
                                          ∗
                                          
                                             r
                                             i
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

After the sensor receives k or more than k responses, it delivers its packets to these neighbors, which will continue to forward these packets to next-hop neighbors until it reaches at least k sinks. Even though the same packets are generated by sources, they are maybe different to each other when reaching multiple sinks due to transmission errors. Since sink node id is deployed with unlimited energy, it is easy for all sinks to transmit their receiving data to a remote terminal. The remote terminal analyzes these data and tries to renew them, which may reflect the information monitored by sensors.

Simulation of our algorithm for R-WSNs was done by Matlab software, with up to 100–200 nodes and 5–10 sinks that are randomly deployed in a 500m∗500m square field. The maximum communication range of each node is set to be 80m. All nodes' energy devices are rechargeable with 20cm2 square size solar panel, and transmission powers are adjustable. The solar panel will be affected by cloudy or sunny environments, as well as the angle of sunlight, as solar radiation may change at any time, along with time or climate. Every two nodes can communicate with each other directly within their transmission range. Every data point in simulation figure is obtained by averaging 20 runs with different random seeds, node deployment, and node working schedules.

What we use consists of a solar panel optimized for outdoor use, two eZ430-RF2500T target boards and one AAA battery pack, which is rechargeable and can be recharged repeatedly. The target board comprises the TIMSP430 microcontroller, CC2500 radio transceiver and an on-board antenna. The C-C2500 radio transceiver operates in the 2.4GHz band with data rate of 250kbps and is designed for low power wireless applications. The harvested energy is stored in EnerChip, a thin-film rechargeable energy storage device with low self-discharge manufactured by Cymbet, as is shown in Fig. 8
                        .

In this section, we execute the routing process using k-anycast communication models with 100 sensors and 5 sinks deployed in a 500m∗500m square field. In the experiment scenario, source nodes generate packets by sensing environment and send them to k sinks with one or multiple-hop transmission (k is set to be 3). We present the routing paths for all sources to reach at least 3 sinks, the connectivity graph is shown in Fig. 9
                        . By considering the limited energy supplement, a source node still chooses closer base station as its destination. However, the packets from all sources may be through all intermediate nodes in the network area before they reach k sinks, and the communication energy consumption will be balanced to all nodes in order to improve sensor utilization efficiency.

In order to further understand the performance of our routing protocol for k-anycast communication for R-WSNs (RPKAC) under network settings, in this section, we provide two algorithms for performance comparison, which are proposed by Mitton N et al [41] and K.S. et al [42]. In [41], the authors propose KanGuRou (k-ANycast Guaranteed delivery ROUting protocol), the position-based k-anycast routing protocol, which is energy-efficient and guarantees the packet delivery for traditional WSNs with limited energy supplement. While, an opportunistic routing protocol (EHOR) for multi-hop WSN-HEAP is introduced to resolve the optimal forwarder problem [42], which uses a region-based approach by grouping nodes together to reduce delay. Considering that there is lacked of k-anycast technique's consideration for data delivery in existing routing protocols of R-WSNs, so the two algorithms are selected for performance comparison with our algorithm.

In [41], the authors provide a k-MST (minimum spanning trees) algorithm to reach any k sinks among all available sinks for a source by the variant of KanGuRou. However, due to limited energy supplement, the packets are expected along the same path before they are reaching k sinks for saving energy. At the same time, a source has to compute the k-MST by comparing every path costs of all possible solutions. Even though these strategies can reduce energy expenditure and extend the network lifetime efficiently, the reliability of k-anycast communication is reduced and the algorithm complexity is improved significantly.

We first compare the average E2E delay between our algorithm and KanGuRou, EHOR under different duty cycles when (α1,
                        α2,
                        α3,
                        α4)=(0,1,0,0), as is shown in Fig. 10
                        . From Fig. 10, we can know that the average E2E delay in three algorithms decreases with the duty cycle increasing, and the average E2E delay of PRKAC is a little lower than other algorithms in the whole process of transmission. Especially, with the duty cycle of the node decreases greatly, the delay of KanGuRou and EHOR increases more quickly than that of our algorithm. We can see if the duty cycle of a node is lower than 1%, the average E2E delay from a source to k sinks is lower about 6% than that of KanGuRou and 4% than that of EHOR. In other words, when sensor nodes keep in low duty cycles, our algorithm will operate more efficiently than both.

In KanGuRou, considering limited energy supplement, saving energy is the main purpose for maximizing network lifetime and sleep latency cannot be prior to be considered as the process of packet's transmission. In the EHOR, all sensor nodes are divided into multiple regions based on the distance to the sender within sensor transmission range. Only one node will be chosen as the forwarding node in each region, which depends on the remaining energy and the distance to the sink. Even though the EHOR can achieve maximize goodput, E2E delay is as secondary performance metrics. In the process of transmission, the transmission power controlling technology has not been considered for each sensor node. Therefore, a sensor node cannot adjust its neighbor table timely, which cause the E2E delay higher than our algorithm.

Secondly, we analyze the average E2E delay with the number of nodes increasing when the average duty cycles of sensors are 0.1% and a different number of sinks are deployed, which is shown in Fig. 11
                        . From Fig. 11, we can observe that the average E2E delay decreases when more sensors and sinks are appended in the experiments for all algorithms. For a packet, it will be forwarded to a sink with fewer hop counts when more sinks and sensors are deployed and the E2E delay is reduced significantly. However, for one thing, if a large number of sensors are deployed in a fixed area field, data transmission collision is serious and intolerable, while in a sparse network, sensors are easy to be separated to each other. Hence, the number of deployed sensors should be reasonable. For another thing, even though it sounds excellent for multiple sinks' deployments, higher costs of a sink cause it is prudential to deploy more sinks in realistic environment. Therefore, a reasonable number of sensors and sinks deployed should be guaranteed for application requirement.

We next analyze the energy depletion for all sensors with the number of nodes increasing when the numbers of sinks are 4, 6, and 8, as shown in Fig. 12
                        . From Fig. 12, we can observe that the energy consumption increases gradually with the number of sensors increasing and our algorithm will consume more energy than that of other methods for any number of sensors and sinks. When more sensors became the sources for data generation and more sinks are added to the monitoring field, the energy expenditure is improved significantly. Even though more power is consumed in our algorithm, it does not mean energy is wasted and network lifetime reduction happens. On the contrary, it demonstrates an outstanding performance for our algorithm because the power of each node can be replenished continually. It is different significantly to traditional WSNs, which saving energy is prior to be considered for routing protocol design.

@&#CONCLUSION@&#

In some applications of WSNs, for enhancing transmission reliability, load-balancing, and security purpose, multiple copies of a packet are needed to be collected by multiple sinks for verifying the information of monitoring field, which is generally achieved by the k-anycast communication technique. In traditional-WSNs, owing to limited energy supplement, k-anycast communication is used prudential. However, in R-WSNs, due to energy replenished continually and limited energy storage capacity, a sensor cannot be always beneficial to conserve energy when a network can harvest excessive energy from the environment. Therefore, the surplus energy of sensor can be used for strengthening data transmission.

In this paper, a routing protocol for k-anycast communication based on the anycast tree scheme is proposed for wireless sensor networks. Multiple-metrics are utilized for instructing the route discovery, which can enhance the transmission reliability. A source initiates to create a spanning tree reaching any one sink with source node as the root. Subsequently, we introduce three schemes for k-anycast: a packet is transmitted to exact k sinks, at least k sinks, and at most k sinks, where, a packet can be transmitted to k or more than k sinks benefiting from broadcast technique without wasting the source energy. Simulation results show that the proposed scheme reduces the delay time successfully and balances the energy consumption among the nodes. Through extensive simulation and experiments, we demonstrate our algorithm is feasible and efficient to collect multiple copies of a packet from a source in rechargeable wireless sensor networks.

@&#ACKNOWLEDGMENT@&#

This work was supported by The Natural Science Foundation of Jiangsu Province of China (Grant No. BK20141474) and the project funded by China Postdoctoral Science Foundation (Grant No. 2015M571639). We also received two projects funded by The Jiangsu Planned Projects for Postdoctoral Research Funds (Grant No. 1402018C), and The Key Laboratory of Computer Network and Information Integration (Southeast University), Ministry of Education (Grant No. K93-9-2015-09C).

@&#REFERENCES@&#

