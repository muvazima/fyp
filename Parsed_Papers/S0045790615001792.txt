@&#MAIN-TITLE@&#A context-aware dispatcher for the Internet of Things: The case of electric power distribution systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Detailed explanation of an automatic dispatcher, its components and functions.


                        
                        
                           
                           Framework structure is based on context-awareness integration. with IOT middleware


                        
                        
                           
                           Framework tested in electrical distribution systems as a case study.


                        
                        
                           
                           High progress in the system performance in terms of cost, time and effort.


                        
                        
                           
                           Acceleration in faults repairing and increased user satisfaction.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Context-awareness

Internet of Things

Electricity distribution systems

Dispatcher framework

@&#ABSTRACT@&#


               
               
                  Automating actions based on collected context from Internet of Things (IOT)-controlled systems is one of the most important requirements of IOT systems; this paper seeks to satisfy this requirement by offering a context-aware service framework on top of IOT controlled systems. The fault management process in electric power distribution networks is taken here as a case study and used for implementing our proposed framework. We discuss the different aspects that need to be covered in such a framework and its components. The obtained results from simulating and testing the framework show a significant improvement in the task management process compared to the traditional approach.
               
            

@&#INTRODUCTION@&#

Currently, most people have limited time, attention and precision, which may cause less accuracy when collecting information in real-world situations. This common behavior of human intervention can render any system prone to delays and/or problems. Computers would be helpful for tracking and collecting data about objects to reduce waste and cost, as well as to provide information about objects that need reparation [1].

The Internet of Things (IOT) definition is well known, but we offer the following illustration for a clearer picture of the systems that will be dealt with through this research. IOT consists of the Internet, which is a global network based on communication protocols, and Things, which are physical or virtual objects, devices, information and used interfaces. Things are supposed to be connected with information networks to be controlled remotely. Moreover, they can be of different types [2].

Supervisory Control and Data Acquisition (SCADA) controlled systems represent an example of IOT controlled systems. SCADA systems are used to monitor and control things. These systems encompass the transfer of data between a central host and a number of Remote Terminal Units (RTUs), and then give alarms when any fault is detected. RTU is an electronic device that monitors and controls the system state by using several interfacing modules for inputs and outputs. RTU is a fast, real-time, accurate, and secure data exchange. The application areas of IOT controlled systems can be seen in information systems used to address different fault management in various infrastructural systems, such as electricity, water, and gas companies. In these systems, after the SCADA system collects data and displays it on its interface, the role of dispatchers begins. A dispatcher is the person who is responsible for monitoring the displayed data and alarms and then assigns tasks for repairing faults. As mentioned above, the human factor, which uses multiple manual actions with almost no complete knowledge about faults and the context of workers, may cause workflow delays and bottlenecks.

IOT-controlled systems represent a vital infrastructure in modern society. Therefore, any improvement in the performance of such systems will definitely be noticed by society. The management of such systems consists of balancing cost, performance and risk, taking into account different aspects, such as economic performance, quality of supply, safety and environmental impacts, which the IOT technology seeks to achieve [3].

After introducing this brief idea about IOT and its application areas, the questions here will be as follows: How do we solve the problems related to human intervention? How do we automate actions depending on learned knowledge? How do we save time and effort? These questions raised the following challenges, which the proposed framework and applications built to address such IOT environment may face [4,5]:
                        
                           1.
                           Communication: Objects can communicate with Internet resources or even with each other to utilize data and services. Wireless technologies, such as the universal mobile telecommunications system (UMTS) and wireless fidelity (Wi-Fi), are used.

Sensing: Objects can collect information about their environments with sensors and then store and send this information to a server to perform an action based on them.

Localization: Objects have a definite physical location obtained via theglobal positioning system (GPS) or a cellular network.

User interfaces: Objects can communicate with people in an appropriate manner.

In IOT-controlled systems, we believe that a context-aware dispatcher will be effective in this area due to its ability to tackle these challenges and automate actions depending on contextual information sensed from the IOT environment and received by the framework through its controlled systems.

This paper is organized as follows: Related work is discussed in Section 2. Then, the conceptual framework, together with its components, is introduced in Section 3. We show how these components are implemented by using a prototype on an electric power distribution network as a domain area in Section 4. Section 5 presents the experimental work of the proposed system. Finally, we conclude the paper in Section 6.

@&#RELATED WORK@&#

Using context is important in interactive applications built for the IOT. A significant body of work exists examining various ways to design a context-aware system to support decisions and actions in healthcare [3], emergency [6] and safety [7]. In [8], a life-context-aware alert system was proposed, in which context was collected from an IOT system in the form of multiple microphone sensors distributed at various places in homes. In cases of emergency, the system could alert hospitals. In [9], a mobile conference information system designed to provide location-based information to conference attendees was proposed. In [7], a tourist guide was developed. The system combines mobile computing technologies with a wireless infrastructure and sensors to present city visitors with information tailored to both their personal and environmental contexts.

After reviewing some frameworks that consider the context, the following examples show other existing IOT middleware solutions for searching things and selecting the appropriate one manually without considering the context. In [10], the global sensor networks (GSN) framework, which depends on manual selection, was proposed. If the user does not explicitly specify the temporal processing model, GSN uses default policies that try to best use the available system resources to achieve load balancing among the things that may not be the best for the users. In [11], the Microsoft Sensor Map was used to automatic discover sensors and allowed users to manually select sensors by using a location map. Few related efforts focus on things search based on context information, such as in [12], which considers the locations of smart things as the main context property and structures them in a logical structure. Sensors are searched for by location using tree search techniques. We do believe that the proposed framework in this paper can be used to complement the above mentioned IOT middleware solutions in regard to automating the search and selection of things, depending on the data collected by using high, simple, and effective technologies.

As we noticed, context is particularly important for applications where the user’s context changes rapidly. These applications were considered by a few researchers from different viewpoints, such as programming language, time scheduler, and receiving and replying to things’ requests. In [13], an architecture was proposed that was designed for dispatching commercial vehicles in general. The architecture is flexible enough to incorporate any type of adaptation that would be necessary for the dispatching of parcel delivery and taxis. We notice that it involves simply integrating many client orders into one ride with different attributes. This system is difficult to apply in nature as a result of the laws and it not being scalable enough. In [14], the interruptible context-dependent executions (ICoDE) model, which aims to ease the development of reactive context-aware applications, was introduced. These applications need to adapt their behaviors to sudden interruptions due to the unpredictable occurrence of context changes when using reactive dispatching.

The majority of the efforts presented have focused on developing context-aware services, where their focus was mainly on the know-how of context sensing and adaptation. In this paper, we have used the concept of context to refer to all collected signals and workloads. Though we agree on the importance of context adaptation, we focus more in this work on the understanding of the different components needed to solve the studied research problem.

@&#INTRODUCTION@&#

As mentioned above, if actions are performed manually by the dispatchers, unexpected delays or the possibility of taking wrong actions will take place in the above systems. Additionally, due to the importance of these systems in our society, their services must be appropriate for customer satisfaction. The proposed framework approach is used for building real applications that are easy to handle and easily understood by users. Through these applications, automating actions will be performed. For example, if the situation tells some specialist about a task to do after it has been alarmed by SCADA, what will be the best way to do that? How do we know who the most suitable person among a group of specialists is and how do we connect him without wasting time? What if a smart-phone application receives a notification with the location the specialist has to visit with information on what he needs to do? What if this message is sent automatically by another application without dispatcher intervention? This will definitely be more effective. Therefore, we enunciate the need for a context-aware dispatcher framework for IOT controlled systems. In the following, we present the framework requirements and detailed components.

A simplified and integrated idea regarding the components developed in the proposed framework will be introduced in Section 3.3, which automatically supports all of the common tasks across applications. To this end, we will identify a number of requirements that the framework must fulfill to meet the objectives. These requirements were inspired by the work of [15–17]. These requirements are based on the requirements for a general system designed for dispatching users (workers) and tasks, which can be used by different organizations. The requirements give priority to the openness and flexibility of the framework and the customizability of the applications to increase the generality of the system. Two applications are considered by this system: one for the user who monitors the system (dashboard application) and one for the user who will be responsible for a task (mobile application). Context is the most important thing that the current systems lack and forms one of the most important requirements that must be met by the proposed solution. Context reflects the information of workers and workflows, locations, time, and the types of faults. For the applications, which are supported by the framework, to meet their requirements, the framework should also meet them, and therefore the requirements are inherited by the framework. These requirements are:
                           
                              1.
                              Availability of Context Acquisition: Ensuring the constant availability of the whole system requires that the components that acquire context must execute independently from the applications that use them. Moreover, there is a need for them to be persistent and available all the time. This eases the burden on the application designer by not requiring them to instantiate, maintain, or keep track of components that acquire context. Therefore, context information should always be available.

Data Accuracy: A requirement linked to the need for context interpretation is the quality of the data collected and passed to the application. For example, coordinates must be accurate; to reach this goal, we plan to build and support the architecture by using GPS.

Reliability and Flexibility: These two requirements are important for building the framework architecture. Reliability is a requirement linked to the need for the availability of context. For example, if one of the specialists has a problem with his mobile device and the server cannot locate him, then the system will search for the rest. This is important for saving time and funds. Flexibility is a special requirement that is needed to make our framework more suitable for cases that tend to use context-aware dispatchers to automate actions on top of IOT systems.

Mobile Devices Support: Mobile devices are constrained by their limited size, processing power, available memory, battery capacity, and screen size, among others. Traditional applications, however are not designed to accommodate such issues. To achieve an acceptable level of performance, the developed application, which targets such ‘thin clients’, needs not only to be able to conserve resources but should also be lightweight enough. The aim of our proposed system is to be able to support real-time processing of the data that are displayed either on a mobile device by the specialist or on a dashboard-mounted computer in the station.

Information Management: Data and information at all levels (collected raw data, processed data, analytical results, and produced reports) are integrated into a comprehensive database that allows for information queries, relational analysis, report generation, and mapping support across data categories and organizational functions.

Customizability: The framework should be applicable to any system built to control IOT in real-time, such as the systems we mentioned above (electricity, water, gas); hence, it needs to be designed in a way that is customizable enough to adapt to the changing requirements.

Interfaces: A set of graphical interfaces and Web applications that provide meaningful and accessible information for co-operation and visual information to facilitate decision making.

Usability: Because the target groups of the applications are users, the target groups of the framework are developers. Because their goal is to build applications with context-aware dispatching capability, the framework should make it easier to reach this goal.

Extensibility: The framework should consider functional extensions. For instance, it should enable the future addition of context sources, information sources, and types.

Our objective is not to introduce such an ideal middleware solution but to design a solution to help users to automate the task of selecting the specialist according to the problems/tasks at hand. Our proposed approach can be adopted into an IOT controlled system middleware solution, such as SCADA. The architecture consists of several components, which can be listed as follows (see Fig. 1
                        .):

The Receiver is the front end of the framework; this component should be a graphical user interface (GUI), e.g. a web application. The Receiver would communicate with the frameworkthrough the application programming interface (API). The web request sent to the API should have a payload message of a JavaScript object notation (JSON) object based on the user requirements according to the schema definition provided by the framework. We use JSON to decouple the mechanism of users expressing their requirements from the internal framework execution process. Therefore, it significantly increases the flexibility, customizability, and creativity, allowing developers to develop more sophisticated mechanisms for the users to express their requirements. From the framework perspective, we expect that only a JSON object would comply with our request definition.

This component is responsible for choosing the most suitable specialist to handle the task with respect to context information, such as department, job, location and availability. It requires a task assignment object and a specialist object. It performs the following:

Firstly, it processes the task data and creates an associated task assignment object (TAO) such that: for every task t
                           i, there exists TAOi
                            and Assj
                            such that TAOi
                           
                           ={tid
                           ,
                           Assj
                           ,
                           lAssj
                           ,
                           DAssj
                           }, where tid
                            is the task id, Assj
                            is the assignment to be executed, lAssj
                            is the coordinates of the assignment location and consists of latitude (lat) and longitude (lng), and DAssj
                            is the department responsible for the assignment.

Secondly, it retrieves the specialists’ data from the local databases and creates an array of objects SP, where every object will represent a single specialist such that: For every specialist SP
                           k, there exists a SPkObj
                            such that SPkObj
                           
                           
                           =
                           {SPk
                           ,
                           lSPk
                           ,
                           DSPk
                           ,
                           RSPk
                           ,
                           AVSPk
                           ,
                           PASPk
                           
                           ,
                           
                           ETFSPk
                           }, where SPk
                            is the specialist to be assigned, lSPk
                            represents the location of SPk and has two values: latitude (lat) and longitude (lng), DSPk represents the SPk department, RSPk represents the SPk
                            role within the department, and AVSPk,
                            is a flag that indicates whether the specialist is available or not. PASPk
                            is a flag that indicates whether the specialist declined or was reassigned to this assignment before. It takes Boolean values of either ‘zero’ or ‘one’. ETFSPk
                            is the estimated time until the specialist is available.

Thirdly, the decision maker sends the above arrays to the match filter and checks the outcome array from the filtering process to see whether it needs more processing. If the size of that array is reduced to one object, the processing engine will directly choose that specialist and assign the task to him. If the array is completely wiped, the processing engine will send the request to the database to choose the manager id of the department that was selected by the assignment. Furthermore, if the size of the array is still big, the rule engine passes the outcome array of the filtering process to the Shortest Path Calculator (SPC) component. The SPC will add the following attributes to each Specialist in the array: DISPk
                           , which represents the distance between the specialist’s and the task’s respective locations, calculated by using the Haversine formula; RDISPk
                           , which represents the real-time distance between the specialist’s and the task’s respective locations, calculated by using Google Maps Directions API; and RDUSPk
                           , which is the real-time duration needed for the specialist to reach the task location, calculated by using Google Maps Directions API. Afterward, the processing engine will sort the outcome array of the SPC according to DISPk, RDISPk
                            and RDUSPk
                            and then select the first specialist in the array, which will be the closest one to the task. A further description of the workflow is presented in Algorithm 1 and Fig. 2.
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm (1) Processing Engine Workflow
                                       
                                       
                                          1: TAO←
                                             t; #Task object
                                       
                                       
                                          2: #SP←Specialists Array
                                       
                                       
                                          3: b
                                             ←Filter Match (SP, TAO);
                                       
                                       
                                          4: if 
                                             b.size
                                             ==0 then
                                          
                                       
                                       
                                          5: 
                                             e
                                             ←Get Manager (TAO.dept);
                                       
                                       
                                          6: else if 
                                             b.size
                                             ==1 then
                                          
                                       
                                       
                                          7: 
                                             e
                                             ←
                                             b [0];
                                       
                                       
                                          8: else
                                          
                                       
                                       
                                          9: 
                                             b
                                             ←Calculate Shortest Path (b, TAO);
                                       
                                       
                                          10: SortArray (b,”DI”);
                                       
                                       
                                          11: SortArray (b,”RDI”);
                                       
                                       
                                          12: SortArray (b,” RDU
                                             
                                             +
                                             
                                             ETF”);
                                       
                                       
                                          13: 
                                             e
                                             ←
                                             b [0];
                                       
                                       
                                          14: end if
                                          
                                       
                                       
                                          15: return 
                                             e;
                                       
                                    
                                 
                              
                           
                        

This is used to receive the assignment object and the specialists array from the processing engine and to apply multiple filters to the specialists array to remove unfit specialists according to the assignment object. The applied filters will be: a department filter, which will remove any specialist who is not in the same department as the assignment; a role filter, which will remove any specialist who has a higher role, e.g., managers; an availability filter, which will remove any unavailable specialist; and a previous action filter, which will remove any specialist who has previously declined or was assigned to the same assignment. Algorithm 2 and the flowchart in Fig. 3
                            represent the filtering process of the Match Filter:
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm (2) Match Filter Workflow
                                       
                                       
                                          1: TAO←
                                             t; #Task object
                                       
                                       
                                          2: #SP←Specialists Array
                                       
                                       
                                          3: for 
                                             i
                                             =0 to SP.size − 1 do
                                       
                                       
                                          4: 
                                             if 
                                             SP[i].D
                                             ≠
                                             TAO.D 
                                             
                                                or
                                              
                                             SP[i].R
                                             ==1 
                                                or
                                              
                                             SP[i].AV
                                             ==0 
                                                or
                                              
                                             SP[i].PA
                                             ≠0 then
                                          
                                       
                                       
                                          5: 
                                             SP←remove (SP[i]);
                                       
                                       
                                          6: 
                                             continue;
                                       
                                       
                                          7: 
                                             end if
                                          
                                       
                                       
                                          8: end for
                                          
                                       
                                       
                                          9: return SP;
                                       
                                    
                                 
                              
                           
                        

This component is responsible for the process of calculating the distance between each specialist and the task location. SPC will receive the outcome array b of the filtering process and apply an algorithm to the array items as a source point and to the task location as a target point. After a brief investigation of graph search techniques, we decided that the concept of the Contraction Hierarchies (CH) approach, which is a combination of Dijkstra’s algorithm and the bidirectional algorithm with some modifications [18], is a good technique for real roads. The algorithm searches from the source in one direction and from the destination in the other direction while skipping unimportant nodes during the query. Nodes are removed one by one from the graph and shortcut edges are inserted to preserve all shortest path distances between the remaining nodes [19]. This algorithm overcomes the drawbacks related to the bidirectional Dijkstra algorithm; it can perform effectively with large graphs and uses data structures that store a small amount of data, even though, when using a bidirectional query, each edge is only stored once [20]. Furthermore, Google provides us with high-end maps and routing services benefiting from a huge community of map contributors and utilizing Google’s servers’ processing power and Google’s satellites for real-time updated maps and fast shortest path calculation.

For the sake of simplicity and a better performance, we used the Google Maps API in our framework because it is faster and more reliable due to real-time updated data and, after all, it is familiar to users; with simple and understandable interfaces, Google maps and directions are the main navigation application in any android operated smart-phone, as well as being accessible from any web browser [21]. The SPC will use two methods to calculate the distance between each specialist’s location and the task’s location. The first method involves the Haversine formula, which is a well-known equation in spherical trigonometry that is used to calculate the distance between two points on a sphere using latitudes and longitudes [22]. The other method is to use the Google Maps Directions API, which will produce both the distance and duration of the shortest route between the specialist’s location and the task’s location. Algorithm 3 and the flowchart in Fig. 4
                            show the steps performed by the SPC.
                              
                                 
                                    
                                    
                                       
                                          
                                             Algorithm (3) Shortest Path Calculator (SPC) Workflow
                                       
                                       
                                          1: TAO←
                                             t; #Task object
                                       
                                       
                                          2: #SP←Specialists Array
                                       
                                       
                                          3: for 
                                             i
                                             =0 to 
                                             SP.size − 1 do
                                          
                                       
                                       
                                          4: da
                                             ←
                                             sin2 ((TAO.l.lat − SP[i].l.lat)/2)+
                                             cos (SP[i].l.lat)∗
                                             cos (TAO.l.lat)∗
                                             sin2 (TAO.l.lng −SP[i].l.lng);
                                       
                                       
                                          5: dc
                                             ←2∗
                                             atan2 (√da, √(1 − da));
                                       
                                       
                                          6: 
                                             SP[i].DI
                                             ←6371∗1000∗
                                             dc;
                                       
                                       
                                          7: 
                                             sc
                                             ←
                                             c
                                             +(SP[i].l.lat+”, ”+SP[i].l.lng+”|”);
                                       
                                       
                                          8: end for
                                          
                                       
                                       
                                          9: tc
                                             ←TAO.l.lat+”, ”+TAO.l.lng;
                                       
                                       
                                          10: j
                                             ←Send2gAPI (sc, tc);
                                       
                                       
                                          11: for 
                                             i
                                             =0 to 
                                             j.rows.size − 1 do
                                          
                                       
                                       
                                          12: 
                                             SP[i].RDU
                                             ←
                                             j.rows[i].elements.duration;
                                       
                                       
                                          13: 
                                             SP[i].RDI
                                             ←
                                             j.rows[i].elements.distance;
                                       
                                       
                                          14: end for
                                          
                                       
                                       
                                          15: return SP;
                                       
                                    
                                 
                              
                           We avoided security and privacy risks by using the oracle database, which features high security, as well as by requiring the framework states to log in using a user name and an encrypted password. This specifies that every user can access only some specified data depending on his role in the system. Fig. 5
                            explains the workflow of the proposed system with the steps performed by the system when applying the algorithms; Fig. 6
                            presents a Unified Modeling Language (UML) class diagram of the above-discussed components in detail with their functions used in the programming code.

One might argue that the operation of collecting information as well as the shortest path calculation only have to be carried out in the beginning and that there is no need to update either in the future. We think that this only applies to static situations and not dynamic ones. In the case of a context-aware dispatcher, information is subject to change in real-time. Every time the context changes, previous actions can no longer be applied, which means that the system will need to obtain an updated value. This emphasizes the assumption that our framework allows for automatic and dynamic situations.

In our framework, the main components are developed in Java and deployed on top of an Apache Tomcat 7.0 web server. We make use of the Tomcat web sockets servlet as the main communication method between all framework components (see Fig. 7
                        ). The first component to communicate with the web sockets servlet is the Receiver. The Receiver displays data retrieved from payload messages received from the web-socket servlet. The messages could be data received from a specialist’s smart-phone or data retrieved from the database tables. The Receiver usually communicates with the web sockets to send messages to a specialist’s smart-phone, request context updates from the specialists, or send a task to the framework to select a suitable specialist to handle this specific task.

Per request, the web sockets will choose how to handle the request either by sending a message directly to a specialist’s smart-phone or by sending a message to the Processing Engine. The Processing Engine is implemented as a java class with a collection of methods that are responsible for querying the database, inserting data into the database and selecting a suitable specialist for a task. Match Filter and Shortest Path Calculator are both implemented as java classes with various methods used by the Processing Engine to select a suitable specialist for a task.

As aforementioned, the smart-phones use web sockets to maintain a constant connection to the server over the internet. This is implemented as a mobile application that is developed in Java for Android smart-phones and supports Android version 4.0.3+(Ice Cream Sandwich). This mobile application is responsible for replying to context update requests with location data retrieved from the smart-phone GPS sensor, sending messages to the Receiver and replying to a specific task request through a native android interface.

When a dispatcher sends a task through the Receiver, it will be passed by the websockets to the Processing Engine to determine which specialist will be asked to handle the task. The chosen specialist’s data are passed back to the websockets, which automatically send the task request in a message to the specialist’s smart-phone.

We choose an electricity distribution company to be our use case to build the two applications considered by this system, i.e., the dashboard application and mobile application. Introducing these two applications will help in understanding the proposed system and gives strength to the simplicity of the interfaces to reach users’ satisfaction where the SCADA system acts as the controlling system of the IOT. The current electricity distribution system consists of a number of workstations with SCADA user interfaces, through which the system is monitored by an engineer. The user interface (UI) functionality consists of facilities with which the engineer can communicate with the outdoor things by means of the operating consoles, which is considered rather complex. Nevertheless, the system also supports the existence of servers to interpret the data and store it. Things in the current system include the different electricity components, such as RTUs, sensors, relays, and protection devices, for electric power distributor plants, which are called koshks, and the specialists (engineers) who are equipped with GPS-enabled android mobile phones. There are some successive steps to signal transmission error passing from an RTU to the SCADA, after which the RTU collects the signals and transmits them widely or wirelessly to the servers to be interpreted; information is displayed on the SCADA system interface. According to this information and the situation, the dispatcher performs different manual actions, as mentioned above in Section 1. Replacing these manual actions by automatic ones will occur through the following application: firstly, through the dashboard application, which is intended mainly for the engineer who is responsible for monitoring the system and has three main sections, as shown in Fig. 8
                        .

The left section is used to search for the koshks and record the koshks’ faults in the database. The right section is an embedded Google map, which has markers that indicate the specialists’ locations and the faulty koshks. The bottom-right section shows a list of all specialists connected to the system, which allows for monitoring specialists and having text conversations with them (see Fig. 8). This interface is definitely more understandable and easier than the operating consoles in the current system.

The mobile application from the user point of view will be responsible for receiving an assignment message, which has some data about the task. Upon touching this message, the specialist will have three options (see Fig. 9
                        ). The “show on map” button is used to display the directions, location and estimated time to arrival to the task location (see Fig. 10
                        ). Second, he/she can accept the assignment. Third, he/she can decline the assignment. Furthermore, when he accepts an assignment, he can receive more options from the assignments list that allow him to reassign the task to another specialist (which will actually send a request to the web sockets to look for the next best suitable specialist to handle the task), put it on hold or change the assignment’s status to finish. The “show on map” option will remain there for all assignments, even finished ones (see Fig. 11
                        ).

Assigning the specialist to a task was completely and autonomously performed by the system, which gives the monitoring engineer a sense of ease and comfort in the use of this system. The monitoring engineer only looks for the faulty koshk code and then determines the type of faults shown on the screen; after that, the framework is responsible for the rest. Moreover, reports are provided to allow the monitoring engineer and higher privilege users to extract information about specialists and their respective assignments by querying the database tables. This provides information about the overall system situation. The database is based on the Oracle 11g Express Edition database and contains tables for storing basic attributes for the web forms in the Receiver interface, basic information about specialists, task logs and specialists’ logs.

To demonstrate the possible benefits of utilizing our system, it needs to be evaluated based on its overall system accuracy, mobility, quality, transparency and performance. Due to the highly controlled nature of the electric environment and importance of the electric data involved, it was not possible to run our experiment with the actual repair faults to avoid any electricity outages. Instead, a controlled environment was setup to simulate the characteristics of the electric power distribution network.

The experimental environment consisted of one laptop powered by an Intel i5 (2.50GHz) processor, which runs on the Windows 7 professional operating system and works as our server. Additionally, five mobile phones running on android operating systems were used. Four of them represent the specialists and one is the manager of a department. The mobile phones are connected together via a wireless network. We define a number of koshks using longitude and latitude to illustrate their locations on the map. Additionally, we define fault types collected from SCADA to be identified by our system, including RTU failure, protection failure, communications failure, and software failure. Each fault is related to a department that has some working specialists.

The testing has been conducted based on certain situations with koshks in different locations to ensure a comprehensive and accurate testing of the system response in every situation. Situation 1 tests the system’s ability to choose the best specialist in the same department based on the specialist’s availability, location and experience with that same fault type. In situation 2, one fault took place, and we tested the ability to classify faults and assign them to the suitable department. Situation 3 is a combination of the two pervious situations, i.e., multiple faults related to multiple departments occur at the same time. We test the ability of the system to choose the department related to the fault and then choose the best specialist in that department. In each case, we log problems faults related to koshks that must be fixed and calculate the time taken to send the assignment to each engineer (see Table 1
                        ).

As shown in Table 1, the test of assigning koshks’ faults to specialists has been repeated 36 times, considering the above situations of changing the fault types and changing the fault locations and taking into account that the reactions of the specialists kept changing according to their situation, e.g., whether they were occupied, or to their circumstances, which control their decision to either accept or reject the task. For the time of assignment, the message takes 2s on average to reach the specialist’s mobile phone. To ensure that the testing of the system has been fully comprehensive, most of the unexpected situations that may occur have been taken into consideration during the testing process, such as the following:
                           
                              1.
                              Rejection from all engineers to repair the fault (decline).

All engineers are busy at work and a new malfunction was found.

An assignment is sent to a specialist but he did not reply by accepting or declining.

Discussing the system actions due to the above unexpected situations, it was found that the system successfully achieved what it was designed for such that:
                           
                              1.
                              In the case of rejection from all engineers of the assignment message, the system sends a message to the manager indicating that immediate action must be taken.

In the case where all engineers are busy at work and a new malfunction takes place, the system calculates the time required for repairing the current fault and the time taken by the engineers to get to the place of the new fault and then chooses the least amount of time. To illustrate how the system could calculate the least amount of time, we provide this part of the pseudocode:
                                    
                                       a.
                                       Input an estimated time to finish the assignment in seconds upon acceptance.

If all engineers are busy, then calculate the time needed by everyone to fix the fault.

Time=assignment start time+estimated time to finish – current time+estimated time to reach the new malfunction.

Order the engineers according to the time obtained from the above formula.

Choose the engineer with the least time.

Send the new assignment to him.

In the case where an assignment has been sent to an engineer but he did not reply by accepting or declining it, at this time, the system takes two actions. Firstly, it sends the assignment to the next suitable engineer. Secondly, it reports to the manager about the situation.

In this section, we evaluate the results based on the stated requirements in Section 3.2 as follows:
                           
                              •
                              
                                 Overall performance: The situation handling time consists of the time consumed by the dispatcher to search for the faulty koshk, which is found to be only a few seconds (on average 2s), and the time taken by the system to send the assignment message, which is found to be only a few seconds also. Real tests stated that the system took less than one minute to send the message and receive the answer from the specialist (assuming the specialist answered the assignment upon receiving), while the existing system took 5–10min just to call a specialist without knowing whether he/she is suitable; if not, it took another 5–10min to call another one, and so on. Therefore, we concluded that the overall performance has been improved by approximately 90% (see Fig. 12
                                 ).


                                 Mobility: The proposed system added flexibility to the possibility of finding any specialist, even if he is not at his office. In the existing system, it is not easy to do that.


                                 Traceability and Control: Tracing and controlling the system faults repairing process improved the entire system. In the existing system, the only way of tracing is to call the specialist frequently (see Fig. 13
                                 ). In the proposed system, automatic actions play a large role in tracing the workflow through the framework. They are used to trace faults’ and specialists’ locations, workloads, and actions taken by the specialists in every situation.


                                 Quality: Being raised in terms of quality standards, managers with our proposed system can monitor and assess the performance of teams. When an engineer or technician repeatedly rejects assignments, the manager can question him and even issue him a warning. On the other hand, it is easier to recognize those who perform well. Moreover, the manager can know who needs to be sent for more training to improve their performance. In the existing system, each manager receives this type of information through human factors, which may not be that objective.


                                 Transparency: The proposed system is a transparent system because the appropriate specialist to repair faults is not requested by the monitoring engineer but through the system without influencing how the choice is made. A lack of knowledge may cause problems.


                                 Fault Tolerance: The system has now become more amenable to repair errors in less time through the proper selection of specialists, avoiding previously repeated wrongful acts, such as sending the same employee, who has proven not to be able to repair certain faults, to the same locations. Moreover, the right department to repair a certain koshk can now be selected without mistakes. These repeated problems no longer exist in the proposed system because the new system can find the best matches.

We have compared our proposed system after its application in the field of electricity with some systems that have also addressed several areas of electric distribution networks to show the progress and excellence that the proposed system adds to these systems. The first system, introduced in [23], concentrates on integrating the application of a distribution automation monitoring system. Dispatchers can study the distribution network’s detailed running state in real-time. The judgment of the point of fault also has an adequate basis. These systems support the dispatcher by effectively shortening the search time of the point of fault and improving the accuracy of the judgment of the dispatcher. This research considers the discussion of applications used to detect faults in the electric power distribution network in real-time. Furthermore, it does not care about post-fault detection, i.e., how to choose the best one from a group of specialists to fix the fault and the optimal way in which to charge him to repair. It does not care about the burdens of the dispatcher after troubleshooting the network. This is what was discussed for our proposed system, i.e., improving the performance by automating actions taken after detecting faults and eliminating human intervention. The second system, introduced in [24], concentrates on the data integration aspects of the system, such as geographic information systems (GIS), Interactive Voice Recognitions systems (IVR), SCADA, and customer information, in determining where the faulty circuit components are located. It is able to locate and identify faulty electric components. The diagnosis is rapid and accurate and takes advantage of available data. The future work of this system is to track the GPS data of the locations of repair crews and schedule repairs, which is already implemented in our proposed system. In this work, we did not consider how data are integrated because we rely on an IOT controlled system that will do the job. To avoid re-inventing the wheel, that system and our proposed one oblige to use as many Commercial Off the Shelf (COTS) components as possible and concentrate on making the code independent of which components were chosen so that a utility would not become locked into using a particular vendor’s solutions. The difference between the two systems is that the first system is concerned with automating the actions of integrating and fusing the information, which are performed manually by the dispatcher. The proposed system is concerned with automating all of the actions previously performed manually by the dispatcher after fault detection. In [25], the Global Understanding Environment (GUN) framework can be applied in the electricity distribution field to address a variety of real world cases in the advanced control and management of power distribution networks. Faults detection and diagnosis could be shared among agents that provide context aware information and collaborate to learn behaviors that aid in detecting new types of faults. The knowledge about new types of faults and their solutions could be shared among agents by using the communication feature. The drawback, from our point of view, is that agents build their knowledge based on the behaviors of the dispatcher in different events; we have to avoid that human intervention because it may cause delays and/or errors. Our proposed system relies on a set of rules as well as intelligence in a number of situations. Additionally, the GUN framework is concerned with cooperation between heterogeneous devices through software agents to assist the dispatcher by supporting automating routine analysis tasks in daily operations. This shows the difference between the two systems: our proposed one does not perform faults analysis because it depends on the existing SCADA system, which detects, analyzes and gathers all of the data related to faults and reports them; however, it does detect, analyze and gather all data related to workers and presents reports about their work behaviors to raise the quality of the company. Table 2 summarizes the aforementioned comparison results.

@&#DISCUSSION AND CONCLUSIONS@&#

In this paper, we used the concept of context to refer to the signals collected by an IOT controlled system along with specialists’ GPS locations and workloads. Despite the importance of context adaptation, we focused more on understanding the different components needed to solve the studied research problem. Additionally, we proposed the adoption of services architecture to provide useful services to both specialists and their managers.

We provided a comprehensive explanation of the system and its components, requirements, implemented tasks and the steps required to solve problems. Moreover, we presented a simple scenario explaining the benefits of IOT and its data management capabilities for our framework and how we use this concept to automate the existing systems, as shown in our case study. After comparing between how problems are solved in the current approach and the proposed system, the results were concluded. By applying our framework, we achieved acceleration in repairing faults, reduction in fault duration and, accordingly, increased user satisfaction and increased savings in the company’s funds.

Future work includes extending the model to enable the representation of more complex scenarios and adapting the functional architecture and prototype accordingly to include this model extension. This extension includes keeping statistical calculations on past situations and faults and predicting possible faults to take the necessary actions; with more sophisticated ways of artificial intelligence, we can determine which objects need to be substituted and changed or maintained only, which allows the system to take decisions completely away from any system user interference. Moreover, we will enhance the user interface and functionalities with additional facilities to strengthen the monitoring process, such as by using video conference and easier interaction methods.

@&#REFERENCES@&#

