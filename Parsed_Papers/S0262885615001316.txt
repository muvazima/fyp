@&#MAIN-TITLE@&#A novel low false alarm rate pedestrian detection framework based on single depth images

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Proposed a low false alarm rate pedestrian detection method


                        
                        
                           
                           Extracted foregrounds with the employment of depth sensor


                        
                        
                           
                           Designed a pre-evaluation stage to save computation time and reduce false alarm rate


                        
                        
                           
                           Built a pedestrian database with 673 depth images collected from 11 different scenes


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Pedestrian detection

Histogram of Oriented Gradients

Shape context

Chamfer matching

@&#ABSTRACT@&#


               
               
                  Pedestrian detection is an important image understanding problem with many potential applications. There has been little success in creating an algorithm which exhibits a high detection rate while keeping the false alarm in a relatively low rate. This paper presents a method designed to resolve this problem. The proposed method uses the Kinect or any similar type of sensors which facilitate the extraction of a distinct foreground. Then potential regions, which are candidates for the presence of human(s), are detected by employing the widely used Histogram of Oriented Gradients (HOG) technique, which performs well in terms of good detection rates but suffers from significantly high false alarm rates. Our method applies a sequence of operations to eliminate the false alarms produced by the HOG detector based on investigating the fine details of local shape information. Local shape information can be identified by efficient utilization of the edge points which, in this work, are used to formulate the so called Shape Context (SC) model. The proposed detection framework is divided in four sequential stages, with each stage aiming at refining the detection results of the previous stage. In addition, our approach employs a pre-evaluation stage to pre-screen and restrict further detection results. Extensive experimental results on the dataset created by the authors, involves 673 images collected from 11 different scenes, demonstrate that the proposed method eliminates a large percentage of the false alarms produced by the HOG pedestrian detector.
               
            

@&#INTRODUCTION@&#

Pedestrian detection is one of the most popular areas in computer vision over the recent years [1–3]. A pedestrian is defined as a human standing in an almost upright position. There are two main classes of methods for pedestrian detection, namely, the generative methods and the discriminative methods. Both methods aim at distinguishing between human and non-human classes of objects [4]. The main concept behind generative methods is to find one or several models (e.g., shape models [5], texture models [6], and others) for classification, while the main concept of discriminative methods is to find the best descriptive features (e.g., Haar wavelet features [7], Histogram of Oriented Gradients (HOG) [8], Scale-invariant Feature Transform (SIFT) [9]) or find the optimal parameter values for their classifier (e.g., Neural Networks (NN) [5,10], Support Vector Machines (SVM) [11] and Adaboost [12]) [7]. The majority of techniques which were originally developed for pedestrian detection perform well only in scenarios where the entire human silhouette is present in the image. Recently, researchers have started to consider using techniques which investigate the characteristics of the image at a local fashion [11,13]. The main advantage of this type of approaches is that the object of interest may be recognized even in the case of occlusion by other objects or when part of it is not visible [14,15].

Inspired by these methods, we propose a pedestrian detection scheme which investigates both global and local shape information and take advantage of recent methodologies developed by experts in this field, to achieve a more accurate detection result. Specifically, to detect pedestrians in an image, firstly, possible candidate regions are estimated by the HOG detector. These regions are kept for subsequent investigation while the remaining regions where no humans were detected using HOG are discarded from the investigation. Taking into consideration the high false alarm rate of HOG detector, candidate regions are further investigated using alternative models. In other words, the proposed framework aims at eliminating false alarms produced by the HOG pedestrian detector while preserving the true detections. There are several challenges in pedestrian detection, e.g., posture variations, heavily cluttered background, occlusion and others. To decrease the influence of these problems, in the proposed work, multiple models rather than one single model are involved to improve evaluation effectiveness. Furthermore, the Kinect depth sensor is also employed to facilitate the elimination of irrelevant signals which affect the detection results, such as background signals, weak edges and texture. We explore the proposed method on a dataset created by the authors that involved 673 patches collected from 11 different scenes with 470 human existing patches and 203 human-like patches.

We discuss the method in Section 2, describe the experiments and performance evaluation results in Section 3 and give conclusions in Section 4.

@&#METHODOLOGY@&#

This section gives an overview of the proposed pedestrian detection scheme. To start with, in this work we use both RGB and Kinect sensors. RGB sensors provide detailed information which facilitates the extraction of refined edges. HOG detector requires a rich and detailed edge map in order to perform sufficiently well and for that reason, in this work the HOG detector is implemented on the outputs of the RGB sensors. However, in order to eliminate false detections produced by HOG, we examine local Shape Context (SC) models [16]. We believe that in order to focus on local features that correspond solely to the object of interest irrelevant signals which affect the detection results, such as background signals, weak edges and texture must be eliminated. Detailed edge maps should not provide a positive contribution in our attempt to deduce the false alarms produced by HOG. Therefore, SC models are implemented on the outputs of the depth (Kinect) sensors only. More specifically, we only examine regions with the depth sensor outputs which have been detected by HOG in the corresponding RGB outputs. We assume that RGB and depth sensors are perfectly registered.

The basic flowchart of the proposed detection scheme is shown in Fig. 1
                        . As already mentioned above, input images are image patches taken from the depth sensor output, selected on the basis that the corresponding patches of the images taken from the RGB sensor have been detected as suspicious regions for the presence of a pedestrian. The first stage of the detection framework involves a sequence of pre-processing operations. Initially, the image that is obtained from the depth sensor is transformed into a black and white (binary) image. After that we obtain the edge map of the binarized depth sensor response by employing the widely used Canny edge detector. We observe that the edge maps extracted from binarized depth images often have a number of line artifacts toward the bottom of the image patches. As far as true detections are concerned, these line artifacts are due to the presence of the ground under the human silhouette and the fact that both ground and silhouette might have the same distance from the camera. Furthermore, there are weak edges and texture within the entire image which appear like blobs and other types of irrelevant micro-structures when we obtain the edge maps from the depth sensor, all of which should be erased in the pre-processing stage. The detailed pre-processing method is introduced in Section 2.2. After the pre-processing of the depth sensor output, the SC representation of each edge pixel is extracted, using the technique described in Section 2.3. In order to use SC we must compare the SC of an edge pixel located within a region of interest with the SC of an edge pixel located within a prototype region. In other words, in contrast with the HOG model which is a training-based model, the SC model is a prototype-based model. In this work we use a database of several representative prototype images of pedestrians at slightly varying poses. The aim is to compare the SC of edge pixels of an image region obtained from an image of interest with the SC of edge pixels of an image region obtained from a prototype image. Comparison of two SC models is realized using specific metrics that have been developed by researchers. Two edge points are “matched” if they possess “similar” shape context. The final stage is introduced in Section 2.4, where matched edge points are clustered into several clusters according to their spatial distribution, and then these clusters are evaluated according to their characteristics either kept or rejected in order to complete the detection scheme.

In this section we assume that the regions detected by HOG after this is applied on the RGB sensor outputs are available. We locate these regions in the corresponding depth images in order to extract the SC models. Before the SC extraction, the edge map extracted by the Canny detector is obtained. It is important to stress out the fact the edge map is not obtained directly from the original depth image but from a binarized version of it constructed in a fashion that will be described in the subsequent section. As already mentioned, it is observed that in the binarized depth image some line artifacts exist toward the bottom of the image. By the term “line artifact”, we are referring to a horizontal line (row) with an excessive number of white pixels. There are two possible detected scenarios that may produce line artifacts. A possible scenario relates to true detections in the depth image where the depth values within human feet are almost the same as the depth values of the ground around human feet. In that case the line artifacts are concentrated toward the bottom of the detected patch. Another possible scenario relates to false detections in the depth image where it is observed that there are line artifacts evenly distributed across the falsely detected patch, and not necessarily present toward the bottom of the detected patch. Furthermore, it is noticed that some relatively small blob artifacts are present and randomly distributed across the binary detected patches. Both line artifacts and blob artifacts can significantly undermine the quality of the extracted edge map. A pre-processing method based on the structural properties of these artifacts is applied in order to eliminate them, which is described in detail in Section 2.2.1 below. Then, a pre-evaluation process is used to eliminate false detections. These detections can be identified by investigation of simple features, e.g., the number of white pixels in the binary image patch and the degree of similarity of the two edge maps, i.e., that of a detected patch in the complex image under investigation and that of a perfect model of a human body (prototype). The idea behind the pre-evaluation process is that some images without human that are occasionally found should be eliminated at the early stage of the detection scheme without further processing in order to save computation time. The details of the pre-evaluation process are introduced in Section 2.2.2.

Firstly, we aim at converting the detected depth image patches into a binary image patches. This is different from the standard binarized edge map where a threshold is set and pixels with edge response greater or smaller than this threshold are replaced with white or black respectively. Our binary image consists of two areas, namely, the object of interest (human-like object) and the background. It is obvious to assume that the depth values of pixels which are located within the object of interest show a small variation around their mean. Therefore, the object of interest can be preserved in the binary image by estimating a range of depth values which correspond to depth values that pixels located on the object of interest possess. In order to realize this task, both the minimum and the maximum of the depth values corresponding to the subject should be ideally found. Let the width of the detected from the depth sensor be w and the height of the same patch be h. We denote the depth value for the central point as d(w/2,
                           h/2). The central point of the depth image is considered as a key point for the selection of binarization values. This is because, since the HOG detection window is placed around the human in a symmetrical fashion, it is definite that the centroid of the detection window will be located on the human in the case of a true detection. Therefore, the lower and upper thresholds for thresholding are set as d(w/2,
                           h/2)−15 and the upper threshold for thresholding is d(w/2,
                           h/2)+15, respectively. The value of 15 has been selected after a thorough investigation which involved a large number of images.

The depth image is converted into a binary image according to the following equation
                              
                                 (1)
                                 
                                    b
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       
                                          
                                             
                                                255
                                                ,
                                             
                                             
                                                d
                                                
                                                   
                                                      w
                                                      2
                                                   
                                                   
                                                      h
                                                      2
                                                   
                                                
                                                −
                                                15
                                                <
                                                d
                                                
                                                   x
                                                   y
                                                
                                                <
                                                d
                                                
                                                   
                                                      w
                                                      2
                                                   
                                                   
                                                      h
                                                      2
                                                   
                                                
                                                +
                                                15
                                             
                                          
                                          
                                             
                                                0
                                                ,
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           where b(x,
                           y) is the value of binary image and d(x,
                           y) is the depth value of depth image.

As already mentioned, it is observed that various types of artifacts exist in the binarized image, e.g., the line-type and the blob-type artifacts discussed in Section 2.2. We define line artifacts as these rows which exhibit a high concentration of white pixels. These particular rows are identified by setting a threshold for white pixels of 0.7w and they are replaced by zero valued (black) pixels. The number of white points in row x is calculated as
                              
                                 (2)
                                 
                                    
                                       n
                                       x
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             y
                                             =
                                             1
                                          
                                          w
                                       
                                       
                                          
                                             
                                                b
                                                
                                                   x
                                                   y
                                                
                                                /
                                                255
                                             
                                          
                                       
                                    
                                 
                              
                           where b(x,
                           y) is defined as above.

The blob artifacts in the binary image are assumed to be caused by the presence of weak edges, micro-structures and textured surfaces that have similar depth as the human body in the original depth image. In this paper, small blob artifacts in the binary image are detected and removed. Specifically, small blob artifacts are detected by counting its contained pixels. Here, blobs are detected by repeating the following processes 1 and 2 until all the pixels are labelled as one pixel of a blob (connected component): 1. search for the unlabeled (unprocessed) pixel d(x,
                           y); and 2. flood-fill algorithm is applied to label all the pixels in the connected component containing d(x,
                           y). The involved flood-fill algorithm is used for finding the area connected to a given pixel [17]. The minimum area size is defined with respect to the number of pixels of the whole binary image, which is mathematically calculated as
                              
                                 (3)
                                 
                                    t
                                    =
                                    
                                       
                                          w
                                          ×
                                          h
                                       
                                       b
                                    
                                 
                              
                           where t is the minimum area size, w is the width of the binary image, h is the height of the binary image, and the scale factor b is set as 14.

As the last step of pre-processing, the closing operation is applied on the processed binary image to make the boundary edges smoother. We have tried a couple of structuring elements for this morphological operation and selected the disk-shaped element with radius one based on visual inspection. Finally, the Canny edge detector is applied on the pre-processed binary image to extract its edge map [18]. The extracted edge map is shown in column (d) in Fig. 2.
                        

The aim of pre-evaluation stage is to identify which of the previously detected image patches are false detections and discard them from the subsequent procedure. Instead of the original detected patches we utilize the binarized version of them which have been created previously in the so-called “pre-processing” stage. It has been observed that both the relative amount and distribution of black and white pixels in a binarized patch can be used as markers to identify patches which are highly likely to be false detections. We define two sequential steps with the first being the detection of relative amount of black and white pixels in a patch followed by the investigation of their spatial pattern. Specific rules relate the above markers with the likelihood of a patch being false. At the end of this procedure which succeeds in identifying a fraction of the false patches, an image patch is further evaluated if it is not labeled as a false detection. At the end of this procedure which succeeds in identifying a fraction of the false patches, an image patch is further evaluated if it is not labeled as a false detection.

Regarding the relative amount of black and white pixels in a detected patch, it is noticed that binarized falsely detected patches often contain a distinctively dominant color or, in simple terms, they contain either too many or too few white pixels compared with a true detection, as shown in Fig. 3
                           . These false detection can be eliminated by introducing two thresholds Bu
                            and Bl
                            with B
                           
                              u
                           
                           >
                           B
                           
                              l
                           . Then, patches with white pixels more than Bu
                            or less than Bl
                            are labeled as false detections. These thresholds are selected by estimating the white pixels of all true detections and ensuring that both their minimum and maximum values lie within these boundaries so that all true detections are kept during this procedure. In our scenario the above thresholds are set to B
                           
                              u
                           
                           =
                           N
                           
                              all
                           /2.5 and B
                           
                              l
                           
                           =
                           N
                           
                              all
                           /15, where Nall
                            is the total number of pixels in a patch. Illustration of image patches with an excessive number of rows that contain more than 70% white pixels are shown in Fig. 4
                           .

Regarding the relative distribution of black and white pixels in a detected patch, it is observed that falsely detected binarized patches often contain a large number of rows with high concentrations of white pixels whereas true detections do not. A threshold of 70% is set based on experimental validations. A detected patch is then labeled as false if at least one third of its rows contain at least 70% of white pixels. The number of rows nr
                            in a patch with at least 70% of white pixels may be identified using the following formula:
                              
                                 (4)
                                 
                                    
                                       n
                                       r
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          h
                                       
                                       
                                          
                                             
                                                
                                                   1
                                                   2
                                                
                                                
                                                   
                                                      sign
                                                      
                                                         
                                                            
                                                               ∑
                                                               
                                                                  j
                                                                  =
                                                                  1
                                                               
                                                               w
                                                            
                                                            
                                                               
                                                                  d
                                                                  
                                                                     i
                                                                     ,
                                                                     j
                                                                  
                                                               
                                                               −
                                                               
                                                                  70
                                                                  100
                                                               
                                                               w
                                                            
                                                         
                                                      
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

Finally, an additional further step employs the so called chamfer matching method to estimate the possibility of the presence of a human in the image patch. Chamfer matching is a method for measuring the fitness of the silhouettes (edge boundaries) between two edge map images [19,20]. In chamfer matching, the testing edge image is transformed into a distance map (DM) by employing a distance transform (DT). After this, a matching measurement is calculated between a prototype edge image and the DM of the testing image. The matching measurement reflects the possibility of the presence of the prototype image within the testing image. In DT, the testing image is doubled in size to form a new image. Then, each edge pixel in the expanded image is set to zero and each non-edge pixel is assigned a value that measures the distance between itself and its nearest edge pixel. In this paper, we measure the distance using the quasi-Euclidean formula, which has similar accuracy but less computation time compared with the Euclidean distance. The quasi-Euclidean distance between P
                           1
                           =(x
                           1,
                           y
                           1) and P
                           2
                           =(x
                           2,
                           y
                           2) is calculated as,
                              
                                 (5)
                                 
                                    T
                                    
                                       
                                          P
                                          1
                                       
                                       
                                          P
                                          2
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         x
                                                         1
                                                      
                                                      −
                                                      
                                                         x
                                                         2
                                                      
                                                      
                                                         
                                                            +
                                                            
                                                               
                                                                  
                                                                     2
                                                                  
                                                                  −
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         y
                                                         2
                                                      
                                                      −
                                                      
                                                         y
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                ,
                                                
                                                   
                                                      
                                                         x
                                                         1
                                                      
                                                      −
                                                      
                                                         x
                                                         2
                                                      
                                                   
                                                
                                                >
                                                
                                                   
                                                      
                                                         y
                                                         1
                                                      
                                                      −
                                                      
                                                         y
                                                         2
                                                      
                                                   
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         2
                                                      
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   
                                                      
                                                         x
                                                         1
                                                      
                                                      −
                                                      
                                                         x
                                                         2
                                                      
                                                      
                                                         +
                                                      
                                                      
                                                         y
                                                         2
                                                      
                                                      −
                                                      
                                                         y
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                ,
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The DM of a true detection is shown in Fig. 5(c) and the DM of a false alarm is shown in Fig. 5(d).

After these edge maps have been calculated, the edge map of the prototype image is superimposed on part of the DM and shifted over the entire DM to calculate the root mean square (r.m.s.) average of pixel values for describing the degree of the similarity between the prototype image and the testing image. The r.m.s. for current offset position (i,
                           j) is calculated as,
                              
                                 (6)
                                 
                                    
                                       v
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             1
                                             N
                                          
                                          
                                             
                                                ∑
                                                
                                                   n
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            p
                                                            n
                                                         
                                                         
                                                            d
                                                            n
                                                         
                                                      
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where N is the number of pixels in the superimposed area, i and j are the offset of the prototype image in terms of the upper left corner of the DM, pn
                            is the n-th pixel of the prototype image, and dn
                            is the n-th pixel of the DM.

In most cases, the minimum value of the matching result of a false detection is higher than the corresponding minimum value of a true detection. It is quite straightforward to show that smaller average values indicates better matches. Furthermore, a perfect match should ideally yield a zero value. In this paper, the size of the DM is 380×180, the size of the prototype image is 190×90, and the matching operation produces a 190×90 matrix as the matching result, as shown in Fig. 6
                           . The matching result of the true detection has a much smaller minimum value compared with the matching result of the false detection, indicating a higher possibility for the presence of a human in the patch of interest. The threshold for chamfer matching is set as 13. It is worth mentioning that the selection of the prototype image has a minor effect on the outcome of this process. It is noted that several parameters in the pre-evaluation section are selected based on the principle that the pre-evaluation process should ensure that true detections are preserved. The benefit of using the sequence of tasks that form the pre-evaluation stage is evaluated in Section 3.3.

A further investigation of the detected image patches that survived the pre-evaluation stage is realized by using the Shape Context (SC) model. In contrast to the HOG model, SC is a prototype-based object detection which can be utilized either in a global or in a local fashion and can only be applied on edge maps. For the creation of the SC model of an edge map patch each pixel in the patch is associated with a feature vector derived from the local edge information, i.e., the spatial distribution of the edge pixels within the local neighborhood of the pixel under investigation. The similarity is measured between the SC model of the detection patch and the SC model of a set of prototype image patches. The involved prototypes contain human silhouettes with a plain background which are free from noise, irrelevant objects, or micro-structures.

The basic idea of the SC is that a compact and robust object descriptor with high discriminative power can be defined within the neighborhood of each pixel, where the neighborhood is defined by using the log-polar coordinate system (ρ,
                        θ) instead of the traditional Cartesian coordinate system. The size of the local neighborhood defines the degree of locality of the model which is controlled by the radius R of the descriptor. The degree of detail (resolution) of the SC is controlled by two parameters within the log-polar space, namely, the sampling rate N along ρ that controls the number of rings and the sampling rate M of polar angle θ that controls the number of triangles (pizza slices). According to these parameters, the logarithmic distance is calculated as 
                           ρ
                           =
                           
                              
                                 
                                    ρ
                                    i
                                 
                                 =
                                 
                                    R
                                    
                                       log
                                       
                                          R
                                       
                                    
                                 
                                 log
                                 
                                    
                                       
                                          R
                                          i
                                       
                                       N
                                    
                                 
                                 ,
                                 i
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 N
                              
                           
                         and the polar angle is calculated as θ
                        ={θ
                        
                           i
                        
                        =2πi/M,
                        i
                        =1,⋯,
                        M}. To extract the SC for a pixel, let P
                        ={p
                        1,…,
                        p
                        
                           m
                        } describe a set of pixels that form an edge map P, where pi
                         be the i-th edge pixel. The edge map P might form either an entire object or part of it. The SC Hi
                         for pixel pi
                         is defined as
                           
                              (7)
                              
                                 
                                    H
                                    i
                                 
                                 =
                                 
                                    
                                       
                                          h
                                          1
                                       
                                       
                                          
                                             p
                                             i
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          h
                                          k
                                       
                                       
                                          
                                             p
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        where h
                        
                           k
                        (p
                        
                           i
                        ) is computed according to h
                        
                           k
                        (p
                        
                           i
                        )=#{p
                        
                           j
                        
                        ≠
                        p
                        
                           i
                        |p
                        
                           j
                        
                        ∈
                        P,
                        p
                        
                           j
                        
                        ∈
                        bin(k)} and K
                        =
                        NM is the number of SC bins. All bins belong to the log-polar space (ρ,
                        θ) around pixel pi
                        .

Eq. (7) introduces how to extract SC for a single pixel. In order to describe the SC model for an entire edge map which forms and object O with points (pixels) oi
                        , we rewrite Eq. (7) as a function H
                        
                           R,N,M
                        (o
                        
                           i
                        )=
                        H
                        
                           i
                         with parameters R,N and M. The SC model of the object O is described as
                           
                              (8)
                              
                                 S
                                 
                                    C
                                    o
                                 
                                 =
                                 
                                    
                                       
                                          H
                                          
                                             R
                                             ,
                                             N
                                             ,
                                             M
                                          
                                       
                                       
                                          
                                             o
                                             i
                                          
                                       
                                       |
                                       
                                          o
                                          i
                                       
                                       ∈
                                       O
                                       ,
                                       i
                                       =
                                       1
                                       ,
                                       ⋯
                                       ,
                                       m
                                    
                                 
                                 .
                              
                           
                        
                     

The performance and in general the functionality of SC models rely on the selection of R, N, and M. A large R often provides a global SC descriptor, which has a good performance when the object of interest is rigid. However, its performance would be significantly degraded when the object is deformed or occluded. A smaller R indicates that the SC describes the neighborhood of a pixel oi
                        . In contrast with the global descriptor, the local descriptor tends to have higher tolerance of shape distortion or partial occlusion, since in the above scenarios it can still efficiently describe the available and/or non-distorted parts of the object of interest, and thus, it is more suitable for a real life application. Therefore, we choose a relatively small R for the SC descriptor. The optimal value for R is chosen during the experimental validation of Section 3.2. Both N and M control the number of bins of a SC descriptor, where higher values indicate more bins. More specifically, a detailed descriptor requires higher number of bins, which, however, yield to higher computational burden and do not always lead to improved results. This is because the descriptor becomes sensitive to the fine details of objects and therefore, similar objects which belong to the same class but exhibit small differences might be identified as dissimilar positive detections would be eliminated. A detailed study about the selection of values for N and M is presented in Section 3.2. The optimal values for N and M are given after the elaborate study.

As mentioned in Section 2.1, we employ the SC descriptor to find pixels in the test edge map image that are similar to pixels in the prototype edge map image, as far as their local neighborhood's shape is concerned. Let 
                           P
                           =
                           
                              
                                 p
                                 1
                              
                              ⋯
                              
                                 p
                                 
                                    N
                                    P
                                 
                              
                           
                         describe a set of NP
                         edge points of the prototype edge image, 
                           T
                           =
                           
                              
                                 t
                                 1
                              
                              ⋯
                              
                                 t
                                 
                                    N
                                    T
                                 
                              
                           
                         describe a set of NT
                         edge points of the testing edge image, the above defined H
                        
                           i
                        
                        ={h
                        1(p
                        
                           i
                        ),⋯,
                        h
                        
                           K
                        (p
                        
                           i
                        )} be the SC of pi
                         (the prototype image's edge point), and G
                        
                           j
                        
                        ={g
                        1(t
                        
                           j
                        ),⋯,
                        g
                        
                           K
                        (t
                        
                           j
                        )} be the SC of tj
                         (the testing image's edge point). χ
                        2 distance is involved to measure the cost c
                        
                           i,j
                         of matching these two edge points' SC. The similarity measurement between a prototype image and a testing image is described as,
                           
                              (9)
                              
                                 
                                    c
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    1
                                    2
                                 
                                 
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       K
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      g
                                                      k
                                                   
                                                   
                                                      
                                                         t
                                                         j
                                                      
                                                   
                                                   −
                                                   
                                                      h
                                                      k
                                                   
                                                   
                                                      
                                                         p
                                                         i
                                                      
                                                   
                                                
                                             
                                             2
                                          
                                          
                                             
                                                g
                                                k
                                             
                                             
                                                
                                                   t
                                                   j
                                                
                                             
                                             +
                                             
                                                h
                                                k
                                             
                                             
                                                
                                                   p
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where K is the number of bins in the SC descriptor and c
                        
                           i,j
                         is an element of a N
                        
                           P
                        
                        ×
                        N
                        
                           T
                         matrix C (NP
                         is the number of edge points in prototype image, NT
                         is the number of edge points in testing image).

An edge point of the test image is matched up with the edge point of the prototype image which has the minimum matching cost. It is possible that edge pixels of the test image might have multiple matches with zero cost. In this case, the spatially nearest matched pixel pi
                        , estimated by employing Euclidean distance, is selected to match up with tj
                        . It is worth mentioning that in this framework we assume that patches to be compared are resized so that they have identical size. Furthermore, in the prototype patch the human is placed in the middle. This is also the case in the test patch which has been produced by the HOG detector which places a square boundary box around the detected human. Therefore, we can assume that the prototype and test patch are by construction registered. A matched pixel tj
                         will be considered as a “dummy” point and will be eliminated from the set of matched points, if the spatially nearest matched pixel pi
                         is “too far” away, since similar contours should located in spatially close positions rather than far ones. Furthermore, edge points of the test image will be eliminated when no match exists. In this paper, the Euclidean distance between two pixels is used to measure their distance. To compute the spatial distance between two pixels of the test edge patch and the prototype edge patch, let us use their Cartesian coordinates 
                           
                              p
                              i
                           
                           =
                           
                              
                                 x
                                 
                                    p
                                    i
                                 
                              
                              
                                 y
                                 
                                    p
                                    i
                                 
                              
                           
                         and 
                           
                              t
                              j
                           
                           =
                           
                              
                                 x
                                 
                                    t
                                    j
                                 
                              
                              
                                 y
                                 
                                    t
                                    j
                                 
                              
                           
                        . Their Euclidean distance is calculated as
                           
                              (10)
                              
                                 
                                    d
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   y
                                                   
                                                      t
                                                      j
                                                   
                                                
                                                −
                                                
                                                   y
                                                   
                                                      p
                                                      i
                                                   
                                                
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   x
                                                   
                                                      t
                                                      j
                                                   
                                                
                                                −
                                                
                                                   x
                                                   
                                                      p
                                                      i
                                                   
                                                
                                             
                                          
                                          2
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Based on the matched up pixels, the new edge map images of the test and prototype patch Et
                         and Ep
                         are determined, representing the edge map of testing image and prototype image, respectively. The only difference between the edge map Et
                         and the original edge map T is that those unmatched pixels are erased in the edge map Et
                        ; this is the same for the case of the edge map Ep
                         and the original edge map P.

In this section, the properties of the matched edge map Et
                         are evaluated so as to verify whether a real human exists. It is observed that the main drawback of local SC is the large number of matched points that it produces. This is due to the simple structure that an image possesses if it is observed locally. Our goal is to keep only the matched points which relate to matches of corresponding parts between the test object and the prototype object. In this work we use a framework [21] in which the matched points are spatially clustered in both the test and prototype patch and then certain clusters are sequentially removed in four separate stages in order to keep only those that are likely to contain true matched points. The elimination processes are based on certain cluster properties. The entire framework is depicted in Fig. 7
                        . In the first stage, cluster sparsity is applied to measure the number of clusters in the matched edge map of the testing image. Then, cluster activity is applied to measure the number of corners in each cluster and cluster density is applied to measure the distribution of the edge boundaries of each cluster. In the final stage, figural continuity is applied to evaluate the similarity between the clusters of Et
                         and Ep
                        .

Clusters are formed using the so-called subtractive clustering method. More specifically, each edge pixel is a potential cluster center and its likelihood is measured in direct proportion to the density of its surrounding pixels [22]. Given an edge point set X
                        ={x
                        1,…,
                        x
                        
                           N
                        } in two dimensional space ℜ2, the density function of xi
                         is defined as,
                           
                              (11)
                              
                                 D
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       N
                                    
                                    
                                       exp
                                       
                                          
                                             −
                                             
                                                
                                                   |
                                                   
                                                      x
                                                      i
                                                   
                                                   −
                                                   
                                                      x
                                                      j
                                                   
                                                   |
                                                   
                                                      
                                                      2
                                                   
                                                
                                                
                                                   
                                                      r
                                                      a
                                                   
                                                   /
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ra
                         is a neighborhood radius and |x
                        
                           i
                        
                        −
                        x
                        
                           j
                        |2 is the Euclidean distance between xi
                         and xj
                        . N is the number of pixels within the neighborhood of pixel xi
                        .

The edge point with highest density value is selected as the first cluster center 
                           
                              x
                              
                                 c
                                 1
                              
                           
                        . After this, each edge point is assigned with a new density value calculated according to its distance to 
                           
                              x
                              
                                 c
                                 1
                              
                           
                         in an inverse proportion. This process iterates until sufficient clusters have been attained. Let k be the number of iteration, the new density value is computed as
                           
                              (12)
                              
                                 
                                    D
                                    k
                                 
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 =
                                 
                                    D
                                    
                                       k
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 −
                                 
                                    D
                                    
                                       k
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       x
                                       
                                          c
                                          
                                             k
                                             −
                                             1
                                          
                                       
                                    
                                 
                                 exp
                                 
                                    
                                       −
                                       
                                          
                                             |
                                             
                                                x
                                                i
                                             
                                             −
                                             
                                                x
                                                
                                                   c
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                             
                                             |
                                             
                                                
                                                2
                                             
                                          
                                          
                                             
                                                r
                                                b
                                             
                                             /
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        where rb
                         is a positive constant.

It is observed that at least 5 clusters can be usually formed in an edge map which contains a human silhouette with the use of the selected clustering parameters. It is also worth mentioning that ellipse shape clusters are used since it has been observed that they capture the contour of the human body in a more optimal fashion. The detected clusters are usually placed around the head and the limbs. This is expectable since these are distinctive features of the human body and quite consistent among different human silhouettes. In the case of partial occlusion we still aim at detecting at least 4 clusters within the human silhouette. It is observed that quite often false detections originated by HOG produce smaller number of matched points when SC is applied and subsequently less clusters. To eliminate those false detections, the minimum number of clusters (cluster sparsity) is set to 4. A testing image patch will be labeled as non-human if the number of clusters of its matched points is less than the selected value of 4.

At this stage, we evaluate the number of salient (high activity) points and the density of pixels in each cluster to select the clusters which will survive for the subsequent evaluation. This is because clusters of matched points which form almost straight lines (low activity clusters) are not conclusive since simple structures are found in all objects. In general key parts of the human body such as the “head and shoulder” (or so called Omega Shape) part contain a substantial number of salient points. The same comments are valid for clusters which contain points that do not form any shape but are randomly distributed within the boundaries of the cluster (non-dense clusters).

In this work, the cluster activity is related to the number of corner points of a cluster. Corners are “interesting” points of a shape since they can compactly and efficiently describe the shape. In mathematical terms corners are points with a high curvature [21]. We are seeking for high activity clusters and therefore, we are looking for a threshold for this classification. The threshold is calculated as follows. Provided that the number of clusters in a current edge map is nc
                            and the number of corner points in cluster j is nj
                           , then the number of corner points in the matched edge map is calculated as 
                              
                                 N
                                 s
                              
                              =
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                       c
                                    
                                 
                                 
                                    
                                       n
                                       j
                                    
                                 
                              
                           . We divide Ns
                            by the number of cluster nc
                            in order to obtain the mean of the number of cluster corners. However, it is observed through exhaustive experimental validation that a functional threshold for cluster activity is given by the formula below where the mean described above is further divided by a constant which is selected to be 5. Therefore, the cluster activity threshold is defined as follows:
                              
                                 (13)
                                 
                                    
                                       c
                                       act
                                    
                                    =
                                    round
                                    
                                       
                                          
                                             N
                                             s
                                          
                                          
                                             5
                                             
                                                n
                                                c
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

Furthermore, for cluster density [21] we use the mathematical formula shown below,
                              
                                 (14)
                                 
                                    
                                       c
                                       den
                                    
                                    =
                                    
                                       
                                          n
                                          p
                                          2
                                       
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                n
                                                p
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                               i
                                                            
                                                            −
                                                            
                                                               m
                                                               x
                                                            
                                                         
                                                      
                                                      2
                                                   
                                                   +
                                                   
                                                      
                                                         
                                                            
                                                               y
                                                               i
                                                            
                                                            −
                                                            
                                                               m
                                                               y
                                                            
                                                         
                                                      
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           np
                            is the number of edge pixels in current cluster, where each pixel is denoted using the subscript i,
                           i
                           =1,…,
                           n
                           
                              p
                           , (m
                           
                              x
                           ,
                           m
                           
                              y
                           ) is the pair of coordinates of the cluster centroid, and (x
                           
                              i
                           ,
                           y
                           
                              i
                           ) is the pair of coordinates of the cluster points. A larger cden
                            indicates a dense point spatial distribution (points are located spatially close), while a smaller cden
                            indicates a sparse distribution.

In the above section clusters with high activity points which are spatially close (dense) did finally survived. In this section we are looking for clusters whose points form continuous shapes. This requirement relies on the fact that edge maps of real life objects should contain some “almost” continuous curves and are never a collection of randomly distributed edge points. Knowing that the prototype image is artificially created and does not contain any cracked edges or random noise, we assume that clusters of points of the prototype image should form solid curves that belong to key parts of the human body as mentioned in the previous section. Therefore, we assume that the property of figural continuity is quite prominent within clusters of points of the prototype image. On the other hand, two clusters of matched points which belong to the test and prototype patch respectively should “look” spatially similar if they are located around corresponding parts of the two human bodies. Therefore, figural continuity should be a required property in clusters of matched points of the test image as well. This property is implicitly tested by forming an equation that describes the difference between boundary shapes of two clusters defined as f
                           
                              cont
                           (i).
                              
                                 (15)
                                 
                                    
                                       f
                                       cont
                                    
                                    
                                       i
                                    
                                    =
                                    
                                       1
                                       
                                          
                                             n
                                             i
                                             t
                                          
                                          
                                             n
                                             i
                                             p
                                          
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             m
                                             =
                                             1
                                          
                                          
                                             n
                                             i
                                             t
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   
                                                      m
                                                      ′
                                                   
                                                   =
                                                   1
                                                
                                                
                                                   n
                                                   i
                                                   t
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         1
                                                         
                                                            
                                                               L
                                                               
                                                                  t
                                                                  ,
                                                                  i
                                                                  ,
                                                                  m
                                                               
                                                            
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         
                                                            ∑
                                                            
                                                               k
                                                               =
                                                               2
                                                            
                                                            
                                                               L
                                                               
                                                                  t
                                                                  ,
                                                                  i
                                                                  ,
                                                                  m
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     I
                                                                     k
                                                                     
                                                                        t
                                                                        ,
                                                                        i
                                                                        ,
                                                                        m
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     I
                                                                     
                                                                        k
                                                                        −
                                                                        1
                                                                     
                                                                     
                                                                        t
                                                                        ,
                                                                        i
                                                                        ,
                                                                        m
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      −
                                                      
                                                         1
                                                         
                                                            
                                                               L
                                                               
                                                                  t
                                                                  ,
                                                                  i
                                                                  ,
                                                                  
                                                                     m
                                                                     ′
                                                                  
                                                               
                                                            
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         
                                                            ∑
                                                            
                                                               k
                                                               =
                                                               2
                                                            
                                                            
                                                               L
                                                               
                                                                  t
                                                                  ,
                                                                  i
                                                                  ,
                                                                  
                                                                     m
                                                                     ′
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     I
                                                                     k
                                                                     
                                                                        t
                                                                        ,
                                                                        i
                                                                        ,
                                                                        
                                                                           m
                                                                           ′
                                                                        
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     I
                                                                     
                                                                        k
                                                                        −
                                                                        1
                                                                     
                                                                     
                                                                        t
                                                                        ,
                                                                        i
                                                                        ,
                                                                        
                                                                           m
                                                                           ′
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

In the above equation f
                           
                              cont
                           (i) is the figural continuity of the i-th cluster of the edge map of the testing image, n
                           
                              i
                           
                           
                              t
                            is the number of connected-components in the i-th cluster of the same image and L
                           
                              t,i,m
                            is the length of the m-th connected-component. Moreover, n
                           
                              i
                           
                           
                              p
                            is the number of connected-components in the i-th cluster of the matched edge map of the prototype image and 
                              
                                 L
                                 
                                    t
                                    ,
                                    i
                                    ,
                                    
                                       m
                                       ′
                                    
                                 
                              
                            is the length of the m′‐th connected-component. Finally, I
                           
                              k
                           
                           
                              t,i,m
                            and 
                              
                                 I
                                 k
                                 
                                    t
                                    ,
                                    i
                                    ,
                                    
                                       m
                                       ′
                                    
                                 
                              
                            are the k-th edge pixel of the m and m′‐th connected-components of the corresponding image.

@&#EXPERIMENTAL RESULTS@&#

The performance of the proposed method is evaluated and tested in this section. Among the crucial parameters to be selected for the implementation of the proposed method are parameters related to the SC descriptor and furthermore, the size (scale) of the clusters of matched points. The optimal values for these parameters are selected after a large number of experiments have been conducted. A discussion is presented in Section 3.2. Following parameter selection, the performance of the proposed method is evaluated in Section 3.3. Moreover, we test the proposed method with the Princeton Tracking Benchmark (PTB) database [23], which has RGB images and depth images captured in various scenes, using the selected parameters of Section 3.2.

In this work the images used are rectangular patches generated by the HOG pedestrian detector applied on images obtained using the Kinect depth sensor. All detections, i.e., true positives and false positives, are initially kept for further investigation. The aim of the proposed method is to eliminate false alarms produced by the HOG pedestrian detector, i.e., the HOG technique is the baseline method for our investigations. We evaluate the performance of the proposed method by measuring the number of reserved true positive detections and eliminated false alarms. To this end, we define P as the number of true positives, FA the number of false positives and N
                     =
                     P
                     +
                     FA the total number of detections. In terms of the processed results of the proposed method, let Np
                      be the number of correctly labeled positive images, Nfn
                      be the number of positive images which are wrongly labeled as false alarms, Nn
                      be the number of correctly eliminated false alarms, and Nfp
                      be the number of false alarms which are wrongly labeled as positive images. Since we aim at eliminating false alarms and preserving positive images generated by the HOG detector, the correctly labeled results should include both correctly labeled positive images and correctly eliminated false alarms N
                     
                        p
                     
                     +
                     N
                     
                        n
                     . Then the precision is defined as Precision
                     =(N
                     
                        p
                     
                     +
                     N
                     
                        n
                     )/N, the truth positive rate is defined as TPR
                     =
                     N
                     
                        p
                     /P, and the false alarm rate is defined as FAR
                     =
                     N
                     
                        fp
                     /N.

In terms of the prototype image formation we initially considered a set of pedestrians with slightly varying poses. From this set we attempted to derive a single image that captures the characteristics of all the individual images of the set, using the so called Karhunen–Loeve Transform (KLT). However, the performance of the proposed framework was poor due to the fact that a single model of a pedestrian cannot, by and means, capture the properties of all possible postures. However, prototypes with different postures provide sufficient information for evaluation. By jointly considering evaluation accuracy and time efficiency, four human (pedestrian) silhouettes with different representative postures are selected as prototype images as shown in Fig. 8
                        .

By employing the HOG detector on 11 different scenes captured by the Kinect camera depth sensor we obtained a large number of detected patches including a significant number of falsely detected patches. We manually selected 470 representative human existing patches and 203 non-human existing patches (false alarms generated by the HOG detector); the size of the dataset was doubled to 1346 patches by involving the left–right flipped version of these patches, where only the representative posture of one pedestrian out of multiple continuous frames are selected such that of downsizing reasonably the size of the dataset. All patches are resized to the same size 190×90. Some database images are shown in Fig. 9
                        .

In this section, the optimal parameter values are obtained by thoroughly studying the precision of the proposed scheme with various choices of parameter values. These parameters are namely, the number of angular bins of SC (NASC), the number of radius bins of SC (NRSC), the radius of SC (RSC) and the radius size of the candidate clusters (CCS). Selecting jointly optimal values for 4 parameters is not a simple task, since each choice usually exhibits both advantages and drawbacks, let alone the fact that the parameters under consideration are implicitly correlated. To give an example, the cluster size should be big enough to contain a sufficient number of edge points for cluster evaluation but also small enough to capture the local signal information which, however, is also affected by the parameters of the SC descriptor.

We manually selected the optimum values for these four parameters using the following strategy: an initial coarse test is conducted to locate the possible region of the parameters that can achieve a good performance, after which we select one parameter and finds its optimal parameter value while keeping the other parameter unchanged, then keep this parameter fixed and test different combinations of the rest parameters to find their relative optimum values. In our experiment, NASC is selected as the first parameter. For simplicity and clearance, we use precision to evaluate the performance.

Furthermore, there are additional parameters required in this work for which we use the default values provided in the literature. These are the normalized image size set to 190×90, the threshold for chamfer matching is 13 and the scale and lower threshold parameters related to the Canny edge detector set to σ
                        =1.2 and 0.4 respectively. For the subtraction clustering method, the quash factor is set to 1.25, the accept ratio to 0.5 and reject ratio to 0.15. Finally, for cluster assessment the cluster sparsity is set to 4, the cluster activity is to 5.50, the cluster continuity is to 3.60 and cluster density to 2.00.

In order to find the optimum value for NASC, the whole scheme is loop executed with different NASC and NRSC while keeping other parameters fixed. Fig. 10
                            shows the precision of the proposed method with a varying number of angular bins and radius bins, where both NASC and NRSC vary from 1 to 7 while the RSC is set to 0.10 and the CCS is set to 0.6.

As can be seen from Fig. 10(a), the precision shows a fluctuation trend as NASC changes. For NASC equals to 1, the experimental results show relatively low precision. Then the precision maintains an increasing trend as the number of angular bins increase. After the point that corresponds to NASC equal to 4, the precision starts to decline and this trend lasts until NASC changes to 7.

Here, we include an additional experiment that aims at testing the benefit of involving the pre-evaluation process, shown in Fig. 10(b). We can see that including the pre-evaluation stage yields better precision. More specifically, the proposed method achieves a good precision when NASC equals to 1. Then precision falls when the value of NASC changes to 2. After this point, the precision rises again and this trend lasts until NASC changes to 5, where the precision falls again. It is easy to conclude that, on the overall, the pre-evaluation process has a noticeable positive impact on the proposed method especially for smaller NASC values.

To select the optimal value for NASC, we present the experiment results jointly with the values of Nn
                            and N
                           
                              fn
                           , as shown in Table 1
                           , where an improved result should have a high Nn
                            and a low N
                           
                              fn
                           . It can be seen from Table 1 that the best results are achieved when NASC equals to 4. Therefore, for the following experiments, 4 is selected as the value for NASC.

In this section we aim at finding the optimal values for the rest of the parameters, namely, NRSC, SCR and CCS. As mentioned, it is difficult to determine the optimal value for each parameter separately, since the above parameters are not independent to each other. Therefore, the proposed scheme is loop executed for different combinations of NRSC, SCR and CCS. For simplicity, and due to the large number of experimental results to be compared, we have decided to use the precision solely as an evaluation metric for the proposed technique. We already know from previous experiments that a “good” value for the NASC is 4. Therefore, we set the NASC to 4 and test 7 combinations of the other three parameters to find the optimal set of parameter values.

We vary the NRCS from 1 to 7 with step 1, vary the RSC from 0.07 to 0.13 with step 0.01 and finally, vary the CCS from 0.30 to 0.75 with step 0.05. The proposed ranges of values for the above 3 parameters yield 7×10×10=700 combinations of parameters to be tested here for finding the optimal one. The results for these combinations are shown in Fig. 11
                           . We can find from the figures that as the NRSC increases from 1 to 4, the precision increases too. For NRSC larger than 5, the precision decreases as the number of radius bins increases. It is straightforward to conclude that more radius bins do not yield a better precision. This is because the descriptor becomes detailed enough so as to be sensitive to small and/or irrelevant signal variations. We can also extract from the set in Fig. 11 that the best precision is always achieved when RSC equals to 0.11 or 0.12, and basically 0.11 is the most robust choice since it yields good performance regardless of the value selection for the NRSC or the CCS. In terms of the CCS, higher values achieve improved precision but this trend stops when the value of the CCS reaches 0.70 and therefore we select the value of 0.70 for CCS.

In this section, we also test the performance of the proposed method for eliminating false alarms produced by the HOG detector with different combinations of four cluster metrics used for matched point cluster elimination, namely, sparsity, activity, density and continuity.

As mentioned in Section 2.4.1 the cluster sparsity is set to 4. Therefore, we discuss the influence of various combinations of the other three cluster metric values on the proposed method. Firstly, we investigate the three scenarios where in each scenario only one of the cluster metrics is involved. These scenarios are depicted in Fig. 12(a) where the blue, green and the red line illustrate the evaluated performance with varying values for cluster activity, continuity, and density, respectively. Furthermore, we investigate scenarios where in each scenario two of the cluster metrics are involved. These are depicted in Fig. 12(b–d). These tests are evaluated with a fixed value for one parameter while varying values are for the other parameter. For example, the green line in Fig. 12(b) is produced with a fixed value for cluster density and varying values for cluster continuity. Finally, we investigate scenarios with all cluster metrics as shown in Fig. 12(e). Similarly, these tests are evaluated with fixed values for two parameters while varying values for the rest one parameter. For example, the blue line in Fig. 12(d) is evaluated with a fixed value for cluster continuity and cluster density and different values for cluster activity. In these tests, the default value is 5.50 for cluster activity, 3.60 for cluster continuity and 2.00 for cluster density. It is quite straightforward to conclude from Fig. 12 that involving two cluster metrics achieves better result than a single one and furthermore, varying all three metrics simultaneously yields the best performance. This is further improved by involving the pre-evaluation process as described in Section 2.2, as shown in Fig. 12(f).

In these tests, all patches (470 positive patches and 203 negative patches) of the database are involved. The best performance is achieved in Fig. 12(f), where 189 out of 203 (93.10%) negative patches were eliminated, 7 out of 470 (1.49%) positive patches are wrongly labeled as false alarms and 14 out of 203 (6.89%) negative patches were wrongly labeled as positive samples.

Using the same parameter, furthermore, we test the proposed method with the PTB dataset. 1297 image patches were segmented from the image frames of the dataset, including 832 positive patches and 465 negative patches. The final result is listed in Table 2
                           , where 449 out of 465 (96.56%) negative patches were eliminated, 23 out of 832 (2.76%) positive patches are wrongly labeled as false alarms. The main conclusion of this section is that the proposed method is able to eliminate most of the false alarms while preserving most of the true detections. More than this, it is proved effective to involve the proposed pre-evaluation process.

@&#CONCLUSION@&#

In this paper, we introduced a pedestrian detection method for eliminating false alarms generated by the HOG pedestrian detector. The involvement of Kinect offers depth information and enables the proposed method to be able to separate the object of interest from the background in a simple way. The proposed method achieves high detection rate while keeping false alarm rate in a much lower standard. This is because the proposed method uses a combination of object models which can capture efficiently both global and local patterns. Specifically, the employment of the Shape Context representation exploits additional information in comparison with the widely used HOG method and thus is able to explore and eliminate false alarms within a sequence of post-processing evaluation stages. Our experiments have demonstrated the effectiveness of the proposed method.

@&#ACKNOWLEDGEMENT@&#

This paper was supported by the China Scholarship Council (CSC) for 1year study at Imperial College London, File No. 201306120111.

@&#REFERENCES@&#

