@&#MAIN-TITLE@&#Quality optimized medical image information hiding algorithm that employs edge detection and data coding

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A method for embedding patient's information into medical image is proposed.


                        
                        
                           
                           Two coding methods have been utilized to embed the EPR and improve imperceptibility.


                        
                        
                           
                           Cost optimization function is contributed to enhance the quality of the stego image.


                        
                        
                           
                           The proposed system is robust against textural feature steganalysis.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Digital steganography

Cryptography

EPR

Edge detection

STC

Hamming code

@&#ABSTRACT@&#


               
               
                  Objectives
                  The present work has the goal of developing a secure medical imaging information system based on a combined steganography and cryptography technique. It attempts to securely embed patient's confidential information into his/her medical images.
               
               
                  Methods
                  The proposed information security scheme conceals coded Electronic Patient Records (EPRs) into medical images in order to protect the EPRs’ confidentiality without affecting the image quality and particularly the Region of Interest (ROI), which is essential for diagnosis. The secret EPR data is converted into ciphertext using private symmetric encryption method. Since the Human Visual System (HVS) is less sensitive to alterations in sharp regions compared to uniform regions, a simple edge detection method has been introduced to identify and embed in edge pixels, which will lead to an improved stego image quality. In order to increase the embedding capacity, the algorithm embeds variable number of bits (up to 3) in edge pixels based on the strength of edges. Moreover, to increase the efficiency, two message coding mechanisms have been utilized to enhance the ±1 steganography. The first one, which is based on Hamming code, is simple and fast, while the other which is known as the Syndrome Trellis Code (STC), is more sophisticated as it attempts to find a stego image that is close to the cover image through minimizing the embedding impact. The proposed steganography algorithm embeds the secret data bits into the Region of Non Interest (RONI), where due to its importance; the ROI is preserved from modifications.
               
               
                  Results
                  The experimental results demonstrate that the proposed method can embed large amount of secret data without leaving a noticeable distortion in the output image. The effectiveness of the proposed algorithm is also proven using one of the efficient steganalysis techniques.
               
               
                  Conclusion
                  The proposed medical imaging information system proved to be capable of concealing EPR data and producing imperceptible stego images with minimal embedding distortions compared to other existing methods. In order to refrain from introducing any modifications to the ROI, the proposed system only utilizes the Region of Non Interest (RONI) in embedding the EPR data.
               
            

@&#INTRODUCTION@&#

In recent years, the growth of information and communication technology have made the transmission of digital information more appropriate and necessary requirement for different sectors such as government, education, banking and health care where the Internet has become the backbone for data exchanging and sharing [1,2]. The health care system primarily utilizes the Internet to facilitate remote exchange of digital medical images and information between hospitals and clinics and to provide e-health services to patients [3,4]. Access to medical information, enable the communication of patient data between different doctors; and efficient remote diagnosis [4].

Digital medical images are fundamental to the diagnosis and treatment of many diseases, and hence, it is extremely important to guarantee secure storage, processing and analysis of medical images without violating the Code of Ethics for Health Information Professionals. The Hospital Information System (HIS) and Picture Archiving and Communication System (PACS) form the bases of digital hospital systems that adopt the Digital Imaging and Communication in Medicine (DICOM) standard [5–8]. Since the first publication of DICOM in 1993, it has been established as the international standard for handling, storing, printing and transmitting medical imaging and related information [9]. It defines the format for medical images that can be exchanged with the data necessary for clinical use. However, DICOM was initially introduced without considering network security or data protection [7,8,10]. A DICOM encoding method has later been initiated and become the only data protection for nearly 20 years. DICOM standard accepts different encryption methods such as Data Encryption Standard (DES), Triple-DES, and RSA (Rivest, Shamir, Adleman) to protect the privacy and confidentiality of health information [11]. However, those encryption methods do not ensure confidentiality of important data [6].

Lately, numerous methods were introduced to provide protection of medical image and patient records [3,12,13]. For secure communication, these methods depend either on cryptography or information hiding techniques. Cryptography methods use encryption to hide the meaning of the message, but they cannot hide its existence [1,14]. The main feature of cryptography is that unintended users cannot explain the encrypted message without the private key. However, the transmission of encoded text certainly stimulates intruders’ attention, whom may attempt to decrypt it. Information hiding on the other hand is the process of embedding information inside another medium for secure transmission. It can be applied in a wide range of applications such as copyright, tampering detection and secret data transmission [15]. In general, information hiding techniques can be categorized into two types, i.e., steganography and watermarking, according to the applications that information hiding is utilized for. Steganography is the art of concealing the existence of the secret message within other media such as text, image, audio and video without drawing attention of unintended users and achieving a high embedding capacity [12]. Whereas watermarking techniques are used to verify the identity and authenticity of the owner of a digital image by embedding a distinguishable data such as a signature into the host medium [16]. The work presented in this paper belongs to the steganography category, where the purpose is to conceal the existence of patient's secret data in a medical image. Section 4 reviews steganography and watermarking methods that have been utilized in hiding data in medical images. Combining steganography and cryptography aim to make it difficult for attackers to extract the sensitive information [1]. This type of integration does not embed readable text, but embeds encrypted text to add another layer of security. In recent years, there has been increased interest to integrate these two techniques such as [1,17–20].

Steganography techniques can be classified into two categories depending on the domain type; spatial and transform [12,21,22]. Spatial domain algorithms directly embed the secret data in the cover image. Transform domain algorithms on the other hand embed the data after transforming the cover image to another domain [23,24]. Transform domain algorithms usually have better robustness against attacks compared to the spatial ones, however their main limitations are the high computational cost and limited embedding capacity [25]. On the contrary, spatial domain algorithms need shorter execution time and provide a high embedding rate [22,25].

On the contrary to steganography, steganalysis aims to distinguish whether a given digital media has a secret message embedded in it. Moreover, some steganalysis methods may determine the type of steganography technique or estimate the length of the secret message [26]. In term of security measurement, steganalysis has been utilized to evaluate the efficiency of steganography techniques from a security point of view [27]. There are two categories of steganalysis techniques: blind and targeted methods. Blind steganalysis methods depend on machine learning techniques to detect the existence or absence of an embedded message in a different steganographic schemes. While targeted steganalysis methods aim to detect specific steganographic scheme [28]. In [26], it is possible to design an optimal detector scheme when the embedding technique is determined and there is an optimal statistical model of the cover medium. However, there are many theoretical and practical problems prevent the moving of steganography and steganalysis from the laboratory into the real world, such as cover selection.

In this research, we have contributed towards introducing a secure digital medical imaging information system based on a combined steganography and cryptography technique. The proposed steganography method represents an integration of two main components: (1) two different syndrome codes (STC or Hamming code) that have been utilized to enhance the embedding efficiency by minimizing the distortion function caused due to data embedding, and (2) an accurate method to identically identify sharp regions in both cover and stego images for improving the imperceptibility and to embed larger payload.

The rest of the paper is organized as follows. The basic steganographic methods are reviewed in Section 2. Section 3 introduces the Syndrome Trellis Code (STC). Section 4 presents some of the existing biomedical steganography methods. Our proposed method is described in Section 5. Experimental results to evaluate the effectiveness of the proposed method are presented in Section 6. Finally, the conclusion is given in Section 7.

The Least Significant Bit (LSB) method is the most common spatial steganography methodology [29,30]. It is capable of embedding relatively large secret data in a cover image [31]; by replacing the LSBs of the cover image pixels with the secret data bits [32,33]. Eq. (1) presents the embedding process of the LSB steganography.
                        
                           (1)
                           
                              
                                 y
                                 i
                              
                              =
                              2
                              ⌊
                              
                                 
                                    
                                       
                                          x
                                          i
                                       
                                    
                                    2
                                 
                              
                              ⌋
                              +
                              
                                 m
                                 i
                              
                           
                        
                     where x
                     
                        i
                      is the ith cover pixel value before embedding, y
                     
                        i
                      is the ith pixel value after embedding, and m
                     
                        i
                      is the ith message bit. The ⌊ ⌋ operation is the floor function.

Several examples of the LSB method have been presented [12,30,32], and improvements to the original method have been proposed, e.g. through the incorporation of Pseudo Random Number Generator (PRNG) [32,34]. Moreover, LSB matching (LSBM), also known as ±1 embedding, presents a slight improvement on LSB replacement to solve the asymmetry structure (even values are never decreased and odd values are never increased by using Eq. (1)). In LSBM, when the secret bit to be embedded does not match the LSB of the cover pixel, then a random increment or decrement is added to the cover pixel. However, LSB techniques are vulnerable to statistical attacks, which would allow unauthorized users to extract the secret message [35,36]. Various steganalytic methods have been introduced to detect the LSB methods. These approaches can be classified into four groups: (1) hypothesis testing theory detector [37], (2) structural detector [38,39], (3) weighted stego-image detector [40,41] and (4) the modern steganalysis methods that are based on extracting a set of features [42–44].

The Pixel Value Differencing (PVD) is another powerful spatial domain steganography method that embeds the secret data directly in the cover pixels. It was proposed by Wu and Tsai to provide both high embedding capacity and imperceptibility [45]. The method which was motivated by the functionality of the Human Visual System, divides and classifies the cover image into non-overlapping blocks of two adjacent pixels and each block is evaluated based on the difference between the grey values of its two pixels. A large difference value indicates that the block is in sharp region while a small difference value indicates that the block is in a smooth region. The PVD method has a high embedding capacity as it embeds more than one bit per pixel in large difference grey value blocks [46], but it cannot utilize all edge directions because it depends on a single direction [47,48]. The PVD method may also cause significant distortions to the stego image histogram [49].

The Tri-way Pixel Value Differencing (TPVD) represents an extension of the original PVD method, as it hides secret data into non-overlapping blocks of 2×2 pixels. It enlarges the embedding capacity by embedding more bits in sharp contrast areas of the image compared to smooth areas [47,50,51]. The TPVD has a higher embedding rate with lower visual quality compared to the PVD method [47].

Luo et al. [48] designed an edge adaptive LSB Matching Revisited (EALSB-MR) algorithm. The method discovers vertical and horizontal edges in an adaptive way. It searches for edge regions by calculating the difference between consecutive pixels. The selection of regions depends on the secret message length and is verified by a threshold value. The method uses horizontal and vertical edges by dividing the image into blocks then rotating each block by a random angle, however, this process could destroy the relationship between vertical/horizontal pixels [52].

The utilization of coding theory in steganography (also known as matrix embedding) that was introduced by Crandall [53] has attracted the attention of many researchers, as it proved to enhance the embedding efficiency by minimizing the amount of changes caused by the embedding process. Coding theory was adopted by Westfeld, who incorporated Hamming code in his F5 method [54]. Later on, different steganographic methods were introduced by utilizing other linear codes, such as Golay [55], BCH [56], Reed-Solomon code [57] and low density generator matrix codes [58]. Recently, a novel syndrome coding approach based on convolutional codes equipped with the Viterbi algorithm was proposed, also known as Syndrome Trellis Code (STC), to minimize the impact of the embedding process [59,60]. So far, STCs serve as the most powerful coding method for steganography. Some of the other state-of-the-art image steganography that do not introduce detectable artefacts into the statistical features include: Highly Undetectable SteGO (HUGO) [61], Wavelet Obtained Weights (WOW) [62], ASO [63], UNIversal WAvelet Relative Distortion (UNIWARD) [64] and MultiVariate Gaussian cover model (MVG) [65].

As will be explained in the next section, most of the existing medical information hiding algorithms are based on LSB, PVD or their variants, and hence inherit the limitations of these steganography techniques. In this paper, we propose an efficient information hiding for medical images that (i) combines encryption and steganography, (ii) proposes a simple, yet effective, method for accurately identifying edge pixels in both cover and stego images with the aim of minimizing visual distortions to the original medical image, (iii) utilizes either STC, which is described in the next section, or Hamming code to add an extra security level and reduce the amount of changes caused by the embedding process, and (iv) incorporates an optimization function that balances between the embedding capacity and number of bits utilized from edge locations. Accordingly, the goal of the proposed method is to come up with a scheme that can enhance the security level and resist steganalysis attacks.

Convolutional codes are introduced in [66] and considered one of the most common Error Correcting Codes (ECC). Basically, the encoder of the convolutional codes has memory and outputs depend on the current and previous inputs. A binary convolutional code C is specified by three parameters (N, K, h), where K is the number of inputs, N is the number of outputs and h is the constraint height which represents number of shift registers.

Filler et al. [59,60] proposed an efficient coding method for steganography, which is called the Syndrome-Trellis Code (STC). It aims to minimize the embedding distortion by finding the closest stego image to the cover image. The STC, which is classified as convolutional code class, represents the codeword by the parity-check matrix. In the binary Syndrome-Trellis Code, the parity-check matrix H ∈{0, 1}
                        k×n
                      of size k
                     ×
                     n is represented by placing a small sub-matrix 
                        
                           
                              
                                 ℍ
                              
                           
                           ˆ
                        
                      of size 
                        h
                        ×
                        w
                      and shifting it down by one row for a number of times. Eq. (2) shows an example of a parity-check matrix H with k
                     =4 and n
                     =8 formed from the sub-matrix 
                        
                           
                              
                                 
                                    ℍ
                                 
                              
                              ˆ
                           
                        
                        (
                        h
                        =
                        2
                        ,
                        w
                        =
                        2
                        )
                     .


                     
                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          ℍ
                                       
                                    
                                    ˆ
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                              ,
                              
                              
                                 
                                    H
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                             
                                             
                                             
                                          
                                          
                                             
                                             
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                             
                                          
                                          
                                             
                                             
                                             
                                             
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                1
                                             
                                             
                                                0
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     It is worth to mention that the constraint height h influences the embedding process speed (typically, 6≤
                     h
                     ≤15).

The Syndrome-Trellis Code is a graph compromising a number of blocks, where each block of the trellis represent one sub-matrix and has 
                        
                           2
                           h
                        
                        (
                        w
                        +
                        1
                        )
                      nodes structured in a grid of 2
                        h
                      rows and 
                        w
                        +
                        1
                      columns. A bipartite graph is created between the nodes of the two adjacent columns.

Suppose the cover vector X
                     ∈{0, 1}
                        n
                      is changed to the stego vector Y
                     ∈{0, 1}
                        n
                      after embedding a secret data vector m
                     ∈{0, 1}
                        k
                     . The extraction process of the Syndrome Code is calculated as shown in Eq. (3).
                        
                           (3)
                           
                              Ext
                              (
                              y
                              )
                              =
                              H
                              
                                 y
                                 T
                              
                           
                        
                     
                  

There are many solutions of y that can satisfy Eq. (3). The set of all possible solutions of y is called coset of m, which is identified by C(m)={z
                     ∈{0, 1}
                        n
                     
                     ∣
                     Hz
                     =
                     m}. To select the best solution of y that achieves the minimum distortion, the embedding method computes the additive distortion function for each y from the coset using Eq. (4). The additive distortion function D
                     
                        st
                      is used to identify the total effect of the embedding modifications caused by the embedding process, such that the lower value of D
                     
                        st
                     , is the less detectable by steganalysis.
                        
                           (4)
                           
                              
                                 D
                                 st
                              
                              (
                              x
                              ,
                              y
                              )
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 n
                              
                              ρ
                              (
                              
                                 x
                                 i
                              
                              ,
                              
                                 y
                                 i
                              
                              )
                           
                        
                     where ρ(x
                     
                        i
                     , y
                     
                        i
                     ) is the cost of altering x
                     
                        i
                      with y
                     
                        i
                      and d
                     
                        i
                     
                     ∈[0, ∞]. To improve the embedding efficiency, the syndrome embedding process is to select y that minimizes the embedding distortion using Eq. (5).
                        
                           (5)
                           
                              Emb
                              (
                              x
                              ,
                              m
                              )
                              =
                              arg
                              
                                 min
                                 
                                    y
                                    ∈
                                    C
                                    (
                                    m
                                    )
                                 
                              
                              D
                              (
                              x
                              ,
                              y
                              )
                           
                        
                     
                  

The embedding process is comprised of two stages: a forward and backward stages. The forward stage involves constructions of the trellis based on H
                     
                        k×n
                      and Ext(y), while the identification of the closest codeword is implemented in the backword stage.

Each path in the trellis begins in the leftmost all-zero state and extends to the right. The edges represent adding (y[i]=1) or not adding (y[i]=0) the ith column of H
                     
                        k×n
                      to the current partial syndrome. The calculation of the syndrome trellis is explained step-by-step on each path. For example, in Fig. 1
                     , the first two edges that connect the state 00 (S
                     00) from column P
                     0 with states 11 (S
                     11) and 00 (S
                     00) in the next column, correspond to adding or not adding the first column of H[.,1] to S
                     00. At the end of the first block, all paths for which the first bit of the partial syndrome does not correspond to the message bit m
                     1 are finished. Then, we get a new column P
                     1 of the trellis, which will be utilized as the starting column of the next block. The previous step is repeated at each sub-block of the matrix H. To achieve the best match between the stego and cover bits, a weight is computed to each edge in the trellis. Therefore, the path that has the minimum weight is considered the closest match between the cover and stego bits. It is easy to find this path using the backward path from the rightmost state using the edges that were not terminated and create the stego bits (y).


                     Fig. 1 represents an example to embedding process using syndrome-trellis when the secret message (m) is 1001 and the cover vectors (X) is 10011011. The path with the minimum weight using the backward step is used to produce the stego vector (Y) which is 10110011.

@&#LITERATURE REVIEW@&#

Many methods have been proposed in the area of medical image information hiding for different objectives. Al-Qershi [67] has classified medical image watermarking schemes into three groups according to their objective: authentication, data hiding, and both authentication and data hiding. Navas et al. suggested three key requirements for EPR data hiding and transmission: (1) the extraction process of EPR should be blind, (2) EPR data should be extracted with zero Bit Error Rate (BER) at the receiver side and (3) imperceptibility should not be compromised for any reason. For additional confidentiality, encryption of the EPR can also be used in EPR data hiding [68]. The required criteria of medical image information hiding algorithms are clarified by these requirements such as information hiding methods should be blind and invisible. A summary of the main medical information hiding method is presented in Table 1
                     , which indicates that most of the proposed techniques are blind and incorporate cryptography to enhance security. It can also be noticed that the methods differ in the embedding domain, embedding rate and quality of the produced images, where these factors are influenced by the objective of each of the data hiding methods.

Many of the information hiding methods use LSB, because of its simplicity and high embedding rate. However, as mentioned in the previous section the LSB technique has many weaknesses [6,24]. Among the information hiding methods that utilize LSB are the methods described in [69–73]. In 2001, Zhou et al. [69] introduced a lossless data embedding scheme for validating authenticity and integrity of mammography images. This method embeds the encrypted digital signature and patients’ information into random pixels of mamograph digital images using the LSB method. Chao et al. presented a protected information concealing procedure to generate patient Electronic Medical Records (EMR) and agent-EMR ciphertext to ensure the confidentiality of patients EMRs stored in the healthcare database. The method is based on the bipolar multiple-base transformation to permit a mixed of EPR information to be concealed inside the same mark image. This scheme guarantees that only the authorized users can gain access to the EMR [70]. However, the extraction process of the watermark needs the original image, a fact that eliminates the value of this method in practice.

Rahimi and Rabbani [74] introduced a blind watermarking technique which embeds the watermark bits in the singular value vectors within the low pass sub bands in the contourlet transform domain of DICOM images. This method automatically identifies a rectangular ROI and hides the watermark with different embedding strength in ROI and RONI, where RONI is the background region (black area around the medical information). This technique is tested using CT and MR images. However, the embedding rate of this method is limited because of the way used to select ROI.

Ali et al. [71] proposed a spatial medical image watermarking technique to provide the integrity of medical image and protect the confidentiality of patient's information during transmission. The digital signature of hospital data is generated using Secure Hash Algorithm (SHA1), then it is concatenated to the patient information. The secret data is embedded in edge pixels using the LSB method. The quality of the watermarked medical images is acceptable but according to [75] the technique is very fragile and provides very little security.

Memon et al. developed a hybrid watermarking scheme which hides watermark in RONI [76]. In this scheme, the medical image is segmented into ROI and RONI using a Vector Quantization technique. After that, a fragile watermark is hidden into the LSBs of ROI. RONI is distributed into blocks of size N
                     ×
                     N and then a location map is generated. A watermark is embedded in the RONI coefficients. The time complexity of this method is quite high because of the calculations required to generate the location map.

Navas et al. [77] introduced a blind and reversible data hiding scheme for telemedicine applications that depends on Integer Wavelet Transform (IWT). The ROI is manually identified as a rectangle shape. In order to obviate misdiagnosis, encrypted EPR is embedded in RONI and the ROI is stored without any noise. However, this method can hide at most 3400 characters into a cover image of size 512×512 and the computational cost is high.

In [72], a spatial information hiding method for medical images is presented. To improve the security of the method, patient information and Electrocardiogram (ECG) signals are encrypted before concealing inside the cover image using the LSB steganography. Bremnavas et al. introduced a method to hide patient's information in text form and image form into the cover images using two different algorithms. The medical details record is converted to UTF format which is then embedded using the LSB steganography. The medical image is again encrypted using chaos algorithms [78].

The main limitation of the previously mentioned methods is the direct implementation of LSB steganography, which is known for its vulnerability to some steganalysis methods.

Lou et al. [79] introduced a lossless multiple-layer spatial data hiding scheme for medical image based on pixel-value differencing expansion. This method utilized a reduced difference expansion technique to conceal the bit stream in the LSBs of the expanded differences to provide a high embedding rate and maintain good quality stego images.

In [80], a multi secure and robustness steganography technique for medical image is introduced to protect MRI images. The Integer Wavelet Transform (IWT) is performed to embed the secret data bits into a single container image. A dummy container was acquired by applying flip left operation on the container image. Then Arnold transform was performed on the patient's medical diagnosis image to get a scrambled secret image. The scrambled secret image was hidden into the dummy container and Inverse IWT was applied to get the stego image. The main limitation of this method is the high computational cost.

Nambakhsh et al. [81] presented a contextual double digital watermarking technique for medical images. The ECG and patient ID are embedded as a double watermark into Positran Emission Tomography (PET) images. Embedding locations are detected using the texture feature extraction method of PET using multi-resolution wavelet decomposition. However, this method does not differentiate between ROI and RONI when embedding the secret data.

In [33], a spatial steganography method for hiding patient's confidential information into a medical image is introduced. It begins with manually identifying an irregular ROI. The PVD is used to identify high contrast regions in the RONI. Also, an embedding process is accomplished using a Hamming code to embed 3 secret message bits into 4 bits of the cover image. The main limitations of this method are decreased embedding capacity by embedding 2bpp in sharp regions as well as smooth regions and unable to detect all edge directions because it concentrates on a horizontal direction.

Tian et al. [82] introduced a reversible data hiding method based on difference expansion (DE) and have been recently extended in [79,83,67] for medical images. Tian's method divides the cover image into non-overlapping blocks of two consecutive pixels. The secret bits are embedded using difference expansion of each block. Differences are classified into three groups. Secret data is embedded only into two groups. Location map is required to specify which pairs are used. The difference expansion method has an embedding capacity of 0.5 bits per pixel. The limitation of the difference expansion method is the limited embedding rate resulting from embedding the compressed location map in the cover image.

In order to overcome some of the limitations of the existing medical image information hiding methods such as limited embedding rate and high computational cost, we propose in this paper a new data hiding technique that aims at achieving a good balance between embedding capacity and quality of the stego image. In our scheme both cryptography and steganography are combined to protect EPR. The next section presents our proposed method, which embeds the encrypted EPR into RONI to preserve the ROI from any modifications.

@&#PROPOSED METHOD@&#

Since the Human Visual System (HVS) is less sensitive to modification in sharp image regions compared to uniform regions, we propose to hide the EPR into sharp regions by utilizing a simple edge detection method. In order to maintain good quality of the generated stego images a syndrome code is utilized. Moreover, to add a second layer of security, we introduce an efficient and simple encryption method to conceal the meaning of EPR.

The flow diagram of our proposed method is illustrated in Fig. 2
                     . The proposed method begins with encrypting the secret data using the symmetric encryption algorithm, then embeds the ciphertext into the cover image. To retrieve the secret data, the encrypted data is extracted from the stego image using the extraction procedure. Finally, the decryption procedure is utilized to retrieve the original secret data.

The proposed method comprises five main procedures: encryption, edge detection, embedding, extraction, and decryption.

To enhance the confidentiality of the patient information records, secret data is encrypted using the symmetric encryption approach before embedding in the medical image. However, the existing encryption methods have many limitation such as high computational cost. Therefore, we present a new and simple encryption approach which comprises three main stages: first round permutation, substitution and second round permutation. Permutation operation is a core element of cryptography methods that aim to generate shuffled order of the plaintext. While the substitution operation is the backbone of almost every cryptography method. It seeks to make the statistical relationship between the plaintext and ciphertext as complex as possible.

The implementation of this process is explained in the following steps:


                        
                           Algorithm 1
                           Encryption process.

Inputs: Plaintext (PT), key1 (X), key2 (Y), key3 (Z).

Output: Ciphertext (CT).
                                 
                                    (1)
                                    
                                       Permutation 1st Round (T
                                       1
                                       ): The first round permutation is illustrated in Fig. 3(a) with 25 characters organized into a 5×5 matrix. Each entry in the matrix represent a character index within a 25 data block. These indices are written in spiral order, then read column by column as shown in Fig. 3a.


                                       Substitution round: We present a simple mathematical function to implement a poly-alphabetic substitution cipher, where each ASCII code is mapped to many ASCII code symbols using Eq. (6).
                                          
                                             (6)
                                             
                                                CT
                                                =
                                                [
                                                (
                                                (
                                                PT
                                                −
                                                X
                                                )
                                                ×
                                                Y
                                                )
                                                mod
                                                256
                                                ]
                                                ⊕
                                                Z
                                             
                                          
                                       where CT is the ciphertext, PT is the plaintext, X is a group of four values ranging from 1 to 255, repeated as many times as necessary, Y is the second key.

Y value is between 1 and 255, such that Y and 256 is relatively prime, i.e. greatest common divisor (Y, 256)=1. Finally, Z is a sequence of binary digits that is extracted from the cover pixels. To reduce the shared information between sender and receiver, key values are derived from the cover image.


                                       Permutation 2nd round (T
                                       2
                                       ): The order of the output from the substitution stage are rearranged using Box-2 as shown in Fig. 3
                                       b. For example, we want to encrypt the following secret data “There is a negative sign.”. We select four pixels from specific locations to be assigned to the first key (X), and Y = 3. An illustration of the data encryption process is shown in Table 2
                                       .

It is well known that embedding data in sharp contrast areas of an image is less noticeable by the human eye compared to uniform areas [45,84]. Consequently, patient's information is embedded in edge areas in order to produce a high quality stego image. If adopting one of the existing edge detection methods to identify and embed in the edge regions, then the generated stego image will be slightly different from the original cover image. Thus, when trying to perform edge detection on the stego image to identify the edges (or produce the edge image) for the purpose of extracting the message, some of the identified edges will not exactly match the original ones, and hence, there is no guarantee that all pixels used to extract the message will be identical to those used in embedding it. Therefore, we propose a simple new algorithm to identify the edge regions on the cover image, such that the two edge images generated using the cover and stego images are identical. This will enable the correct extraction of the concealed message from the stego image. The algorithm starts by dividing the image into non-overlapping blocks that would be individually evaluated and then categorized as either edge or non-edge blocks.


                        
                           Algorithm 2
                           Edge detection.

Inputs: Cover image (C), block size (n
                              ×
                              n, which is expected here to be 3×3), threshold value (Th)

Output: edge image with edge magnitude (E)
                                 
                                    Step 1:
                                    Divide the image C into non-overlapping blocks of the size n
                                       ×
                                       n. Fig. 4
                                        shows a 3×3 block.

Compute the absolute mean difference between the left and right columns of the block (magnitude of vertical edge (VE)). Repeat for horizontal (HE), first diagonal (D1) and second diagonal (D2) edges. Edge magnitude can be computed using Eq. (7).


                                       
                                          
                                             (7)
                                             
                                                
                                                   
                                                      
                                                         HE
                                                         =
                                                         avg
                                                         |
                                                         
                                                            (
                                                            [
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ,
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ]
                                                            −
                                                            [
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ,
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ]
                                                            )
                                                         
                                                         |
                                                      
                                                   
                                                   
                                                      
                                                         VE
                                                         =
                                                         avg
                                                         |
                                                         
                                                            (
                                                            [
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ,
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ]
                                                            −
                                                            [
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ,
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            ]
                                                            )
                                                         
                                                         |
                                                      
                                                   
                                                   
                                                      
                                                         D
                                                         1
                                                         =
                                                         avg
                                                         |
                                                         
                                                            (
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            −
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            )
                                                         
                                                         |
                                                      
                                                   
                                                   
                                                      
                                                         D
                                                         2
                                                         =
                                                         avg
                                                         |
                                                         
                                                            (
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  −
                                                                  1
                                                                  ,
                                                                  j
                                                                  −
                                                                  1
                                                                  )
                                                               
                                                            
                                                            −
                                                            
                                                               P
                                                               
                                                                  (
                                                                  i
                                                                  +
                                                                  1
                                                                  ,
                                                                  j
                                                                  +
                                                                  1
                                                                  )
                                                               
                                                            
                                                            )
                                                         
                                                         |
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    

Find the maximum of the four values and assign it to e, which is computed using Eq. (8). If e
                                       >
                                       Th, then the block is considered to be an edge block, otherwise it is not an edge block. Construct E that contains the calculated e value of each of the edge blocks (which reflects the edge strength), and 0 for non-edge blocks. A binary edge image can also be constructed, which contains 1 for edge blocks and 0 for non-edge blocks.
                                          
                                             (8)
                                             
                                                e
                                                =
                                                max
                                                {
                                                HE
                                                ,
                                                VE
                                                ,
                                                D
                                                1
                                                ,
                                                D
                                                2
                                                }
                                             
                                          
                                       
                                    

For the edge blocks, embed in the white 5 pixels, P
                                       (i−1,j), P
                                       (i,j−1), P
                                       (i,j), P
                                       (i,j+1), P
                                       (i+1,j), as shown in Fig. 4.

The flow diagram of the embedding procedure is illustrated in Fig. 5
                        . The embedding procedure starts by dividing the cover image into ROI and RONI. To identify the edge region, a high value is initially assigned to the threshold variable, which is then modified based on the message length and the number of pixels needed. A STC is used to encode the secret data and then embed it into the identified edge pixels. The implementation of the embedding process is explained in the following steps.


                        
                           Algorithm 3
                           The embedding procedure.
                                 
                                    (1)
                                    
                                       Identification of ROI and RONI: Medical image usually contains a particular region that is referred to as the Region of Interest (ROI). It is quite important to protect this region from any modifications in order not to compromise the diagnosis. A rectangular or ellipse ROI is identified by the user manually using four-element vector that specifies its initial coordinates and size. After the identification of ROI, the medical image is converted into a binary image, where pixels that have a value of 1 belong to ROI, while those that have a value of 0 belong to RONI, as shown in Fig. 6
                                       . The secret data is embedded only in edge blocks of RONI to avoid making any change to the ROI. The extraction process requires ROI coordinates to identify the embedding region, and therefore, the coordinates of ROI are concatenated with the secret message to form the data that will be embedded.


                                       Identification of edges: In order to increase the embedding rate, n LSBs from each edge pixel are used in embedding. Procedure 1 (Edge
                                       
                                       Detection) is applied to detect edge regions. The edge mean value of each block determines the value of n to be utilized from each pixel as shown in Table 3
                                       . Accordingly, a high mean value which represents strong edges will carry more bits than a lower mean value. Based on this, we may not need to embed in all blocks of the RONI. The magnitude of each block is compared to the initial threshold value. However, to reduce the computational cost of edge detection algorithm, initial threshold value is set to a value of four. Then, edge blocks are classified into four groups according to the magnitude value (e) as shown in Table 3. According to Eq. (9), three secret bits are embedded into four bits of the cover image.


                                       
                                          
                                             (9)
                                             
                                                (
                                                4
                                                ×
                                                
                                                   Message
                                                   
                                                   length
                                                
                                                
                                                /
                                                3
                                                )
                                                ≤
                                                
                                                   Number
                                                   
                                                   of
                                                   
                                                   edge
                                                   
                                                   bits
                                                
                                             
                                          
                                       where edge bits are the utilized n LSBs from each edge pixel as shown in Table 3.


                                       Comparison between ROI and edge region locations: As the ROI coordinates are embedded in the initial edge blocks, a comparison between the first/last row of the ROI with the first/last edge regions is required to ensure the initial edge blocks are excluded from ROI pixels. The comparison is explained in the following cases:
                                          
                                             •
                                             Case 1: If the location of the first row of the edge region is below than that of the first row of ROI, the secret data is embedded from top to bottom of the cover image, and the cover pixel C(1, 1) is changed to even value to determine the extraction process direction.

Case 2: If the location of the first row of ROI is below than or equal to the first row of edge region and the location of the last row of ROI is below than that of the last row of the edge region, the secret data is embedded from bottom to top of the cover image, and the cover pixel C(1, 1) is changed to odd value to determine the extraction process direction.

Case 3: If the top and bottom rows of the edge regions are completely included in the ROI, return to step 1 of the embedding process to re-identify the ROI.

In case 3, steps 1–2 will be repeated, otherwise we proceed to step 4. The first pixel C
                                                (1,1) must be modified so that it indicates the direction of the extraction process. Extract the secret message from top to bottom of the stego image if the C
                                                (1,1) pixel is even. Otherwise, extraction process will start from bottom to top.


                                       Classification of edge pixels: To improve the embedding capacity, RONI pixels are classified into four groups ([4–7], [8–15], [16–63], and [64–255]) based on the magnitude value, e, of their corresponding edge blocks. Thus, more bits can be embedded in sharp edges compared to less strong edges. Another advantage of this approach is that embedding different number of bits per pixel may improve the security of the message.


                                       Linear cost function: Embedding capacity and image quality are two key factors that should be considered when implementing a steganography method. However, some of these factors are conflicting. For example, improving the image quality generally implies decreasing the embedding capacity. We propose here an optimization function that balances between the embedding capacity (secret message length) and number of bits utilized from each group. For example, if the message length is less than the number of pixels that belong to Group 4, then we utilize only 1-bit from Group 4 instead of using 3-bits to improve the imperceptibility. In other words, If we utilize 3 bits from each pixel in Group 4, then the difference between the cover and stego pixels will be in the range [0–7] according to the weight of each digit in the binary system, where the first LSB is of weight 20, the second LSB is of weight 21, and the third LSB is of weight 22.


                                       
                                          
                                             (10)
                                             
                                                
                                                   Number
                                                   
                                                   of
                                                   
                                                   edge
                                                   
                                                   bits
                                                
                                                =
                                                (
                                                a
                                                ×
                                                
                                                   G
                                                   4
                                                
                                                   
                                                pixels
                                                )
                                                +
                                                (
                                                b
                                                ×
                                                
                                                   G
                                                   3
                                                
                                                   
                                                pixels
                                                )
                                                +
                                                (
                                                c
                                                ×
                                                
                                                   G
                                                   2
                                                
                                                   
                                                pixels
                                                )
                                                +
                                                (
                                                d
                                                ×
                                                
                                                   G
                                                   1
                                                
                                                   
                                                pixels
                                                )
                                             
                                          
                                       where a, b, c and d are integer numbers ranging from 0 to n.


                                       Embedding function: To modify the cover bits according to the message bits, either Hamming or Syndrome-Trellis Codes have been utilized to find the stego bits. Those two coding methods have been considered as one of them is simple and fast while the other is more sophisticated and computationally more expensive.
                                          
                                             (a)
                                             
                                                Embedding using a (7,4) Hamming code: Hamming code is a linear error-correcting codes that detects and corrects one-bit error at the receiver. To fulfil this objective, extra bits (parity check bits) should be added to the original data before transmission to form a codeword. Encoding 4 bits using (7, 4) Hamming code requires 3 additional parity check bits; i.e. the original 4 bits are expanded to 7 bits. Fig. 7
                                                b indicates the relationship between original and parity check bits, where b
                                                   i
                                                 refers to an original bit and P
                                                   i
                                                 to a parity check bit. Parity check bits P
                                                1, P
                                                2, and P
                                                3 are computed using Eq. (11).


                                                
                                                   
                                                      (11)
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     P
                                                                     1
                                                                  
                                                                  =
                                                                  
                                                                     b
                                                                     1
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     2
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     4
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     P
                                                                     2
                                                                  
                                                                  =
                                                                  
                                                                     b
                                                                     1
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     3
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     4
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     P
                                                                     3
                                                                  
                                                                  =
                                                                  
                                                                     b
                                                                     2
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     3
                                                                  
                                                                  ⊕
                                                                  
                                                                     b
                                                                     4
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             

Decoding procedure aims to detect and correct errors, and then retrieve the original bits. For error detection and error correction, a syndrome vector (SR) is computed by multiplying the parity check matrix and the received codeword using Eq. (12), where the multiplication operation performed using a bitwise AND between two bits followed by an XOR between the terms. If the syndrome vector is not equal to zero, then there exist an error in the received codeword and the decimal value of the syndrome vector indicates error location in the codeword. According to the codeword arrangement, the variable in the fourth digit is inverted to its complement.
                                                   
                                                      (12)
                                                      
                                                         SR
                                                         =
                                                         H
                                                         ×
                                                         
                                                            W
                                                            T
                                                         
                                                      
                                                   
                                                where
                                                   
                                                      
                                                         H
                                                         =
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              0
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                            2
                                                         
                                                      
                                                   
                                                
                                             

In our proposed method, Hamming code is utilized to minimize the number of bits that need to be modified in the stego image. In this stage, Hamming code is used to hide each 3 bits of the secret data (m
                                                1, m
                                                2 and m
                                                3) into 4 cover bits (b
                                                1, b
                                                2, b
                                                3 and b
                                                4) that come from two embedding pixels (selected as described in the previous step). A codeword, W, is formed by arranging the seven bits in the following order: W
                                                =[m
                                                1, m
                                                2, b
                                                1, m
                                                3, b
                                                2, b
                                                3, b
                                                4]. The parity check matrix and the codeword are multiplied to determine which of the cover pixels need to be modified, as shown in Eq. (12). SR indicates the bits that need to be modified based on the codeword W. If SR is equal to the 3rd, 5th, 6th or 7th column of H, then one bit is changed from the cover pixels. For example, when SR
                                                =[0, 1, 1] then b
                                                1 is changed. If SR is equal to the 1st, 2nd or 4th column of H, then two bits of cover pixels are changed. For example, if SR
                                                =[0, 0, 1] then b
                                                3 and b
                                                4 are changed. If b
                                                1, b
                                                2 or b
                                                4 are converted to its complement, then m
                                                2 or m
                                                3 are modified while they do not require any modification. So, we have selected two cover bits to change given that one of them should be used to compute m
                                                1, m
                                                2, and m
                                                3, and the other cover bit is used to compute m
                                                2 and m
                                                3. If SR
                                                =[0, 1, 0] then b
                                                2 and b
                                                4 are changed. Finally, if SR
                                                =[0, 1, 1] then b
                                                1 and b
                                                4 are changed. An example of embedding 3 secret bits is shown in Fig. 8
                                                .


                                                Embedding using Syndrome-Trellis Code: We utilize the Syndrome-Trellis Coding (STC) [59,60] for data hiding using Eq. (5). As described in Section 3, the framework of steganography based on STC, the additive distortion function (D
                                                
                                                   st
                                                ) is defined to choose the codeword having the lowest distortion.


                                       Update the stego image: Modify the stego image using Least Significant Bit Matching (LSBM) as defined in the following embedding function:


                                       
                                          
                                             (13)
                                             
                                                
                                                   Sb
                                                   i
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     2
                                                                     
                                                                        pos
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                                  ,
                                                               
                                                               
                                                                  if
                                                                     
                                                                  
                                                                     m
                                                                     i
                                                                  
                                                                  ≠
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  
                                                                  and
                                                                  
                                                                  (
                                                                  k
                                                                  >
                                                                  0
                                                                  
                                                                  or
                                                                  
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  =
                                                                  2
                                                                  ×
                                                                  (
                                                                  pos
                                                                  −
                                                                  1
                                                                  )
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  −
                                                                  
                                                                     2
                                                                     
                                                                        pos
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                                  ,
                                                               
                                                               
                                                                  if
                                                                     
                                                                  
                                                                     m
                                                                     i
                                                                  
                                                                  ≠
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  
                                                                  and
                                                                  
                                                                  (
                                                                  k
                                                                  <
                                                                  0
                                                                  
                                                                  or
                                                                  
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  =
                                                                  255
                                                                  −
                                                                  2
                                                                  ×
                                                                  (
                                                                  pos
                                                                  −
                                                                  1
                                                                  )
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                                  ,
                                                               
                                                               
                                                                  if
                                                                     
                                                                  
                                                                     m
                                                                     i
                                                                  
                                                                  =
                                                                  
                                                                     b
                                                                     i
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       where Sb
                                       
                                          i
                                        is the ith stego bit obtained by using LSBM, b
                                       
                                          i
                                        is the modified cover bit produced from step 6, k is the random variable with uniform distribution on 
                                          
                                             
                                                +
                                                1
                                                ,
                                                −
                                                1
                                             
                                          
                                        and pos the right most ith LSBs of b
                                       
                                          i
                                        ranging from 1 to 3. Note that LSBM has been chosen over LSB replacement, as according to [85] it proved to be more efficient.


                        
                           Algorithm 4
                           The extraction procedure.
                                 
                                    (1)
                                    
                                       Extraction of the shared information: Identify the extraction direction from the first pixel S(1, 1).


                                       Identification of edges: Identify edge regions in the stego image using procedure 1 (Edge
                                       
                                       Detection) and the extracted threshold value.


                                       Identification of ROI and RONI: To divide the stego image into ROI and RONI, coordinates of ROI should be extracted from the initial edge blocks using the following XOR operations:
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            m
                                                            1
                                                         
                                                         =
                                                         
                                                            b
                                                            1
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            2
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            4
                                                         
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            m
                                                            2
                                                         
                                                         =
                                                         
                                                            b
                                                            1
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            3
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            4
                                                         
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            m
                                                            3
                                                         
                                                         =
                                                         
                                                            b
                                                            2
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            3
                                                         
                                                         ′
                                                         ⊕
                                                         
                                                            b
                                                            4
                                                         
                                                         ′
                                                      
                                                   
                                                
                                             
                                          
                                       where (b
                                       1′, b
                                       2′, b
                                       3′
                                       and
                                       
                                       b
                                       4′) are the stego bits and (m
                                       1, m
                                       2
                                       
                                       and
                                       
                                       m
                                       3) are the secret bits.


                                       Classification of edge region: RONI pixels are classified into groups based on the edge mean value of each block as shown in Table 3.


                                       Linear cost function: Apply the cost function to determine how many bits are used from each group.


                                       Secret message extraction: extract the secret data bits (m
                                       1, m
                                       2
                                       
                                       and
                                       
                                       m
                                       3) using the previous XOR operations when the embedding function applied the Hamming code. Otherwise, if the STC was performed, then extract the secret message using Eq. (3).


                        
                           Algorithm 5
                           The decryption procedure.
                                 
                                    (1)
                                    
                                       Inverse permutation of round 2 (
                                       
                                          
                                             T
                                             2
                                             
                                                −
                                                1
                                             
                                          
                                       
                                       ): Apply the inverse permutation (T−1) on the extracted ciphertext to get the original order. The inverse permutation is defined in the following sequence.


                                       
                                          
                                             T
                                             2
                                             
                                                −
                                                1
                                             
                                          
                                        = [25, 24, 10, 11, 9, 23, 22, 8, 2, 12, 13, 3, 1, 7, 21, 20, 6, 4, 14, 15, 5, 19, 18, 16, 17].


                                       Inverse substitution: An inverse substitution function should be applied to replace the ciphertext with the original text (plaintext). The corresponding decryption function is defined in Eq. (14).
                                          
                                             (14)
                                             
                                                PT
                                                =
                                                (
                                                [
                                                (
                                                CT
                                                ⊕
                                                Z
                                                )
                                                ×
                                                
                                                   Y
                                                   
                                                      −
                                                      1
                                                   
                                                
                                                ]
                                                +
                                                X
                                                )
                                                
                                                mod
                                                
                                                256
                                             
                                          
                                       where CT is the ciphertext, PT is the plaintext, X is a group of four values ranging from 1 to 255, repeated as many times as necessary, and Y
                                       −1 is the multiplicative inverse of the second key (Y), in the range 1–255, such that Y
                                       .
                                       Y
                                       −1
                                       ≡1
                                       mod
                                       256.


                                       Inverse Permutation of Round 1 (
                                       
                                          
                                             T
                                             1
                                             
                                                −
                                                1
                                             
                                          
                                       
                                       ): Finally, inverse permutation of round 1 is performed to get the correct order of the plaintext. The inverse permutation is defined in the following sequence.
                                          
                                             
                                                
                                                   T
                                                   1
                                                   
                                                      −
                                                      1
                                                   
                                                
                                                =
                                                [
                                                5
                                                ,
                                                6
                                                ,
                                                15
                                                ,
                                                16
                                                ,
                                                25
                                                ,
                                                24
                                                ,
                                                23
                                                ,
                                                22
                                                ,
                                                21
                                                ,
                                                20
                                                ,
                                                11
                                                ,
                                                10
                                                ,
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                ,
                                                4
                                                ,
                                                7
                                                ,
                                                14
                                                ,
                                                17
                                                ,
                                                18
                                                ,
                                                19
                                                ,
                                                12
                                                ,
                                                9
                                                ,
                                                8
                                                ,
                                                13
                                                ]
                                                .
                                             
                                          
                                       
                                    

In this section, the proposed method is evaluated using 100 MRI cover images (all of them are grey level of size 255×255). Fig. 9
                     a and b represents one of the cover images used in the experiment and its ROI. Fig. 9c shows the corresponding histogram of the cover image. To evaluate the performance of the proposed scheme, the length of the secret message (data capacity) is used as one of the evaluation criteria, which is defined as the amount of bits that can be embedded into the cover image. The embedding capacity is computed using Eq. (15).


                     
                        
                           (15)
                           
                              E
                              =
                              
                                 K
                                 WH
                              
                              
                              (
                              bpp
                              )
                           
                        
                     where K is the number of data message bits, while W and H are the width and height of the cover image respectively (both cover and stego images are of the same size with W
                     =
                     H
                     =255).

There is no unique method to measure imperceptibility of steganography methods. One of the commonly used measures of imperceptibility is the Peak Signal-to-Noise Ratio (PSNR) between the cover and stego images, which is calculated as shown in Eq. (16).
                           
                              (16)
                              
                                 PSNR
                                 =
                                 10
                                 
                                    log
                                    10
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   255
                                                   2
                                                
                                             
                                             MSE
                                          
                                       
                                    
                                 
                                 
                                 (
                                 dB
                                 )
                              
                           
                        where MSE is the mean square error between cover and stego images, which is defined as:
                           
                              (17)
                              
                                 MSE
                                 =
                                 
                                    1
                                    WH
                                 
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    W
                                 
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    H
                                 
                                 
                                    
                                       (
                                       
                                          c
                                          ij
                                       
                                       −
                                       
                                          s
                                          ij
                                       
                                       )
                                    
                                    2
                                 
                              
                           
                        where c
                        
                           ij
                         and s
                        
                           ij
                         are the grey values of pixel (i, j) of the cover and stego images respectively.

The weighted Peak signal-to-Noise Ratio (wPSNR) is an alternate measurement of imperceptibility. It utilizes an extra parameter called Noise Visibility function (NVF). wPSNR is roughly equivalent to PSNR for flat areas because NVF is close to one in smooth regions. However, for regions with sharp contrasts, wPSNR is higher than PSNR, because NVF is close to zero for complex regions. Hence, wPSNR attempts to reflect how the Human Visual System (HVS) perceives images.
                           
                              (18)
                              
                                 wPSNR
                                 =
                                 10
                                 
                                    log
                                    10
                                 
                                 
                                    
                                       
                                          
                                             
                                                max
                                                
                                                   
                                                      (
                                                      C
                                                      )
                                                   
                                                   2
                                                
                                             
                                             
                                                ∥
                                                NVF
                                                (
                                                S
                                                −
                                                C
                                                )
                                                
                                                   ∥
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                 (
                                 dB
                                 )
                              
                           
                        The average difference is a simple and popular image quality evaluation criterion. It is computed by averaging the absolute difference between the cover and stego images, which is calculated as shown in Eq. (19).
                           
                              (19)
                              
                                 
                                    Average
                                    
                                    difference
                                 
                                 =
                                 
                                    1
                                    WH
                                 
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    W
                                 
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    H
                                 
                                 |
                                 
                                    c
                                    ij
                                 
                                 −
                                 
                                    s
                                    ij
                                 
                                 |
                              
                           
                        
                     

The quality of the embedding process is often evaluated by the embedding efficiency (e). It represents the number of embedded bits per embedding change (introduced change), where a maximized embedding efficiency value is related to a minimized embedding distortion. It can be determined by e
                        =
                        K/d, where K is the length of the secret message and d is the number of bit changes [59,60]..

The stego images produced with embedding rates of 5%, 20% and 40% using the proposed method using STC are shown in Fig. 10
                        a–c. One can notice that it is difficult for the human eye to differentiate between the original and stego images. Moreover, the histogram of the stego images (represented in Fig. 10d–f) are quite similar to that of the cover images. It is important to mention that for a 255×255 image, which contains 65,025 pixels, an embedding rate of 40% means embedding (40/100)*65,025=26,010 bits, which is equivalent to 3715 ASCII characters. For a 512×512 image, an embedding rate of 40% means embedding 104,757 bits or 14,979 ASCII characters.

In order to have a comprehensive comparison with the proposed method, we implemented PVD, TPVD, edge adaptive PVD and edge adaptive n-LSBs methods. In edge adaptive PVD, we embed the secret data in the sharp regions first based on the difference value between each two consecutive pixels (without overlap). In edge adaptive n-LSBs method, we expand LSB steganography method and used our edge detection method to discover the sharpest regions for the embedding process. It is similar to our embedding method excluding the coding algorithm and cost function. The visual quality performance results are shown in Table 4
                        . It is clear that the proposed method using STC obtained the best image quality in all image metric measurements compared to the other methods, followed by the Hamming code implementation of the proposed algorithm.

Similar to other measures, the average difference increases with the increase of the embedding rate, but for our proposed method using STC an average difference of 0.21 is obtained using an embedding rate of 50%. The average difference for the Hamming code is found to be the second best, with a maximum of 0.323 for 50% embedding rate. These results indicate that the difference between the cover and stego images obtained using our proposed method is generally small. The proposed method and the edge adaptive n-LSB results confirm the effectiveness role of using the coding theory, which aims to reduce the difference between the cover and stego images.

A graphical representation of the PSNR and wPSNR values are shown in Fig. 11
                        a and b respectively. Those two figures demonstrate the superior performance of our proposed method using STC, and to a slightly less degree using Hamming code, in comparison to the other methods with PSNR values greater than 50dB and wPSNR values greater than 55dB, which means the hidden data is undetectable according to the human visual perception.


                        Table 5
                         presents the quality of the stego images using different state-of-the-art 1bpp steganography methods using STC with embedding rates ranging from 5% to 30%. It is observed that, the proposed 1bpp method obtained the best image quality compared to EALSB-MR [48] and Bassil [86] since it utilizes the trellis code to reduce the difference between the cover and stego images.


                        Table 6
                         shows the embedding efficiency of the proposed algorithm for the two coding techniques of STC and Hamming code. The results indicate that STC achieves a better embedding efficiency (causes less modifications to the cover image) compared to the Hamming code. On the other hand, it is worth mentioning that due to the shift operations, the STC has noticeably higher computational time compared to the Hamming code. Fig. 12
                         illustrates the computational time and PSNR values of the STC and Hamming code for various embedding rates. According to [59,60], the constraint height is usually ranged between 6 to 15, and therefore, we chose a value of 12 in implementing the STC. The figure shows that the difference in PSNR between the two methods gets smaller for higher embedding rates (25% or more), whereas the difference in computational time gets bigger, where it exponentially increases with the increase of the embedding rate for the STC method. Therefore, based on the length of the message to be embedded, i.e., embedding rate, and the need for computational time saving, the choice between the STC and Hamming code implementations can be left to the user.

The effect of varying the size of ROI has also been investigated for different embedding rates, as shown in Fig. 13
                        . As explained earlier, our proposed method demonstrated a high embedding capacity with a very good visual quality in terms of PSNR and wPSNR. However, as the ROI size gets bigger, the RONI size gets smaller, and hence the number of bits that can be embedded gets smaller. Even if the message can be fully embedded when using a bigger ROI, the algorithm will need to embed in less sharp regions, which will have an impact on PSNR, wPSNR and MSE. For an acceptable visual quality of our MRI dataset, the maximum possible message length which may be embedded around a particular ROI was determined and analyzed, for cover images of size 255×255 as shown in Table 7
                        . From this evaluation, we observed the following: an ROI of size 105×105 that is covering 17% of the original image size was capable of carrying a message length of up to 32,512 bits, whereas for a bigger ROI (165×165) covering 41%, the message length reduced to only 19,507 bits.

In this section, the proposed method is evaluated using the Li-110D blind steganalysis method [87], which is one of the most efficient steganalyzers used for detecting textural features in spatial domain steganography. The Li-110D is effective in detecting stochastic textures in a fine scale such as the stego images produced by some adaptive steganographic algorithms.

The Li-110D method [87] extracts features from the normalized histogram of the local linear transform coefficients of the image. These features aim to detect particular alternations of the local texture before and after the embedding process based on the fact that steganography introduces more stochastic textures to the stego images in a fine scale. Since our medical data set is small and not enough for the Li-110D method to produce accurate results, the security of the proposed method has been tested on the BOWS2 database [88], which contains 10,000 greyscale natural images of size 512×512 without taking into consideration ROI. It then trains a classifier to differentiate between stego and cover images. In the experiments, stego images are created using the proposed method with different embedding rates ranging from 5% to 50%. Then image features are extracted from the cover and stego images. An SVM (Support Vector Machine) classifier is utilized to train these features to learn the difference in features produced by data embedding. Testing is done in two fold cross-validation i.e., half of the cover and stego images are selected randomly for training, and the remaining images are used for testing. This test is repeated thirty times, and the averages of the obtained accuracy values are shown in Table 8
                        . It can be noticed that our proposed method using STC outperforms the other methods for most of the embedding rates. When the embedding rate increased the difference between the cover and stego images increased, and consequently the error rate of the SVM classification decreased. Since there are only two classes and they have the same number of images in our problem, an error rate of 50% means random guess. The table shows that our proposed method had error rates between 49% and 59% for embedding rates that are 30% and less. This range of error rate indicates that it is hard to make conclusive judgement about the existence of secret data in images. Even when the embedding rate is as high as 50%, the error rate was still quite high (35%) by using STC and (33%) by using Hamming code, which proves the efficiency of our proposed information hiding method.


                        Table 9
                         shows a comparison with an existing medical information hiding methods (Navas [77], Bremnavas [78], Thiyagarajan [2], Al-Dmour [33]), in term of embedding process, embedding capacity and encryption process. The extraction process of all methods is classified as blind, i.e., does not need the cover image to extract the secret data. The efficiency of the encryption methods depends on three factors: key generation, substitution and transposition operations. In [77] and [78], mono-alphabet substitution operation was utilized to encrypt the EPR, which replaces each plaintext letter with one ciphertext letter. While our encryption method performs poly-alphabet substitution operation by representing each plaintext letter with multiple cipher letters. In terms of information hiding technique evaluation, the proposed method provides a high embedding rate compared to the other methods, and hence can be used to efficiently embed large amount of secret data.

Similar to other spatial steganography and many of the transform ones, the proposed algorithm is fragile to changes in the stego image (change in size, rotation, etc). However, even in such cases, the hidden information will not be revealed to the intruder, while the original image and EPR data can always be retrieved from the source.

The transposition process transforms a plaintext by arranging the positions of the secret data digits of the original text without changing the identities of the digits. Let L represents the length of plaintext/ciphertext and K represents all possible permutations of {1, 2, …, L}. The random key matrix which is used in Fig. 3a and b, is a 5×5 matrix. There can be 25!=1.55
                        e
                        +25 possible permutations for each stage. If the key is not known to the attacker, the brute force attack has to do a comprehensive search among these possibilities and it requires a large computational cost to find the correct order. Moreover, the hacker has to start in the reverse order to retrieve the original plaintext and the encryption process replaces the digits, where the ciphertext will not have exactly the same letter frequency distribution (the ciphertext is not vulnerable to the frequency distribution analysis methods).

The poly-alphabetic substitution cipher replaces each plaintext letter by a number of ciphertext letters. In our process, we have three different keys (x, y and z), and therefore the number of possible keys is [(256×51)−1)×2
                           S
                        ], where S is the length of the secret data in the binary system. For example, if the secret data length is 500byte, then the key space is 1.72
                        e
                        +1208.

Finally, the XOR operation is considered unconditionally secure since the plaintext and key lengths are equal and are only used once and never repeated with different embedding process. It is worth mentioning that state-of-the-art encryption techniques could be more robust against attacks. However, they are usually more computationally expensive, which would increase the overall computational cost of the steganography algorithm, especially that it contains a number of other building blocks.

@&#CONCLUSION@&#

This paper handles the security issue of patient's information in the digital medical system. We presented an efficient combination between cryptography and information hiding techniques in order to ensure the security and privacy of patients’ information through concealing the meaning of the secret data and its existence. Because medical images have to be carefully processed, as introducing modifications to their important regions, known as the region of interest (ROI), may impact diagnosis of patients’ conditions, we have refrained from making any modifications to the ROI and developed our algorithm to conceal the secret data in the Region of Non Interest (RONI). Moreover, based on the characteristic of the human visual perception, we focused on embedding data into the sharp edges of the RONI, as this would attract less attention from intruders about the existence of secret data in the image. To further enhance the embedding efficiency and increase data security, we incorporated a coding algorithms that helped in reducing modifications to the original (cover) images. Experimental results indicated that the proposed algorithm achieved high embedding rate with low level of embedding distortion, and hence provided a good compromise between payload and quality of the stego images. Moreover, steganalysis results of the proposed algorithms obtained using the Li-110D technique proved the superiority of the proposed algorithm compared to the well-known PVD algorithm and two of its variants. Finally, even though tested on grey images, the proposed algorithm can be extended to colour images.

@&#REFERENCES@&#

