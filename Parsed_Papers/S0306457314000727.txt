@&#MAIN-TITLE@&#Efficient processing of keyword queries over graph databases for finding effective answers

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We define a new measure of relevance of a node in the graph to a keyword query.


                        
                        
                           
                           We propose an extended answer structure for a top-k query over graph databases.


                        
                        
                           
                           We propose an inverted list index and search algorithm to find top-k answer trees.


                        
                        
                           
                           We enhanced the basic method for more efficient and scalable processing the query.


                        
                        
                           
                           Experiments show that the proposed method can find effective top-k answers efficiently.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Graph database

Keyword search

Top-k query processing

@&#ABSTRACT@&#


               
               
                  In this paper, we study on effective and efficient processing of keyword-based queries over graph databases. To produce more relevant answers to a query than the previous approaches, we suggest a new answer tree structure which has no constraint on the number of keyword nodes chosen for each keyword in the query. For efficient search of answer trees on the large graph databases, we design an inverted list index to pre-compute and store connectivity and relevance information of nodes to keyword terms in the graph. We propose a query processing algorithm which aggregates from the pre-constructed inverted lists the best keyword nodes and root nodes to find top-k answer trees most relevant to the given query. We also enhance the method by extending the structure of the inverted list and adopting a relevance lookup table, which enables more accurate estimation of the relevance scores of candidate root nodes and efficient search of top-k answer trees. Performance evaluation by experiments with real graph datasets shows that the proposed method can find more effective top-k answers than the previous approaches and provides acceptable and scalable execution performance for various types of keyword queries on large graph databases.
               
            

@&#INTRODUCTION@&#

Recently, graph-structured data are widely used in many applications such as XML, bio-informatics, semantic web, ontologies, and social networking services. Keyword-based query over graph-structured databases has been attracting much attention since it enables users to represent their information need using only a set of keyword terms, instead of using a query language and understanding the underlying database schema (Chen, Wang, Liu, & Lin, 2009; Dalvi, Kshirsagar, & Sudarshan, 2008; Golenberg, Kimelfeld, & Sagiv, 2008; He, Wang, Yang, & Yu, 2007; Kacholia et al., 2005; Kargar & An, 2011; Kim, Park, & Lee, 2011; Li, Ooi, Feng, Wang, & Zhou, 2008; Park, 2013; Tran, Rudolph, Cimiano, & Wang, 2009). Keyword-based query processing has also been studied extensively in the literature of relational databases, where relational data can be modeled as a directed graph of tuples based on the foreign-key relationships among tuples (Agrawal, Chaudhuri, & Das, 2002; Baid, Rae, Li, Doan, & Naughton, 2010; Balmin, Hristidis, & Papakonstantinou, 2004; Bergamaschi, Domnori, Guerra, Lado, & Velegrakis, 2011; Bhalotia, Hulgeri, Nakhe, Chakrabarti, & Sudarshan, 2002; Ding et al., 2007; Hristidis, Gravano, & Papakonstantinou, 2003; Hristidis & Papakonstantinou, 2002; Li, Zhou, Feng, & Wang, 2009; Liu, Yu, Meng, & Chowdhury, 2006; Luo, Lin, Wang, & Zhou, 2007; Qin, Yu, & Chang, 2009; Qin, Yu, Chang, & Tao, 2009).

Keyword-based search on a graph-structured database usually returns a set of connected structures derived from the database, which represent how the data containing query keywords are interconnected in the database. In most approaches, a sub-tree of the graph is used to describe an answer to a given query. Since there can be a significant number of answer structures in a large graph database, a relevance scoring function is often used to rank the candidate answers and return top-k ones most relevant to the query.

The problem of answering keyword-based queries over graph-structured databases is described as follows. Let G
                     =(V, E) be a directed graph representing a graph-structured database, where each node is labeled with some text. The nodes and edges in G may have weights on them. Given a keyword query Q over G consisting of a set of keywords, denoted by Q
                     ={k
                     1, k
                     2, …, kl
                     }, an answer to Q is defined as a sub-tree T of G satisfying the following properties: there exists a set of nodes in T called keyword nodes, where each node contains at least one keyword in Q, and the leaf nodes of T only come from those keyword nodes. Given a relevance scoring function rel(T), which maps an answer sub-tree T to a numeric score value measuring goodness of T or relevance to Q, top-k processing of Q should find k best answers with the highest values of rel(T).

To evaluate and rank the answer sub-trees, various scoring functions have been proposed in the literature based on different semantics, which will be described in Section 2. In this paper, we adopt distinct root-based semantics, where the weight of a sub-tree is computed as the sum of the shortest distance from the root to each keyword node and at most one sub-tree rooted at each node is considered an answer to the query (Dalvi et al., 2008; He et al., 2007; Kacholia et al., 2005). This approach can deal with top-k query processing over very large graph databases more efficiently than the other approaches based on Steiner tree-based semantics. It also enables effective indexing on the graph (He et al., 2007).

For example, suppose that a keyword query Q
                     ={volcano, ocean} is given on a graph-structured data G in Fig. 1
                     (a). As indicated in the figure, nodes K, L, M, O, and R are keyword nodes containing keyword volcano and nodes S and U are keyword nodes for ocean. Fig. 1(b) shows some possible answer trees rooted at node B, C, or D. Under the distinct root-based semantics, only one among the sub-trees TB
                     
                     1, TB
                     
                     2, and TB
                      which are rooted at node B can be returned as an answer to Q. Note that in the previous approaches, only sub-trees including exactly one keyword node for each query keyword, such as TB
                     
                     1, TB
                     
                     2, TC
                     
                     1, and TD
                     
                     1, have been considered candidate answer trees. However, we consider that sub-trees which have more than one keyword node for each query keyword, such as TB
                      and TC
                     , also can be possible answers to Q.

The main contributions of our work are as follows:
                        
                           •
                           To produce more effective and relevant search result for a given query, we propose an extended structure of answer trees and a new relevance metric and ranking mechanism for the answer trees. Different from the existing approaches, the proposed answer structure has no such constraint that it should include one and only one keyword node for each keyword in the query. That is, an answer tree is allowed to contain a part of query keywords and to have more than one node containing the same keyword, and based on the new measure of relevance, more extended and relevant answers can be generated.

For efficient finding of top-k answers in the proposed structure, we design an inverted list-style index to the keywords and nodes in the graph, which stores information on the connectivity and relevance of a node to each keyword term. Then we present a basic query processing algorithm which exploits the pre-constructed inverted lists to aggregate most relevant keyword nodes for each candidate answer tree with a distinct root and find top-k answer trees most relevant to the given query.

Aiming at improving the efficiency of the basic approach, we extended the above inverted list index to store at each entry additional relevance information of another entry related in the same list. We also introduce a relevance lookup table which pre-computes and stores the largest relevance value of each node to each keyword term in the graph. Then we present an enhanced search algorithm based on the extended inverted list and the relevance lookup table. It estimates the worst and best relevance scores of a node more closely to its actual score and thus can find top-k answer trees rooted at different nodes more efficiently than the basic approach.

The rest of the paper is organized as follows. Section 2 presents related work and motivation of our study. Section 3 defines a new answer structure and relevance measure for keyword queries over graph databases. In Section 4, we propose an inverted list index for keywords and nodes in the graph and a top-k query processing algorithm using the index. In Section 5, we improve the proposed indexing scheme and present a more efficient search method. We provide experimental results on the effectiveness and performance of the proposed method in Section 6 and draw a conclusion in Section 7.

There has been much work on keyword search over relational databases (Agrawal et al., 2002; Baid et al., 2010; Balmin et al., 2004; Bergamaschi et al., 2011; Bhalotia et al., 2002; Ding et al., 2007; Hristidis & Papakonstantinou, 2002; Hristidis et al., 2003; Li et al., 2009; Liu et al., 2006; Luo et al., 2007; Qin, Yu, Chang, 2009; Qin, Yu, Chang, Tao, 2009). Many approaches, however, use underlying schema information to generate candidate expressions on the schema graph and then translate them into SQL queries to be executed on the database to get answer trees of tuples (Agrawal et al., 2002; Baid et al., 2010; Balmin et al., 2004; Bergamaschi et al., 2011; Hristidis & Papakonstantinou, 2002; Hristidis et al., 2003; Liu et al., 2006; Luo et al., 2007; Qin, Yu, Chang, 2009). Thus, they are only applicable to querying on relational data. Other approaches are schema-agnostic and materialize a relational database as a graph, and thus they can be applied to any graph-structured data (Bhalotia et al., 2002; Ding et al., 2007; Li et al., 2009; Qin, Yu, Chang, Tao, 2009).

Most of the studies on keyword-based search over graph databases find minimal connected sub-trees as succinct answers to a given query (Bhalotia et al., 2002; Dalvi et al., 2008; Ding et al., 2007; Golenberg et al., 2008; He et al., 2007; Kacholia et al., 2005) while some recent approaches search for sub-graphs to provide more informative answers (Kargar & An, 2011; Li et al., 2008; Qin, Yu, Chang, Tao, 2009). In this paper, we adopt a tree-based approach for efficient query processing over a large volume of graph data.

To evaluate and rank sub-trees satisfying answer conditions, weight functions have been proposed in the literature based on two different semantics, namely Steiner tree-based semantics and distinct root-based semantics (Yu, Qin, & Chang, 2010). The Steiner tree-based semantics defines weight of an answer tree as the total weight of the edges in the tree. Under this semantics, finding an answer tree with the smallest weight is a well-known optimal group Steiner tree problem, which is NP-complete (Hwang & Richards, 1992). Since there can be exponentially many candidates to consider to select the optimal Steiner tree, the previous approaches proposed a heuristic backward search algorithm to find an l-approximation of the optimal answer where l is the query size (Bhalotia et al., 2002) or a dynamic programming algorithm to find the optimal answer for small-sized queries efficiently (Ding et al., 2007). Another work presented an algorithm to enumerate answers in a 2-approximate order by height with polynomial delay (Golenberg et al., 2008). Li et al. (2009) proposed a polynomial time approximate solution for answering top-k queries over relational databases based on Compact Steiner Tree structure and the capabilities of relational DBMS. Those methods, however, cannot produce top-k Steiner tree-structured answers efficiently over large-scale graph databases.

As an alternative to the Steiner tree semantics, other approaches adopted easier semantics, namely distinct root semantics, to find answer trees rooted at distinct nodes (Dalvi et al., 2008; He et al., 2007; Kacholia et al., 2005). For each node in the graph, only a single sub-tree which has a minimal weight among those rooted at the node is considered a candidate answer to the query. The weight of a sub-tree is defined as the sum of the shortest distances from the root to the keyword nodes chosen for each query keyword. Under this semantics, given a graph having n nodes, there can be at most n answer trees and thus we can deal with queries over very large graph databases more efficiently than under the Steiner tree semantics. A bi-directional search algorithm proposed in Kacholia et al. (2005) performs backward explorations of the graph starting from nodes containing query keywords like BANKS (Bhalotia et al., 2002), as well as executing forward explorations from the potential roots of answer sub-trees toward keyword nodes. It uses a heuristic activation strategy to prioritize nodes to expand during the bi-directional search while it does not take advantage of any prior knowledge on the connectivity between nodes in the graph. Thus it may lead to poor performance on certain complex graphs. In BLINKS approach (He et al., 2007), indexing schemes and query processing algorithms were proposed to speed up the bi-directional exploration of the graph with a good performance guarantee. A single-level index consisting of sorted keyword-node lists and a node-keyword map pre-computes and indexes all the shortest paths and distances from nodes to keywords in the graph. By accessing the sorted lists of nodes relevant to the given keywords in parallel and exploiting the node-keyword map, the search method of BLINKS performs backward and forward expansions efficiently and finds top-k answers in a time and space efficient manner. To reduce index space for large graph, they also suggested graph partitioning strategies and a bi-level indexing scheme. Dalvi et al. (2008) considered the issue of keyword search on graphs that are larger than main memory. They proposed to create and exploit a multi-granular representation of graph data to minimize I/O by directing search toward limited areas of the graph resident in memory. They suggested two approaches to extending existing search algorithms such as BANKS (Bhalotia et al., 2002) and bi-directional search (Kacholia et al., 2005) to work on multi-granular graphs. As described in the paper, any in-memory graph search algorithm can be used in their approach. Thus, their strategy of exploiting a multi-granular representation of the graph in search process is orthogonal to our work based on a new answer structure and indexing scheme.

The previous approaches including those mentioned above have a common constraint on the answer structure employed: it should have one and only one keyword node for every keyword in the query. In Fig. 1, for example, sub-tree TB
                     
                     1 of G is a possible answer to query Q
                     ={volcano, ocean}, which is rooted at node B and has keyword nodes K and S chosen for keywords volcano and ocean, respectively. Note that, besides node K, there are other keyword nodes L, M, and O in G which contain volcano and are reachable from node B, but an answer tree rooted at node B should have only one of them in the previous approaches. Moreover, the distinct root semantics allows at most one answer tree rooted at a certain node hence another candidate answer tree TB
                     
                     2 rooted at node B cannot be returned with TB
                     
                     1 at the same time. As shown in Fig. 1(b), there are other candidate answer trees, such as sub-tree TC
                     
                     1 rooted at C and containing {O, U} as keyword nodes and sub-tree TD
                     
                     1 rooted at D and having {R, U} as keyword nodes. Based on the distinct root semantics where the weight of a sub-tree is computed as the sum of the shortest distance from the root to each keyword node selected, answer trees TB
                     
                     1 and TB
                     
                     2 have a larger weight, and thus lower relevance score, than answer tree TC
                     
                     1
                     . On the other hand, TB
                     
                     1 and TB
                     
                     2 have the same weight or relevance score as TD
                     
                     1 since they have the same distances from the root to the keyword nodes in them. However, we observe that node B has connections to more nodes containing query keywords than node C or D have, and we consider that we can obtain a more relevant answer by including more paths from B to the keyword nodes in a single sub-tree rooted at B.

To improve the quality of query result based on the consideration, we propose a new answer structure which has no constraint on the number of keyword nodes chosen for each query keyword, so that an answer tree can have more than one keyword node for some keywords while it may include no keyword node for other keywords. To restrict an answer tree to an acceptable size, we limit the number of pairs of a keyword and keyword node for it in an answer tree. For instance, allowing maximum 4 pairs of a keyword and keyword node to be included in an answer tree for the query in Fig. 1, we have a new candidate answer tree TB
                      which is extended from the conventional answer trees TB
                     
                     1 and TB
                     
                     2 by containing keyword nodes M in addition to K and L for volcano, as shown in Fig. 1(b). A sub-tree TC
                      rooted at node C with four keyword nodes M, O, S, and U also can be a candidate answer to the query. To search for the best answer trees for a given query, we will propose an effective relevance measure for the candidate answer trees in Section 3. According to the metric, TB
                      is considered more relevant to the query than TC
                      or TD
                     
                     1 in our approach.

In this section, we propose a structure of answer trees and a relevance measure for them. Given a data graph G
                     =(V, E), let K be the set of keyword terms extracted from the nodes in V(G). We first define relevance of a node in V(G) to a keyword term in K contained in a specific node in the graph. When a node contains a keyword term, the relevance of the node to the keyword is computed based on the tf-idf weighting scheme (Buttcher, Clarke, & Cormack, 2010) which is popularly used in information retrieval. The relevance of a node n to another node m in the graph is calculated based on the shortest distance from n to m
                     
                        1
                        For the simplicity of description, we do not consider weight on edges in the graph.
                     
                     
                        1
                     . We consider that even if a node does not contain a keyword k, n is relevant to k if there is a path from n to another node s which contains k, i.e., a keyword node for k. Its relevance is formally defined as follows.
                        Definition 1
                        Relevance of a node n to a keyword k contained in a node s
                        


                        Given a keyword k∈K and a node s∈V(G), let tf(k,
                           s) be the number of occurrences of k in s and df(k) be the number of nodes in V(G) which contain k. The relevance of s to k is defined by

According to the above definition, when s does not contain k or there is no path from n to s, rel(n, s, k) becomes 0. Also note that if n and s denote the same node, rel(n, s, k) equals to the relevance of s to k, i.e., rel
                     1(s, k). A node n is called relevant to a keyword k if and only if there exists a keyword node s for k such that rel(n, s, k)>0. Given a keyword query, an answer tree to the query is defined based on rel(n, s, k) as follows.
                        Definition 2
                        Answer tree for a query


                        Given a keyword query of size l, Q
                           ={k
                           1, k
                           2, …, kl
                           }, on the data graph G and a constant integer p greater than or equal to l, let V(Q) be a set of keyword nodes in G which contain a keyword in Q. For a node n in V(G), Topp
                           (n,
                           Q) is defined as a set of at most p pairs of a node s in V(Q) and a keyword k in Q where the relevance of n to k contained in s is in the p highest over all the pairs of a node in V(Q) and a keyword in Q. Formally,

Note that based on the distinct root semantics, our approach finds at most one answer tree Tn
                      rooted at each node n in the graph. It is derived from at most p pairs of a query keyword k and a keyword node s for k to which its root node n is most relevant. For ranking candidate answer trees with different root nodes, we propose a relevance measure for them as follows.
                        Definition 3
                        Relevance measure for answer trees


                        Given an answer tree Tn
                            for query Q rooted at node n, the relevance of Tn
                            to Q, denoted by rel(Tn
                           ,
                           Q), is the sum of the relevance of n to k contained in s for all pairs of (s, k) in Topp
                           (n,
                           Q) shown in Definition 2, i.e.,

Given a keyword query Q
                           ={volcano, ocean} on the graph G in Fig. 1(a), the set V(Q) of the keyword nodes for Q is {K, L, M, O, R, S, U}. Assuming that p
                           =4, we have Topp
                           (B, Q)={(K, volcano), (L, volcano), (M, volcano), (S, ocean)} and Topp
                           (C, Q)={(M, volcano), (O, volcano), (S, ocean), (U, ocean)} based on Definition 2, and thus two possible answer trees TB
                            and TC
                            rooted at nodes B and C, respectively, can be derived from the graph as shown in Fig. 1(b). Supposing that the relevance rel
                           1(s, k) of keyword node s to each keyword k in Q are the same as 1, 
                              
                                 rel
                                 (
                                 
                                    
                                       T
                                    
                                    
                                       B
                                    
                                 
                                 ,
                                 Q
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       3
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       3
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       3
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       4
                                    
                                 
                                 =
                                 1.25
                              
                            and 
                              
                                 rel
                                 (
                                 
                                    
                                       T
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 Q
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       4
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       5
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       3
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       3
                                    
                                 
                                 =
                                 1.12
                              
                            based on Definition 3 hence answer tree TB
                            is considered more relevant to Q than TC
                            is.

In this section, we present an indexing scheme and query processing algorithm to find k best answers to a given keyword query based on the answer structure and relevance measure defined in the previous section.

To enable efficient search of top-k answer trees in a graph database, we suggest an inverted list-style index which pre-computes and stores information on the relevant nodes for each keyword term in the database. We first find all keyword nodes and relevant nodes for each keyword term in the graph, pre-compute relevances of the nodes to the keyword as defined in Definition 1, and then build an inverted list per keyword which can be formally defined as follows.
                           Definition 4
                           Inverted list L(k)


                           for a keyword k). For a keyword term k in the graph, let S(k) be the set of nodes in V(G) which contain k. The inverted list for k, denoted by L(k), is a list of triples (n, s, rel(n, s, k)) obtained from all the pairs of nodes n∈V(G) and s∈S(k) such that rel(n, s, k)>0. The list entries are sorted in a non-increasing order of their relevance values. Formally,

We call an entry (n, s, r) in the list an entry of node n. As defined above, L(k) stores entries of the nodes that either contain keyword k or have a path to a keyword node for k in a decreasing order of relevance to k. Therefore, we can identify the nodes that are most relevant to k in terms of relevance measure rel(n, s, k) by reading the entries in L(k) in order. Note that the proposed inverted list is different from the conventional one used for ranked search over documents or multi-dimensional data (Bruno, Gravano, & Marian, 2002; Fagin, Lotem, & Naor, 2003; Güntzer, Balke, & Kießling, 2001) in that L(k) not only has entries of the keyword nodes for k but also has entries of the nodes that do not contain k. The proposed inverted list structure is also distinguished from the keyword-node list used in BLINKS (He et al., 2007) since our inverted list may have multiple entries of the same node n, one for each keyword node reachable from n, while the latter has only a single entry per node n which stores a keyword node in the shortest distance from n. In order to compute the amount of relevance of a node to the keywords in a given query, we should aggregate a set of the most relevant entries of the same node in the inverted lists according to the query keywords. The query processing algorithm exploiting the proposed inverted list index will be detailed in the following section.

Our query processing model is based on the threshold algorithm (Fagin et al., 2003; Güntzer et al., 2001), which is popularly used for evaluating top-k queries on multi-dimensional data, such as similarity search on multimedia objects (Best, Majumdar, Schenkel, Theobald, & Weikum, 2006; Bruno et al., 2002; Theobald, Weikum, & Schenkel, 2004). It performs sequential scans on the pre-computed index lists which are sorted in descending order of per-attribute scores of data and searches for top-k data items having the highest total scores aggregated from the index lists.

Given a query Q
                        ={k
                        1, k
                        2, …, kl
                        }, let L(Q) be the set of pre-constructed inverted lists for the keywords in Q, i.e. L(Q)={L(ki
                        ) | ki
                        ∈Q}. The query processor performs sequential scans on the lists in L(Q) in parallel by reading their entries in a round-robin manner. During the scans, it maintains the relevance values of the entries at the current scan position in each list L(ki
                        ), denoted by curScorei
                         (1⩽
                        i
                        ⩽
                        l). The largest one among those is called maxCurScore, i.e. 
                           
                              maxCurScore
                              =
                              
                                 
                                    max
                                 
                                 
                                    1
                                    ⩽
                                    i
                                    ⩽
                                    l
                                 
                              
                              
                                 
                                    curScore
                                 
                                 
                                    i
                                 
                              
                           
                         Note that since the entries in the lists are stored in a non-increasing order of their relevances, maxCurScore can serve as an upper bound for the relevances of the entries which have not been read yet from the lists in L(Q).

While reading the lists, the query processor also maintains a priority queue per a root node n of a candidate answer tree, called a relevance queue of n and denoted by qn
                        . It stores at most p entries of n which have the highest relevance values among the entries of n retrieved from the lists. From an entry (n, s, r), only the pair of s and r is stored in qn
                        . Since qn
                         maintains the current top-p relevance values of n found from the lists, the sum of the current values in qn
                         can be a lower bound for the relevance rel(Tn
                        , Q) of an answer tree Tn
                         rooted at n when the lists in L(Q) are scanned. Thus, we define the worst score of n as follows:
                           
                              (1)
                              
                                 worstScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                q
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                 
                                 r
                              
                           
                        On the other hand, the best score of n can be calculated using the relevances in qn
                         and maxCurScore. Let Rn
                         be a multi-set of the relevance values in qn
                         that are greater than or equal to maxCurScore, i.e. Rn
                        
                        ={r|(s,
                        r)qn
                        ,
                        rmaxCurScore} Since maxCurScore is an upper bound for the relevances of the entries currently unseen from the lists in L(Q), it is guaranteed that the relevance values in Rn
                         belong to the p highest of all the entries of n in the lists while the other relevance values in qn
                         can be outweighed by relevance values which will appear in the lists. Assuming that all the currently unknown ones among the top-p relevances of n are the same as maxCurScore, an upper bound of the relevance rel(Tn
                        , Q), called the best score of n, can be defined as follows:
                           
                              (2)
                              
                                 bestScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                 
                                 r
                                 +
                                 maxCurScore
                                 ·
                                 (
                                 p
                                 -
                                 |
                                 
                                    
                                       R
                                    
                                    
                                       n
                                    
                                 
                                 |
                                 )
                              
                           
                        Note that since maxCurScore monotonically decreases as entries are retrieved from the lists, worstScore(n) increases whereas bestScore(n) decreases monotonically during the list scan. When the relevance queue qn
                         has p entries and all the relevance values in them are no less than maxCurScore (i.e., |Rn
                        |=
                        p), both bestScore(n) and worstScore(n) are equal to rel(Tn
                        , Q).
                           Example 2
                           Given a graph G and a keyword query Q
                              ={k
                              1, k
                              2, k
                              3, k
                              4}, Fig. 2
                               shows an example of computing worst and best scores of a node n in G when we process Q using the inverted lists in L(Q). In the figure, lines represent inverted lists for the query keywords, scanned from left to right in a round-robin manner. On the lists, the entries of n are indicated by closed dots. Assuming that scanning of the lists has proceeded to the entries denoted by rectangles, curScorei
                              ′s (1⩽
                              i
                              ⩽4) are 2.4, 3.0, 1.5, and 2.2, respectively, and maxCurScore
                              =3.0. Given p
                              =6, the relevance queue of n currently has 5 entries of n retrieved from the lists, i.e. qn
                              
                              =[(s
                              1, 4.0), (s
                              2, 3.5), (s
                              4, 3.0), (s
                              3, 2.3), (s
                              5, 1.7)], and a multi-set Rn
                               of the relevance values in qn
                               that are greater than or equal to maxCurScore is {4.0, 3.5, 3.0}. Consequently, based on Eqs. (1) and (2), we have worstScore(n)=
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                q
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                    r
                                    =
                                 
                              14.5 and bestScore(n)=
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                    r
                                    +
                                 
                              3.0 · (6–3)=19.5.

As scanning the lists in L(Q), we can find the nodes which are roots of top-k answer trees using two priority queues:
                           
                              •
                              Top-k queue T stores at most k nodes with the highest worst scores over the nodes that have been found from the lists. The nodes in T are sorted by their worst scores in a descending order. The minimum (i.e., rank-k) worst score value from the current top-k nodes in T is called min-k, i.e., 
                                    
                                       
                                          
                                             min
                                          
                                          -
                                          k
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  min
                                                               
                                                               
                                                                  n
                                                                  ∈
                                                                  T
                                                               
                                                            
                                                            {
                                                            worstScore
                                                            (
                                                            n
                                                            )
                                                            }
                                                            ,
                                                            
                                                            if
                                                            
                                                            |
                                                            T
                                                            |
                                                            =
                                                            k
                                                         
                                                      
                                                      
                                                         
                                                            0
                                                            ,
                                                            
                                                            otherwise
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Candidate queue C maintains candidate nodes which have a worst score smaller than min-k but could still make it into the top-k queue T. A node whose best score is also smaller than min-k cannot belong to the final top-k nodes and thus is rejected or removed from C. The nodes in C are sorted in a descending order of their best scores to facilitate looking up a candidate node having the maximum best score.

Whenever the worst and best scores of a node change as a new entry of the node is read from a list, we check if the node can be entered into top-k queue T or it should be maintained in candidate queue C. Query processing can terminate safely with the correct top-k relevant nodes in T when the maximum best score in C as well as the best score of any node nu
                         currently unseen from the lists is no higher than min-k, i.e., when
                           
                              (3)
                              
                                 |
                                 T
                                 |
                                 =
                                 k
                                 
                                 and
                                 
                                 max
                                 {
                                 
                                    
                                       max
                                    
                                    
                                       m
                                       ∈
                                       C
                                    
                                 
                                 {
                                 bestScore
                                 (
                                 m
                                 )
                                 }
                                 ,
                                 bestScore
                                 (
                                 
                                    
                                       n
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 }
                                 ⩽
                                 min
                                 -
                                 k
                                 ,
                              
                           
                        where bestScore(nu
                        )=
                        maxCurScore · p. Then, using the nodes in T and the keyword nodes stored in their relevance queues, we can derive top-k answer trees from the graph database as defined in Definition 2. Specifically, for each node n in T, an answer tree Tn
                         rooted at n is constructed by merging the nodes and edges in the shortest paths from n to each keyword node in qn
                        .


                        Fig. 3
                         shows a pseudo-code algorithm of the basic query processing scheme described above. At each step of reading an entry from an inverted list, the following tasks are performed repeatedly. Given an entry of a node n read, it is ignored if the correct top-p relevances of n had been found from the lists or node n had been already rejected from candidate queue C (Line 7). In Line 8∼10, the current entry is inserted into relevance queue qn
                        , and worstScore(n) and bestScore(n) are computed based on the relevance values in qn
                         and maxCurScore. If the current entry is the first entry of n found from the lists, n can be inserted into top-k queue T or candidate queue C depending on its worst and best scores as well as the current min-k value in T (Line 11∼13). If n is already in T, T should be re-organized considering the new worstScore(n) (Line 14∼15). Otherwise, if n exists in C, it is moved into T or remains in C or is eliminated from C depending on the new worstScore(n), bestScore(n), and min-k value (Line 16∼20). As mentioned earlier, if Eq. (3) is satisfied after the current entry is processed, the algorithm stops immediately and top-k answer trees are derived from the graph using the top-k relevant nodes in T and the keyword nodes stored in their relevance queues (Line 22 and 26).

In our method, the worst and best scores of the nodes in top-k queue or candidate queue may change as the list scan proceeds since they depend on maxCurScore determined from the entries at the current scan position of each list. However, a naïve approach to re-calculating the worst and best scores of all the nodes in the queues and to conducting re-organization of the queues at every time of reading an entry from a list would result in very high performance overhead. Instead, we adopt a strategy of periodic updates and cleaning of the queues after every pre-defined number of entries is read from the lists. As shown in Line 23, procedure updateQueues is invoked periodically, which performs rebuilding of top-k queue and candidate queue based on maxCurScore (Refer to the pseudo-code of the procedure in Fig. 3).

In the basic method described in Section 4, the worst score and best score of each node n are estimated assuming that all the unknown relevances of the entries of n unseen from the inverted lists are equal to the largest of the relevances of the entries at the current scan positions of the lists, i.e. maxCurScore. This strategy, however, is too conservative since the actual relevance of an entry of n unseen from a list L(ki
                     ) can be much smaller than curScorei
                     , the relevance of the entry at the current scan position in the list L(ki
                     ). We consider that if we can look ahead at the relevance of the next entry of the same node n stored after the current scan position in each list, we can predict its worst score and best score more closely to the actual relevance rel(Tn
                     , Q) by exploiting the next relevance value instead of maxCurScore. Based on the consideration, we extend the inverted list structure to store in each entry a relevance of the next entry of the same node appearing in the list. Then we propose an enhanced search algorithm which can compute a narrower range of relevance score for each node in the graph and identify top-k answer trees for a given query earlier than the basic query processing algorithm.

For more efficient processing of a keyword query, we extend the index structure defined in Definition 4 as follows.
                           Definition 5
                           Extended inverted list L′(k)


                           for a keyword k). Given a keyword term k, let S(k) be a subset of nodes in V(G) which contain k. For a node n in V(G), let L(n, k) be an ordered list of quadruples (n, si
                              , ri
                              , r′
                                 i
                              ) which are derived from all nodes si
                               in S(k) and sorted in a non-increasing order of ri
                              , the relevance of n to k contained in si
                              , i.e. rel(n, si
                              , k). Formally,

The extended inverted list for k, denoted by L′(k), is a list of quadruples merged from the lists L(ni
                        , k) for all nodes ni
                         in V(G), which are sorted in a non-increasing order of their relevance values.

The extended inverted list L′(k) defined above is different from the original inverted list L(k) in that when an entry ei
                        
                        =(
                           
                              n
                              ,
                              
                                 
                                    s
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         of a node n is read from the list, we can see not only the relevance ri
                           
                        =
                        rel(n, si
                        , k) but also the relevance ri
                        
                        +1
                        =
                        rel(n, si
                        
                        +1, k), i.e. the relevance of the next entry ei
                        
                        +1
                        =(
                           
                              n
                              ,
                              
                                 
                                    s
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              
                                 
                                    r
                                 
                                 
                                    i
                                    +
                                    1
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         of n which follows ei
                         in the list since 
                           
                              
                                 
                                    r
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         in ei
                         is equal to ri
                        
                        +1 in ei
                        
                        +1. For the first entry of n, however, we do not know its relevance until we retrieve the entry in the sequential scan of the list. Thus, for more efficient query evaluation, we also consider constructing a lookup table to store relevance of the first entry of each node appearing in the list for each keyword term.
                           Definition 6
                           Relevance lookup table for a graph G


                           Given a graph G
                              =(V, E), let K be a set of keyword terms in V(G). The relevance lookup table RT is a hash table which stores for each node n in V(G) and keyword k in K, the largest relevance rel(n, s, k) among all keyword nodes s containing k in G. Formally,

The overall query processing strategy is similar to the basic method described in Section 4.2. Assuming that L′(Q) be the set of extended inverted lists for a given query Q
                        ={k
                        1, k
                        2, …, kl
                        }, i.e. L′(Q)={L′(ki
                        )|ki
                        ∈Q}, the entries in the lists in L′(Q) are sequentially read in a round-robin manner and the top-p relevant entries of each node n are aggregated using its relevance queue qn
                        . The current top-k relevant nodes and candidate nodes for the query answers are maintained in a top-k queue T and candidate queue C until the final top-k nodes are identified.

However, different from the basic method, the enhanced approach exploits next relevance values in the entries of the extended inverted lists, as well as the relevance lookup table, to estimate the worst and best scores of each node more exactly. When an entry of a new node n is found from a list, the relevances of the first entries of n in the other lists in L′(Q) are also looked up from the relevance lookup table and inserted into the relevance queue qn
                         of n in advance. Whenever an entry (n, s, r, r′) of a node n is read from a list, not only its relevance r but also the next relevance r′ is stored in qn
                         if it belongs to the current top-p relevance values of n. Since qn
                         has at most p highest relevances of n which have been found from the lists, the sum of those values in qn
                         gives a lower bound for the relevance rel(Tn
                        , Q) of an answer tree Tn
                         rooted at n. Thus, the worst score of n is defined as
                           
                              (4)
                              
                                 worstScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                q
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                 
                                 r
                              
                           
                        For each node n in top-k queue T and candidate queue C, the query processor maintains its next relevance value for each query keyword ki
                         in Q, which is either retrieved from the list L′(ki
                        ) most recently or looked up from RT(G). Denoted by nextScoren,i
                        , it indicates the relevance in an entry of n which will appear next in the list L′(ki
                        ) and the largest of nextScoren,i
                        ′s, denoted by maxNextScoren
                        , represents the highest relevance of n stored in the remaining parts of the lists in L′(Q). Thus, assuming that all the unknown relevances are the same as maxNextScoren
                        , an upper bound for the relevance rel(Tn
                        , Q), called the best score of n, can be computed based on maxNextScoren
                         instead of maxCurScore as follows:
                           
                              (5)
                              
                                 bestScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                n
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                                 r
                                 +
                                 
                                    
                                       maxNextScore
                                    
                                    
                                       n
                                    
                                 
                                 ·
                                 (
                                 p
                                 -
                                 |
                                 
                                    
                                       R
                                    
                                    
                                       n
                                    
                                    
                                       ′
                                    
                                 
                                 |
                                 )
                              
                           
                        where R′
                           n
                         is a multi-set of the relevance values in qn
                         which are no less than maxNextScoren
                        , i.e. 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                 
                                 
                                    ′
                                 
                              
                              =
                              {
                              r
                              |
                              (
                              s
                              ,
                              r
                              )
                              ∈
                              
                                 
                                    q
                                 
                                 
                                    n
                                 
                              
                              ,
                              r
                              ⩾
                              
                                 
                                    maxNextScore
                                 
                                 
                                    n
                                 
                              
                              }
                              .
                           
                         Note that while the worst score of n is computed by all the known relevances of n including the next relevance values looked ahead, the best score of n is calculated using only the relevances greater than or equal to maxNextScoren
                        . Since the entries in each list are stored in a descending order of relevance, nextScoren,i
                        ′s (1⩽
                        i
                        ⩽
                        l) and maxNextScoren
                         monotonically decrease as entries are read from the lists. Therefore, we ensure that for each node n, worstScore(n) monotonically increases while bestScore(n) monotonically decreases during the list scan.
                           Example 3
                           
                              Fig. 4
                               shows an example of computing the worst and best scores of a node n when evaluating a query Q over graph data using extended inverted lists. Suppose that graph data and the given query are the same as in Example 2 and the extended inverted lists in L′(Q) have been scanned to the same positions on the inverted lists in L(Q) in Fig. 2, denoted by rectangles. With an extended inverted list, however, the relevance of the next entry of n which will appear after the current scan position is already available from the recent entry of n or from the relevance lookup table. In Fig. 4, the next relevances of n represented by nextScoren,i
                               (1⩽
                              i
                              ⩽4), are 2.0, 2.5, 1.0, and 1.5, respectively, and thus maxNextScoren
                                 
                              =2.5. Note that nextScoren,
                              
                              4 is obtained from RT because no entry of n has been found from L′(k
                              4) yet. Moreover, the relevance queue of n stores p highest relevances not only from the entries of n retrieved from the lists but also from the next relevances provided by nextScoren,i
                              ′s. Thus, assuming p
                              =6, the next relevances of n in L′(k
                              1) and L′(k
                              2), i.e. nextScoren,
                              
                              1 and nextScoren,
                              
                              2, are maintained in qn
                               instead of the second entry of n read from L′(k
                              3), which results in qn
                              
                              =[(s
                              1, 4.0), (s
                              2, 3.5), (s
                              4, 3.0), (−, 2.5), (s
                              3, 2.3), (−, 2.0)]. According to Eqs. (4) and (5), we have worstScore(n)=
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                q
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                    r
                                 
                              
                              =17.3 and bestScore(n)=
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                n
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                    r
                                 
                              
                              +2.5 ·(6–4)=18.0 since maxNextScoren
                                 
                              =2.5 and R′
                                 n
                              
                              ={4.0, 3.5, 3.0, 2.5}. Note that this range of relevance score [17.3, 18.0] is narrower than the range [14.5, 19.5] obtained by the basic method in Example 2.


                        Fig. 5
                         shows a pseudo-code of the enhanced query processing algorithm based on the extended inverted lists and relevance lookup table. The overall structure of the algorithm is the same as the basic one presented in Fig. 3. Besides curScorei
                        , nextScoren,i
                         is introduced to maintain the next relevance of each node n in each list Li
                         for keyword ki
                         (in Line 11 and 16). Suppose that an entry of a node n has been read when scanning the extended inverted lists and without loss of generality, it was from list Li
                        . If the entry is the first entry of n found from the lists in L′(Q), nextScoren,j
                         for all the other lists Lj
                         in L′(Q) is initialized by the values looked up from RT using (n, kj
                        ) as a search key. They are also inserted into relevance queue qn
                         of n with their keyword nodes unspecified (Line 8∼14). The relevance r and next relevance r′ of the current entry are en-queued into qn
                         in Line 15. Note that if the current entry is not the first entry of n from the list Li
                        , an item in qn
                         previously inserted with a next relevance value and no keyword node for the current entry should be updated using the keyword node in the entry. Then, the next relevance r′ is maintained as nextScoren,i
                         and the worst score and best score of n are computed from the relevances in qn
                         and maxNextScoren
                        , regardless of the relevance curScorei
                         at the current scan position in each list Li
                         in L′(Q) (in Line 16∼17). Processing the current node in the top-k queue or candidate queue and checking the fulfillment of termination condition in Eq. (3) are the same as in the basic algorithm (Refer to Line 11∼22 of Algorithm 1), but the correct root nodes of top-k answer trees can be determined much earlier than the basic method. It should be also noted that since the worst and best scores of the nodes in the top-k queue or candidate queue do not change except the node whose entry is currently read from a list, we do not have to conduct periodic update and re-organization of the queues shown in Line 23∼24 in Basic query processing algorithm in Fig. 3 and thus can process queries more efficiently than the basic method.

As defined earlier in Section 3, the proposed answer structure has no such constraint that an answer tree should contain all the keyword terms in the query, and our relevance measure is to find answer trees having the keyword nodes most relevant to the root nodes, regardless of which query keywords are concerned. For that reason, in the query processing algorithm presented above, a relevance queue for each root node maintains top-p pairs of a keyword and keyword node most relevant to the root node without considering keywords. However, if a user’s information need underlying the given keyword query is to find sub-trees which contain all the keywords, the proposed answer structure cannot fully satisfy the user’s need.

To handle keyword queries with AND semantics effectively, we modify our method to search for a restricted form of answer trees which include at least one keyword node for every keyword in the queries. Specifically, the relevance queue structure and the worst and best score metrics should be changed in the query processing scheme.

As mentioned above, the first entry of a node n in the inverted list for a keyword k, denoted by firstEntry(n, k), provides a keyword node for k which is the most relevant to n. Thus, given a query Q of l keywords with AND semantics, the keyword nodes in firstEntry(n, ki
                        )′s for all keywords ki
                         (1⩽
                        i
                        ⩽
                        l) in Q should be included in the answer tree rooted at node n. Considering this, we store the pairs of the keyword node and relevance in firstEntry(n, ki
                        )′s separately from the relevance queue qn
                         of n to maintain them until the list scan terminates. As shown in the enhanced search algorithm, all the relevance values in firstEntry(n, ki
                        )′s can be obtained either from the entries themselves or from the relevance lookup table when an entry of n is first retrieved from an inverted list in L(Q). The relevance queue qn
                         maintains at most p
                        −
                        l entries of n which are most relevant to n besides firstEntry(n, ki
                        )′s, where p is the parameter for the answer structure defined in Definition 2.

The worst and best score metrics in Eqs. (4) and (5) are also changed in order that the relevance values in firstEntry(n, ki
                        )′s are always considered in computation of the worst and best scores of n. Assuming that firstRels(n) is a multi-set of the relevance values in firstEntry(n, ki
                        )′s for all ki
                         in Q and 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                 
                                 
                                    ′
                                 
                              
                              =
                              {
                              r
                              |
                              (
                              s
                              ,
                              r
                              )
                              ∈
                              
                                 
                                    q
                                 
                                 
                                    n
                                 
                              
                              ,
                              r
                              ⩾
                              
                                 
                                    maxNextScore
                                 
                                 
                                    n
                                 
                              
                              }
                           
                        , we have
                           
                              (6)
                              
                                 worstScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          firstRels
                                          (
                                          n
                                          )
                                       
                                    
                                 
                                 r
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                q
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                 
                                 r
                              
                           
                        and
                           
                              (7)
                              
                                 bestScore
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          firstRels
                                          (
                                          n
                                          )
                                       
                                    
                                 
                                 r
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                n
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                                 r
                                 +
                                 
                                    
                                       maxNextScore
                                    
                                    
                                       n
                                    
                                 
                                 ·
                                 (
                                 p
                                 -
                                 l
                                 -
                                 |
                                 
                                    
                                       R
                                    
                                    
                                       n
                                    
                                    
                                       ′
                                    
                                 
                                 |
                                 )
                              
                           
                        When the scanning of the lists terminates, the keyword nodes in firstEntry(n, ki
                        )′s as well as those in qn
                         are used to derive an answer tree rooted at node n if n belongs to top-k queue T.

@&#PERFORMANCE EVALUATION@&#

In this section we evaluate effectiveness and efficiency of the proposed approach including basic method (BM) and enhanced method (EM-RL) by experiments using real datasets. We compare their performances with the BLINKS method (He et al., 2007) which adopts distinct root semantics and inverted list-style index similar to our approach.

In the implementation of the proposed methods in Java, we use a hash table to maintain data associated with each node in the graph whose entries have been read from the inverted list index, such as a relevance queue qn
                     , nextScoresn
                     , and the reference to the entry in top-k queue or candidate queue. The top-k queue and candidate queue are implemented using a Fibonacci heap. The top-k queue stores the ID’s of current top-k nodes using their worst scores as keys in order to find the min-k node having the smallest worst score in the queue efficiently. Meanwhile, the candidate queue stores node ID’s using the best scores of nodes as keys in order to find the node having the largest best score quickly and evaluate the termination condition in Eq. (3) in an efficient way.

As for the test graph databases, we use Mondial
                        2
                        
                           http://www.dbis.informatik.uni-goettingen.de/Mondial/
                        
                     
                     
                        2
                     , IMDB
                        3
                        
                           http://www.imdb.com/
                        
                     
                     
                        3
                     , and DBLP
                        4
                        
                           http://dblp.uni-trier.de/xml/
                        
                     
                     
                        4
                      datasets which are popularly used for performance evaluation in the literature. They have geographic data, movie-related data, and computer science bibliographic data, respectively. From Mondial dataset, we built a graph which has 6,441 nodes, 25,865 edges, and 14,131 keyword terms. In IMDB database, we selected data on 147K movies released in 2006–2010, as well as data on the actors, actresses, and directors related with the movies, and derived a graph consisting of about 831K nodes, 2.82M edges, and 303K keyword terms. From DBLP bibliography database, we extracted data on papers, authors, conferences, and citations to build a graph having about 2.24M nodes, 8.88M edges, and 460K keyword terms. For each dataset, we used JGraphT
                        5
                        
                           http://www.jgrapht.org/
                        
                     
                     
                        5
                      library to construct a graph and compute the shortest paths between the nodes. We extracted keyword terms from text type attributes of nodes in the graph and computed the relevance of a node to a keyword term in the node using Lucene
                        6
                        
                           http://lucene.apache.org/java/docs/index.html
                        
                     
                     
                        6
                      library. The shortest paths between pairs of nodes in the graph are calculated using Bellman–Ford algorithm. In our experiment, we have only considered pairs of nodes that are close to each other within a shortest distance of 4 for the sake of efficiency and effectiveness. Then the relevance of a node to a keyword term contained in a certain node can be computed as defined in Section 3. Based on the results, we built basic and extended inverted lists for the given graph as proposed in Sections 4 and 5.

In the first experiment, we evaluate the precision of search results produced by our methods and BLINKS. Test queries used in the experiments are shown in Table 1
                     , which have been selected by the authors reflecting a variety of information needs on the test datasets. Most queries have both Boolean-AND and OR semantics in their keywords while queries Q4, Q5, Q13, Q14, Q15, Q22, Q23, and Q26 have only AND semantics among their keywords. Given a query, the precision of a set 
                        
                           Res
                           [
                           1
                           .
                           .
                           k
                           ]
                        
                      of top-k answer trees returned as a search result is measured by 
                        
                           P
                           @
                           k
                           =
                           
                              
                                 |
                                 Res
                                 [
                                 1
                                 .
                                 .
                                 k
                                 ]
                                 ∩
                                 Rel
                                 |
                              
                              
                                 k
                              
                           
                        
                     , where Rel is a set of sub-trees in the graph which are considered relevant to the query. Relevance assessments for the answer trees to the test queries were conducted by five independent adjudicators who were not aware of the considered search methods. Relevance judgment for an answer tree was done on a binary scale, i.e., relevant or non-relevant, based on the original information need underlying each query. The multiple independent judgments of the assessors were integrated into the final assessment on the answer by selecting the majority opinion among them. In the experiment of our approach, parameter p was set to 1.5 times the number of keywords in the query.


                     Fig. 6
                      shows the precisions of the top-10 and top-20 answers obtained by our approach and BLINKS for the test queries. Note that the proposed methods, BM and EM-RL, produce the same answers to a given query. The experimental result shows that the precision of our approach is higher than or equal to that of BLINKS in 73% of the query evaluations. The average precisions of our approach and BLINKS for the given queries are respectively about 0.70 and 0.60 for top-10 search and are about 0.64 and 0.53 for top-20 query processing. It means that search effectiveness in terms of precision at top-20 answers improves by about 21% compared to the BLINKS method. We can observe that our method outperforms BLINKS for the most of the test queries having both AND and OR semantics (specifically, in about 80% of the top-10 and top-20 query evaluations) while BLINKS achieves higher precision than our method for many queries with AND-only semantics (specifically, in about 63% of the query evaluations). This is mainly due to the fact that our method finds sub-trees containing a set of keyword nodes chosen for any given keyword to which its root node is most relevant in the graph while the previous method such as BLINKS searches only for the sub-trees having a keyword node for each and every keyword in the query. On the other hand, Fig. 7
                      shows experimental results of EM-RL method optimized for the queries with AND-only semantics which was described in Section 5.3. We can see that the adapted method, denoted by EM-RL-A, achieves precision better than or equal to that of BLINKS in the most evaluations of the queries with AND-only semantics, except in top-10 processing of Q22 and top-20 processing of Q15. Specifically, the average precision of the top-20 answers to the queries obtained by EM-RL-A is about 0.58, which is better than the average precisions of 0.48 and 0.46 achieved by BLINKS and BM/EM-RL, respectively. Note that if we use EM-RL and EM-RL-A adaptively for the different kinds of test queries, we can achieve average precisions of 0.76 and 0.68 for top-10 and top-20 answers, respectively, which are about 26% higher than those of BLINKS. Thus, we observe that our approach can produce more effective answers than the previous method for keyword queries with various semantics.

Next, we measured precision of the top-k answers obtained by our method varying the value of parameter p. As defined in Section 3, it denotes the number of pairs of a keyword and keyword node which are selected to derive an extended answer tree in our approach. The chart in Fig. 8
                      shows the average precision of the top-10 answers to the test queries on Mondial dataset varying p from 4 to 8. We can observe that average precision improves as the value of p increases, but it is saturated when p is 6. This implies that including more keyword nodes irrespective of keywords may results in an answer tree less relevant to the user’s need.

In the third experiment, we evaluate performances of the proposed search methods as well as BLINKS by measuring their execution time in processing top-k queries. We generated and executed 20 test queries, each of which has 4 keywords, on IMDB dataset for different values of k varying from 5 to 30 by 5. The parameter p used in our methods is set to 1.5 times the query size. Periodic updates of the priority queue T and C in BM are conducted after reading every 3,000 entries from the inverted lists. In the results shown in Fig. 9
                     , execution time of the proposed method EM-RL is shown to be worse than that of BLINKS by a factor of 6.5 on the average. This is mainly due to the overhead of our approach to find effective top-k answer trees having the proposed extended structure, which requires identifying p pairs of a keyword and keyword node most relevant to each candidate root of an answer tree. When comparing the performances of our methods, query processing time of EM-RL is reduced, compared to that of BM, by about 56.5% for top-5 answers and 83.6% for top-30 answers on the average. As k grows from 5 to 30, average execution time of BM increases by a factor of about 3.5 while EM-RL shows relatively stable performances as its execution time increases by only about 31.9%. This indicates that enhanced method utilizing the extended indexing scheme and the relevance lookup table provides great benefits on the execution performance especially when a large number of answers should be obtained.

We also evaluated execution time of the considered methods with respect to different query sizes, i.e. the number of keywords in a query. Varying the query size from 2 to 6, we evaluated 20 test queries of each query size to find top-10 answers from IMDB dataset. Parameter p is set to 1.5 times the query size and queue update period in BM is set to every 3,000 entries. The result in Fig. 10
                     (a) shows that average execution times of all the methods increase as query size grows and the performance of BM is severely degraded in particular. Specifically, as the query size grows from 3 to 6, the average execution time of BM increases by a factor of about 3.6 while that of EM-RL grows by about 2.9 times. Average execution time of EM-RL is reduced by about 75.4% compared to that of BM when the query size is 6. These results imply that EM-RL is scalable with query size and is much more efficient than BM for large queries.

Finally, we investigate performances of our methods with respect to parameter p used in our approach. Varying the value of p from 4 to 8, we evaluated a set of 20 test queries having 4 keywords and finding top-10 answers over IMDB dataset. Fig. 10(b) shows that as the value of p grows from 4 to 8, the average execution time of BM increases significantly by a factor of about 13.3 while it does not take two times for EM-RL. As a result, the average execution time of EM-RL is reduced by about 86.9% with respect to BM when p is 8. Thus, we consider that the enhanced search method exploiting relevance lookup is also scalable with parameter p, i.e., the number of pairs of a keyword and keyword node chosen for an answer tree.

@&#CONCLUSION@&#

In this paper, we propose a new ranked keyword search method for graph databases. To find more effective top-k answers to a given query, we define a new measure of relevance of a node to a keyword query and suggest an extended and flexible answer structure which may have multiple keyword nodes for a keyword in the query. For efficient top-k query processing based on the proposed answer structure and relevance measure, we design an inverted list index which stores reachability and relevance information of the nodes with respect to each keyword term. Then we present a query processing algorithm exploiting the inverted list to find top-k answer trees most relevant to the given query. To enhance the performance of the algorithm, we extend the inverted list by storing in the list entry an additional relevance value of a related entry in the list. Furthermore, we also utilize a relevance lookup table which stores the largest relevance values of the nodes to each keyword term. These techniques enable the search method to estimate a range of relevance score of a node more precisely and to find top-k answer trees more quickly than the basic method. Additionally, we proposed a query processing algorithm which can find more effective answers to the queries with AND-only semantics.

We have evaluated effectiveness and efficiency of the proposed methods by experiments using real datasets and various test queries. The result shows that precision of the top-k answers obtained by our approach is higher than that of the answers by a pervious method BLINKS for the most queries. Thus we observe that top-k answer trees based on the proposed structure and relevance measure can satisfy users’ various information needs better than conventional answer structures. The execution performance of the proposed search algorithm is shown to be worse than the previous method, mainly due to the overhead incurred by adopting the new answer structure. However, the enhanced method based on the extended inverted list and relevance lookup table executes much more efficiently than the basic method, particularly for finding a large number of top-k results. The enhanced method is also scalable with respect to the number of keywords in the query, the number of answer trees to be found, and the number of keyword nodes included in an answer tree.

As for future work, we plan to elaborate the proposed answer structure, inverted list index, and query processing algorithm to enable evaluation of keyword queries and multi-word phrase queries over nodes as well as edges in the graph. We also consider exploiting the multi-granular graph representation and search strategy introduced in Dalvi et al. (2008) to improve the performance of our method.

@&#REFERENCES@&#

