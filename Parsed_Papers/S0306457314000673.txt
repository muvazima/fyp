@&#MAIN-TITLE@&#A model-based evaluation of data quality activities in KDD

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           MRDQA: a model-based approach for supporting the Data Quality task on KDD.


                        
                        
                           
                           Evaluation of quality requirements of weakly-structured data via model-checking.


                        
                        
                           
                           A fine-grained quality analysis of the cleansing procedures effectiveness.


                        
                        
                           
                           Automatic identification of error-patterns and interactive visualisation.


                        
                        
                           
                           Experiments done on a real scenario making data publicly available.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Data quality

Data cleansing

Model checking

Real-life application

@&#ABSTRACT@&#


               
               
                  We live in the Information Age, where most of the personal, business, and administrative data are collected and managed electronically. However, poor data quality may affect the effectiveness of knowledge discovery processes, thus making the development of the data improvement steps a significant concern.
                  In this paper we propose the Multidimensional Robust Data Quality Analysis, a domain-independent technique aimed to improve data quality by evaluating the effectiveness of a black-box cleansing function. Here, the proposed approach has been realized through model checking techniques and then applied on a weakly structured dataset describing the working careers of millions of people. Our experimental outcomes show the effectiveness of our model-based approach for data quality as they provide a fine-grained analysis of both the source dataset and the cleansing procedures, enabling domain experts to identify the most relevant quality issues as well as the action points for improving the cleansing activities.
                  Finally, an anonymized version of the dataset and the analysis results have been made publicly available to the community.
               
            

@&#INTRODUCTION@&#

Nowadays, huge masses of people’s data are available, thanks to the wide use of Information Systems, which represent the back-end of an increasing number of services and applications. Actually, public and private organizations recognise the value of data as a key asset to deeply understand social, economic, and business phenomena and to improve competitiveness in a dynamic business environment, as pointed out in several works (Batini, Cappiello, Francalanci, & Maurino, 2009; Fox, Levitin, & Redman, 1994; Madnick, Wang, Lee, & Zhu, 2009). Indeed, as Fayyad, Piatetsky-Shapiro, and Smyth (1996) remarks while introducing the KDD process, “the value of storing volumes of data depends on our ability to extract useful reports, events and trends, support decisions and policy based on statistical analysis and inference.” In the last years, the data quality improvement and analysis techniques have become an essential part of the KDD process as they contribute to guarantee the believability of the overall knowledge process,
                        1
                        Here the term believability is intended as “the extent to which data are accepted or regarded as true, real and credible” (Wang & Strong, 1996).
                     
                     
                        1
                      making the reasoning over data a very significant concern (Fisher, Lauría, Chengalur-Smith, & Wang, 2012; Herrera-Viedma & Peis, 2003; Holzinger, Yildirim, Geier, & Simonic, 2013; Pasi, Bordogna, & Jain, 2013a; Sadiq, 2013). In this paper we aim to draw the attention to data quality in the context of KDD.

Indeed, most researchers agree that quality of data is frequently poor, and this represents a problem in practical applications of KDD since according to the “garbage in, garbage out” principle, dirty data can have unpredictable effects on the information derived from them, as noted by Fox et al. (1994), Levitin and Redman (1995), Ballou and Tayi (1999), Hipp, Güntzer, and Grimmer (2001), Haug, Zachariassen, and Van Liempd (2011), Dasu (2013).

In recent years industrial and academic communities have spent a great effort to address data quality issues (e.g., by performing quality analysis and improvement, data visualisation and management, data cleansing, etc.) both from a practical and a theoretical point of view, as studied by Barateiro and Galhardas (2005), Pipino, Lee, and Wang (2002), Wang and Strong (1996). In this regard, Batini and Scannapieco (2006) reported that a gap between practice-oriented approaches and formal research contributions still exists in this field. Indeed, from an industry perspective, a lot of off-the-shelf tools are available, but often they lack of formality in addressing domain independent problems, as the case of the ETL tools.
                        2
                        The ETL (Extract, Transform and Load) is an approach supporting the data preprocessing and transformation tasks in the KDD process (Fayyad et al., 1996). The data extracted from a source system undergo a set of transformations that analyse, manipulate and then cleanse the data before loading them into a Datawarehouse.
                     
                     
                        2
                      In such tools a quite relevant amount of the data quality analysis and cleansing design has still to be done manually or by ad hoc developed routines, that may be difficult to write and maintain (Rahm & Do, 2000). On the other side, theoretical formalisms are sound and rigorous, but they often require a strong background from practitioners, reason that prevents their large-scale diffusion.

Within this work we support the idea that model-based verification approaches (model checking for instance) can support the Data Quality task of the KDD process in real-life situations by:
                        
                           (i)
                           modelling data evolution over time in a natural way (e.g, as path on a graph). This allows domain experts to concentrate on what quality constraints need to be modelled rather than how to verify them, thus supporting the definition and formalisation of domain related quality requirements;

evaluating the effectiveness of cleansing activities performed through a practice-oriented approach (like the Extraction, Transformation, and Loading used in data warehousing).

In this regard, here we present the Multidimensional Robust Data Quality Analysis, a novel technique we defined to formalise and automatically verify both the quality of the data and the robustness of an industrial cleansing process. The technique has been realised by using a model-checking based tool. Furthermore, we report our experience in the application of such technique to a public administration dataset composed by more than 21 million items framed in the context of the Italian Labour Market Domain, then providing a (smaller) database and the experimental results to the community.

Huge amounts of data describing people behaviours are collected by the Information Systems of enterprises and organizations. Such data often have an unexpressed informative power, indeed the study of relations and correlations among them allows domain experts to understand the evolution of subtended behaviours or phenomena over time, as recently outlined by Holzinger (2012, 2011), Wong, Xu, and Holzinger (2011), Lovaglio and Mezzanzanica (2013). Among the time-related data, the longitudinal data (i.e., repeated observations of a given subject, object or phenomena at distinct time points, see, e.g., Bartolucci, Farcomeni, & Pennoni (2012)) have received much attention from several academic research communities as they are well-suited to model many real-world instances, including labour and healthcare domains, see, e.g. (Devaraj & Kohli, 2000; Hansen & Järvelin, 2005; Holzinger, 2012; Holzinger & Zupan, 2013; Lovaglio & Mezzanzanica, 2013; Prinzie & Van den Poel, 2011).

In such a context graphs or tree formalisms, which are exploited to model weakly-structured data, are deemed also appropriate to model the expected data behaviour, that formalise how the data should evolve over time. In this regard, Holzinger (2012) has recently clarified that a relationship exists between weakly-structured data and time-related data. Namely, let 
                        
                           Y
                           (
                           t
                           )
                        
                      be an ordered sequence of observed data, e.g., subject data sampled at different time 
                        
                           t
                           ∈
                           T
                        
                     , the observed data 
                        
                           Y
                           (
                           t
                           )
                        
                      are weakly structured if and only if the trajectory of 
                        
                           Y
                           (
                           t
                           )
                        
                      resembles a random walk (on a graph). The following example should help in clarifying the matter.

Let us introduce the Mobile Phone Tracking Example. The dataset in Table 1
                         shows the events recorded by a mobile telephone operator for lawful interception purposes.
                           3
                           Lawful Interception is a security process where a service provider or a network operator collects individuals intercepted data or communications on behalf of law enforcement officials, see (European Telecommunications Standards Institute ES 201 671, 2009) for more details.
                        
                        
                           3
                         The data describe mobile phones connecting to cells of a cellular network, performing calls, exchanging messages, and data packets. Such data represent a log of the activities that a law enforcement agency can request for investigation. Each record reports information about: the MS-ID (Mobile Station ID, i.e. an ID identifying the mobile phone involved); the BTS-ID (the ID of the base transceiver station to which the Mobile Phone is connected); and the Event-Type. For the sake of simplicity, we reduce the several existing event types to cell-in, cell-out, and traffic. The cell-in event happens when a mobile phone starts being served by a BTS (Base Transceiver Station), e.g. the mobile phone is switched on or it enters into the BTS coverage area. The cell-out event takes place when the mobile phone is no longer served by the BTS where it has previously performed a cell-in (this can be due to the mobile phone being switched-off, or to the exit from the BTS coverage area). The traffic event is recorded when a call is initiated, or a message is sent or received, or some data are exchanged by the phone. The Timestamp value reports the call start time or the message/data packet send time.

Intuitively, one could model the longitudinal data evolution on a graph, then it could apply any graph-search to verify if the longitudinal data sequence (i.e., the trajectory) is “correct” or not (i.e., if it satisfies or not a set of quality requirements). To this aim, a mobile phone event sequence should evolve according to the automaton described in Fig. 1
                        (a). Unfortunately, the real data do not fully comply with these criteria: several cell-in can be found in the same cell (with no cell-out in between), several traffic events have no previous cell-in on the BTS, etc. This is mainly due to signal drop issues affecting the radio connections. Let us suppose that the elapsed intervals should be computed for analysis purposes i.e., the intervals when a mobile phone is served by (and thus being into) a BTS. Unfortunately the data quality issue may prevent or affect such intervals computation. Note that, as we discuss in Section 3, modelling such quality requirements through functional dependencies (FDs) may be a hard task since they mainly work on attributes rather than tuples, even though their expressivity has been recently revisited and improved, see Bravo, Fan, Geerts, and Ma (2008).

Actually, evaluating and improving the quality of a data source archive and, in turn, the effectiveness of a cleansing process is a challenging task while the comparison between archive contents against real data is often either unfeasible or very expensive (e.g. lack of alternative data sources, cost for collecting the real data, etc.). In such a case, cleansing procedures based on business rules still represent the most adopted solution by industry, as proved by the diffusion of several open source and commercial tools, see (Barateiro & Galhardas, 2005; Thomsen & Pedersen, 2005) for a survey. A reliable answer to questions like “How good are the adopted data cleansing processes?” becomes quite relevant, especially when formalising and measuring such “goodness” can strengthen the believability of the overall knowledge discovery process.

Here we support the idea that a model-driven verification of data cleansing activities can strengthen the effectiveness of the KDD process, by providing to data mining algorithms a more reliable cleansed dataset. The contribution of this paper, which extends preliminary results from (Boselli, Cesarini, Mercorio, & Mezzanzanica, 2013), goes into three directions.
                           
                              •
                              First, we present and formalise the Multidimensional Robust Data Quality Analysis (MRDQA for short), a domain-independent iterative technique aimed to evaluate the effectiveness of a black-box cleansing function over a dirty dataset. Then, a visualisation technique is used to facilitate the understanding and assessment of the MRDQA results, namely the parallel-coordinates;

Second, we express the task of evaluating weakly structured data quality as a model checking problem, then we implemented the MRDQA using the UPMurphi tool (Della Penna, Intrigila, Magazzeni, & Mercorio, 2009);

Third, we apply the MRDQA on a real-life government application in the field of Labour Market (The Italian Ministry of Labour & Welfare, 2012). Finally, a smaller version of the dataset we analysed and a demo are made available on line to the community.

The outline of this paper is as follows. In the next section we provide an overview of the related work while in Section 4 we introduce some background notions about data quality, model checking and the interaction between them. Then, in Section 5 we present the Multidimensional Robust Data Quality Analysis while in Section 6 we introduce the labour market domain. Section 7 extensively draws the experimental results as well as the characteristics of the online database. Finally, in Section 8 we sketch some concluding remarks providing in Appendix A the code used to model the labour market domain.

@&#RELATED WORK@&#

The data quality analysis and improvement tasks have been the focus of a large body of research in different domains, that involve statisticians, mathematicians and computer scientists, working in close cooperation with application domain experts, each one focusing on its own perspective (Abello, Pardalos, & Resende, 2002; Fisher et al., 2012).

To give a few examples, statisticians always fought for better data quality by applying: data mining and machine learning techniques for data edits (Fellegi & Holt, 1976; Mayfield, Neville, & Prabhakar, 2010; Winkler, 1997), probabilistic record linkage (Fellegi & Sunter, 1969; Newcombe & Kennedy, 1962; Winkler, 2000), and error detection (Elmagarmid, Ipeirotis, & Verykios, 2007; Winkler, 2004). On the other side, computer scientists developed algorithms and tools to ensure data correctness by paying attention to the whole Knowledge Discovery process, from the collection or entry stage to data visualisation (Clemente, Kaba, Rouzaud-Cornabas, Alexandre, & Aujay, 2012; Fox et al., 1994; Holzinger, Bruschi, & Eder, 2013; Ferreira de Oliveira & Levkowitz, 2003), exploiting both hard and soft computing techniques, see e.g. (Bertossi, 2006; Chomicki & Marcinkowski, 2005b; Hipp et al., 2001; Yu, Wang, & Lai, 2006).

Usually, the quality evaluation task in the literature is related to the data cleansing (or cleaning) problem, which basically consists in the identification of a set of activities to cleanse a dirty dataset. In this regard, a common technique is record linkage (also known as object identification, record matching, merge-purge problem) which aims to bring together corresponding records from two or more data sources. The purpose is to link the data to a corresponding higher quality version and to compare them (Elmagarmid et al., 2007). An alternative approach uses Business Rules identified by domain experts to cleanse the dirty data. The cleansing procedures can be implemented in SQL or in other tool specific languages.

This paper handles the problem of data quality verification in terms of consistency (as specified in Section 4.1) by mapping both the data dynamics and the consistency constraints over a finite state system, then using model checking to verify them.

Finite State Systems in the context of data (and Formal Methods in general) have been investigated in the areas of databases and artificial intelligence. Chomicki (1995) basically encodes bounded database history over Büchi automata to check temporal constraints. The purpose of Chomicki (1995) is to build an efficient framework to perform temporal queries on databases while no attention is paid to the data quality issues. Indeed, the author declares that the work focuses on transaction time databases and it is assumed that the stored data exactly correspond to the real world ones. Formal verification techniques were applied to databases with the aim to prove the termination of triggers by exploiting both explicit model checking (Choi, Tsuchiya, & Kikuno, 2006) and symbolic techniques (Ray & Ray, 2001). The use of CTL model checking has been investigated for semistructured data retrieval, whether XML based (Neven, 2002) or web based (Dovier & Quintarelli, 2002) as well as to solve queries on semistructured data (Afanasiev, Franceschet, Marx, & de Rijke, 2004; Dovier & Quintarelli, 2002; Dovier & Quintarelli, 2009).

In the database area, a lot of works have been focusing on constraint-based data repair for identifying errors by exploiting FDs (Functional Dependencies), multivalued dependencies, join dependencies, and inclusion dependencies. However, as introduced in Section 4.1, they are not suited for specifying constraints on longitudinal or historical data (Chomicki, 1995; Fan, 2008; Vardi, 1987). Specifically, Vardi (1987) motivated the usefulness of formal systems in databases by observing that FDs are only a fragment of the first-order logic used in formal methods while Fan, Li, Ma, Tang, and Yu (2010) observed that, even though FDs allow one to detect the presence of errors, they have a limited usefulness since they fall short of guiding one in correcting the errors.

Two very effective approaches based on FDs are database repair (Chomicki & Marcinkowski, 2005a; Greco, Greco, & Zumpano, 2001) and consistent query answering (Arenas, Bertossi, & Chomicki, 1999; Bertossi, 2006). The former aims to find a repair, namely a database instance that satisfies integrity constraints and minimally differs from the original (maybe inconsistent) one. The latter approach tries to compute consistent query answers in response to a query, namely answers that are true in every repair of the given database, but the source data is not fixed. Unfortunately, finding consistent answers to aggregate queries is a NP-complete problem already using two (or more) FDs (Bertossi, 2006; Chomicki & Marcinkowski, 2005b). To mitigate this problem, recently a number of works have exploited heuristics to find a database repair, as (Cong, Fan, Geerts, Jia, & Ma, 2007; Kolahi & Lakshmanan, 2009; Yakout, Berti-Équille, & Elmagarmid, 2013). They seem to be very promising approaches, even though their effectiveness have not been evaluated on real-world domains.

More recently, the NADEEF (Dallachiesa et al., 2013) tool has been developed for creating a unified framework able to merge the most used cleansing solutions by both academy and industry. It provides a programming interface that would facilitate the user in expressing quality constraints - and thus in cleansing the data – through business rules, conditional functional dependencies, matching dependencies, and denial constraints. In our opinion NADEEF gives an important contribution in the field of data cleansing also providing an exhaustive overview about the most recent (and efficient) solutions for cleansing the data. Indeed, as the authors remark, consistency requirements are usually defined on either a single tuple, two tuples or a set of tuples. The first two classes are enough for covering a wide spectrum of basic data quality requirements for which FD-based approaches are well-suited. However, the latter class of quality constraints (that NADEEF does not take into account according to its authors) requires reasoning with a finite (but not bounded) set of data items over time as the case of longitudinal data, and this makes the exploration-based technique a good candidate for that task. More specifically, AI planning can enable domain experts to express complex quality requirements and to effortlessly identify best suited cleansing actions for a particular data quality context.

Finally, from an industry point of view, a lot of off-the-shelf tools are available and well-supported, but they often lack of formality in addressing domain independent problems, as the case of several ETL tools.
                        4
                        In the ETL approach (Extract, Transform and Load) data extracted from a source system pass through a sequence of transformations, that analyse, manipulate and then cleanse the data before loading them into a Datawarehouse.
                     
                     
                        4
                      In such tools a quite relevant amount of the data analysis and cleaning work has still to be done manually or by ad hoc routines, that may be difficult to write and maintain, as discussed by Rahm and Do (2000).

@&#BACKGROUND@&#

In this section we first briefly discuss about data quality, then we introduce some background notions about the model checking technique and the UPMurphi tool, which will be used in the remainder of the paper. Finally, we connect all these concepts by introducing the finite state event databases and datasets, then describing how to perform data consistency verification through model checking.


                        Data quality is a broad concept and it has been widely addressed in the literature of several research communities. In this regard, the most common and concise definition of data quality is given by Wang and Strong (1996), which define data quality as “fitness for use”. This implies that data quality is a domain and goal dependent concept, thus a dataset can be considered appropriate for one use while may not be suitable for a different one. In such direction, Kahn, Strong, and Wang (2002) considers the quality of data as “the extent to which data are conform to a given specification” while, in a more extensive way, Redman (2001) states that “data are of high quality if they are fit for their intended uses in operations, decision making, and planning. Data are fit for use if they are free of defects and possess desired features”.

In this paper we focus on consistency, a quality dimension which Batini and Scannapieco (2006) refer to “the violation of semantic rules defined over (a set of) data items where e.g., items can be tuples of relational tables or records in a file”.

Model checking (see e.g., Clarke, Grumberg, & Peled (1999), Baier & Katoen (2008)) is a hardware/software verification technique to determine whether a model system obeys a specification of its intended behaviour. The model is described in terms of state variables, whose evaluation determines a state, and transition relations between states, which specify how the system can move from a state to the next one as a consequence of a given input action.

Generally speaking, given a model of a dynamic system (i.e., a transition system) and a formal property to be verified on it, a model checking tool verifies whether this property holds for each state of that model or not. In the latter case, the model checker returns the error-trace, describing how the system reached the error.

Focusing on explicit model checking, it performs an exhaustive search on the transition system and it progressively collects the complete set of the system states (also called the system state space). Thus, such technique can work on Finite State System (FSS for short) only. To clarify this concept, let us consider a system model with a finite set of state variables 
                           
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                 
                              
                           
                        . If each variable 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         ranges over a (nonempty) set 
                           
                              
                                 
                                    D
                                 
                                 
                                    i
                                 
                              
                           
                         of values, the state space is 
                           
                              S
                              =
                              
                                 
                                    D
                                 
                                 
                                    1
                                 
                              
                              ×
                              ⋯
                              ×
                              
                                 
                                    D
                                 
                                 
                                    n
                                 
                              
                           
                        , which enumerates all the possible system behaviours. If a particular system state cannot be actually reached (e.g., a variable can never be set to a specific value, even if it is in its domain), it will be never generated or analysed. This kind of state space exploration is also called reachability analysis.

Model checking algorithms are subject to the state explosion problem, since managing a large state space may require a very big storage space (usually RAM): however, the ability to generate only the system reachable states, and several space saving techniques helps mitigating the problem, see e.g. (Della Penna, Intrigila, Melatti, Tronci, & Venturini Zilli, 2004; Edelkamp & Jabbar, 2006).

For the sake of clarity, we formalise an FSS as follows.
                           Definition 1
                           Finite state system


                           A Finite State System (FSS) 
                                 
                                    S
                                 
                               is a 4-tuple (
                                 
                                    S
                                    ,
                                    I
                                    ,
                                    A
                                    ,
                                    F
                                 
                              ), where: S is a finite set of states, 
                                 
                                    I
                                    ⊆
                                    S
                                 
                               is a finite set of initial states, A is a finite set of actions and 
                                 
                                    F
                                    :
                                    S
                                    ×
                                    A
                                    →
                                    S
                                 
                               is the transition function, i.e. 
                                 
                                    F
                                    (
                                    s
                                    ,
                                    a
                                    )
                                    =
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                 
                               iff the system from state s can reach state 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          ′
                                       
                                    
                                 
                               via action a. Hence, we define:
                                 
                                    •
                                    a trajectory as a sequence 
                                          
                                             π
                                             =
                                             
                                                
                                                   s
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   s
                                                
                                                
                                                   1
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                
                                             
                                             
                                                
                                                   s
                                                
                                                
                                                   2
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   n
                                                   -
                                                   1
                                                
                                             
                                             
                                                
                                                   s
                                                
                                                
                                                   n
                                                
                                             
                                          
                                        where, 
                                          
                                             ∀
                                             j
                                             =
                                             0
                                             ,
                                             …
                                             ,
                                             n
                                             ,
                                             
                                                
                                                   s
                                                
                                                
                                                   j
                                                
                                             
                                             ∈
                                             S
                                          
                                        is a state, 
                                          
                                             ∀
                                             i
                                             =
                                             0
                                             ,
                                             …
                                             ,
                                             n
                                             -
                                             1
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             ∈
                                             A
                                          
                                        is an action and 
                                          
                                             F
                                             (
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             =
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                          
                                       . If π is a trajectory, we denote with 
                                          
                                             |
                                             π
                                             |
                                          
                                        the length of π given by the number of actions; Finally, we write 
                                          
                                             
                                                
                                                   π
                                                
                                                
                                                   s
                                                
                                             
                                             (
                                             k
                                             )
                                          
                                        (resp. 
                                          
                                             
                                                
                                                   π
                                                
                                                
                                                   a
                                                
                                             
                                             (
                                             k
                                             )
                                          
                                       ) to denote the state 
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   k
                                                
                                             
                                          
                                        (resp. the action 
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       );


                                       Reach(S) as the set of all states reachable from the initial ones.

Let 
                           
                              S
                           
                         be an FSS according to Definition 1 and let φ be a formula specifying a property to be satisfied on the system. Let a state 
                           
                              
                                 
                                    s
                                 
                                 
                                    E
                                 
                              
                              ∈
                              E
                           
                         be an error state if the invariant formula φ is not satisfied. Then, we can define the set of error states 
                        
                           
                              E
                              ⊆
                              S
                           
                         as the union of the states violating φ. Moreover, we limit the error exploration to at most T actions (the finite horizon), i.e. only sequences reaching an error 
                           
                              
                                 
                                    s
                                 
                                 
                                    E
                                 
                              
                              ∈
                              E
                           
                         within the finite horizon are detected. Note that this restriction has a limited practical impact in our contexts although being theoretically quite relevant, see Kroening, Clarke, and Yorav (2003), Biere, Cimatti, Clarke, Strichman, and Zhu (2003).

Model checking is traditionally used to explore and verify all the feasible execution paths of a system. Then, informally speaking a model checking problem is composed by a description of the FSS to be explored, a property to verify and a finite horizon. A feasible solution, i.e. the error trace (if any), is a trajectory leading the system from an initial state to an error one. More formally we can define the following.
                           Definition 2
                           Model Checking Problem and Solution


                           Let 
                                 
                                    S
                                 
                               = 
                                 
                                    (
                                    S
                                    ,
                                    I
                                    ,
                                    A
                                    ,
                                    F
                                    )
                                 
                               be an FSS. Then, a model checking problem (MCP in the following) is a triple 
                                 
                                    P
                                    =
                                    (
                                    S
                                    ,
                                    φ
                                    ,
                                    T
                                    )
                                 
                               where φ is the invariant condition and T is the finite horizon.

Then a feasible solution for 
                                 
                                    P
                                 
                               is a reachable trajectory π in 
                                 
                                    Reach
                                    (
                                    S
                                    )
                                 
                               s.t.: 
                                 
                                    ∃
                                    
                                       
                                          s
                                       
                                       
                                          I
                                       
                                    
                                    ∈
                                    I
                                 
                              , 
                                 
                                    |
                                    π
                                    |
                                    =
                                    k
                                    ,
                                    k
                                    ⩽
                                    T
                                    ,
                                    
                                       
                                          π
                                       
                                       
                                          s
                                       
                                    
                                    (
                                    1
                                    )
                                    =
                                    
                                       
                                          s
                                       
                                       
                                          I
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          π
                                       
                                       
                                          s
                                       
                                    
                                    (
                                    k
                                    )
                                    ∈
                                    E
                                 
                              .

The high formalisation and computational power of model checking has been applied to several contexts away from the HW/SW verification, from Fault-Tolerance to Control and AI Planning domains, see e.g. (Atlee & Gannon, 1993; Giunchiglia & Traverso, 2000). As a consequence, a number of model checking tools have been adapted and enhanced properly, see Bérard et al. (2010) for a survey. Here we use the UPMurphi tool (Della Penna et al., 2009; Della Penna, Magazzeni, & Mercorio, 2012), a model-checking-based universal planner containing algorithms directly derived from the explicit model checker Murphi (Dill, 1996). A detailed description of Murphi is out of the scope of this paper, however it is important to highlight that Murphi naturally supports first-order logic quantifiers in the model specification, which are unravelled through state enumeration.

Note that, even though UPMurphi is a planner, it exploits the well-known planning-via-model-checking paradigm (Giunchiglia & Traverso, 2000), that allows one to use a model checker for searching the planning state space, stopping the search when a goal state is found.

Moreover, UPMurphi has proved its effectiveness in dealing with several AI planning problems in both deterministic and non-deterministic domains (Della Penna et al., 2009; Della Penna, Intrigila, Magazzeni, & Mercorio, 2010a; Della Penna, Intrigila, Magazzeni, & Mercorio, 2010b; Della Penna, Intrigila, Magazzeni, Mercorio, & Tronci, 2011; Della Penna et al., 2012; Fox, Long, & Magazzeni, 2011; Fox, Long, & Magazzeni, 2012). Finally, UPMurphi presents three features useful for our purposes:
                              
                                 •
                                 it allows the use of C/C++ language constructs to model complex dynamics and to exploit external libraries to connect with other services (e.g., databases through ODBC drivers). This feature helps us to directly access to external data sources, since restrictions on accessing and duplicating archives are frequently enforced due to non-disclosure and secrecy agreements;

it was enhanced with a disk-based algorithm (Mercorio, 2013) for exploring the system dynamics, thus enabling the visit of huge graphs.

it is also a Universal Planner. A Universal Plan, first introduced by Schoppers (1987) is a set of policies, computed off-line, able to bring the system to the goal from any state reachable from the initial ones, the reader can see the contributions of Cimatti, Roveri, and Traverso (1998), Della Penna et al. (2012) for details. The universal planner output is a table (also known as controller) of <state,action> pairs describing which actions can be performed from each state to reach the goal. In this work we modify the UPMurphi universal plan algorithm to synthesise a Universal Checker, i.e., a taxonomy of all the inconsistencies affecting the data, as described in detail in Section 7.3.

Finite State Systems have been widely applied in the literature, also dealing with event-driven systems by mapping events onto actions e.g., see (Atlee & Gannon, 1993; Holzmann & Smith, 1999). Similarly, an Information System recording longitudinal data in a database can be viewed as an event-driven system by considering a database record as an event, i.e. a record content or a subset thereof is interpreted as the description of an external world event modifying the system state, while an ordered set of records represents an event sequence.

To this aim we introduce the following.
                           Definition 3
                           Let 
                                 
                                    R
                                    =
                                    (
                                    
                                       
                                          R
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          R
                                       
                                       
                                          n
                                       
                                    
                                    )
                                 
                               be a schema of a database relation.
                                 
                                    •
                                    An event 
                                       
                                          
                                             e
                                             =
                                             (
                                             
                                                
                                                   r
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   r
                                                
                                                
                                                   m
                                                
                                             
                                             )
                                          
                                        is a record of the projection 
                                          
                                             (
                                             
                                                
                                                   R
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   R
                                                
                                                
                                                   m
                                                
                                             
                                             )
                                          
                                        over 
                                          
                                             Q
                                             ⊆
                                             R
                                          
                                        with 
                                          
                                             m
                                             ⩽
                                             n
                                          
                                       , such that 
                                          
                                             
                                                
                                                   r
                                                
                                                
                                                   1
                                                
                                             
                                             ∈
                                             
                                                
                                                   R
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   r
                                                
                                                
                                                   m
                                                
                                             
                                             ∈
                                             
                                                
                                                   R
                                                
                                                
                                                   m
                                                
                                             
                                          
                                       ;

An event sequence is a ∼-ordered sequence of events 
                                          
                                             ∊
                                             =
                                             
                                                
                                                   e
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   e
                                                
                                                
                                                   n
                                                
                                             
                                          
                                       . Indeed, a total order relation ∼ on events can be defined such that 
                                          
                                             
                                                
                                                   e
                                                
                                                
                                                   1
                                                
                                             
                                             ∼
                                             
                                                
                                                   e
                                                
                                                
                                                   2
                                                
                                             
                                             ∼
                                             …
                                             ∼
                                             
                                                
                                                   e
                                                
                                                
                                                   n
                                                
                                             
                                          
                                       ;

A Finite State Event Dataset (FSED) 
                                          
                                             
                                                
                                                   S
                                                
                                                
                                                   i
                                                
                                             
                                          
                                        is an event sequence derived from a longitudinal dataset, while a Finite State Event Database (FSEDB) is a database S whose content is 
                                          
                                             S
                                             =
                                             
                                                
                                                   ⋃
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   k
                                                
                                             
                                             
                                                
                                                   S
                                                
                                                
                                                   i
                                                
                                             
                                          
                                        where 
                                          
                                             k
                                             ⩾
                                             1
                                          
                                       .

In the following we denote by 
                                 
                                    
                                       
                                          ∊
                                       
                                       
                                          i
                                       
                                    
                                 
                               a subsequence of ∊ from the first event to the one in position i.

In several domains it is advisable to split a (large) dataset into different subsets (e.g., for improving scalability). Then, each subset can be managed separately (e.g., parallel computation can be performed). From now on, the term FSED will be used to refer to a subset while the overall dataset will be called FSEDB.

Intuitively, the application of model checking techniques to data quality problems (as introduced in (Mezzanzanica, Boselli, Cesarini, & Mercorio, 2011)) is driven by the idea that a model describing the expected evolution of any event sequence can be used to verify if a dataset (called actual data) retrieved from a data source (e.g., a database) is compliant with such model. Then, the data consistency verification problem can be expressed as a model checking problem on FSSs: a solution for the latter (if any) is an inconsistent set of records for the former.

Performing a model-based data consistency evaluation requires the following steps: (1) to define a model of the data evolution, (2) to identify the consistency rules to be verified and (3) to verify the data source (e.g., the FSEDB introduced before) against the data evolution model and the consistency rules. A schematic representation of how this task can be accomplished by using a model checker is depicted in Fig. 1(b), which works as follows. From here on, without loss of generality, we refer to the consistency model as a model which encapsulates both the model of the data evolution and the consistency properties.
                           5
                           Generally, researchers often use the term model referring to the result of a modelling phase (see, e.g. Baier & Katoen (2008)), despite two distinct tasks are involved, namely to (1) represent the system evolution (i.e., the model) and (2) formalise the properties to be verified.
                        
                        
                           5
                        
                        
                           
                              
                                 Step 1 (Domain Modelling): A domain expert defines the consistency model describing the correct evolution of the data through the model checking tool language.


                                 Step 2 (Data Verification): An FSED 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                    
                                  is retrieved from the FSEDB source S. The model checker looks for an error trace. A solution (if any) represents an inconsistency affecting the dataset 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                    
                                 . Otherwise 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                    
                                  is considered consistent.


                                 Step 3 (Iteration) Repeat step 2 for each 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       S
                                    
                                 .

The following example should clarify the matter. Let us consider the dataset introduced in Table 1. The information collected about a single mobile phone is an FSED 
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                              
                           , while the information of several of them is the FSEDB S.

An event 
                           
                              
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                              
                            is composed of the attributes MS-ID, Event Type, Cell-ID, and Timestamp, namely 
                              
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 (
                                 MS
                                 -
                                 
                                    
                                       ID
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       EType
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 Cell
                                 -
                                 
                                    
                                       ID
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       Timestamp
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           . Moreover, the total-order operator∼could be the binary operator<defined over the event’s attribute Timestamp, hence 
                              
                                 ∀
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       e
                                    
                                    
                                       j
                                    
                                 
                                 ∈
                                 E
                                 ,
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                                 <
                                 
                                    
                                       e
                                    
                                    
                                       j
                                    
                                 
                              
                            iff 
                              
                                 
                                    
                                       Timestamp
                                    
                                    
                                       
                                          
                                             e
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 <
                                 
                                    
                                       Timestamp
                                    
                                    
                                       
                                          
                                             e
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           . A simple consistency property could be “A mobile phone connected to cell A, cannot connect to a different cell unless it disconnects from A”. Finally, the finite horizon can be set to the maximum dataset cardinality, namely 
                              
                                 T
                                 =
                                 
                                    
                                       max
                                    
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       ⊆
                                       S
                                    
                                 
                                 |
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                                 |
                              
                           .

We can model this consistency property using an FSS. The consistency model is graphically represented in Fig. 1(a). The system state is composed of two variables, namely (1) the variable cell, which describes to which cell the mobile phone is connected and (2) the variable 
                              
                                 state
                                 ∈
                                 {
                                 con
                                 ,
                                 dis
                                 }
                              
                           , whereas con denotes a phone connected to a cell, dis otherwise.

The data source S can be a database instance (e.g., an actual FSEDB) to be verified against the consistency model. Note that for each different 
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                              
                            (i.e., for each different FSED) the model checker generates a different FSS modelling the 
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                              
                            consistency. In other words, each different FSS is instantiated according to the actual data, therefore each FSS will have its own state space.

To clarify this aspect, it is worth to describe a different domain where a similar approach is used.

Let us consider a discrete-time hybrid system
                              6
                              A Discrete Time Hybrid System is a formal model for mixed discrete–continuous systems which allows the presence of both continuous and discrete variables. As a characteristic, it operates on a discrete state and performs discontinuous state changes at discrete time points.
                           
                           
                              6
                            modelling a continuous domain where a car needs to cover a specified distance in the least possible time by incrementing or decrementing its current acceleration.

Clearly, due to the nonlinearity of the dynamics, discretising the time either every 10s or every 5s may generate different values for distance, velocity and acceleration, then resulting in different state spaces. As a consequence, the model evaluation through a model checker will generate different Finite State Systems according the discretisation time step chosen, see the Discretise and Validate approach of (Fox et al., 2012). Similarly, in our model, data (i.e., a 
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                              
                           ) play the same role that the time has in the car model: the model checker will generate and verify different FSSs according to the actual data. As a drawback, this behaviour prevents the identification of general patterns of data inconsistency, which could be useful for the purpose of generalizability. The following example should help in clarifying this concept.

Let us consider again the Mobile Phone Tracking example of Table 1 and let us focus on the inconsistent event sequences of two mobile phones: 
                              
                                 
                                    
                                       Mob
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 (
                                 cell
                                 -
                                 in
                                 ,
                                 03290
                                 )
                                 ,
                                 (
                                 cell
                                 -
                                 out
                                 ,
                                 03291
                                 )
                              
                            and 
                              
                                 
                                    
                                       Mob
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 (
                                 cell
                                 -
                                 in
                                 ,
                                 03120
                                 )
                                 ,
                                 (
                                 cell
                                 -
                                 out
                                 ,
                                 03288
                                 )
                              
                           , whereas respectively the 
                              
                                 
                                    
                                       EType
                                    
                                    
                                       i
                                    
                                 
                              
                            and 
                              
                                 Cell
                                 -
                                 
                                    
                                       ID
                                    
                                    
                                       i
                                    
                                 
                              
                            attributes only are reported, and very short sequences are showed for the sake of simplicity. The inconsistencies found share a common characteristic: the “cell-out” has been made on a cell different from the one where the last “cell-in” took place. We introduce the data abstraction to better manage such general inconsistencies. We replace the actual cell domain data 
                              
                                 
                                    
                                       D
                                    
                                    
                                       cell
                                    
                                 
                                 =
                                 {
                                 03120
                                 ,
                                 03288
                                 ,
                                 03290
                                 ,
                                 03291
                                 ,
                                 …
                                 }
                              
                            (whose cardinality can be very high although finite) with an abstract domain composed by a set of symbols. We can make an abstraction of the domain 
                              
                                 
                                    
                                       D
                                    
                                    
                                       cell
                                    
                                 
                              
                            by using only a reduced set of symbols, namely 
                              
                                 
                                    
                                       D
                                    
                                    
                                       cell
                                    
                                    
                                       abstract
                                    
                                 
                                 =
                                 {
                                 
                                    
                                       C
                                    
                                    
                                       X
                                    
                                 
                                 ,
                                 
                                    
                                       C
                                    
                                    
                                       Y
                                    
                                 
                                 }
                              
                            as described next.

The idea to produce an abstract model from a concrete one is not new (also known as abstract interpretation, see (Cousot & Cousot, 1977)) and it has been applied also in the verification of transition systems (see the work of Clarke, Grumberg, & Long, 1994 where abstraction has been formally and widely addressed). In our context, the key intuition is that a relation between actual and abstract data can be based on an equivalence relation, thus an abstract state will represent several actual ones. This approach, in turn, generates an abstract state space which can be explored by an abstract consistency model, useful to generalise data inconsistency.

We formalise this concept as follows.
                              Definition 4
                              Data Abstraction


                              Let s be an FSS state and e be an event with respectively 
                                    
                                       s
                                       =
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             n
                                          
                                       
                                    
                                  state variables and 
                                    
                                       e
                                       =
                                       (
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             m
                                          
                                       
                                       )
                                    
                                  event attributes. Let D be a finite (although very large) attribute domain where 
                                    
                                       {
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       }
                                       ⊆
                                       {
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             n
                                          
                                       
                                       }
                                    
                                  and 
                                    
                                       {
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             
                                                
                                                   m
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       }
                                       ⊆
                                       {
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             m
                                          
                                       
                                       }
                                    
                                  are instances of D, i.e., 
                                    
                                       {
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       }
                                       ∈
                                       D
                                    
                                  and 
                                    
                                       {
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             
                                                
                                                   m
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       }
                                       ∈
                                       D
                                    
                                 .

An event e happening in the state s requires the evaluation of 
                                    
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                  and 
                                    
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             
                                                
                                                   m
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                  values, namely a configuration of 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             ′
                                          
                                       
                                       +
                                       
                                          
                                             m
                                          
                                          
                                             ′
                                          
                                       
                                    
                                  different values of D. Then, we define the Abstract Domain of D as a set of different symbols 
                                    
                                       
                                          
                                             d
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   ′
                                                
                                             
                                             +
                                             
                                                
                                                   m
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                 , called Abstract Data, required to represent the values of D in the consistency model, i.e. 
                                    
                                       
                                          
                                             D
                                          
                                          
                                             abstract
                                          
                                       
                                       =
                                       {
                                       
                                          
                                             d
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   ′
                                                
                                             
                                             +
                                             
                                                
                                                   m
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       }
                                    
                                 .

Some conditions should be met to apply such data abstraction:
                              
                                 (p1) no total order relation is defined in the actual domain (or the total order relation is not considered for the scope of the analysis);

(p2) No condition should compare a symbol to a non-abstract value (e.g., 
                                       
                                          
                                             
                                                C
                                             
                                             
                                                X
                                             
                                          
                                          =
                                          03120
                                       
                                     in our example).

In this section we first introduce the Robust Data Quality Analysis, then we describe its extension, namely the Multidimensional Robust Data Quality Analysis, which identifies, extracts, and classifies data inconsistencies.

The Robust Data Quality Analysis (RDQA for short) is a model-based technique to verify the consistency of a longitudinal database before and after the cleansing intervention, as we discuss in the application domain of Section 7. Let us have and FSEDB S which can be decomposed in several FSED 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         as outlined in Definition 3. Let us introduce a function clr that can generate a cleansed (and consistent) version 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                         of a source dataset 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                        . In this respect, the clr cleansing function is considered regardless of its implementation and can be deemed as a black-box working as follows.
                           Function 1
                           
                              clr
                           


                           Let 
                                 
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 
                               be an FSED, then 
                                 
                                    clr
                                    :
                                    FSED
                                    →
                                    FSED
                                 
                               is a function able to generate the cleansed instance 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                 
                               of a dataset 
                                 
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 
                              .

Then, several questions arise about the believability of the cleansing process: what is the degree of consistency achieved through clr? Can we improve the consistency of the cleansed output? Are we sure that clr does not introduce any error in the cleansed dataset?

To answer these questions we need a function able to check the consistency of a dataset before and after the cleansing intervention, providing knowledge to evaluate the entire cleansing process.
                           Function 2
                           
                              ccheck
                           


                           Let 
                                 
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                               be a FSED. Let ∼ be a total order relation such that 
                                 
                                    ∊
                                    ∈
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                               is an ∼-ordered event sequence, as defined in Definition 3.

Then 
                                 
                                    ccheck
                                    :
                                    FSED
                                    →
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                               is a function that returns 1 if ∊ is inconsistent, 0 otherwise.

Clearly, the ccheck can be realised by means of several programming paradigms. In this paper the ccheck has been implemented through UPMurphi, thus expressing the data consistency verification as a model checking problem, as described in Section 4.3.

Even though the ccheck is model-based, no guarantees are given about the correctness of ccheck (it is well-known that any model-based reasoning is only as good as the model is).

Given a FSED 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         and its cleansed instance 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                        , since no details about the cleansing process are provided, we need to know the extent to which the clr has modified or not the output. We can guess whether the clr function has affected or not a dataset by comparing the source and cleansed instances (i.e, 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              ≟
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                        ). To this end, we introduce the following.
                           Function 3
                           
                              equals
                           


                           Let S and C be FSEDs, we define 
                                 
                                    equals
                                    :
                                    FSED
                                    ×
                                    FSED
                                    →
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                               which returns 0 if no differences between 
                                 
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                 
                               are found, 1 otherwise.


                        Fig. 2
                         describes the RDQA process which takes as input: a consistency model of the data, the source database S, and its cleansed instance C. The cleansed version C was generated executing the cleansing function clr on each 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              ⊆
                              S
                           
                        . Finally, for a given set 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         (
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                        ) we define a function returning the representative element of the set 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         (
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                        ).
                           7
                           Intuitively, in a database record the representative element could be the primary key value or a hash value computed on the selected attributes.
                        
                        
                           7
                        
                        
                           Function 4
                           
                              rep
                           


                           Let K be an FSEDB and let R be the set of all the representative elements of K. For all 
                                 
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                    ⊆
                                    K
                                 
                               
                              
                                 
                                    rep
                                    :
                                    FSED
                                    →
                                    R
                                 
                               is a function which returns the representative element 
                                 
                                    
                                       
                                          r
                                       
                                       
                                          i
                                       
                                    
                                    ∈
                                    R
                                 
                              .

The output of a RDQA iteration is the Double Check Matrix (DCM), as shown in Table 2(a) and (b)
                        , produced by collecting the results of functions 
                           
                              ccheck
                              ,
                              equals
                           
                        , and clr and computing statistics on the resulting 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         and 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                         clusters. For the sake of clarity, we provide the pseudo-code of the RDQA in Procedures 1–3. Furthermore, Fig. 3
                         provides a graphical overview of a single RDQA iteration.

To give a few example, the Row 1 (called also cluster 1) of Table 2(a) provides information about how many sequences have been considered consistent by both clr and ccheck functions and no differences between the original instance and the cleansed one has been found by equals. On the contrary, row 4 (called also cluster 4) represents the number of sequences for which no error was found by ccheck on the source, whereas the equals certifies that a cleansing intervention took place, and the sequence was considered inconsistent after cleansing. Finally, row 8 represents the number of sequences originally inconsistent that were modified during the cleansing with no success, since after the intervention they are still marked as inconsistent by the ccheck. The other cases will be extensively commented in Section 7 focusing on a specific application domain.

The DCM provides useful insights about the consistency of clr results and helps the identification of cleansing issues. The DCM results also contribute to the identification of errors in the formalisation of the consistency model, which in turn allows a better understanding of the domain rules. The RDQA procedure is applied iteratively by refining at each step the functions clr and ccheck. Clearly, this approach does not guarantee the correctness of the data cleansing process, nevertheless it helps making the process more robust with respect to data consistency.

Basically, the RDQA exploits the ccheck function to analyse the effectiveness of a cleansing routine clr. However, the ccheck function works according to an on/off approach: it can detect an inconsistency, but it does not provide any further information about the inconsistency characteristics.
                           Procedure 1
                           RDQA 
                                 
                                    
                                       
                                       
                                          
                                             
                                                1. 
                                                   
                                                      S
                                                      =
                                                   
                                                 get_database_content();
                                          
                                          
                                             
                                                2. 
                                                   
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      =
                                                      ∅
                                                      ;
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      =
                                                      ∅
                                                   
                                                ;
                                          
                                          
                                             
                                                3. 
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            S
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      =
                                                      ∅
                                                      ;
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            S
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      =
                                                      ∅
                                                   
                                                ;
                                          
                                          
                                             
                                                4. 
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            C
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      =
                                                      ∅
                                                      ;
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            C
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      =
                                                      ∅
                                                   
                                                ;
                                          
                                          
                                             
                                                5. for all 
                                                
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⊆
                                                      S
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                6. 
                                                
                                                   
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      =
                                                      clr
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             
                                                7. 
                                                
                                                   
                                                      equals
                                                      _
                                                      aux
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             
                                                8. 
                                                
                                                   
                                                      ccheck
                                                      _
                                                      aux
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             
                                                9. 
                                                
                                                   
                                                      ccheck
                                                      _
                                                      aux
                                                      (
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             10. end for
                                             
                                          
                                          
                                             11. compute_
                                                   
                                                      DCM
                                                      (
                                                      )
                                                   
                                                ;//Table 2(a)
                                          
                                          
                                             12. display_DCM();
                                          
                                       
                                    
                                 
                              
                           


                              equals_aux 
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             1. if 
                                                
                                                   
                                                      (
                                                      equals
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      =
                                                      1
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             2. 
                                                
                                                   
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      ∪
                                                      rep
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             3. else
                                             
                                          
                                          
                                             4. 
                                                
                                                   
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            D
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      ∪
                                                      rep
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             5. end if
                                             
                                          
                                       
                                    
                                 
                              
                           


                              ccheck_aux 
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                
                                                   
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                 //It can be 
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                 or 
                                                   
                                                      
                                                         
                                                            C
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             1. if 
                                                
                                                   
                                                      (
                                                      ccheck
                                                      (
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      =
                                                      1
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             2. 
                                                
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            X
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            X
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      ∪
                                                      rep
                                                      (
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             3. else
                                             
                                          
                                          
                                             4. 
                                                
                                                   
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            X
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            F
                                                         
                                                         
                                                            X
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      ∪
                                                      rep
                                                      (
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                ;
                                          
                                          
                                             5. end if
                                             
                                          
                                       
                                    
                                 
                              
                           

To better clarify this concept, let us consider again the Mobile Phone Tracking example. In Table 3
                        (b) we describe the system variables, the events, and the domain values used by a Finite State System modelling the expected system behaviour. The information can be used to identify in advance all the combination of <state,action> pairs leading to an inconsistent state. The set of <state,action> pairs can be reduced by using the abstract data set introduced in Section 4.3. According to the latter, the “cell” domain has been mapped on an abstract data set 
                           
                              
                                 
                                    D
                                 
                                 
                                    cell
                                 
                                 
                                    abstract
                                 
                              
                              =
                              {
                              
                                 
                                    C
                                 
                                 
                                    X
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    Y
                                 
                              
                              }
                           
                        . In this way a Universal Checker can be computed: an object which compactly represents all the possible inconsistencies which affect the data, as reported in Table 3(a).
                           8
                           Only a subset of the feasible pairs is reported, since the entries shown are reduced using some symmetry reduction techniques, e.g. <
                                 
                                    state
                                    =
                                    con
                                    ∧
                                    cell
                                    =
                                    
                                       
                                          C
                                       
                                       
                                          X
                                       
                                    
                                    ;
                                    cell
                                    -
                                    in
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          Y
                                       
                                    
                                 
                              > and <
                                 
                                    state
                                    =
                                    con
                                    ∧
                                    cell
                                    =
                                    
                                       
                                          C
                                       
                                       
                                          Y
                                       
                                    
                                    ;
                                    cell
                                    -
                                    in
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          X
                                       
                                    
                                 
                              > are symmetric then can be represented using only the first one according to the symmetry reduction technique (Norris Ip & Dill, 1996) present in UPMurphi.
                        
                        
                           8
                         A taxonomy of errors can be obtained by assigning an error-code (i.e., a unique natural number) to each pair <state values;event values> leading to an inconsistency.

To this aim, in the following we introduce the concept of error-code on an event sequence and how to compute it on an FSS.
                           Definition 5
                           Error-Code on FSED


                           Let 
                                 
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 
                               be an FSED and let 
                                 
                                    ∊
                                    =
                                    
                                       
                                          e
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          e
                                       
                                       
                                          n
                                       
                                    
                                 
                               be a sequence of events according to Definition 3. Moreover, let i be the index of a minimal consistent subsequence, that is a sequence 
                                 
                                    
                                       
                                          ∊
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          e
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          e
                                       
                                       
                                          i
                                       
                                    
                                 
                               such that 
                                 
                                    
                                       
                                          ∊
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                 
                               is inconsistent while 
                                 
                                    ∀
                                    j
                                    :
                                    j
                                    ⩽
                                    i
                                    ⩽
                                    n
                                    -
                                    1
                                    ,
                                    
                                       
                                          ∊
                                       
                                       
                                          j
                                       
                                    
                                 
                               is consistent.

An error-code 
                              
                                 
                                    
                                       
                                          err
                                       
                                       
                                          ∊
                                       
                                    
                                 
                               for ∊ is a number 
                                 
                                    k
                                    ∈
                                    
                                       
                                          N
                                       
                                       
                                          +
                                       
                                    
                                 
                               such that 
                                 
                                    k
                                    =
                                    0
                                 
                               if 
                                 
                                    
                                       
                                          ∊
                                       
                                       
                                          n
                                       
                                    
                                 
                               is consistent, otherwise 
                                 
                                    k
                                    >
                                    0
                                 
                               uniquely identifies the inconsistency affecting the sequence 
                                 
                                    
                                       
                                          ∊
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                 
                              .

Clearly, to compute error-codes on a FSED, we need to improve the ccheck function as follows.
                           Function 5
                           
                              ccheck
                              ec
                           


                           Let 
                                 
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                               be a FSED. Let ∼ be a total order relation such that 
                                 
                                    ∊
                                    ∈
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                               is an ∼-ordered event sequence, as defined in Definition 3.

Then 
                                 
                                    
                                       
                                          ccheck
                                       
                                       
                                          ec
                                       
                                    
                                    :
                                    FSED
                                    →
                                    N
                                 
                               is a function that returns an error-code 
                                 
                                    
                                       
                                          err
                                       
                                       
                                          ∊
                                       
                                    
                                 
                              , according to Definition 5, such that 
                                 
                                    
                                       
                                          err
                                       
                                       
                                          ∊
                                       
                                    
                                    >
                                    0
                                 
                               if an inconsistency with error-code 
                                 
                                    
                                       
                                          err
                                       
                                       
                                          ∊
                                       
                                    
                                 
                               has been found on 
                                 
                                    ∊
                                    ,
                                    0
                                 
                               otherwise.

Also in this case, we used model-checking to implement the 
                           
                              
                                 
                                    ccheck
                                 
                                 
                                    ec
                                 
                              
                           
                         semantics. In particular, error-codes have been identified as follows.
                           Definition 6
                           Error-Code on FSS


                           Let 
                                 
                                    S
                                    =
                                    (
                                    S
                                    ,
                                    I
                                    ,
                                    A
                                    ,
                                    F
                                    )
                                 
                               be an FSS, let E be the set of errors states (i.e. inconsistent states) and T is the finite horizon. Moreover, let Π be the set of all the inconsistent trajectories 
                                 
                                    π
                                    ∈
                                    Π
                                 
                              , i.e. 
                                 
                                    π
                                    =
                                    
                                       
                                          s
                                       
                                       
                                          0
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          0
                                       
                                    
                                 
                               
                              
                                 
                                    …
                                 
                               
                              
                                 
                                    
                                       
                                          s
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                 
                               
                              
                                 
                                    
                                       
                                          s
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                 
                               with 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          0
                                       
                                    
                                    ∈
                                    I
                                 
                              , 
                                 
                                    |
                                    π
                                    |
                                    ⩽
                                    T
                                 
                               and 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    ∈
                                    E
                                 
                              . We introduce:
                                 
                                    •
                                    the error-code function 
                                       
                                          
                                             h
                                             :
                                             Reach
                                             (
                                             S
                                             )
                                             ×
                                             A
                                             →
                                             
                                                
                                                   N
                                                
                                                
                                                   +
                                                
                                             
                                          
                                        that, for a given pair 
                                          
                                             (
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                        generates a unique natural number 
                                          
                                             h
                                             (
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             ;
                                             0
                                          
                                        is used to denote a no error condition;

a Universal Checker 
                                       
                                          
                                             K
                                          
                                        as a map where each pair 
                                          
                                             (
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                        is assigned to an error-code 
                                          
                                             h
                                             (
                                             
                                                
                                                   s
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   a
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       .

Note that, the h function has been implemented by using the STL hash object class, since UPMurphi allows the use of external C/C++ libraries.

Roughly speaking, the Universal Checker represents a taxonomy of all the inconsistencies affecting the data. This, in turn, can be used to enhance a DCM cluster with error-code data as follows.
                           
                              •
                              Each DCM cluster is enriched with a square matrix having 
                                    
                                       n
                                       +
                                       1
                                    
                                  rows and columns, where n is the number of distinct error-codes detected (i.e., 
                                    
                                       |
                                       K
                                       |
                                    
                                 ) according to Definition 6, as shown in Eq. (1).
                                    
                                       (1)
                                       
                                          ∀
                                          l
                                          ∈
                                          {
                                          1
                                          ,
                                          …
                                          ,
                                          8
                                          }
                                          
                                             
                                                M
                                             
                                             
                                                n
                                                +
                                                1
                                                ,
                                                n
                                                +
                                                1
                                             
                                             
                                                l
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  0
                                                                  ,
                                                                  0
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  0
                                                                  ,
                                                                  1
                                                               
                                                            
                                                         
                                                         
                                                            ⋯
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  0
                                                                  ,
                                                                  n
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  1
                                                                  ,
                                                                  0
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  1
                                                                  ,
                                                                  1
                                                               
                                                            
                                                         
                                                         
                                                            ⋯
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  1
                                                                  ,
                                                                  n
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            ⋮
                                                         
                                                         
                                                            ⋮
                                                         
                                                         
                                                            ⋱
                                                         
                                                         
                                                            ⋮
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  n
                                                                  ,
                                                                  0
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  n
                                                                  ,
                                                                  1
                                                               
                                                            
                                                         
                                                         
                                                            ⋯
                                                         
                                                         
                                                            
                                                               
                                                                  err
                                                               
                                                               
                                                                  n
                                                                  ,
                                                                  n
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

For a given cluster of the DCM, an element of the matrix 
                                    
                                       
                                          
                                             err
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                    
                                  is a positive number 
                                    
                                       k
                                       ∈
                                       
                                          
                                             N
                                          
                                          
                                             +
                                          
                                       
                                    
                                  if k distinct event sequences have presented the error-code i in the original dataset and the error-code j in the cleansed one, otherwise k is zero. To give a few examples, 
                                    
                                       
                                          
                                             err
                                          
                                          
                                             0
                                             ,
                                             0
                                          
                                       
                                    
                                  is the number of sequences consistent before and after the cleansing intervention, while 
                                    
                                       
                                          
                                             err
                                          
                                          
                                             1
                                             ,
                                             5
                                          
                                       
                                    
                                  represents the number of sequences presenting the error-code 1 before the intervention and error-code 5 after the cleansing.

In this section we introduce our application domain in the field of the Labour Market, describing how the data consistency problem has been described as a model checking one.

According to the Italian Labour Law, every time an employer hires or dismisses an employee, or an employment contract is modified (e.g. from part-time to full-time, or from fixed-term to unlimited-term) a communication (i.e., an event) is sent to a job registry. Those information are called Mandatory Communications (CO). From 1997, the Italian public administration has been using an Information System, called the “CO System” (The Italian Ministry of Labour & Welfare, 2012), where data concerning employment and active labour market policies are stored. Thus generating an administrative archive useful for studying the labour market dynamics. Indeed, extracting the longitudinal data by the CO archives allows one to observe the overall evolution of the labour market for a given observation period, obtaining insightful information about worker career paths, patterns and trends, facilitating the decision making processes of civil servants and policy makers, as studied by Cipollini, Ferretti, Ganugi, and Mezzanzanica (2013), Lovaglio and Mezzanzanica (2013).

Unfortunately the CO archive data quality is very poor, and several studies have looked at the social and economic effects of inadequate data quality see, e.g. Haug et al. (2011), Redman (1998), Fisher and Kingma (2001), Wang and Strong (1996), Cesarini, Mezzanzanica, and Fugini (2007). The RDQA approach presented in the previous section has been used to assess and improve the data cleansing process performed on the mandatory communications of an Italian region inhabitants.

For each worker, a mandatory notification (an event in our context) is decomposed into the following attributes:
                           
                              w_id:
                              id identifying the person involved in the event;

id identifying the event;

event occurrence date;

type of events affecting the worker career. Events types are the start or the cessation of a working contract, the extension of a fixed-term contract, or the conversion from a contract type to a different one;

specifies whether the event is related to a full-time or a part-time contract;

contract type under the Italian law (e.g. fixed-term or unlimited-term contract, etc.).

employer involved in the event.

The development of a consistent career path over time is described by an event sequence ordered with respect to e_date. More precisely, in these settings an FSED is the (ordered) set of events for a given w_id (i.e. an FSED represents a single career in this context), and the FSEDs union composes the FSEDB.

Now we look more closely at the careers consistency, where the consistency semantic is derived from the Italian labour law, from the domain knowledge, and from the common practice. Some domain constraints are briefly reported:
                           
                              c1:
                              an employee can have no more than one full-time contract in force at any given time;

an employee cannot have more than K part-time contracts (signed by different employers); in our context we assume 
                                    
                                       K
                                       =
                                       2
                                    
                                  i.e., an employee cannot have more than two part time jobs active at the same time;

an unlimited term contract cannot be extended;

a contract extension cannot change the existing contract type (
                                    
                                       c
                                       _
                                       type
                                    
                                 ) and the part-time/full-time status (
                                    
                                       c
                                       _
                                       flag
                                    
                                 ) e.g., a part-time fixed-term contract cannot be turned into a full-time contract by an extension;

a conversion requires either the 
                                    
                                       c
                                       _
                                       type
                                    
                                  or the 
                                    
                                       c
                                       _
                                       flag
                                    
                                  to be changed (or both).

For simplicity, we omit to describe some trivial constraints e.g., an employee cannot have a cessation event for a company for which she/he does not work, an event cannot be recorded twice, etc.

We used UPMurphi to build the consistency model and to verify the data consistency. A worker’s career at a given time point (i.e., the system state) is composed by three elements: the list of companies for which the worker has an active contract (
                           
                              C
                              [
                              ]
                           
                        ), the list of modalities (part-time, full-time) for each contract (
                           
                              M
                              [
                              ]
                           
                        ) and the list of contract types (
                           
                              T
                              [
                              ]
                           
                        ).

To give an example, 
                           
                              C
                              [
                              0
                              ]
                              =
                              12
                              ,
                              
                              M
                              [
                              0
                              ]
                              =
                              PT
                              ,
                              
                              T
                              [
                              0
                              ]
                              =
                              unlimited
                           
                         models a worker having an active unlimited part-time contract with company 12.

A graphical representation of the domain model is showed in Fig. 4
                         and it outlines a consistent career evolution. Note that, to improve the readability, we omitted to represent conversion events as well as inconsistent states/transitions (e.g., a worker activating two full-time contracts), which have been considered into the UPMurphi model. A valid career can evolve signing a part-time contract with company i, then activating a second part-time contract with company j, then closing the second part-time, and then reactivating the latter again (i.e., 
                           
                              unemp
                              ,
                              
                                 
                                    emp
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    emp
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ,
                              
                                 
                                    emp
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    emp
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        ).

For the sake of completeness, in Fig. A.7 and A.8 we provide the UPMurphi model for our application domain.

Finally, a mapping from actual to abstract data has been identified as described in Section 4.3 taking into account both states and events of the automaton of Fig. 4. The empr_id attribute domain has been mapped on a set of 3 symbols 
                           
                              {
                              
                                 
                                    empr
                                 
                                 
                                    x
                                 
                              
                              ,
                              
                                 
                                    empr
                                 
                                 
                                    y
                                 
                              
                              ,
                              
                                 
                                    empr
                                 
                                 
                                    z
                                 
                              
                              }
                           
                         according to Definition 4. The attribute domains of c_type, e_type, and c_flag have not been replaced by abstract data since their domains are already bounded.

Indeed, we highlight that the model of Fig. 4 satisfies conditions p1 and p2, namely: (1) a total order relation for the empr_id domain is defined but it is not considered in the automaton, and (2) there are no conditions comparing an abstract value with a non abstract one.

@&#EXPERIMENTAL RESULTS@&#

In this section we describe some experimental results obtained on the Labour Market Domain presented in the previous section. The experimental setup is detailed in Section 7.1. Then we present the output of the RDQA and MRDQA iterations in Section 7.2 and Section 7.3 respectively. Some comments about the effectiveness of the applied techniques are outlined in Section 7.4 while Section 7.5 reports details about the online dataset.

We performed an extensive experimental evaluation of our approach on an administrative archive of an Italian Region composed by 21,805,653 mandatory communications. The source archive (S from now on) contains data on the careers of 2,498,615 people observed starting from 1st January 2004 to 31st December 2011. For each career a subset 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         is identified (where 
                           
                              i
                              ∈
                              [
                              1
                              …
                              2
                              ,
                              498
                              ,
                              615
                              ]
                           
                        ). In these settings, 
                           
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                           
                         is a FSED while S is the FSEDB.

The cleansed FSEDB C has been generated by using the function clr, implemented exploiting ETL business rules developed through the Talend tool
                           9
                           
                              http://www.talend.com/.
                        
                        
                           9
                         at CRISP Research Centre (CRISP Research Centre Web Page, 2013) whilst ccheck function has been realised using the UPMurphi tool. The computation of a MRDQA iteration was performed on a 32 bits 2.2GHz CPU (connected to a MySQL server through ODBC driver) in about 2h. Finally, for the sake of completeness, in Appendix A we report an extract of the UPMurphi model used.

We highlight that the aim of this experimental section is (1) to verify the effectiveness (if any) of the proposed approach on a real-world domain instance and (2) to provide a fine-grained analysis of both the source dataset and the cleansing procedures, allowing domain experts to derive a large number of analysis, statistics and action points to improve the overall data quality process.


                        Table 4
                         shows the double check matrix (DCM) computed by the RDQA. Each DCM line shows the number of FSEDs (i.e. the number of careers) satisfying the properties of the corresponding cluster. Note that clusters labelled with (∗) represent the job careers dropped by the clr (in spite of their consistency), since those careers refer to workers living in regions different from the reference one. Those events are therefore outside the scope of the analysis.

Each DCM row shown in Table 4 can be shortly commented as follows, by focusing on the columns DCM clusters and Careers Data:
                           
                              Cluster 1: represents careers already clean that have been left untouched by clr. It provides an estimation of the consistent careers in the source archive.

Cluster 2: refers to careers considered consistent (by ccheck) before but not after the cleansing, although they have not been touched by clr. As expected this subset is empty.

Cluster 3: describes consistent careers that have been unexpectedly changed by the clr. Note that, although such kind of careers remained consistent after the intervention, the clr behaviour was investigated to understand and clarify the role of the cleansing procedure. By inspecting this cluster the domain experts discovered that the clr implementation improperly changed events and values for some kind of careers. Since up to 5% of the overall careers are affected, this issue cannot be neglected. Two main intervention types are performed by the clr on cluster 3 careers. The sizes of the affected sets are summarised in Table 5
                                 . The domain experts identified that both intervention 1 and 2 are wrong with respect to the expected semantics (although both produce consistent results), therefore the clr needs to be fixed. The remaining 0.36% of other interventions is actually under investigation (in Table 5), and this bears a witness to the finely grained analysis obtained through the RDQA.

Cluster 4: represents careers originally consistent that clr made inconsistent. These careers strongly helped identifying and correcting bugs in the clr implementation.

Cluster 5: refers to careers considered inconsistent (by ccheck) before but consistent after cleansing, although they have not been touched by clr. This subset is empty, as expected.

Cluster 6: describes inconsistent careers, that clr was unable to detect (and thus to correct), therefore they were not touched.

Cluster 7: describes the number of (originally) inconsistent careers that ccheck recognises as properly cleansed by clr at the end.

Cluster 8: represents careers originally inconsistent that have been not properly cleansed since, despite an intervention of clr, the function ccheck still identifies them as inconsistent.

The “Careers Data” columns show statistics focusing on the career number dimension. One can observe that the number of (initially) consistent careers in the source dataset (Cluster 1) is 33.34%. The cleansing routines were not able to recognise the 0.55% of the careers as inconsistent (Cluster 6). On the contrary, it recognised but not fixed 4.88% of the overall careers set (Cluster 8). The number of consistent careers reached after the clr intervention is 89.2% (the sum of clusters 1 and 7).

The DCM provides relevant information to evaluate the cleansing activities, shedding light on different behaviour of the consistency semantics implemented in ccheck and clr. To give a few examples, cases 2, 4, and 5 can denote a potential issue that domain experts should address.

In the next section we show how the MRDQA, as introduced in Section 7.3, has been applied to obtain fine-grained information on how improve the cleansing function.

The multidimensional RDQA described in Section 5.2 has been used to deeply analyze the cleansing activities previously outlined in Sections 7.1 and 7.2. The consistency model described in Fig. 4 and the abstract data described in Section 6.2 have been used to generate a Universal Cleanser.

As a result, 231 error-codes have been identified. Fig. 5
                         shows the results of the DCM most significant clusters, namely the clusters 6, 7, 8, and the second (*). On the x-axis we report the labels of the inconsistency patterns (i.e. the error codes). For each error code, the number of affected careers is reported (the triangle which refers to the value of the right y-axis). The histogram shows the distribution of the errors among the clusters: the left y-axis reports the distribution of careers as percentage among the DCM clusters.

The Multidimensional DCM represents a fine-grained analysis of both the source dataset and the cleansing procedures, which allows domain experts to perform several analysis and statistics to understand and improve the overall data quality process.

In this regard, we can identify several issues worth of intervention (action points). Roughly speaking, action points can be seen as a checklist that should be beneficial for domain expert and cleansing architects to improve the cleansing routines. We have identified, among the others, the following action points.
                           
                              •
                              Let us consider the error codes from 212 to 215, as shown in Table 6
                                  (note that the closer the error codes, the similar the error patterns). All these inconsistencies emerge when a worker receives a start event while having an on-going full-time contract referring to the same employer. The several error codes differs for some event attributes, e.g. the limited and unlimited term contract flag. This information proves, as expected, that a huge number of closing contract communications are missing from the archive. Due to the high error occurrence (i.e., about 17% of total careers), the domain experts and the cleansing designers concluded that it is worth to pay attention to all the cleansing routines dealing with such cases.

The Cluster 6 discovery careers where the clr failed the cleansing intervention. The error code 193 is the most frequent (i.e., 77% of careers in the cluster are affected by this error) and it refers to workers having an unlimited-term contract and receiving a limited-term cessation event. Fixing the error code 193 can dramatically reduce the cardinality of this group.

Focusing only on clusters where the clr always failed the cleansing process, the error codes 93, 115, and 184 can be neglected as they represents only 4 careers. Differently, domain experts and cleansing designers have focused on the most frequent error-codes affecting Cluster 8 to identify bugs on cleansing routines.

Finally, the inconsistencies are mainly generated when a worker is in a full-time or unemployed status (consider that 78% of the source dataset is composed by full-time events). Thus, all the cleansing routines related to full-time events should be widely analysed.

Thanks to the DCM and the further analysis on the error set generation we can summarise our results by computing the following indicators:
                           
                              
                                 The consistency degree (Cluster 1+Cluster 4) of the source dataset before and after the cleansing intervention. Note that 33.34% of the careers are consistent. This result is enough to stress the significance of a cleansing process before using the data for decision making purposes.


                                 The room for improvement (Cluster 3+Cluster 4+Cluster 6+Cluster 8) represents cases where the cleansing intervention was not successful. These clusters account for 10.47% of the careers, and this value is a quantitative estimation about how the clr process could be improved and refined.


                                 The quality improvement (Cluster 7−Cluster 4) achieved by the cleansing intervention accounts for 55.86% of the careers. Note that the use of a model-based approach to evaluate the cleansing process makes more reliable this value. In other words, the results obtained can be considered a measure of the clr effectiveness.


                                 The Action Points. The capability to identify error patterns affecting the data, their distribution and characteristics is a useful swiss army knife during the development of cleansing routines. Indeed, one can discover a set of issues and their relevance by analysing the DCM and the error codes distribution, and subsequently refining the cleansing routines, comparing previous and further versions, making more robust the data quality process.

A source archive containing 1,248,814 mandatory communications describing 
                           
                              214
                              ,
                              429
                           
                         careers extracted from the dataset presented in Section 7 has been made publicly available for download.
                           10
                           Publicly available at http://goo.gl/sS3rvv.
                        
                        
                           10
                         On such dataset we performed the consistency verification as detailed in the paper. The dataset is composed by the following tables:
                           
                              
                                 The Worker Careers. It is a table composed by 7 columns, whose semantics has been detailed in Section 6.1.


                                 The Consistency Verification Results. It is a table composed by three columns, namely the worker id, the error code and the error index of the event after the shortest consistent subsequence: Considering a career composed by n events, an error index i with 
                                    
                                       0
                                       ⩽
                                       i
                                       <
                                       n
                                    
                                  means that 
                                    
                                       i
                                       -
                                       1
                                    
                                  events make the career consistent whilst the i-th event makes it inconsistent.

The results of a single iteration of the RDQA are shown in Table 7
                           . Finally, we also provide the result of the Multidimensional RDQA, by exploiting a well-known multidimensional visualisation technique, namely the parallel-coordinates (abbrv: 
                              
                                 ‖
                              
                           -coord see Inselberg (1985)).

Informally speaking, 
                              
                                 ‖
                              
                           -coord allow one to represent an n-dimensional datum 
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       n
                                    
                                 
                                 )
                              
                            as a polyline, by connecting each 
                              
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                              
                            point in n parallel y-axes. We used the 
                              
                                 ‖
                              
                           -coord to plot the DCM and the error-code data by using four dimensions, namely 
                              
                                 (
                                 l
                                 ,
                                 i
                                 ,
                                 
                                    
                                       err
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                                 j
                                 )
                              
                            which respectively represent the DCM row number, the error-code before the cleansing, the number or careers (i.e. the 
                              
                                 
                                    
                                       err
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                              
                            value in Eq. (1)), and the error-code after the cleansing. Generally, 
                              
                                 ‖
                              
                           -coord tools show their powerfulness when used interactively (i.e., by selecting ranges from the y-axes, by emphasising the lines traversing through specific ranges, etc). For these reasons, the plot file has been made publicly available for downloading.

For the sake of completeness, we report two 
                              
                                 ‖
                              
                           -coord graphs shown in Fig. 6
                           . Fig. 6(a) shows the Cluster 7 of the DCM (i.e., the originally inconsistent careers correctly cleansed by the clr function). The figure explains how the error-codes are distributed on the original inconsistent data and their related frequencies. Differently, Fig. 6(b) highlights the Cluster 8 results (i.e. the careers improperly cleansed by the clr), which help in discovering how an error-code in the source dataset evolves due to a wrong cleansing intervention. Note that, in our experience, such information has played a key role in discovering the cleansing issues (e.g., it was easy to identify the most relevant and more numerous cases and to prioritise their fixing).

Finally, the Multidimensional RDQA outcomes and the 
                              
                                 ‖
                              
                           -coord sheets have been made publicly available for download and demonstration, so that the results we present can be assessed, shared, and used by the community.

In this paper we have shown how the data quality tasks of a KDD process can be expressed as a model checking problem. Then, we presented the Multidimensional Robust Data Quality Analysis, an iterative and domain-independent technique aimed to (1) analyse the consistency of a dataset before and after the cleansing intervention and (2) iteratively improve the cleansing procedures by identifying the issues to be addressed. We implemented the consistency check through the UPMurphi tool (whose model is provided in Appendix A) and we applied the MRDQA to a real-world governmental application in the field of the Italian Labour Market domain, dealing with the weakly structured data of million of citizens living in an Italian Region. Moreover, an anonymized instance of the dataset and the results have been made public available, in order to provide a dataset for KDD tasks to the community.

The traditional development of cleansing routines is a resource consuming and error prone activity as the huge set of data to be cleansed, the complexity of the domain, and the continuous business rules evolution make the cleansing process a challenging task. In such a scenario, the main benefits provided by our model-based approach for weakly-structured data are in (i) modelling data behaviour and quality constraints over time as a pathway on a graph, that allows expressing quality requirements that FDs and their variants do not handle, and (ii) the automatic evaluation of existing cleansing routines, that enables domain experts and decision makers to obtain insights about the dataset to be cleansed, reducing the human effort required for evaluating the realised cleansing intervention and improving the believability of the overall cleansing process as well.

More specifically, in our experience at the CRISP Research Centre,
                        11
                        
                           www.crisp-org.it/en.
                     
                     
                        11
                      the results have pointed out the usefulness of our approach in supporting data cleansing tasks before using mining algorithms. To give a few examples, the MRDQA allowed domain experts and the cleansing architects to identify the initial database consistency degree (i.e., about 33%), the overall quality improvement obtained thanks to the use of their cleansing function (i.e., 55.86%) as well as the room for improvement of the cleansing function used (i.e., about 10%). Furthermore, the MRDQA has identified the distribution of the inconsistency patterns which, in turn supported the identification of several “action points”, useful for investigating and improving the cleansing functions realised by means of an ETL tool.

Generally, speaking, the approach we presented enables domain experts to concentrate on what quality constraints need to be modelled rather than how to verify them, thus providing a (more) reliable cleansed data on which run mining techniques. Moreover, it simplifies the management of quality constraints by focusing on the model design, rather than working on the engine which catches them. Finally, it allows domain experts to discover quality patterns on data, helping them to achieve a better comprehension of data characteristics and dynamics.

Actually, we are working to expand our approach to perform cleansing by synthesising a universal cleanser (Mezzanzanica, Boselli, Cesarini, & Mercorio, 2013), i.e. an object which summarises the set of all cleansing actions for each feasible data inconsistency, according to a given consistency model by exploiting AI Planning languages and tool (Boselli, Cesarini, Mercorio, & Mezzanzanica, 2014b; Boselli, Mezzanzanica, Cesarini, & Mercorio, 2014c). As a further step, we have been working for evaluating the effectiveness of our approach on biomedical domain (Boselli, Cesarini, Mercorio, & Mezzanzanica, 2014a).

@&#ACKNOWLEDGEMENT@&#

The authors would like to thank the anonymous reviewers for their valuable comments and suggestions for improving this work.

For the sake of completeness, in Figs. A.7 and A.8
                     
                      we provide an extraction of the UPMurphi code for our application domain. The former contains the static part of the model, i.e., the system states as defined in Fig. 4 as well as the system procedure; the latter describes the system evolution (i.e., transitions) and invariant conditions, according to the automaton of Fig. 4. Note that the C/C++ functions handling the real-time connection with the MySQL Server have been wrapped by the function nextEvent().

@&#REFERENCES@&#

