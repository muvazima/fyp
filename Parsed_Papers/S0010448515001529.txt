@&#MAIN-TITLE@&#Can local NURBS refinement be achieved by modifying only the user interface?

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A mechanism providing local NURBS refinement by changing only the user interface.


                        
                        
                           
                           Provides the user with local editing without changing the underlying representation.


                        
                        
                           
                           A middle way between global refinement and changing to a different representation.


                        
                        
                           
                           The method will degenerate to non-local refinement in certain cases.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

NURBS

User interface

Local refinement

Surface design

Hierarchical B-spline

Control mesh

@&#ABSTRACT@&#


               
               
                  NURBS patches have a serious restriction: they are constrained to a strict rectangular topology. This means that a request to insert a single new control point will cause a row of control points to appear across the NURBS patch, a global refinement of control. We investigate a method that can hide unwanted control points from the user so that the user’s interaction is with local, rather than global, refinement. Our method requires only straightforward modification of the user interface and the data structures that represent the control mesh, making it simpler than alternatives that use hierarchical or T-constructions. Our results show that our method is effective in many cases but has limitations where inserting a single new control point in certain cases will still cause a cascade of new control points to appear across the NURBS patch.
               
            

@&#INTRODUCTION@&#

NURBS are the standard mechanism for modelling in CAD. For decades  [1], there has been interest in producing hierarchical NURBS, NURBS with T-junctions, and other NURBS variants that allow for local refinement of a NURBS patch (Section  3). None of these solutions, however, has yet been widely adopted in the CAD industry. Some require significant changes to the underlying NURBS engine. We investigate whether it is possible to construct a mechanism that provides local refinement to the designer by modifying only the user interface, leaving the underlying NURBS engine unchanged (Sections  5 and 6).

Our motivation is that providing local refinement through the user interface alone would allow CAD software providers to add the extra functionality without the need to make expensive additions and changes to the underlying NURBS engine. Our investigation shows that our method does deliver such functionality but that it suffers from inescapable limitations (Section  8). Nevertheless, this idea provides an interesting intermediate option between the status quo and adoption of a new engine.

Bivariate NURBS patches are composed, in parameter space, as the tensor product of univariate NURBS. It is well known that, in the univariate case, a NURBS curve can be locally refined arbitrarily often in arbitrary locations (Fig. 3). A NURBS patch cannot be refined arbitrarily often at arbitrary point locations, owing to its tensor product nature. Any refinement of the NURBS patch will stretch from one side of the patch to the other (Fig. 1
                     ).

Our basic idea is to provide a mechanism whose user interface shows only the desired control points to the designer. That is, it hides unwanted control points. We implement this as a series of tensor product control meshes, each of which we call a layer. Each layer is a refinement of the layer above in which a single knot is added. Some points from a given layer may be visible to the user and some may be hidden. The rationale here is that the positions of the hidden control points, in the refined layer, can be calculated from control points in the previous layer without altering the shape of the surface. This is just basic knot insertion where, in the univariate case, inserting a single knot in a curve of order 
                        k
                      (degree 
                        k
                        −
                        1
                     ) causes one new control point to be introduced and 
                        k
                        −
                        2
                      existing control points to be moved without changing the shape of the curve.

Our basic idea is illustrated in Fig. 2
                     . 
                     Fig. 2(a) shows what the user sees in the user-interface. Fig. 2(b)–(f) shows how this can be implemented as a series of layers, each of which introduces a single new knot. The bottom-most layer, Fig. 2(f), is a tensor-product NURBS that is passed to the underlying NURBS engine. There are three types of points: visible control points available in the user interface (coloured circles), replaced control points (grey circles) that have been superseded by points in a lower layer, and hidden points (coloured diamonds) that are calculated from points in the layer above. Note that every layer is a tensor-product arrangement, while the control mesh visible to the user is not necessarily tensor-product and is constructed by building a mesh from the control points that are marked as visible in the various layers.

@&#RELATED WORK@&#

Since their invention in the 1970s, NURBS  [2], a non-uniform rational extension of B-splines, have become a universal standard for representing free form curves and surfaces in computer aided design. Modelling is facilitated by control points whose positions determine the desired shape. NURBS possess many features that make them attractive for various applications such as geometric modelling, analysis, and approximation. However, NURBS suffer from a major drawback: control points need to form a rectangular topological grid.

We are interested in using NURBS for designing models in three-dimensional space. Consider the situation when a fine detail needs to be added to an existing coarse model. This is a typical operation performed in practice, for example, when adding a small ear detail to a face model. The structure of NURBS does not allow this to be performed as a local operation. If a new control point needs to be introduced, a whole strip of control points, running across the whole patch, has to be added. Otherwise, control points would no longer lie in a rectangular grid. Thus, requesting only a single new control point causes many unwanted control points to be introduced into the model. This fact complicates design and produces unnecessary overhead for the designer.

One of the earliest studies addressing this shortcoming led to the framework called hierarchical B-splines (HB-splines)  [1]. Using nested spaces, the framework allows for locally refined patches that can represent finer detail. Later, a basis for these nested spaces was found and its stability studied  [3]. More recently, HB-splines were studied from the point of view of iso-geometric analysis  [4], a finite element framework  [5]. By construction, the new basis functions formed by coarse and fine level B-splines do not sum to unity: weights need to be introduced. An improved construction, truncated hierarchical B-splines, which avoids the need for weights and provides a strongly stable basis, was recently discovered  [6]. The truncated basis functions are convex combinations of B-splines.

Independently, spline spaces over T-meshes have been investigated  [7,8]. In this approach to local refinement of B-splines, a T-mesh in the parameter space forms a foundation for the method. The most recent construction that addresses local refinement was coined locally refined (LR) B-splines  [9].

The most widely known and used T-construction is T-splines [10,11]. T-splines are basically B-splines whose control meshes allow T-junctions. Local refinement is supported. Nevertheless, some local changes trigger a whole chain of local refinements  [11, Section 4.3]   [12, Section 3.2.5]. T-splines were originally introduced for degree three and later generalised to arbitrary degrees  [13].

All of the T-constructions mentioned above are based on B-splines and thus can be converted and generalised to NURBS. This led us to the question, answered in this paper, of whether we could achieve the desired local control by changing only the user interface, without introducing T-splines or hierarchical B-splines. This would allow existing NURBS software to be used, with all of its optimisations and functionality, with modifications required only to the user interface.

The B-spline patch is a bivariate generalisation of the univariate B-spline curve. A B-spline curve is defined by a sequence of 
                        n
                      
                     control points, 
                        
                           
                              
                                 P
                              
                           
                           
                              i
                           
                        
                     , and their associated basis functions, 
                        
                           
                              N
                           
                           
                              i
                              ,
                              k
                           
                        
                     . 
                        
                           (1)
                           
                              
                                 P
                              
                              
                                 (
                                 t
                                 )
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                    ,
                                    k
                                 
                              
                              
                                 (
                                 t
                                 )
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                              
                                 
                                    t
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              ≤
                              t
                              <
                              
                                 
                                    t
                                 
                                 
                                    
                                       max
                                    
                                 
                              
                              .
                           
                        
                      The basis functions are determined by a sequence of knots, the knot vector 
                        
                           [
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 t
                              
                              
                                 k
                                 +
                                 n
                              
                           
                           ]
                        
                     , where knots are a non-decreasing sequence of real numbers, 
                        
                           
                              t
                           
                           
                              i
                           
                        
                        ≤
                        
                           
                              t
                           
                           
                              i
                              +
                              1
                           
                        
                        
                        ∀
                        i
                     , in a parameter space spanned by 
                        t
                     . The order of a B-spline curve is given by 
                        k
                     , which is one higher than the degree of the curve  [14].

NURBS are a generalisation of B-splines in which the operations are conducted in a four-dimensional (4D) homogenous coordinate space, where the extra coordinate is a weight associated with the control point. Displaying a NURBS curve in standard three-dimensional (3D) space requires the straightforward projection from this 4D homogenous space to 3D  [14, Section 5–13]. In common with many other authors, we use “NURBS” and “B-spline” interchangeably, with the understanding that NURBS operations require this 4D to 3D projection.

It is straightforward to introduce a new control point into a B-spline or NURBS curve, without affecting the shape of the curve at all. This allows subsequent manipulation of the curve, at a finer level of detail, in the neighbourhood of the new point.

When a new knot is introduced to the knot vector, the locations of the new control points, 
                        
                           
                              
                                 Q
                              
                           
                           
                              i
                           
                        
                     , are calculated by simple linear interpolation of the existing control points, 
                        
                           
                              
                                 P
                              
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              
                                 P
                              
                           
                           
                              2
                           
                        
                        ,
                        …
                        ,
                        
                           
                              
                                 P
                              
                           
                           
                              n
                           
                        
                     . In general, given a knot vector 
                        
                           [
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 t
                              
                              
                                 k
                                 +
                                 n
                              
                           
                           ]
                        
                      and a new knot value 
                        w
                      to be inserted between knots 
                        
                           
                              t
                           
                           
                              j
                           
                        
                      and 
                        
                           
                              t
                           
                           
                              j
                              +
                              1
                           
                        
                     , we find  [15]: 
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Q
                                                
                                             
                                             
                                                i
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   P
                                                
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                       
                                       
                                       
                                          i
                                       
                                       
                                          ≤
                                          j
                                          −
                                          k
                                          +
                                          1
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   Q
                                                
                                             
                                             
                                                i
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             (
                                             1
                                             −
                                             
                                                
                                                   α
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          
                                             
                                                
                                                   P
                                                
                                             
                                             
                                                i
                                                −
                                                1
                                             
                                          
                                          +
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                          
                                             
                                                
                                                   P
                                                
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                       
                                       
                                          j
                                          −
                                          k
                                          +
                                          1
                                          <
                                       
                                       
                                          i
                                       
                                       
                                          ≤
                                          j
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   Q
                                                
                                             
                                             
                                                i
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   P
                                                
                                             
                                             
                                                i
                                                −
                                                1
                                             
                                          
                                       
                                       
                                          j
                                          <
                                       
                                       
                                          i
                                       
                                       
                                    
                                 
                              
                           
                           
                              
                                 where:
                                 
                                 
                                    
                                       α
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       w
                                       −
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             t
                                          
                                          
                                             i
                                             +
                                             k
                                             −
                                             1
                                          
                                       
                                       −
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  


                     Fig. 3(a) and (b) shows an example of a cubic (
                        k
                        =
                        4
                     ) B-spline curve, with four new points introduced successively. For this cubic example, the introduction of a new control point requires that the two control points either side are moved to new locations (Eq. (2)). The resulting, refined, control polygon is shown in Fig. 3(c).

A B-spline or NURBS patch is defined as a tensor product, where the basis functions in each direction are derived from separate knot vectors: 
                        
                           (3)
                           
                              
                                 P
                              
                              
                                 (
                                 s
                                 ,
                                 t
                                 )
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    m
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                    ,
                                    
                                       
                                          k
                                       
                                       
                                          s
                                       
                                    
                                 
                              
                              
                                 (
                                 s
                                 )
                              
                              
                                 
                                    N
                                 
                                 
                                    j
                                    ,
                                    
                                       
                                          k
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                              
                                 (
                                 t
                                 )
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              .
                           
                        
                      It is usual for the patch to have the same order (i.e., 
                        
                           
                              k
                           
                           
                              s
                           
                        
                        =
                        
                           
                              k
                           
                           
                              t
                           
                        
                     ) in both directions. Patches are thus defined by a quadrilateral grid of control points of size 
                        m
                        ×
                        n
                     .

Control of finer detail in a patch can be achieved by introducing new knots, as in the curve case, but these propagate across the whole patch (Fig. 1(c)). It is therefore impossible to introduce local control of fine detail in part of the patch without introducing unwanted control of fine detail elsewhere in the patch.

Our desire is to introduce new control points in the user interface only in locations where the user wishes finer control. Our concept for achieving this is to have multiple layers of control points. Each layer is a tensor-product NURBS mesh. The difference between one layer and the next is the introduction of a single new knot in one of the principal directions, that is, in either the 
                        s
                      or the 
                        t
                      direction in Eq. (3). When a new layer is created, links are formed from points in the previous layer to points in the new layer. These links determine the geometric positions of the new layer’s control points from those in the layer above, using the simple relationships in Eq. (2). Points in this structure are allocated one of three labels: 
                        
                           visible
                        
                        
                           —A point that is available to the user to be manipulated and is therefore visible in the user interface.

—A point that is not visible in the user interface but which is used in determining the final surface; its position is calculated internally from points in the layer above (Fig. 2).

—A point that is not visible in the user interface and plays no part in calculating the final surface; the blending function that it would have controlled is instead controlled by one or more visible points in lower layers.

When a layer is created, all its points are initially marked as hidden and then appropriate points are made visible in the user interface. For odd degrees (
                        k
                      even), these are the new point requested by the user and 
                        
                           (
                           k
                           −
                           2
                           )
                        
                        /
                        2
                      points on each side of the new point along the row (or column) on which the new point has been inserted.

When a point’s geometric position is changed, all of its dependent hidden points in the layer below are recalculated. Only one knot is introduced for any given layer, in either 
                        s
                      or 
                        t
                      direction; the recalculation therefore comprises only univariate calculations in that direction for each row (or column) of control points. Recalculation propagates down through the layers until it reaches the bottommost layer, and it is this layer of control points that is passed to the NURBS engine.

Switching a point’s status from hidden to visible has implications for visible points in higher layers. A visible control point will be marked replaced when a matching control point in a lower layer becomes visible (see Section  6 for details). This is seen, for example, in the univariate case where introducing one new point leads to the replacement, in the visible control mesh, of both of the adjacent existing points (Fig. 3(b–c)).

This concept can be extended to the introduction of arbitrarily many knots, with each new knot adding a new layer. Provided the newly-visible control points are separated sufficiently far from one another, this layering concept works perfectly (e.g.,  Fig. 2). It also works for introducing a row of control points at the same knot location (e.g.,  Fig. 2(c)) and for introducing a block of control points (e.g.,  Fig. 2(e) and (f)) where points are refined first in one direction and then the other, creating two hidden layers.

However, the examples in Fig. 2 are constructed carefully to avoid any challenging cases. Challenges occur when the user introduces a new control point near to existing hidden points. The question is: how best to handle the dependences between the newly-desired visible points and the nearby hidden points. There are several possible alternative approaches, which are described and discussed in detail in Appendix A.

Our conclusion, from considering all these approaches, is that the only viable solution to these challenges, one which maintains the integrity of the mesh, is to ensure that any hidden point that becomes dependent on (i.e., would be calculated from) a replaced point is made visible to the user.

The data structure (Fig. 4
                     ) comprises a set of layers, each of which is linked to the layer above (a coarser layer) and the layer below (a finer layer). Each layer is a valid tensor-product NURBS control mesh. Each control point, in each layer, is marked as one of visible, hidden, or replaced. Each control point is marked with a 
                        
                           (
                           s
                           ,
                           t
                           )
                        
                      co-ordinate corresponding to the position of the central knot in the support of its basis function. This constrains the algorithm to work only for odd degree (
                        k
                      even) because only odd degree B-splines have an odd number of knots in their support.
                        1
                     
                     
                        1
                        The algorithm could be modified to support even degree B-splines, but odd degrees are sufficient to demonstrate the potential and the limitations of the proposed method.
                     
                  

Each control point, in each layer, has either one or two weighted links to control points in the layer below. One of those links will be to a point that has the same 
                        
                           (
                           s
                           ,
                           t
                           )
                        
                      co-ordinate. We say there is a parent–child relationship between points of the same 
                        
                           (
                           s
                           ,
                           t
                           )
                        
                      co-ordinates in adjacent layers. For a given point, the one or two weights from the layer above, which always sum to one, provide the mechanism by which a hidden point’s location is calculated from the location of the points in the layer above.

From the set of layers we can create the mesh that is presented to the user in the user-interface. It comprises all of the visible control points from all the layers, linked together with appropriate edges.

The assumed starting point is a single layer, layer 0, with all control points marked as visible. Because there is only a single layer at the start, the initial user-interface mesh is identical to the initial starting mesh.

We now define an algorithm (illustrated in Figs. 5 and 6
                     ) which allows us to insert a single new control point on an edge in the mesh. Each point has a status, which may be visible, hidden or replaced and each point has a flag which allows it to be marked as to be replaced when necessary.


                        
                           
                              1.
                              (Fig. 5(a)) User requests that a new point be inserted on a specific edge in the mesh of visible points. The new knot value is halfway between the knot values associated with the control points at either end of that edge.

If there is already a layer that introduces that particular knot value, then the 
                                    k
                                    −
                                    1
                                  appropriate points in that layer are made visible and go to step 5.

(Figs. 5(e), 6(b)) Otherwise, a new layer is created with the newly-generated knot value. Links are formed to the control points in the previous layer, with weights for computing the control points in the new layer from the points in the previous layer (Eq. (2)). All points in the new layer have their geometric positions initialised by calculation from the points in the layer above. Mark as hidden all points in the new layer.

(Figs. 5(d), 6(c)) Mark as visible, in the new layer, the point created on the specified edge and 
                                    
                                       (
                                       k
                                       −
                                       2
                                       )
                                    
                                    /
                                    2
                                  points either side of the new point. That is, mark as visible the 
                                    k
                                    −
                                    1
                                  points on that single row (or column) that are calculated from more than one point in the layer above.

(Fig. 6(c)–(d)) For each point that is newly marked as visible, mark its parent as to be replaced.

(Fig. 6(d)–(e), see Appendix A for detail) For each point that is marked as to be replaced, first check its status: if it is hidden then mark it as replaced and mark its parent as to be replaced and recurse on step 6; if it is visible, then it becomes replaced and its parent is unaffected; if it is already replaced then do nothing. Then look at the points that it contributes to. One will be its child, which will already have been dealt with. The other, if it exists, needs to be checked: if it is hidden then mark it visible and go to step 5; if it is visible or replaced then nothing needs to be done.

(Fig. 5(b) and Section  6.2) Build a new control mesh for the user-interface based on all points that are marked as visible.

The visible control mesh (VCM) for the user-interface is created by processing every visible point in the mesh and determining its connectivity to other visible points. Points in the VCM may be linked to points in other layers. Each control point has a permanent link to the control point in the layer above that it replaces, its “parent”, if such a point exists. Each control point also has a permanent sets of links to its (up to four) neighbours in its own layer. These links are set when the layer is created and are never changed. In addition to these, each control point has a mutable set of links to its (up to four) neighbours in the VCM. The VCM links must be regenerated (Step 7 in Section  6.1) whenever a new control point is inserted to the visible mesh. 
                           
                              1.
                              Reset all VCM links to all be null.

For each layer, starting with the finest and working to the coarsest:


                                 
                                    ⊳
                                  For each visible control point, p, in the layer:


                                 
                                    ⊳
                                    
                                    ⊳
                                  For each of the four directions, 
                                    d
                                 , of connectivity:


                                 
                                    ⊳
                                    
                                    ⊳
                                    
                                    ⊳
                                  If the VCM link from p in direction 
                                    d
                                  is null, then set q to be the next point in that direction in that layer. While q is not visible and not null, set q to be its own parent. [The result is that q will be the first (and, if it exists, the only) visible point in the stack of parents of the point in direction 
                                    d
                                 ; if there is no visible point in that stack or there was no next point in direction 
                                    d
                                 , then q is null.] Set p’s VCM link in direction 
                                    d
                                  to point to q. If q is not null then set q’s VCM link in the opposite direction to point to p. [This makes a bi-directional link between the two points and means that points in coarser layers get the correct VCM links to points in finer layers.]

Each layer, 
                        l
                     , in the data structure comprises a complete tensor-product B-spline basis, 
                        
                           
                              V
                           
                           
                              l
                           
                        
                     , which consists of a set of basis functions, 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              l
                           
                        
                     . The final surface is that produced by the lowest layer, using Eq. (3). In addition to the bases for each layer, which are straightforward NURBS bases, it is necessary to consider the generating system associated with the VCM.

Each visible control point in the VCM has an associated blending function. These combine to make the generating system for the VCM. The generating system associated with the visible control points is most usefully compared with Giannelli et al.’s Truncated Hierarchical B-spline basis  [6]. Indeed, it can be considered a variation on THB-splines.

Every blending function in our system is a weighted sum of NURBS basis functions from the lowest level. This is identical to the situation with THB-splines. However, THB-splines are presented in a different way by Giannelli et al.: they present them as basis functions at a higher level being truncated by subtracting basis functions from a lower level. The two views are equivalent mathematically, but, in contrast to THB-splines, our system is not based on a hierarchy of nested domains which govern refinement. Instead, our user interface is focused on handling refinement via (visible) control points.

We now demonstrate how we can represent the blending functions associated with the set of visible control points in a manner similar to that used for THB-splines.

Consider a rewriting of the bivariate B-spline definition, Eq. (3), to remove unnecessary subscripts: 
                        
                           
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    l
                                 
                              
                              
                                 (
                                 s
                                 ,
                                 t
                                 )
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              
                                 (
                                 s
                                 ,
                                 t
                                 )
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              ,
                           
                        
                      where 
                        l
                      is the level in the data structure and 
                        i
                      ranges over all of the points in that level. If we remove explicit reference to the parameter space, 
                        
                           (
                           s
                           ,
                           t
                           )
                        
                     , we can see clearly the relationship between one level and the next in the data structure: 
                        
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    l
                                    −
                                    1
                                 
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                                 
                                    l
                                    −
                                    1
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              .
                           
                        
                      The way in which control point locations are calculated, Eq. (2), can be stated in a single equation: 
                        
                           
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              =
                              
                                 (
                                 1
                                 −
                                 
                                    
                                       α
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 )
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                    −
                                    1
                                 
                                 
                                    l
                                    −
                                    1
                                 
                              
                              +
                              
                                 
                                    α
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                                 
                                    l
                                    −
                                    1
                                 
                              
                           
                        
                      where we have assumed that the index 
                        i
                      indexes the rows and columns of the two-dimensional grid in an appropriate way, that is, it runs along each row (or column) in which a new knot is inserted before moving to the next. This allows us to show how NURBS basis functions, 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              l
                           
                        
                     , in one layer relate to basis functions, 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              l
                              −
                              1
                           
                        
                     , in the previous layer: 
                        
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       l
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       
                                          P
                                       
                                    
                                    
                                       i
                                    
                                    
                                       l
                                       −
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 
                                    
                                       
                                          P
                                       
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 
                                    (
                                    
                                       (
                                       1
                                       −
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                          
                                             l
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             P
                                          
                                       
                                       
                                          i
                                          −
                                          1
                                       
                                       
                                          l
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       
                                          α
                                       
                                       
                                          i
                                       
                                       
                                          l
                                       
                                    
                                    
                                       
                                          
                                             P
                                          
                                       
                                       
                                          i
                                       
                                       
                                          l
                                          −
                                          1
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    (
                                    
                                       
                                          α
                                       
                                       
                                          i
                                       
                                       
                                          l
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          i
                                       
                                       
                                          l
                                       
                                    
                                    +
                                    
                                       (
                                       1
                                       −
                                       
                                          
                                             α
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                          
                                             l
                                          
                                       
                                       )
                                    
                                    
                                       
                                          N
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                       
                                          l
                                       
                                    
                                    )
                                 
                                 
                                    
                                       
                                          P
                                       
                                    
                                    
                                       i
                                    
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                           
                           
                              
                                 ⇒
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       l
                                       −
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       α
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       l
                                    
                                 
                                 +
                                 
                                    (
                                    1
                                    −
                                    
                                       
                                          α
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                       
                                          l
                                       
                                    
                                    )
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                    
                                       l
                                    
                                 
                                 .
                              
                           
                        
                      We are now ready to demonstrate how to construct a generating system for the set of visible control points.

Each hidden or visible control point has a NURBS basis function, 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              l
                           
                        
                     , and a possibly-truncated blending function, 
                        
                           
                              T
                           
                           
                              i
                           
                           
                              l
                           
                        
                     . For the bottom layer, 
                        
                           
                              V
                           
                           
                              n
                           
                        
                     : 
                        
                           
                              
                                 
                                    T
                                 
                                 
                                    i
                                 
                                 
                                    n
                                 
                              
                              =
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    n
                                 
                              
                              .
                           
                        
                      Now, let 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              l
                           
                        
                        ∈
                        
                           
                              V
                           
                           
                              l
                           
                        
                      be a basis function associated with a hidden or visible control point: 
                        
                           (4)
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              =
                              
                                 
                                    α
                                 
                                 
                                    i
                                 
                                 
                                    l
                                    +
                                    1
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    l
                                    +
                                    1
                                 
                              
                              +
                              
                                 (
                                 1
                                 −
                                 
                                    
                                       α
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                    
                                       l
                                       +
                                       1
                                    
                                 
                                 )
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                    +
                                    1
                                 
                                 
                                    l
                                    +
                                    1
                                 
                              
                              .
                           
                        
                      The truncated versions depend on the status of the points 
                        
                           
                              
                                 P
                              
                           
                           
                              i
                           
                           
                              l
                              +
                              1
                           
                        
                      and 
                        
                           
                              
                                 P
                              
                           
                           
                              i
                              +
                              1
                           
                           
                              l
                              +
                              1
                           
                        
                      as follows: 
                        
                           (5)
                           
                              
                                 
                                    
                                       both
                                       
                                       
                                          
                                             
                                                P
                                             
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                P
                                             
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       
                                       
                                          hidden
                                       
                                    
                                    
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                          
                                             l
                                          
                                       
                                       =
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       +
                                       
                                          (
                                          1
                                          −
                                          
                                             
                                                α
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                             
                                                l
                                                +
                                                1
                                             
                                          
                                          )
                                       
                                       
                                          
                                             T
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 
                                    
                                       only
                                       
                                       
                                          
                                             
                                                P
                                             
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       
                                       
                                          hidden
                                       
                                    
                                    
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                          
                                             l
                                          
                                       
                                       =
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 
                                    
                                       only
                                       
                                       
                                          
                                             
                                                P
                                             
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       
                                       
                                          hidden
                                       
                                    
                                    
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                          
                                             l
                                          
                                       
                                       =
                                       
                                          (
                                          1
                                          −
                                          
                                             
                                                α
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                             
                                                l
                                                +
                                                1
                                             
                                          
                                          )
                                       
                                       
                                          
                                             T
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        
                      The first option corresponds to no truncation, the coarser blending function at level 
                        l
                      is a weighted sum of two finer blending functions of level 
                        l
                        +
                        1
                      as in standard B-spline knot insertion. Basically, the newly created function ‘does not see’ the newly inserted knot.

The last two options correspond to truncation: the finer blending function from level 
                        l
                        +
                        1
                      is passed directly up the data structure and ‘replaces’ the original coarser blending function of level 
                        l
                     . In this case, the newly inserted knot ‘remains visible’ for the function.

Consequently, the 
                        T
                      functions are either B-splines or combinations thereof from different levels, i.e., they are truncated B-splines.

The overall generating system, based solely on visible control points, creates the final surface: 
                        
                           
                              
                                 P
                              
                              
                                 (
                                 s
                                 ,
                                 t
                                 )
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    
                                       
                                          
                                             P
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ∈
                                    
                                    
                                       visible
                                    
                                 
                              
                              
                              
                                 
                                    T
                                 
                                 
                                    i
                                 
                              
                              
                                 (
                                 s
                                 ,
                                 t
                                 )
                              
                              
                                 
                                    
                                       P
                                    
                                 
                                 
                                    i
                                 
                              
                              .
                           
                        
                     
                  

To ensure partition of unity, the blending functions of the set of visible control points must truly encompass the set of NURBS basis functions of the lowest layer of the data structure. That is, every 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      must be incorporated into the 
                        T
                      of visible points, with the contribution of each 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      summing to unity. Details of this, and of how we can check linear independence of the generating system, are in Appendix B.

Those familiar with the blossom (polar forms) formulation will be able to see an alternative, more compact, way of representing this mechanism in the one-dimensional case (e.g., Fig. 4). However, the fact that the corresponding blending functions in our construction are not, in general, minimally supported B-splines but rather linear combinations thereof from different levels precludes the use of blossoms in the two-dimensional case. The blossom notation could be used for control points but not for evaluating the spline itself.

@&#DISCUSSION@&#


                     Fig. 7
                      shows some examples in our experimental user interface. The method allows for the insertion of new control points on any visible edge. Once a point has been inserted it gives finer control of the local shape of the surface than would be possible with the original control points. The algorithm can be adapted to work for any method definable by knot insertion, including subdivision and NURBS of even degree.

Four optional features are worth discussing in more detail:


                     Simultaneous introduction of many new control points.
                     Fig. 2 shows the introduction of a row of control points (Fig. 2(c)) and of a block of control points (Fig. 2(e) and (f)). In these cases, the newly-inserted knot(s) suffice for all new points and so one or two hidden layers suffice to introduce many new control points. The user-interface can be designed to allow the user to specify insertion on a single edge (Fig. 2(d)), or on several parallel edges (Fig. 2(c)), or in a block (Fig. 2(e) and (f)).


                     Insertion at arbitrary knot values. As written, the algorithm follows Gordon and Riesenfeld’s original suggestion for B-spline refinement  [16, Section 13], which is to place the new knot “midway (parametrically) between two of the previously existing knots”. The advantage of this is that introducing a new control point between two knot lines where there has already been introduced a control point elsewhere in the mesh leads simply to a hidden control point being made visible and means that we do not have to create a new hidden layer nor do a new knot insertion. However, there is nothing in the method that prevents a knot being introduced at any value.


                     Higher degrees. Our implementation works for NURBS of arbitrary odd degree. However, the limitations of the method (see below) become increasingly obvious for higher degrees, because insertion of a single new control point has a wider influence across the mesh as degree increases.


                     Multiple NURBS patches. The algorithm can be applied to compositions of multiple NURBS patches. First, we need to ensure that adjacent patches are compatible, i.e., they are of the same degree across their shared edge and they share the knot vector along the edge. This can be always ensured by standard algorithms such as degree raising and knot insertion. Assuming that the two adjacent patches are compatible in this sense, there are still subtleties in what changes need to be propagated across their shared boundary. Naïvely one would expect that any knot insertion needs to propagate into the patches either side of the existing patch. However, because the patch does not change its geometry after knot insertion, this only needs to happen if there is a change in the visible control points on the actual edge between two patches.

An alternative is to merge two or more (compatible) NURBS patches into one NURBS surface, which can then be treated without any further modifications. However, this approach is available only if the patches form a logical rectangular array when combined.

@&#LIMITATIONS@&#

Despite working, the method suffers from several limitations. The commonly occurring limitations are minor inconveniences, but the more rarely occurring ones could be considered a serious drawback for the user, because they cause a large number of unexpected (and therefore unwanted) control points to be generated from a single insertion. We discuss the limitations from the most commonly occurring, and least problematic, to the least commonly occurring.


                        New points may not appear exactly where the user expects.
                        Fig. A.14 gives a clear example of this. The user requests a new point on an edge that she sees as sloping slightly up from left to right (Fig. A.14(a)). What she gets (Fig. A.14(b) and (f)) is a new point on a horizontal edge slightly displaced from the horizontal line through the original (red) points. However, users of any system get used to its quirks. For example, normal cubic knot insertion causes two existing control points to apparently jump slightly away from the newly-introduced point (e.g.,  Figs. 3 and 5(b)). Mathematically this is the right behaviour, but a novice user still needs to get used to it. Likewise, slight jumps in control point position are likely to be quickly accepted as a feature of the system, especially as the surface itself does not change when a new control point is inserted.


                        Unexpected control points may appear. In Fig. A.14, the replacement of point 
                           ρ
                         by point 
                           γ
                         requires that we make point 
                           σ
                         visible, leading to Fig. A.14(f). This behaviour might surprise a user, though in this case a user might easily understand that the extra point appears because the newly-inserted point is adjacent to a previously-inserted point. More surprising is such behaviour when it is caused by control points inserted on the far side of the mesh.


                        Lack of symmetry. Because previously-inserted points can affect later insertions there is a lack of symmetry in operations. Inserting two points in different orders can have different results. This is the case in Fig. A.14(f), where the two points requested by the user are symmetric, but the result is not symmetric with respect to those two points. One result of the lack of symmetry is the possibility that the new control points will control different blending functions depending on the order in which the user inserts them. This might be considered problematic but recall that we are proposing a user-orientated solution: the user requests the insertion of new points in a particular order, and adjusts the new points as they see appropriate. If they then insert a new point, it is with the full understanding of all previous insertions and they have to accept that the earlier insertions may affect the later ones.


                        Unusual-looking configurations may occur. There are pathological sequences of insertions that lead to corners (Fig. 8
                        (a)) and peninsulas (Fig. 8(b)). Similar features appeared in the early versions of T-splines
                           2
                        
                        
                           2
                           Tom Sederberg and Tom Hughes both independently confirmed that similar features were in the earliest versions of T-splines.
                         but are not present in the published version  [10]. These unusual configurations are not errors; the control points are connected correctly in the user-interface grid, as shown in more detail in Appendix C. If such features are deemed to be undesirable, they can be easily identified from the connectivity of the VCM and the unusual-looking connectivity “fixed” by forcing adjacent control points in the same layer to become visible, creating a 
                           ⊤
                         or + connectivity. The disadvantage of this “fix” is that even more unexpected control points will become visible.


                        Cascades of unexpected control points may occur. In other pathological cases, previously inserted knots can cause a cascade of new control points to appear. That is, local insertion of a new control point has the effect of introducing a set of points across the mesh. Fig. 9
                         shows such a pathological case. The original T-spline method  [10] also suffered from unwanted cascade across the mesh  [11, Section 4.3]   [12, Section 3.2.5], but more recent work  [17] has demonstrated how T-splines can be refined without excessive propagation of control points. Our simpler mechanism does not admit such an elegant solution. As a user-centric method, the appropriate way to ameliorate the effect of any cascade is to make the user aware of the consequences of any insertion. A straightforward way to do this is, when the user hovers their cursor over a particular edge, to highlight all edges that would be affected if the user chose to refine that particular edge. A user who is aiming for a local refinement can then investigate which edge should be selected to introduce the best set of new control points.

@&#CONCLUSION@&#

We have shown that it is possible to provide the user with local refinement of the control mesh solely by modifying the user-interface. All that is required is a data structure for storing the layers and the straightforward algorithms for adding a new layer (Section  6.1) and for generating the user-interface view (Section  6.2). The limitations that we have highlighted (Section  8.1) mean that we do not expect our user-centric approach to compete with the more powerful mechanisms offered by T-splines, LRB-splines, and HB-splines. We have, however, shown that is possible to use the standard NURBS implementation to provide locally refined behaviour to the user.

@&#ACKNOWLEDGEMENTS@&#

Kosinka was supported by the Engineering and Physical Sciences Research Council [EP/H030115/1]. We acknowledge Tao Yang, whose implemented our first test bed during his Masters project (2011–12), which provided insights into some of the potential solutions discussed in Appendix A. For useful discussions, we gratefully acknowledge Malcolm Sabin, Tom Hughes, and Oliver Deussen. We thank the organisers of the SMART 2014 workshop for allowing us to present the talk on which this paper is based.

Challenging cases arise when the user requests a new visible point that is close to an existing hidden point. There are challenges for new points inserted on a row parallel to an existing insertion and challenges for new points inserted on a column perpendicular to an existing insertion on a row.

The first set of challenges that we consider is where we introduce new points on two parallel knot lines. Fig. A.10
                         shows the context. In Fig. A.10(a), we see the situation as presented in the user-interface. Two new control points are introduced on two parallel knot lines, 
                           B
                         and 
                           C
                        , in each case causing the two adjacent control points to be replaced by new points, in the same manner as happens in the univariate case. The knot lines, 
                           B
                         and 
                           C
                        , could be adjacent or separated by a small number of other knot lines (two in this example) or on completely opposite sides of the patch. In any case, the challenge is caused by the overlap between the newly-introduced visible points in the bottom layer, (c), and the previously-introduced hidden points in the previous layer, (b). Fig. A.10(b) shows the introduction of new (green) points in the upper layer, related to the control point on row 
                           B
                        . Fig. A.10(c) shows the introduction of new (yellow) points in the lower layer, related to the control point on row 
                           C
                        . Everything works well on all rows other than row 
                           C
                        .

To get some intuition into the challenge, first consider row 
                           B
                         (Fig. A.11
                        ). The insertion of a new control point in this row is straightforward. The position of the new point and the points either side are calculated using the new knot value, the existing knot vector, and the positions of the control points. The three new control points are then made visible to the user in the user-interface, with the two replaced control points removed from the user-interface.

Consider now the subsequent insertion of a new control point on row 
                           C
                         (Fig. A.12
                        ). The insertion of this new layer (Fig. A.12(b)) proceeds by direct analogy to the previous insertion (Fig. A.11(b)). However, the removal of the replaced points from the user-interface (Fig. A.12(c)) causes a problem: one of the points in the first hidden layer depends on one of the replaced points (
                           ρ
                        , dashed arrow) and that point is no longer available to the user. This insertion is therefore invalid, because the user has lost control of part of the generating system. This problem will arise in any situation where there is overlap of the extent of the newly-introduced points in the new bottom layer with the extent of introduced points in any one of the layers above and it will happen even if the newly-inserted point is on the far side of the mesh, because the existing inserted knot spans the entire mesh.

We now consider ways to avoid the problem of hidden layers interfering with each other in the way described above. We describe these for the parallel case here. In Appendix A.3, we consider the added challenges of insertion on knot lines that are perpendicular. There are three potential solutions for the parallel case, shown in Fig. A.13
                        . 
                     


                           Fig. A.13(a) shows the hidden layer for row 
                              C
                            being introduced before that for row 
                              B
                           . This avoids the problem. Only row 
                              C
                            needs to have the order swapped. This works for arbitrarily many rows and arbitrarily many insertions on any given row, provided all the insertions for each row are done for that row first. On each row, the hidden insertions related to all other rows can be done in any order subsequently. However, this neat solution does not generalise well to insertions on perpendicular knot lines (Appendix A.3).

In this solution, we make visible any hidden point that depends on a replaced point. Fig. A.13(b) shows the effect of making visible the affected hidden point, 
                              ω
                           , in the first hidden layer. This is the point that was previously relying on a replaced control point. By making such points visible to the user, the problem is resolved. However, this means that introducing a new point on row 
                              C
                            causes an extra control point to appear on that row. In general, the appearance of unexpected new points may be a mysterious, and therefore undesirable, side-effect for the user, especially if row 
                              C
                            is distant from row 
                              B
                           . However, this solution does generalise well to the case of insertions on perpendicular knot lines (Appendix A.3).

A superficially-attractive solution is not to replace existing control points. All original control points stay in the user-visible mesh but each now controls a reduced blending function, with some of their original blending functions being controlled by the single newly-introduced control point. This is reminiscent of THB-splines  [6], but the absence of nested domains means that it has drawbacks in our system. Fig. A.13(c) shows how this plays out in our layer system. The original points all stay visible to the user, generating hidden control points as needed. The single newly-introduced control point, 
                              ν
                           , is calculated as usual from Eq. (2) and then made visible to the user for subsequent manipulation. This solution certainly works in the univariate case because in that case there are no problematic intervening hidden layers. However, the layer diagram in Fig. A.13(c) reveals a problem in the bivariate case: the original control point labelled 
                              α
                           , to the right of the new control point, 
                              ν
                           , contributes to a point, 
                              β
                           , in the first hidden layer, which then contributes to a point, 
                              γ
                           , in the second hidden layer that is to the left of the new control point. Thus 
                              α
                           , which should only influence the mesh to the right of 
                              ν
                           , has influence to the left of 
                              ν
                            and will continue to do so no matter how many further points are introduced between 
                              δ
                            and 
                              α
                           .

For the parallel case, we thus have two satisfactory insertion methods, exchanging layers (Appendix A.2.1) and revealing hidden control points (Appendix A.2.2), and two unsatisfactory methods, the original idea (Fig. A.12) and the “no replacement” idea (Appendix A.2.3). Now we consider whether the two satisfactory methods work when points are inserted on perpendicular knot lines.


                        Fig. 2 shows examples of insertion along perpendicular edges in which the method, as described, works without introducing any unexpected visible control points. Fig. A.14, by contrast, shows the most challenging of the perpendicular insertion cases: insertion along adjacent perpendicular edges.

The challenge is that, again, a replaced point, 
                           ρ
                        , is required for calculation of other, hidden, points. Let us consider our two satisfactory approaches from the parallel case.

While the method of exchanging layers would work in some perpendicular insertion configurations, it will not work in the most challenging case shown in Fig. A.14. This is firstly because this case is perfectly symmetric. If we exchange the green and yellow insertions, then we get exactly the same problem. Secondly it is because the yellow insertion would need the context of red points that have already been replaced. The vertical offset of the new yellow points in Fig. A.14(b) shows that the second insertion is affected by the first; they cannot be made independent and so they cannot be exchanged in order. Indeed, if one were to try to swap the order, one would find that two red control points required to do the yellow knot insertion had been replaced by green control points. If the user had not moved any of the green control points before requesting the new yellow point (arrow in Fig. A.14(a)) then it would be plausible to exchange the layers but if the user has moved any of those three green points, any exchange of these layers becomes invalid.

The second satisfactory approach in the parallel case does generalise to the perpendicular case. This is where we reveal any hidden points that depend on replaced points. In the case of Fig. A.14, the solution is straightforward: we make point 
                           σ
                         visible to the user. This is the solution that maintains integrity and is incorporated in the algorithm (Section  6.1).

We consider how the algorithm ensures that the partition of unity of the initial generating system (which is, by definition, a NURBS basis) is maintained when a new layer is introduced, and we consider how we can check whether the generating system comprises linearly independent blending functions.

To ensure partition of unity, we must be sure that the set of generating functions of visible control points encompasses the set of NURBS basis functions of the lowest layer of the data structure. For this to be true, every 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      must be incorporated into the 
                        T
                      of visible points, with the contribution of each 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      summing to unity. The iterative definition in Eq. (5) shows that the 
                        T
                      blending functions are passed up the layers until they hit a visible point, where they stop. Therefore, every visible point must have at least one hidden point as a child, that is, at least one of the three cases in Eq. (5) holds for each visible point. Furthermore, no replaced point can have a hidden point as a child, otherwise part of a 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      basis function will not be included in the 
                        T
                      blending function of any visible point. Finally, there may be no hidden points in the top layer, again because otherwise part of a 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      basis function will not be included in the blending function of any visible point.

Therefore, the highest level layer, 
                        
                           
                              V
                           
                           
                              0
                           
                        
                     , must consist only of visible and replaced control points; there can be no hidden points in the top layer because such points require points above them that control them. The lowest level layer, 
                        
                           
                              V
                           
                           
                              n
                           
                        
                     , must consist only of visible and hidden control points; there can be no replaced points in the bottom layer, because such points must be replaced by points in lower layers and no such points exist.

When the data structure is initialised, it comprises a single layer consisting entirely of visible points, meeting the conditions on both the topmost and bottommost layers. Its generating system is a standard tensor-product B-spline basis. Because of this, the blending functions attached to the initial set of visible points form a valid, linearly-independent, partition of unity.

To maintain a partition of unity, we must demonstrate that the algorithm in Section  6.1 ensures that, given a valid partition of unity amongst the visible control points, the result is a new valid partition of unity. The calculation of the 
                        α
                      values using the standard method (Eq. (3)) ensures that the blending functions will be split correctly to maintain a partition of unity, so long as the algorithm ensures two things: (1) that no visible point has only visible points as its children and (2) that there is no direct connection between a replaced point in one layer and a hidden point in the next layer. In Step 3 of the algorithm a new layer is created comprising entirely hidden points. This does not affect the validity of the partition of unity amongst visible control points because it does not change the set of visible control points. Step 4 sets some of the points in the new layer to be visible, thereby invalidating the partition. Steps 5 and 6 adjust the status of other points to restore validity. The first part of Step 6 runs up the list of parents of a newly visible point and makes them all replaced, ensuring that no visible point has only visible points as its children. This ensures that all parts of a 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      that are allocated to a new visible point are removed from any higher-level points that are newly marked as replaced. However, that higher-level replaced point may have contributions from other 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      than those covered by the new visible point. Therefore, the second part of Step 6 looks at the other child of these newly replaced points to check whether it needs to be made visible in order to restore the partition of unity.

It might be thought that, given the above and the definitions in Eqs. (4) and (5), we should be able to apply, to our generating system, Giannelli et al.’s proofs  [6] for THB-splines. This would allow us to demonstrate linear independence in addition to partition of unity. However, our construction is looser that the THB-spline construction. In particular, THB-splines rely on the concept of nested subdomains in the proof of linear independence. We do not have nested domains in the sense used by THB-splines, we have only nested spaces.

We can, however, demonstrate whether any particular configuration comprises linearly independent blending functions. We have 
                        n
                        +
                        1
                      levels 
                        l
                        =
                        0
                        ,
                        …
                        ,
                        n
                      and in each a set of visible control points, each with a blending function. For a particular level, 
                        l
                     , let the set of visible control points be indexed by the index set 
                        
                           
                              V
                           
                           
                              l
                           
                        
                     . To prove linear independence, we need to show that: 
                        
                           (B.1)
                           
                              
                                 
                                    ∑
                                 
                                 
                                    l
                                    =
                                    0
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    ∈
                                    
                                       
                                          V
                                       
                                       
                                          l
                                       
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              
                                 
                                    T
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              =
                              0
                              
                              ⇒
                              
                              ∀
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              =
                              0
                              .
                           
                        
                      Say we collect all the coefficients from Eq. (5) and combine them to produce the same condition expressed in terms of 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                     . Namely, 
                        
                           (B.2)
                           
                              
                                 
                                    ∑
                                 
                                 
                                    l
                                    =
                                    0
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    ∈
                                    
                                       
                                          V
                                       
                                       
                                          l
                                       
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              
                                 
                                    T
                                 
                                 
                                    i
                                 
                                 
                                    l
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    n
                                 
                              
                              .
                           
                        
                      There exists a matrix 
                        M
                      that computes the 
                        
                           
                              d
                           
                           
                              i
                           
                        
                      from the 
                        
                           
                              c
                           
                           
                              i
                           
                           
                              l
                           
                        
                     . Because the 
                        
                           
                              N
                           
                           
                              i
                           
                           
                              n
                           
                        
                      are linearly independent, proving that 
                        M
                      has full rank would show that the generating system forms a basis. This provides a straightforward algorithmic way of checking whether a given structure leads to a basis. However, it must be said that the proposed application of the method, ab initio design of surfaces, does not depend on linear independence of the generating system.

In Section  8 two cases are presented where a sequence of four insertions leads to an interesting set of dependences being revealed. Fig. C.15
                      shows the layer structure for these cases, which demonstrates that, although the connectivity may look unusual in the user interface, it is correct.

@&#REFERENCES@&#

