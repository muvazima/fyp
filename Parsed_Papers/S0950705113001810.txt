@&#MAIN-TITLE@&#Knowledge reuse integrating the collaboration from experts in industrial maintenance management

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Collaborative maintenance management and problem solving in industrial environments.


                        
                        
                           
                           Case based reasoning as the process for using past experiences to solve new problems.


                        
                        
                           
                           Conceptual graphs for knowledge representation and visual reasoning using taxonomy.


                        
                        
                           
                           Transferable belief model for collaborative decision making/risk based maintenance.


                        
                        
                           
                           Methodological aspects linked to functionality (e.g. diagnosis or health assessment).


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Collaborative decision making

Experienced knowledge

Transferable belief model

Case-based reasoning

Maintenance management

@&#ABSTRACT@&#


               
               
                  Distributed environments, technological evolution, outsourcing market and information technology (IT) are factors that considerably influence current and future industrial maintenance management. Repairing and maintaining the plants and installations requires a better and more sophisticated skill set and continuously updated knowledge. Today, maintenance solutions involve increasing the collaboration of several experts to solve complex problems. These solutions imply changing the requirements and practices for maintenance; thus, conceptual models to support multidisciplinary expert collaboration in decision making are indispensable. The objectives of this work are as follows: (i) knowledge formalization of domain vocabulary to improve the communication and knowledge sharing among a number of experts and technical actors with Conceptual Graphs (CGs) formalism, (ii) multi-expert knowledge management with the Transferable Belief Model (TBM) to support collaborative decision making, and (iii) maintenance problem solving with a variant of the Case-Based Reasoning (CBR) mechanism with a process of solving new problems based on the solutions of similar past problems and integrating the experts’ beliefs. The proposed approach is applied for the maintenance management of the illustrative case study.
               
            

@&#INTRODUCTION@&#

Today, the technological evolution combined with an ever-increasing customer focus has greatly influenced industrial practice. Trends in industry (e.g. the growing outsourcing market and the organizational changes due to mergers or relocations) have shaped the current state of maintenance management in which the reliability and availability of equipment and monitoring and control systems are essential [49]. The maintenance policy optimization has changed much during the last decade, from failure-based maintenance (corrective maintenance only) via condition-based maintenance (opportunity for e-maintenance) to design-out maintenance (maintainability and reliability issues). In this study, the term maintenance, following common usage, includes repairs and all system modifications that occur during the use phase of the system’s life [4]. Equipment modifications are aimed either at increasing the reliability (increasing the mean time between failures (MTBF)) or the maintainability (decreasing the mean time to repair (MTTR)) to improve the equipment availability. The critical success factors for professional and sustainable maintenance management include a sound technical and technological background with management skills and the flexibility to respond to the opportunities and threats for the maintenance department [73]. The experts, as well as the maintenance firms that execute maintenance jobs, are affected by these factors and are concerned about collaborative knowledge management because seemingly identical problems will regularly demand varying approaches and actions [36].

For large organizations, due to the concurrent engineering projects and geographically distributed activities, sharing lessons that have been learned from experience feedback processes covering time and space has become a key issue for performance improvement. The successful application of knowledge management necessitates the interaction within multi-disciplinary projects (e.g. groups of people working on issues related to standardization) and distributed decision-making processes as basic requirements [61]. The value that knowledge management brings to mixed groups results from the potential for enhancing and controlling the flow of knowledge among heterogeneous sources across space and time [45]. Maintenance is embedded in a given business context and must be in accordance with environmental and safety regulations. Collaborative expectations concerning problem solving and its impact also create knowledge conditions for maintenance management [55]. Problem solving requires searching and sharing knowledge among a group of actors in a particular context. Maintenance actors (technicians and experts) have much expertise (implicit or tacit knowledge) from experiences over the years. Capturing this knowledge, storing it and distributing it within and across the communities of practice, is an important issue of maintenance management. For organizations, experience management [9] is useful for generating explicit knowledge to allow actors to find relevant information, for consulting experts’ views on complex installations and for acquiring other forms of implicit or tacit knowledge. Using experience management as a maintenance management technique for industry can be a highly valuable and has a large potential for reuse: for example, the guidelines for the diagnosis of a complex failure can be used for the subsequent repair actions or as fine-tuning parameter advice for determining high-tech installation-implicit knowledge [50]. The application of knowledge management technology in maintenance management can also offer easy access to collaboration tools and community work areas in which experts can share their views and knowledge. For these collaboration tools, an interoperability problem exists when there are barriers (incompatibilities or mismatches) that obstruct the sharing and exchange of information (between information systems) [20]. Semantic technologies are interesting solutions for removing conceptual barriers to interoperability that can be used at different organization levels (business, process, service and data) [15,16] by creating a positive knowledge-sharing environment in the organization. This technique is important for knowledge aggregation, which is the synergistic use of knowledge from different resources to complement insufficient knowledge and obtain new knowledge.

The proposal of this work is based on a cognitive knowledge management approach that is applied for collaborative decision-making situations. The goal of this study is to improve collaboration among maintenance experts through the deployment of artificial intelligence tools to effectively share experiences to generate knowledge and better resolve problems.

The paper is structured as follows. Section 2 provides a background of the state-of-the-art concerning knowledge management (through experience feedback and Case-Based Reasoning), knowledge representation formalisms and aggregation techniques. Section 3 presents the proposed research approach and applies its main components to collaborative maintenance management. An illustrative application example of collaborative problem solving of a maintained system from a case study is provided in Section 4. Finally, Section 5 provides conclusions and discusses future challenges.

For collaborative maintenance management, the capitalization and reuse of expert knowledge is crucial and difficult to implement. There are various psychological techniques (e.g. interviewing, protocol analysis and multidimensional scaling [70]) that can be utilized to elicit and model expert knowledge in industrial decision-making situations. It is essential to combine different theories to address this challenge. More specifically, these theories include problem solving methods (e.g. Case-Based Reasoning (CBR)), knowledge representation formalisms (e.g. Conceptual Graphs), and knowledge aggregation techniques (e.g. the Transferable Belief Model (TBM)). It is beneficial to review these theories in this section.

For this work, our approach fits within the experience feedback framework detailed in [51]. In this framework, the authors propose a structured description of a gradual transformation of an event into knowledge, performed by the actors. Their cognitive experience feedback process is comprised of three levels: context, experience and knowledge/lessons learned. These levels are described as follows.
                              
                                 •
                                 The context level leads to the event description. This level contains a general problem to solve and occurs prior to in-depth analysis. Context is useful when representing and reasoning within a restricted state space in which a problem can be solved. The identification of critical events is often performed by a multidisciplinary committee. In this case, the risk criteria are the reference terms (standards, measures, or expectations) that are used to make a judgment or a decision regarding the significance of the risk that will be assessed [24]. Risk criteria may include associated costs and benefits, legal and statutory requirements or actors’ concerns [3]. Thus, the experience feedback is systematically recorded beyond a critical threshold.

The experience level leads to the definition and implementation of solutions for the event. An event must be analyzed according to its context (search of the causes and evaluation of the effects on the system) to propose corrective actions. A tree analysis diagram is often used to list the various potential causes and their weighting factors, which characterize their degree of plausibility [59]. In a causal tree, the studied event (e.g. the undesired event is the failed state of a system that may occur) is placed at the top. This formalization is important because it focuses on the most likely branches (e.g. safety nets) for validating the root causes.

The “knowledge” level or lessons learned refer to the knowledge of the experiences and summarizes the involved analysis (knowledge from the domain experts), the obtained knowledge (measurement or prediction) and the generalized rules from this set of experiences (e.g. rules from failure investigations). For instance, certain design rules are generalized from the analysis of accidents and system failures in process industries [67]. Thus, lessons learned can considerably improve the decision processes and represents a significant component of the knowledge management approach for modern organizations [69].

We consider that an experience case can be represented as a collection of information that incorporates context (description of the problem), analysis (a search for the root cause of the problem) and a solution (set of actions that solve the problem). Thus, an experience Ei
                            is represented by a triplet Ei
                           
                           =〈Ci
                           ,
                           Ai
                           ,
                           Si
                           〉, where Ci
                           , Ai
                            and Si
                            respectively represent the context, analysis and solution, which are described by several descriptors. Additionally, an experience base corresponds to a set of several experiences:
                              
                                 
                                    
                                       
                                          B
                                       
                                       
                                          Exp
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          E
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    i
                                    ∈
                                    {
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    }
                                    }
                                 
                              
                           In our approach, the conceptualization of the domain vocabulary and relevant knowledge relating to the activities of the concerned organization should support the experience feedback framework. The objectives of this study include explicitly representing the experiential knowledge in an organization and allowing for the actor’s access and re-use of this knowledge.

The two main processes of an experience feedback process are capitalization and exploitation [51]. The capitalization process is based on three sub-processes: acquisition, formalization and stocking of experiences (context description, analysis and solution). Exploitation is based on three sub-processes: retrieval, adaptation and generalization. These sub-processes are the core techniques that support the experience feedback processes. We are particularly interested in the sub-processes of exploitation; thus, a promising technique for this knowledge reuse for problems solving, called Case-Based Reasoning (CBR), is used.

Case-Based Reasoning (CBR) is a cyclic and integrated process for problem solving by learning from experiences. Usually, in CBR, a case is composed of a problem part and a solution part [41]; then, it is represented by this pair of elements, denoted as case=(pb,sol(pb)). In particular, during the five-step process of Case-Based Reasoning (see Fig. 1
                           ), a source case, denoted as source_case=(source,sol(source)), is a case in which the solution will be reused to solve a new problem. The new problem is called a target case denoted as target_case=(target,sol(target)).

Additionally, the problem and solution parts are described by descriptors [43] as follows:
                              
                                 
                                    
                                       
                                          source
                                          =
                                          {
                                          
                                             
                                                d
                                             
                                             
                                                1
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                d
                                             
                                             
                                                n
                                             
                                             
                                                s
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                             
                                                s
                                             
                                          
                                       
                                     is a source problem descriptor (for i
                                    =1,…,
                                    n),


                                    
                                       
                                          sol
                                          (
                                          source
                                          )
                                          =
                                          {
                                          
                                             
                                                D
                                             
                                             
                                                1
                                             
                                             
                                                s
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                D
                                             
                                             
                                                m
                                             
                                             
                                                s
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                j
                                             
                                             
                                                s
                                             
                                          
                                       
                                     is a source solution descriptor (for j
                                    =1…,
                                    m),


                                    
                                       
                                          target
                                          =
                                          {
                                          
                                             
                                                d
                                             
                                             
                                                1
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                d
                                             
                                             
                                                n
                                             
                                             
                                                t
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                             
                                                t
                                             
                                          
                                       
                                     is a target problem descriptor (for i
                                    =1,…,
                                    n),


                                    
                                       
                                          sol
                                          (
                                          target
                                          )
                                          =
                                          {
                                          
                                             
                                                D
                                             
                                             
                                                1
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                D
                                             
                                             
                                                m
                                             
                                             
                                                t
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             
                                                D
                                             
                                             
                                                j
                                             
                                             
                                                t
                                             
                                          
                                       
                                     is a target solution descriptor (for j
                                    =1,…,
                                    m).

The cardinal numbers of the problem and solution descriptions may be different; however, there is a widespread assumption that it is convenient to assume that these numbers are equal because a one-to-one correspondence is possible to solve, even with larger sets of descriptors. Without the limitations of this assumption, we propose a more flexible approach with the generality needed to face the broad spectrum of issues arising in professional practice. However, in order to make the sequence of the reasoning steps more understandable, we have adopted this assumption in our illustrative practical study.

A general CBR cycle may be described with the following five cyclical steps (Fig. 1):
                              
                                 (1)
                                 elaborate a semantically derived list of core descriptors that are related to the new problem (target case) while considering the principles of adaptability and efficiency;

retrieve the previous case (source case) from the case base that is most similar to the new problem;

reuse (adapt) the solution from the retrieved case to determine a solution for the new problem;

revise the proposed solution, while considering the differences between the new problem and the retrieved case;

retain the new problem and its revised solution as a new experience for the knowledge base (case base) if appropriate.

However, the reuse of experiences for this context poses multiple problems, which are often poorly resolved, including the reuse of problem solving processes. For example, similar cases may not have similar output/event states because the problem solver may have different ways to deconstruct the problem. Therefore, certain previous studies proposed the clustered ontology approach to represent the semantic meaning of a case [38,34]. In practice, various types of industrial activities, including monitoring studies (availability and reliability) for infrastructures, can be supported with the CBR principles [44]. When applied to maintenance management, the CBR process can be associated with engineering analytical tools to ease knowledge reuse for equipment diagnosis and repair and to develop a decision support system for maintenance operators [53].

Comparing tacit (or implicit) and explicit knowledge, tacit knowledge involves empirical knowledge that is difficult to represent because it is generally hidden inside personal mental models [14]. Therefore, it is desirable to generate explicit knowledge from implicit knowledge to share and reuse relevant empirical knowledge. Several knowledge representation languages (e.g. Description Logics (DLs) [12,46] and OWL (Web Ontology Language) and its different versions, including OWL–DL [32]) specify a variety of available ontology models in which the analysis depends on their semantic foundations. The semantics of a language are commonly expressible through first-order logic; semantics may contain different features depending on their importance, as determined by the developers, and should be selected according to the needs of the resulting ontology-based application.

Select trends relating to ontology languages [68] are listed as follows:
                           
                              •
                              the information modeling trend (e.g. frame logic [2]) in which relations and interactions are considered as secondary, while the model’s focus is on objects and object properties;

the semantic networks trend (e.g. Resource Description Framework Schema (RDFS) [71]) in which the ontology is usually described as an arbitrary graph with a less strict semantic;

the description logics trend (e.g. Description Logics (DLs) [12] and Conceptual Graphs (CGs) [62]) in which the model focuses on concepts and their roles. This trend uses first-order predicate logic as the underlying formalism and uses abstraction and refinement as structuring primitives. This trend combines well-defined logical semantics with efficient reasoning.

The information modeling and semantic networks trends lack formal semantics or are generally independent of a logical theory, whereas the description logics trend overcomes these deficiencies [5]. Moreover, for several criteria (expressive power, reusability, and formal precision), our work relates to the description logics trend because it provides a method for understanding the application domain and for reliable automated formal reasoning. Particularly, the ontology with the Conceptual Graphs approach in this paper is interesting for problem solving. The properties (e.g. formal semantics, separation of types of knowledge and possible translations into other languages [63]) of Conceptual Graphs allow for modeling and specifying the experience feedback processes in which reasoning is essential.

The Conceptual Graph formalism [62] is a representation that compromises between a formal language and a graphical language because it is visual and includes a range of reasoning processes. Conceptual Graphs can be used in many computer science areas including text analysis, web semantics, and intelligent systems [28].

This section describes knowledge aggregation techniques to perform a well-defined analysis and assist in collaborative decision making. This research domain is clearly related to the problem of representing, reasoning about and overcoming uncertainty with experience feedback information. One of the key requirements of expert knowledge modeling is capturing and interpreting imprecise and conflicting data regarding the physical world. This modeling technique aims to provide a method to manage and integrate uncertainty at different stages of the analysis phase to achieve the most suitable analysis of the information.

Two main purposes have to be considered for uncertainty reasoning: improving the quality of the analysis of information and inferring new types of information analysis [10]. The respective corresponding forms of reasoning are: (i) a multi-expertise fusion to improve the quality of the analysis of information in which the data from different areas of expertise are used to increase confidence, resolution or accuracy and (ii) deducing a higher-level analysis (e.g. failure analysis) from a lower-level analysis (e.g. spectroscopic analysis, surface analysis or software based fault location techniques) based on the arguments to infer the new analysis of information.

Several approaches have been used for reasoning with uncertain context information (Fuzzy Logic [72], probabilistic logic [21], Bayesian networks [52], hidden Markov models [39], and the Dempster–Shafer theory of evidence [56]). In this work, we use the Dempster–Shafer theory to represent any form of uncertainty (from total or partial ignorance to full knowledge) because it is a generalization of the Bayesian theory of subjective probability and enables for an assessment of the degree of belief in a fuzzy event. Additionally, the Dempster–Shafer theory has already been successfully applied to industrial diagnosis problems [48,42] and for solving classification problems with imperfect labels [66]. This theory emphasizes the mathematical principles of evidence based on belief functions and plausible reasoning to combine separate pieces of information (evidence) for calculating the probability of an event [57]. Specifically, we use reasoning mechanisms of the Dempster–Shafer theory for combining the independent analysis of multiple experts addressing the same problem, considering that the solutions are highly subjective and that different experts can establish different solutions for the same case [54]. The uncertainty for this theory of evidence is represented by allocating the unit mass of the belief among subsets of the set of reference Ω. The sum of the masses of all the subsets of one hypothesis constitutes its belief, which is the support for a hypothesis and designates the amount of belief that directly supports this given hypothesis. In our context of maintenance activities, this hypothesis is considered as the supposed cause of the occurrence of an adverse event. Thus, belief functions allow us to model a lack of information from subjective judgments [27]. The belief level is supported by the Transferable Belief Model (TBM) [58], which is an extension of the Dempster–Shafer theory. Beliefs can be held at two levels: (1) a credal level in which beliefs are interpreted and quantified with the belief functions and (2) a pignistic level in which beliefs can be used to make decisions and are quantified with probability functions [59]. When a decision must be made, beliefs at the credal level induce a probability measure at the pignistic level, i.e. there is a pignistic transformation from the belief functions to the probability functions.

Certain general evidence properties, such as the independence or the level of conflict, are considered for the selection of the appropriate combination rule. Therefore, certain authors (e.g. [25,37] have proposed a hierarchical approach with different combination rules that are used for different source clusters and fusion levels. The general idea of this rule is to conjunctively merge coherent sources after disjunctively merging the different results. In [29], this idea was applied for the continuous improvement of industrial processes; thus, we will use a hierarchical procedure to support the fusion of experts in the industrial maintenance domain. This implementation in the industrial maintenance domain requires the development of a new research approach to: (i) integrate models, methods and reasoning techniques that are specific to the requirements of industrial maintenance and (ii) provide all the needed information to monitor and control the experiences, capitalization and similarity searches to the smallest level of granularity.

Experts are not symmetrically combined but rather are grouped into expertise domains where they share a domain specific explanation of the way that the world works, which includes the relevant perceptual features in their domain. Within groups, beliefs are combined using the cautious conjunction rule [19], whereas across groups the non-interactive disjunction [57] is used.

Given, m
                        1 and m
                        2 are mass functions from two reliable distinct experts belonging to the same competency domain; the non-interactive conjunction operator of two real-valued subset functions m
                        1 and m
                        2 is defined, for any subset 
                           
                              A
                              ⊂
                              Ω
                           
                        , as follows:
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 ∩
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 A
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          X
                                          ∩
                                          Y
                                          =
                                          A
                                       
                                    
                                 
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 X
                                 )
                                 ·
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 Y
                                 )
                                 
                                 ∀
                                 X
                                 ,
                                 
                                 Y
                                 ⊂
                                 Ω
                              
                           
                        Nevertheless, this conjunction procedure produces a trivial result when the information sources conflict completely. In this case, the fusion falls into pure contradiction with incompatible reasoning.

Similarly, for mass functions m1 and m2 from two expert groups in which at least one expert is reliable and belong to different competency domains, the disjunction operator is defined by:
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 ∪
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 A
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          X
                                          ∪
                                          Y
                                          =
                                          A
                                       
                                    
                                 
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 X
                                 )
                                 ·
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 Y
                                 )
                                 
                                 ∀
                                 X
                                 ,
                                 
                                 Y
                                 ⊂
                                 Ω
                              
                           
                        Finally, any Basic Belief Assignment (BBA) m, such that m(∅)≠1, defines a pignistic probability function of m as:
                           
                              
                                 Bet
                                 
                                 P
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       k
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          A
                                          ∈
                                          
                                             
                                                2
                                             
                                             
                                                Ω
                                             
                                          
                                          ,
                                          
                                             
                                                H
                                             
                                             
                                                k
                                             
                                          
                                          ∈
                                          A
                                       
                                    
                                 
                                 
                                    
                                       m
                                       (
                                       A
                                       )
                                    
                                    
                                       |
                                       A
                                       |
                                       (
                                       1
                                       -
                                       m
                                       (
                                       Ø
                                       )
                                       )
                                    
                                 
                              
                           
                        
                     

The multidisciplinary problem solving in maintenance requires the knowledge of various application domains and assumes knowledge integration from distributed sources [22]. Aggregation of the knowledge of the involved domain experts provides the opportunity to express diverse opinions about the possible solution and anticipated efficacy in accordance with the maintenance requirements. Our proposal relies on the integration of different approaches for the knowledge management aimed at the development of an adequate and efficient methodology for experience feedback in the collaborative context of industrial maintenance management. Thus, the general scheme of our approach (Fig. 2
                     ) relies primarily on the process of experience feedback in the context of industrial maintenance. This process involves three sub-processes: the capitalization of past experiences, their processing and their exploitation. In the capitalization phase, acquisition of experience and storing is performed. We aim to achieve the knowledge representation formalism of Conceptual Graphs (CGs), which uses domain ontology for the representation of experiences in our application context. This language will be particularly suitable for the knowledge formalization and visualization [35]. The processing phase envisages the creation of knowledge, i.e. once the experiences are formalized and capitalized, an analysis is performed to extract knowledge from this set of experiences. Finally, in the exploitation process, we aim to perform Case-Based Reasoning (CBR) as a technique of problem solving that is based on the adaptation of the solutions from past problems to solve new similar problems. Particularities of this technique are primarily performed in the retrieve phase, which we will consider a measure of the semantic similarity and adaptation of the Transferable Belief Model (TBM) to retrieve the case that will be the object of the adaptation phase. We choose the Transferable Belief Model as an aggregation approach to express and exploit the experts’ opinions, which are sometimes vague and uncertain.

It is important to consider the method that the experts use to analyze a contextual situation to describe the features that influence the occurrence of a maintenance problem. Because the retrieval process is directly related to the structure of the knowledge base, dependencies induced from a hierarchical domain ontology structure can suggest instructive clarifications for the problem-solving CBR. We propose an extension of the CBR paradigm by integrating the analysis of the problem-solving episodes, which can potentially be useful for the retrieval and adaptation phases of CBR. For experience feedback processes, this analysis contains traces of reasoning (a resolution plan and justifications (alternatives and failed attempts)) with the judgments (degree of belief) of the experts, according to the available related information. The retrieval process is comprised of two steps: (i) a set of potentially similar cases is retrieved through feature-to-feature matches; (ii) this obtained set is linked to the subjective judgments made by a group of experts and used to find the optimal similar case. The case adaptation is achieved through the principle of management dependencies between the descriptors of the problem and the descriptors of the solution. This principle uses industry-specific domain knowledge pertaining to equipment failure modes and maintenance activity strategies as well as key metrics for measuring equipment performance and reliability.

A simple Conceptual Graph [62] is a finite, connected, directed, bipartite graph consisting of concept nodes (denoted as boxes) that are connected to conceptual relation nodes (denoted as circles). In the alternative linear notation, concept nodes are written within []-brackets while conceptual relation nodes are denoted within ()-brackets. The concepts set and the relations set are disjoint.

A concept is composed of a type and a marker [〈type〉: 〈marker〉], for example, [Resource: Maintainer23]. The type of concept represents the occurrence of the object class. The concepts are grouped in a hierarchical structure called a concept lattice, showing their inheritance relationships. The marker specifies the meaning of a concept and identifies a considered instance of concept (the “*” denotes an undefined instance).

A conceptual relation binds two or more concepts according to the following diagram:

[C1]←(relation’s name)←[C2] (“C1 is related to C2 by this specific relation”).

For the maintenance management analysis, the most common relations are dependency relations, specifically, causal, conditional, temporal and Boolean connectives, such as alternating-OR and exclusive-OR relations (either relations).


                        Fig. 3
                         provides a graphical model (in the form of a Conceptual Graph) detailing the structure of a case. An even on a parallel lathe is taken as an example of experience. This structure is represented as a CG with three parts: (i) the context part that describes the functional mode of the object of the maintenance (parallel lathe), the failure (overheating), the symptom (vibration), and the potentially failing components, in this case the mobile truck and the motor; (ii) the analysis presents the candidate causes and selects the primary cause of problem (rotor–stator rub), i.e. the active hypothesis, finally (iii) the solution concerns the actions (corrective or preventive) performed (in this case, air gap optimization). More globally, the case is described as: in the experience Exp1, the context C1 requires the analysis A1, which generates the solution S1. This CG is built using the different concepts of the ontological vocabulary and their relations in the maintenance management (Figs. 5 and 6).

For the Conceptual Graph formalism, the information is structured as blocks of nested graphs linked by conceptual relations. Therefore, in this particular graphical formalism, we are describing the elements of a feedback process as well as respecting the structure context, analysis and solution. In the example, the solution consists of a non-instantiated decision action, which is the maintenance on specific equipment with a certain degree of freedom. The interpretation of this Conceptual Graph with predicate logic is performed by translating the concepts into binary predicates (predicate of the concept+predicate of the nesting concept) and the binary relations into ternary predicates (predicate of the two linked concepts+predicate of the nesting concept) [13].

We follow the generally shared distinction in knowledge engineering between task knowledge and domain knowledge. Task knowledge specifies the goal(s) that an application pursues, and the method for achieving these goals can be determined through decomposition into subtasks and (ultimately) inferences [64]. For example, the diagnosis task (finding a malfunction) in Common-KADS [65] seems to have similarities with our work, notably the similar terminology: complaint/symptom, hypothesis, differential, finding(s)/evidence, and fault. In diagnosis, the underlying knowledge typically contains knowledge about the system behavior but also includes real expertise that is derived from practical experiences in the domain [33]. The main addition for our approach concerns the explicit integration of experienced knowledge along with the associated beliefs for adaptive knowledge reuse and a traceability of the reasoning process (e.g. fault(s) with the evidence gathered for the fault(s) and the judgmental knowledge).

For the formal knowledge modeling of multiple maintenance experts to facilitate and improve the quality of industrial experience feedback, we conducted a thorough reflection on properly capitalizing on these experiences and efficiently reusing them. Thus, our work is focused on enriching the description of each case with the information about the credibility of the analysis that is associated with problem solving. This technique includes the credibility of the specific expertise domains of the involved experts and their beliefs about the different assumptions related to the root cause analysis during the problem solving of the studied case. In our CBR approach, the research phase of the most similar cases features three new elements (Fig. 4
                        ): (i) exploiting the taxonomical knowledge that can provide a higher degree of similarity between concepts, (ii) gathering the different hypothesis that were considered in the root cause analysis process, and (iii) grouping domain experts scientific domains (according to their scientific profiles) and combining their thoughts and beliefs that are associated with the hypothesis for a collaborative decision-making process. It is important to integrate the subjective and objective data in the knowledge base to enrich the representation system with information on cases and promote the relevant experience feedback process. Additionally, the subjective opinions of experts can be synthesized with respect to the problem to validate the hypothesis. Thus, for each experience case, we will include an analysis part that is comprised of the hypothesis, the subjective opinion of the experts (pignistic probability) and the objective outcome (hypothesis validation).

A case elaboration is the first step of the CBR process in which a general method consists of completing or filtering the raw description of a problem basis on the domain knowledge and then infers new descriptors and importance weights [43]. Domain ontology of case descriptors is useful for hierarchical description of the concept/relation type sharing within the entire case base.

Information retrieval about similar cases requires an efficient comparison between the descriptors for the similarity evaluation. Considering the wide range of available semantic similarity approaches, our work focused the taxonomical exploitation of the ontology.

In his works, Lin [40] defined the theoretical justifications of the similarity measure that is derived from a set of assumptions about a universal definition of similarity in terms of information theory. From those assumptions, he proved that the similarity between two objects is only related to their common attributes and differences, demonstrating the convenience of adopting a non-linear logarithm-based fractional function [40]. In accordance with these fundamental assumptions, Batet et al. [7] introduced a similarity measure that is based on exploiting the full taxonomic knowledge of an ontology by considering the number of differences between the superconcepts (i.e. ancestors or subsumers of a concept) for a pair of concepts. For a full concept hierarchy or taxonomy of concepts (C) of an ontology, a superconcept is defined as:
                              
                                 
                                    T
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    {
                                    
                                       
                                          C
                                       
                                       
                                          j
                                       
                                    
                                    ∈
                                    C
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          j
                                       
                                    
                                    
                                    is
                                    
                                    the
                                    
                                    superconcept
                                    
                                    of
                                    
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    }
                                    ∪
                                    {
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                              
                           Therefore, in this context, the stated similarity measure is based on an inverted logarithm function of the ratio between the number of non-shared superconcepts and the total number of superconcepts modeled in the ontology [7] as follows:
                              
                                 
                                    
                                       
                                          sim
                                       
                                       
                                          BSV
                                       
                                    
                                    (
                                    
                                       
                                          Co
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    
                                       
                                          Co
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    -
                                    
                                       
                                          log
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          |
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∪
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          |
                                          -
                                          |
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∩
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          |
                                       
                                       
                                          |
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ∪
                                          T
                                          (
                                          
                                             
                                                Co
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          |
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 
                                    Co′ is a concept from the target case,


                                    Coi
                                     is a concept from the source case i,

|T(Co′)∪
                                    T(Coi
                                    )| is the total number of superconcepts between the two concepts for comparison,

|T(Co′)∩
                                    T(Coi
                                    )| is the number of shared superconcepts between the two concepts for comparison.

For the unnormalized nature of the first encountered measure, it is necessary to consider a renormalization (value within the range [0,1]) defined as [30]:
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Sim
                                                
                                                
                                                   JKG
                                                
                                             
                                             (
                                             
                                                
                                                   Co
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Co
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             =
                                             1
                                          
                                          
                                             if
                                             
                                             
                                                
                                                   Co
                                                
                                                
                                                   ′
                                                
                                             
                                             =
                                             
                                                
                                                   Co
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Sim
                                                
                                                
                                                   JKG
                                                
                                             
                                             (
                                             
                                                
                                                   Co
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Co
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             =
                                             
                                                
                                                   
                                                      
                                                         Sim
                                                      
                                                      
                                                         BSV
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         Co
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Co
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                
                                                
                                                   
                                                      
                                                         Log
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   H
                                                   +
                                                   2
                                                   )
                                                
                                             
                                          
                                          
                                             if
                                             
                                             
                                                
                                                   Co
                                                
                                                
                                                   ′
                                                
                                             
                                             ≠
                                             
                                                
                                                   Co
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           In the renormalized formula, H is the height of the ontology (i.e. the number of edges on the longest path from the root node to a lowest node).

This measure allows for comparing two concepts. However, we are interested in a more general measure to compare two descriptors. Thus, from the study by Haouchine et al. [26], we suggest a new measure of local similarity (
                              
                                 
                                    
                                       M
                                    
                                    
                                       
                                          
                                             Sim
                                          
                                          
                                             ij
                                          
                                       
                                    
                                 
                              
                           ) that is composed of three local similarities (presence checking, taxonomic similarity and the comparison of functional modes or performance levels) between the source case i and the target case in the descriptor j, which is defined as follows:
                              
                                 
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                Sim
                                             
                                             
                                                ij
                                             
                                          
                                          =
                                          
                                             
                                                φ
                                             
                                             
                                                ij
                                             
                                             
                                                Presence
                                             
                                          
                                          *
                                          
                                             
                                                φ
                                             
                                             
                                                ij
                                             
                                             
                                                Value
                                             
                                          
                                          *
                                          
                                             
                                                φ
                                             
                                             
                                                ij
                                             
                                             
                                                State
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Presence
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Presence
                                                      
                                                   
                                                   =
                                                   1
                                                
                                             
                                          
                                          The descriptor is filled in the source case and the target case
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Presence
                                                      
                                                   
                                                   =
                                                   0
                                                
                                             
                                          
                                          The descriptor is not filled in the source case or the target case
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Value
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Value
                                                      
                                                   
                                                   =
                                                   1
                                                
                                             
                                          
                                          If Co′=
                                             Coi
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         Value
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         sim
                                                      
                                                      
                                                         JKG
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         
                                                            
                                                               sim
                                                            
                                                            
                                                               BSV
                                                            
                                                         
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         
                                                            
                                                               log
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         (
                                                         H
                                                         +
                                                         2
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             H: H is the height of the ontology. 
                                                
                                                   
                                                      
                                                         sim
                                                      
                                                      
                                                         BSV
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         Co
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         Co
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                   =
                                                   -
                                                   
                                                      
                                                         log
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         |
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         )
                                                         ∪
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                         |
                                                         -
                                                         |
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         )
                                                         ∩
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                         |
                                                      
                                                      
                                                         |
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         )
                                                         ∪
                                                         T
                                                         (
                                                         
                                                            
                                                               Co
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                         |
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                    
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         State
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         State
                                                      
                                                   
                                                   =
                                                   1
                                                
                                             
                                          
                                          If FunctionalMode(Co′)=FunctionalMode(Coi) or Level (Co’)=Level (Coi)
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         ij
                                                      
                                                      
                                                         State
                                                      
                                                   
                                                   ∈
                                                   [
                                                   0
                                                   
                                                   1
                                                   ]
                                                
                                             
                                          
                                          If FunctionalMode(Co′)≠FunctionalMode(Coi) or Level (Co’)≠Level (Coi)
                                          
                                       
                                    
                                 
                              
                           For 
                              
                                 
                                    
                                       φ
                                    
                                    
                                       ij
                                    
                                    
                                       State
                                    
                                 
                              
                           , without restricting the generality of the proposed descriptors, there is an implicit dependence between a functional mode and the level descriptors. In fact, in most situations, the state of industrial equipment is described either by its functional mode (normal, degraded and abnormal modes) or its performance level (in our context, upper, normal and lower).

Then, a global similarity measure Sim(sourcei, target) to compare two cases is obtained by the weighted sum of these functions over the entire set of descriptors. Weights represent the knowledge about the importance of the “influence” of the problem descriptor values on the solution.
                              
                                 
                                    Sim
                                    (
                                    
                                       
                                          source
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    target
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                    
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                sim
                                             
                                             
                                                ij
                                             
                                          
                                       
                                    
                                    
                                    *
                                    
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 
                                    n is the number of problem descriptors,


                                    i is the associated number of the case source,


                                    j is the associated number of the descriptor,


                                    
                                       
                                          
                                             
                                                M
                                             
                                             
                                                
                                                   
                                                      Sim
                                                   
                                                   
                                                      ij
                                                   
                                                
                                             
                                          
                                       
                                     is the local similarity of source case i and descriptor j,


                                    wj
                                     is the weight associated with descriptor j with 
                                       
                                          0
                                          ⩽
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                          ⩽
                                          1
                                       
                                     et 
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                n
                                             
                                          
                                          
                                             
                                                w
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          1
                                       
                                    .

Then, for the analysis modeling using the experts’ opinions reuse principle, which has been introduced in the top of Section 3.2, we propose the following mechanism to reuse the most similar cases as follows: during the research phase of experience cases (similar to using contextual information to guide retrieval), the resulting set of retrieved cases is ranked in decreasing order for the similarity measure. This order suggests that the most similar cases appear at the top of this list and an acceptable similarity threshold is determined for the problem case. We will use the associated two scores for each hypothesis of this set (which determine whether this hypothesis will be proposed for solving the new problem). The first score, called the “subjective score”, is calculated from the similarity of the contexts and from the subjective opinions of domain experts (pignistic probability) [29], which is obtained with the reasoning mechanisms of the Dempster–Shafer theory [57]. The pignistic probability is based on the agent’s beliefs [59], and measures the probability that a domain expert has an option (a diagnosis and associated treatment plan) when required to make a decision. The second score, called the “objective score”, is calculated from the similarity of the contexts and from the validation of the hypothesis.

For most reasoning situations, adaptation knowledge acquisition is complex and domain-dependent. Thus, we adhere to the principle of adaptation-guided retrieval [60] such that the adaptation knowledge contributes to the retrieval knowledge. Following the principles developed in [18], we are interested in the management of the differences and dependencies between the descriptor of the problems and the descriptors of the solutions. Haouchine et al. [26] proposed an adaptation algorithm that builds the ontology and the dependence relationships resulting from a similarity path in the solution space. This algorithm is an adaptation algorithm that is dedicated to the technical diagnosis problem, and it has been applied with a failure model based on domain expertise. In particular, this approach is appropriate for the pattern of causal relationships between the various failures that may occur in industrial equipment [26]. This failure model enables for the determination of dependencies and influences, as they are used in adaptation. In our work, we consider that it is relevant to also use this adaptation approach because this research study suggests we acquired a failure model from the domain expertise in the industrial maintenance.

The revision phase is also called the repair phase. Following the adaptation phase, a solution is proposed for the target case. The suggested solution will be evaluated and eventually modified. Therefore, once the case is revised and validated, it can be applied to become a new experience in the knowledge base.

Finally, the new case is stored in the case base for future use. Thus, the case base is the source of the feedback and the appropriate maintenance of this base is important for ensuring suitable functioning of the system.

In this section, we present an overview of the complex system that is used as an application example. We have deliberately simplified the model to provide understandable explanations. This section is organized as follows: Section 4.1 presents an ontology that was developed with a functional decomposition of descriptors that is necessary for the implementation of the proposed mechanisms. Section 4.2 describes the Case-Based Reasoning principles that takes account of the opinions of the different experts regarding the technical realities within the industrial maintenance. Section 4.3 presents a discussion of the example with the current results of the evaluation phase that is still in progress, while Section 4.4 explores our current architecture with the tools used in our framework.


                        Fig. 5
                         includes the ontology of the concept types that are associated with the maintained system that we will study. In the first part, there is a classification of the machines according to their functionality. Next, there is a classification of the components of these machines according to their type: mechanical, pneumatic, hydraulic, electrical and electronic. Other concepts are concerned with the machines’ symptoms, the status of the machines and components, failures that may arise and repair actions associated with each problem to remove or tolerate the discovered malfunctions. These concept types consist of different parts, which each correspond to the descriptors of the cases. We will examine a particular technical diagnostic based on the patterns of the context, analysis and solution that are used for modeling the experience cases (see Section 2.1.1). A measure that is based on the taxonomical exploitation of the ontology is used to compare the values of the semantic features of conceptual elements in a given domain vocabulary. The context is comprised of the object of the maintenance, the failure, the symptom and a given set of (potentially failing) components with an associated diagnosis. The analysis contains certain hypothesis of the underlying causes for the system failures and the experts’ beliefs about each of these causes (pignistic probabily and validation).

For this simplified application, the proposed lightweight ontology is similar to a simple taxonomy mainly having an order relation between the concepts. This type of relation can be a hierarchical tree describing a semantic link of the specialization between the considered concepts of the studied domain. Generally, an ontology can contain axioms, rules and constraints to more precisely represent the knowledge from the application domain [23].

An ontology that contains many relations other than class-subclass relations is richer than a taxonomy with only class-subclass relationships. Fig. 6
                         includes the taxonomy of the relation types that are associated to system.

Using this lightweight ontology of concept types (taxonomy), we illustrate our case base and especially the method for searching for similar solutions by matching the source and target problems. We built a case base containing five source cases with eight descriptors for the context part (Table 1
                        ) and one descriptor for the solution part (Table 2
                        ). Additionally, each descriptor in the context part is comprised of two parts (concept and value), as shown below. We will, therefore, illustrate the proposed approach to reuse the past experiences and integrating the experts’ beliefs with a detailed description of the problem solving mechanism for a target case in relation to the cases that are stored in the case base. The cases are represented in Tables 1 and 2 to illustrate the different steps of the CBR. Case source 1 corresponds to the Conceptual Graph of Fig. 3.

Therefore, the process for calculating the pignistic probabilities and the validation of the hypothesis are shown below.

For source case 1, three hypothesis (H1,H2,H3) that were deduced from the ontology are the possible causes of the occurrence of this case and are evaluated by the experts (Expert 1, Expert 2, and Expert 3) by allocating the unit mass of belief among the subsets of the set of reference Ω (Table 3
                        ) in order to find the primary cause (failure cause) of problem. We consider that experts 1 and 3 are members of the same domain while expert 2 is member of another domain.

Because Experts 1 and 3 are members of the same domain, a conjunctive combination is applied (Exp1∩Exp3). We illustrate the detailed calculation of the H2 hypothesis as follows:
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 ∩
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                H
                                             
                                             
                                                i
                                             
                                          
                                          ∩
                                          
                                             
                                                H
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          H
                                          2
                                       
                                    
                                 
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 
                                 ∀
                                 
                                    
                                       H
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       H
                                    
                                    
                                       j
                                    
                                 
                                 ⊂
                                 Ω
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 ∩
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 =
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 +
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 H
                                 2
                                 ∪
                                 H
                                 3
                                 )
                                 
                                 *
                                 
                                 
                                    
                                       m
                                    
                                    
                                       3
                                    
                                 
                                 (
                                 H
                                 1
                                 ∪
                                 H
                                 2
                                 )
                                 =
                                 0.2
                                 
                                 *
                                 
                                 0.3
                                 =
                                 0
                                 .
                                 06
                              
                           
                        Similarly, a disjunctive combination is applied for the two expert groups of different domains. Thus, the disjunctive fusion between (Exp1∩Exp3) and Exp2 for H2 is:
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       13
                                    
                                 
                                 ∪
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                H
                                             
                                             
                                                i
                                             
                                          
                                          ∪
                                          
                                             
                                                H
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          H
                                          2
                                       
                                    
                                 
                                 
                                    
                                       m
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 
                                 ∀
                                 
                                    
                                       H
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       H
                                    
                                    
                                       j
                                    
                                 
                                 ⊂
                                 Ω
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       13
                                    
                                 
                                 ∪
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 =
                                 
                                    
                                       m
                                    
                                    
                                       13
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 ∪
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 H
                                 2
                                 )
                                 =
                                 0.06
                                 
                                 *
                                 
                                 0.85
                                 =
                                 0
                                 .
                                 05
                              
                           
                        Finally, the pignistic probabilities of each hypothesis are (Table 4
                        ):

For example:
                           
                              
                                 Bet
                                 
                                 P
                                 (
                                 H
                                 2
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       1
                                       -
                                       m
                                       (
                                       ∅
                                       )
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      123
                                                   
                                                
                                                (
                                                H
                                                2
                                                )
                                             
                                             
                                                1
                                             
                                          
                                          +
                                          
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      123
                                                   
                                                
                                                (
                                                H
                                                1
                                                ∪
                                                H
                                                2
                                                )
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      123
                                                   
                                                
                                                (
                                                H
                                                2
                                                ∪
                                                H
                                                3
                                                )
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      123
                                                   
                                                
                                                (
                                                H
                                                1
                                                ∪
                                                H
                                                2
                                                ∪
                                                H
                                                3
                                                )
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                 
                                 =
                                 0
                                 .
                                 505
                              
                           
                        As result, the pignistic probability is based on the agent’s beliefs, and the validation of the hypothesis is the selected option for the expert group (Table 4).

To illustrate the first step of the CBR, we build the target case, as described in Table 5
                           . The elaboration phase consists of completing all the descriptors that are needed to describe the context of the new problem.

Therefore, the second phase involves calculating the local similarity of each descriptor between the target case and source case (Table 6
                           ).

For example, a detailed calculation for the local similarity for the descriptor 1 (ds1) between the Source 1 and Target is performed, as follows.
                              
                                 
                                    
                                       
                                          φ
                                       
                                       
                                          1
                                          ,
                                          1
                                       
                                       
                                          Presence
                                       
                                    
                                    =
                                    1
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          φ
                                       
                                       
                                          1
                                          ,
                                          1
                                       
                                       
                                          Value
                                       
                                    
                                    =
                                    
                                       
                                          -
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                |
                                                T
                                                (
                                                Parallel
                                                
                                                Lathe
                                                )
                                                ∪
                                                T
                                                (
                                                Frontal
                                                
                                                Lathe
                                                )
                                                |
                                                -
                                                |
                                                T
                                                (
                                                Parallel
                                                
                                                Lathe
                                                )
                                                ∩
                                                T
                                                (
                                                Frontal
                                                
                                                Lathe
                                                )
                                                |
                                             
                                             
                                                |
                                                T
                                                (
                                                Parallel
                                                
                                                Lathe
                                                )
                                                ∪
                                                T
                                                (
                                                Frontal
                                                
                                                Lathe
                                                )
                                                |
                                             
                                          
                                       
                                       
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          H
                                          +
                                          2
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    T
                                    (
                                    Parallel
                                    
                                    Lathe
                                    )
                                    =
                                    {
                                    Lathe
                                    ,
                                    Machining
                                    ,
                                    Machine
                                    ,
                                    System
                                    }
                                    ∪
                                    {
                                    Parallel
                                    
                                    Lathe
                                    }
                                 
                              
                           
                           
                              
                                 
                                    T
                                    (
                                    Frontal
                                    
                                    Lathe
                                    )
                                    =
                                    {
                                    Lathe
                                    ,
                                    Machining
                                    ,
                                    Machine
                                    ,
                                    System
                                    }
                                    ∪
                                    {
                                    Frontal
                                    
                                    Lathe
                                    }
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          φ
                                       
                                       
                                          1
                                          ,
                                          1
                                       
                                       
                                          Value
                                       
                                    
                                    =
                                    
                                       
                                          -
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                |
                                                {
                                                Lathe
                                                ,
                                                Machining
                                                ,
                                                Machine
                                                ,
                                                System
                                                ,
                                                Parallel
                                                
                                                Lathe
                                                ,
                                                Frontal
                                                
                                                Lathe
                                                }
                                                |
                                                -
                                                |
                                                {
                                                Lathe
                                                ,
                                                Machining
                                                ,
                                                Machine
                                                ,
                                                System
                                                }
                                                |
                                             
                                             
                                                |
                                                {
                                                Lathe
                                                ,
                                                Machining
                                                ,
                                                Machine
                                                ,
                                                System
                                                ,
                                                Parallel
                                                
                                                Lathe
                                                ,
                                                Frontal
                                                
                                                Lathe
                                                }
                                                |
                                             
                                          
                                       
                                       
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          H
                                          +
                                          2
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          φ
                                       
                                       
                                          1
                                          ,
                                          1
                                       
                                       
                                          Value
                                       
                                    
                                    =
                                    
                                       
                                          -
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                6
                                                -
                                                4
                                             
                                             
                                                6
                                             
                                          
                                       
                                       
                                          
                                             
                                                log
                                             
                                             
                                                2
                                             
                                          
                                          (
                                          4
                                          +
                                          2
                                          )
                                       
                                    
                                    =
                                    0
                                    .
                                    61
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          φ
                                       
                                       
                                          1
                                          ,
                                          1
                                       
                                       
                                          State
                                       
                                    
                                    =
                                    1
                                 
                              
                           Thus, the measure of local similarity (
                              
                                 
                                    
                                       M
                                    
                                    
                                       
                                          
                                             Sim
                                          
                                          
                                             ij
                                          
                                       
                                    
                                 
                              
                           ) is comprised of three local similarities, as follows:
                              
                                 
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                Sim
                                             
                                             
                                                ij
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          φ
                                       
                                       
                                          ij
                                       
                                       
                                          Presence
                                       
                                    
                                    
                                    *
                                    
                                    
                                       
                                          φ
                                       
                                       
                                          ij
                                       
                                       
                                          Value
                                       
                                    
                                    
                                    *
                                    
                                    
                                       
                                          φ
                                       
                                       
                                          ij
                                       
                                       
                                          State
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                Sim
                                             
                                             
                                                1
                                                ,
                                                1
                                             
                                          
                                       
                                    
                                    =
                                    1
                                    
                                    *
                                    
                                    0
                                    .
                                    61
                                    
                                    *
                                    
                                    1
                                    =
                                    0
                                    .
                                    61
                                 
                              
                           Once we have calculated every local similarity, we compute the global similarity between each source case and the target case (Table 7
                           ) taking into account the weight of each descriptor. These weights translate the relative importance of the descriptors that are main contributors to the analysis. This information is derived from the collective expertise gained in the target domain. The global similarity measure Sim(sourcei
                           ,
                           target) is:

The calculation for the global similarity between the source 1 and target case is described by:
                              
                                 
                                    Sim
                                    (
                                    
                                       
                                          source
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    target
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             8
                                          
                                       
                                    
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                sim
                                             
                                             
                                                1
                                                j
                                             
                                          
                                       
                                    
                                    
                                    *
                                    
                                    
                                       
                                          w
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    Sim
                                    (
                                    
                                       
                                          source
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    target
                                    )
                                    =
                                    (
                                    0.61
                                    
                                    *
                                    
                                    0.15
                                    )
                                    (
                                    0.61
                                    
                                    *
                                    
                                    0.3
                                    )
                                    (
                                    0.51
                                    
                                    *
                                    
                                    0.2
                                    )
                                    (
                                    0.43
                                    
                                    *
                                    
                                    0.07
                                    )
                                    (
                                    0
                                    
                                    *
                                    
                                    0.07
                                    )
                                    (
                                    0
                                    
                                    *
                                    
                                    0.07
                                    )
                                    (
                                    0.51
                                    
                                    *
                                    
                                    0.07
                                    )
                                    (
                                    0
                                    
                                    *
                                    
                                    0.07
                                    )
                                 
                              
                           
                           
                              
                                 
                                    Sim
                                    (
                                    
                                       
                                          source
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    target
                                    )
                                    =
                                    0
                                    .
                                    44
                                 
                              
                           Now, we determine the measures that integrate the experts’ opinions for the two related cases. For a similarity threshold of 40%, source case 1 and source case 5 will be selected and used in the next step. The analysis part (hypothesis, pignistic probability, and validation) was already established when the case was stored in the case base.

We now refer to the results from the two selected cases in Table 8
                           . The calculated similarities and the analysis part for each case are presented (three hypothesis (H1, H2 and H3) were considered for source case 1, and the hypothesis H1, H2, and H4 were considered for source case 5).

The subjective score [1] is obtained as the product of the contextual similarity measures with the pignistic probabilities. The objective score [2] is deducted from the contextual similarity measures and the validation of the hypothesis in the resolution of the case sources. Subsequently, we consider the hypotheses (H1, H2, H3, and H4) from the selected cases with the greatest subjective and objective scores to determine an average between these two measures. Finally, the hypothesis H1 of source case 5 was selected for solving the target case (Table 8).

Therefore, the goal of the adaptation phase is to reuse the information of the source case (source case 5) to build a solution for the problem of the target case (Table 9
                           ). The output of this phase is a suggested solution in the target case but must be revised before its application and its capitalization in the knowledge base.

Several projects focusing on the maintenance problems were carried out in the LGP (Production Engineering Laboratory) with our involvement. A lot of them, aimed primarily at capitalizing the relevant knowledge from experience feedback, were settled in partnership with some departments (e.g. quality and maintenance) in the transport industry (railway and aircraft). The lessons learned enable procedures to be easily cross compared in the domain knowledge, so that they can spot opportunities for leverage. We extracted from these projects the previous example allowing us to study proposed methodology functionalities by estimating the complementarity of the implicated methods and the articulation mechanisms of associated tools.

These functionalities provided us relevant actions to knowledge modeling and reasoning, constituting a first basic validation that we extend to other cases. The focus was on a collaborative engagement of methods and tools in the contextualizing and the evaluation of maintenance objectives as well as their implementation. This evaluation process is done using a bottom-up approach and includes collaborative actions with partner companies in the area of industrial maintenance.

Firstly, the lesson learned principles based on the experimentation that we propose and the used modeling to represent experiences, taking into account three classical parts (context, analysis and solution) are really close to the working logic of the enterprise. The implementation of experienced knowledge capitalization is essential in industrial maintenance management and this is in line with the continuous improvement strategy of many intelligence-driven organizations. It is clearly connected to the requirements of a modern work organization which plays a key role in promoting products and services that feature outstanding quality.

Secondly, the relevant cases of the case database can be easily recovered for solving the new problem thanks to the way as we describe and manipulate the experiences in the industrial process. Recovering the case that is similar to the new problem but also the most credible is assimilated to the daily work of the enterprises because it does not change the manner of experts’ reasoning in problem solving. So, we have found a favorable work environment that has been of great benefit to the establishment of the industrial partnership services.

Thirdly, our strategy of integration of the opinions of several experts, particularly necessary in complex systems and complex situations (as maintenance activities) or when expertise is not specifically well-defined, appeared well-suited to treated cases and to the behavior of actors in these collaborative contexts. Flexible and reliable elements are provided for knowledge representation and reasoning and contribute to their implementation as a part of an operational process in practice.

Finally, our approach seems to be easily transposable to new real industrial case in order to improve the solving problems process using past experiences and experts beliefs in collaborative decisions making.

Another special feature that strengthens the applicability of our methodology is that several tools may be used at each level of the software architecture. This is due to the ontology component faculties that guarantee semantic interoperability, consistency and adaptation to different needs. In practice, this proposal does not hinder current and future progress towards collaboration.

In the next section, we present a related architecture with the tools used in our framework.

In order to support the methodological approach and research activities undertaken to complete the comprehensive characterization of the proposed framework and without loss of generality, we rely on the following architecture that presents the used tools (Fig. 7
                        ). According to the previous developments, three main blocks comprise this architecture: experience feedback system (EF), conceptual graphs support (CGs) with its underlying ontology level and transferable belief model (TBM) with similarity measures.

As reference support for the experience feedback process applied to problem solving, we rely on the T-Rex/ProWhy software. This software has been developed by the LGP initially for an enterprise of railway sector (Alstom Transport) before its porting in other companies. It is a support tool for problem solving process and experience feedback [31]. For exploitation of capitalized experiences, this tool permits the use of software engines allowing a relevant search of past experiences (by keywords or similarity) using the case-based reasoning steps.

In view of ontology modeling, we selected Conceptual Graphical User Interface (CoGui) [6] because of the flexibility of this toolbox, the quality of the reasoning module and the user interface that allows efficient knowledge manipulation and visualization in conceptual graphs. The intuitive user interface of CoGui provides the ability to personalize any ontological preferences and different models of conceptual graphs with a variety of advanced controls and reasoning tools for specialization, equivalence, inference and validation.

CoGui supports a variety of web semantics formats and also incorporates a compatibility module for interoperability management, as well as a reasoning system for information retrieval to demonstrate how CoGui components might be used in an actual implementation. In addition to the advantage of addressing the complementary aspects of an ontology building project that the target modeled system, domain knowledge, formal management rules, and experiences formalization with the Conceptual Graphs, it allows all involved group experts to find the best expression module for letting them share their understanding of the considered situation with the group. The clearly organization of CoGui makes navigation easy and allows rapid access to even more information and knowledge manipulation without changing the logic of the user.

However, CoGui does not yet incorporate an explicit procedure for taking account of the similarity measures between the concepts of ontologies, although this option can been included in the last version that allows the integration of other specific modules. In our case, we made some similarity measurements (local similarities and global similarity) with the external module so that the comparison of concepts matches the ontological application associated to domain knowledge and experiences. This has been written in calculation tables which are easily incorporated into case retrieval procedures, and the instructions are clear for knowledge reuse with experts’ beliefs.

From a practical viewpoint of belief functions implementation, we use a special software tool developed in LGP with the Centre for Resources and Competences “Engineering Decision and Communication for the Enterprise” (CRC-IDCE) of the National School of Engineers of Tarbes. This toolbox allows to combine experts knowledge using the same variables theoretically defined. The belief functions are treated as optional changes in probability distributions using the credibility and plausibility measures defined in the Transferable Belief Model. Regarding propagation mechanisms, with the help of this tool we have developed a specific propagation procedure using the propagation mechanisms introduced by Smets and Kennes [58]. In fact, we customize and use proven belief functions associated to some management procedures attaching the degree of similarity between concepts of compared cases (similarity measures) with our existing software that uses Ruby Programming Language frameworks available which provide for convenient planning, configuration and operation.

The knowledge capitalization in maintenance management is an important issue that significantly contributes to improving the performance of industrial systems. To facilitate collaborative maintenance management, our work is devoted to the formal knowledge modeling of multiple experts as decision support in problem solving within this area. This method allows for common information with rigorous semantics in the collaborative decision-making process, facilitating the exchange and sharing of knowledge among maintenance actors.
                  

Our proposal was structured with three elements: (i) the use of Conceptual Graphs as a knowledge representation language, (ii) the Transferable Belief Model for collaborative decision making with multiple maintenance experts, and (iii) the Case-Based Reasoning for using past experiences while integrating experts’ beliefs.

For Case-Based Reasoning, we use an ontology-based similarity measure for the information retrieval of the most appropriate information for the current case. The similarity measure is characterized with semantic techniques that are based on a hierarchical organization of concepts of the modeled system within a formal ontology. This formalization is particularly important because it guarantees good logical foundations of the reasoning process. A well-built ontology supports the graph-based operations and facilitates adequate and significant results. It is also important to reuse the analysis part containing the reasoning step for the problem solution. This important feedback of how human beings reason, learn and adapt can then be exploited by the system maintainers, since it is a fundamental knowledge component. Thus, from the different parts included in a given case, the context is based on the similarity search mechanism, the analysis integrates the reuse of the experts’ advice and the solution adaptation considers the domain ontology and its established dependency relations for each studied experiment.

We have detailed the various steps of our proposal with an application example that allows us to involve the proposed approach in situations that are similar to those in industry. This application has been instructive for the contributions of the work to demonstrate the model and its limitations. Therefore, prospects for further research are also presented.

Potential short- and medium-term future studies related to this work are as follows:
                        
                           •
                           In the capitalization process, a case base that is partitioned according to the areas of the experts’ competencies that aims to produce a knowledge base satisfying a given integrity constraint would be beneficial. Thus, when a new event occurs, each expert reasons within his own case base, and each local expert is integrated in the global resolution of the target case; thereby, providing effective case combination for the Case-Based Reasoning [17]. This method can be implemented in practice within a collaborative environment with Web services and modern e-collaboration principles [47].

Another aspect to consider involves the importance of risk management with non-additive beliefs of the different actors of the collaborative work for maintenance. The need for a study of experts’ beliefs, practices and attitudes toward uncertainty and the expert’s methods for experience sharing with operators will lead to the exploration of methods to master the full-scale risks and decision making in conflict situations [8].

Other work can involve the performance evaluation of our proposition using certain task-analytic constructs to identify the factual expertise for the formulation of the decision support [11]. Several methods are possible for improving performance based on experience including the quality level of the final decisions, the duration of the process of the solution elaboration, and significant potential benefits (e.g. better productivity and ability to deal with more complex problems).

@&#REFERENCES@&#

