@&#MAIN-TITLE@&#A dynamic programming approach for the aircraft landing problem with aircraft classes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper considers the aircraft landing problem with multiple runways, positive target landing times, and time windows.


                        
                        
                           
                           We assume the set of aircraft to be landed is divided into a (small) number of aircraft classes.


                        
                        
                           
                           We provide an exact algorithm to minimize the total delay cost, yielding exact solutions in short time.


                        
                        
                           
                           We show the efficiency of our algorithm through a numerical study.


                        
                        
                           
                           We outline a possible implementation of our algorithm in a dynamic environment via a rolling horizon approach.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Aircraft landing scheduling

Scheduling

Dynamic programming

Exact approach

@&#ABSTRACT@&#


               
               
                  The capacity of a runway system represents a bottleneck at many international airports. The current practice at airports is to land approaching aircraft on a first-come, first-served basis. An active rescheduling of aircraft landing times increases runway capacity or reduces delays. The problem of finding an optimal schedule for aircraft landings is referred to as the “aircraft landing problem”. The objective is to minimize the total delay of aircraft landings or the respective cost. The necessary separation time between two operations must be met. Due to the complexity of this scheduling problem, recent research has been focused on developing heuristic solution approaches. This article presents a new algorithm that is able to create optimal landing schedules on multiple independent runways for aircraft with positive target landing times and limited time windows. Our numerical experiments show that problems with up to 100 aircraft can be optimally solved within seconds.
               
            

@&#INTRODUCTION@&#

The number of passenger flights and cargo flights has been increasing over recent years and is expected to continue to increase. The number of aircraft in use, the number of passengers carried, and the air cargo tonnage are expected to double within the next two decades (Boeing, 2013). An important limitation in aviation, however, is the runway systems of airports, which limit the number of take-offs and landings per hour. The runway capacity of major European airports is exceeded in periods of high demand, which leads to delays in take-offs and landings. The cost of delays incurred by air traffic flow management (ATFM) (i.e., during take-off, flight, or landing) for all European airports was estimated to be as high as 1.25 billion euros (1.61 billion dollars) in 2011 (Cook and Tanner, 2011). The total ATFM delay cost in North America was estimated to be as high as 4.6 billion dollars in 2010 (Ball et al., 2010).

The number of possible landings per hour depends on the types of aircraft involved and on the sequence of operations. Depending on its size and shape, each aircraft causes air turbulence (“wake vortices”) that affects the following aircraft. Therefore a minimum separation time between two operations is required. Aircraft are usually divided into a small number of aircraft classes. Table 1
                      shows a matrix of class-dependent minimum separation times. The values in this matrix are based upon the spacing requirements imposed by the US Federal Aviation Administration (FAA, 2012). Different separation matrices can be found in the related literature, but most of these matrices consist of three to five aircraft classes and have a similar structure (Beasley, Sonander, and Havelock, 2001; Harikiopoulo and Neogi, 2011; Psaraftis, 1980; Soomer, 2008).

The aircraft landing problem (ALP) assigns landing times and runways to a given set of aircraft approaching an airport. The planning horizon is very short as the mean time of an aircraft from the time it arrives within the radar range of an airport (the Terminal Maneuvering Area, TMA) to the targeted landing time is approximately 30 minutes (Balakrishnan and Chandran, 2010). As each aircraft has a preferred landing time, the objective is to minimize the total delay costs for all aircraft landings while respecting the separation requirements. The cost function approximates the actual costs such as fuel, maintenance, exhaust emissions, and passengers missing their connecting flights.

By re-arranging the sequence of runway operations instead of using a priority rule, such as FCFS, a significant reduction of total cost can be achieved. For congested runway systems, this optimization leads to either a reduction of the number of aircraft in holding patterns or to an increase of capacity, i.e., more landings per hour that can be performed. This would lead to a considerable increase in revenue.

Extensive reviews of the literature on the ALP are given by Beasley, Krishnamoorthy, Sharaiha, and Abramson (2000) and Bennell, Mesgarpour, and Potts (2013). Table 2
                      provides an overview of related articles. The columns in the table show the underlying assumptions of the ALP discussed in the respective articles; most of the articles discuss the ALP with a single runway (R = 1) while others consider multiple (parallel and independent) runways (R ≥ 1). The most common objective is to minimize the total delay costs, but other objectives (such as minimizing the longest delay or minimizing the makespan) are also presented. The delay costs are determined by cost functions that are linear or piecewise linear and convex (i.e., the additional cost per period of delay increases). Regarding the target time, we can distinguish two streams of literature; the target times (Ta
                     ) are assumed to be zero or are allowed to be positive. Some of the papers allowing positive target times allow early landings to occur, that is, landings between the target time and an earliest landing time (Ea
                     ), which are also associated with costs. Most articles assume limited time windows for landings, i.e., there is a latest landing time (La
                     ) for each aircraft that must not be exceeded by its actual landing time. The last column shows which solution approaches are discussed in the respective articles.

To date, no efficient methods have been proposed in the reviewed literature for the multi-runway ALP that are capable of solving large problem instances. The most common solution approaches are (1) mixed-integer programming (MIP) formulations, which are solved with a standard solver; (2) branch-and-bound (B&B) algorithms; (3) dynamic programming (DP) approaches; and (4) heuristic solution approaches.


                     MIP formulations: the first mixed-integer formulation for the ALP on a single runway was published by Abela, Abramson, Krishnamoorthy, De Silva, and Mills (1993). The extension to multiple runways by Beasley et al. (2000) is the most cited MIP formulation of the ALP to date. Pinol and Beasley (2006) further generalize this formulation to runway-dependent time windows and separation times. Briskorn and Stolletz (2014) proposed a modification of the MIP of Beasley et al. (2000) that explicitly considers aircraft classes.


                     B&B algorithms: 
                     Abela et al. (1993) present a B&B approach for the single-runway ALP. Ernst, Krishnamoorthy, and Storer (1999) develop a B&B solution procedure for the ALP that outperforms standard solvers using the MIP formulation by Beasley et al. (2000) but, nevertheless, results in excessive computation times for all instances, except for small problem instances.


                     Dynamic programming approaches: 
                     Dear (1976) presents a dynamic programming formulation for the single runway problem with a constrained-position-shifting (CPS) assumption, i.e., each aircraft can be shifted only by a limited number of positions from the sequence of arrivals at the runway. CPS approaches are also presented by Psaraftis (1980), Dear and Sherif (1991), and, more recently, by Balakrishnan and Chandran (2010). Psaraftis (1980) presents a DP approach for the single-runway ALP that makes use of the class-dependent separation times to reduce the problem complexity. Bianco, Dell’Olmo, and Giordani (1999) present a DP approach for a single-machine scheduling problem with sequence-dependent setup times that is equivalent to the single-runway case of the ALP without consideration of aircraft classes. Briskorn and Stolletz (2014) describe a DP approach for the ALP with multiple runways and under consideration of limited time windows. However, they do not provide numerical results for their approach.


                     Heuristic solution approaches: 
                     Abela et al. (1993) propose a genetic algorithm (GA) as a heuristic solution approach. Bianco et al. (1999) propose two heuristic approaches (cheapest addition and cheapest insertion) for their DP approach. Fahle, Feldmann, Gtz, Grothklags, and Monien (2003) compare different exact and heuristic solution approaches for the ALP on a single runway: MIP, integer programming (IP), constraint programming (CP), hill climbing (HC), and simulated annealing (SA). Pinol and Beasley (2006) develop two population-based heuristic approaches (scatter search and a bionomic algorithm) for the ALP. Soomer (2008) and Soomer and Franx (2008) introduce fairness aspects to the ALP by providing airlines the opportunity to define their own cost functions. The numerical study is performed using a local search heuristic.

Many articles assume a fixed number of aircraft classes, but only a few actually use this property in their solution approaches (Bojanowski, Harikiopoulo, and Neogi, 2011; Briskorn and Stolletz, 2014; Harikiopoulo and Neogi, 2011; Psaraftis, 1980). The algorithms presented in the remaining articles assume aircraft-dependent cost functions and separation requirements. However, most of the problems discussed feature class-dependent cost functions and separation requirements.

This article contributes to the current state of research in the scheduling of airport runway operations by providing a new optimization algorithm for the ALP with general assumptions (multiple runways, positive target times, and limited time windows). Existing approaches are either heuristic or rely on more restrictive assumptions concerning the number of runways, landing times, or time windows, see Table 2. Our method is based on the DP approach by Briskorn and Stolletz (2014). However, this paper focuses on computational complexity only. While polynomiality of the developed approach is proven, it is left open how to efficiently implement the approach and what actual computation times can be achieved. Certainly, computation times can be expected to be huge for a straightforward implementation since the run time complexity is reported to be O(n
                     17) (n being the number of aircraft) for two runways and two aircraft classes. We purposefully modify the problem setting in order to allow more efficient solution methods without losing practice-orientation. Also, we develop a new dominance criterion for state space reduction by which we can reduce computation times significantly. We obtain a DP approach yielding optimum schedules significantly faster than a standard MIP solver (CPLEX).

Our approach does not consider stochastic events, e.g., changes in target landing times of approaching aircraft or weather conditions. We assume short planning horizon of approximately 45–60 minutes, in which it is possible to calculate the target landing times with a high precision, and to have a reliable weather forecast.

In Section 2, we provide a formal problem definition as well as a mixed-integer programming formulation. In Section 3, the new optimization algorithm is described in detail. The numerical study in Section 4 compares the results of the algorithm to optimal results of a MIP solver and provides a sensitivity analysis. Section 5 briefly describes how the algorithm could be used in practice by embedding it in a rolling horizon approach. Section 6 summarizes the major insights and outlines future research.

We consider a set, A = {1, …, |A|}, of aircraft partitioned into disjoint subsets, A
                        1, …, AW
                        , of W classes and a set of R identical and independent runways. Each aircraft, a ∈ A, belongs to exactly one class of aircraft in {1, …, W} denoted by w(a) and has a target landing time, Ta
                        , and a latest possible landing time, La
                        . As in Briskorn and Stolletz (2014), we assume throughout the paper that there is no pair (a, a′) of aircraft with w(a) = w(a′), 
                           
                              
                                 T
                                 a
                              
                              <
                              
                                 T
                                 
                                    a
                                    ′
                                 
                              
                              ,
                           
                         and 
                           
                              
                                 L
                                 a
                              
                              >
                              
                                 L
                                 
                                    a
                                    ′
                                 
                              
                           
                        .

For each class w, a non-decreasing and convex cost function, 
                           
                              
                                 c
                                 w
                              
                              
                                 (
                                 d
                                 )
                              
                              :
                              
                                 R
                                 +
                              
                              →
                              R
                              ,
                           
                         reflects the additional cost depending on the deviation, d, of the actual landing time from the target time of an aircraft of class w. Finally, for each pair (w, w′) of classes, a minimum separation time, 
                           
                              
                                 s
                                 
                                    w
                                    ,
                                    
                                       w
                                       ′
                                    
                                 
                              
                              ,
                           
                         is given.

A solution to the ALP is a schedule 
                           
                              S
                              ⊂
                              A
                              ×
                              {
                              1
                              ,
                              …
                              ,
                              R
                              }
                              ×
                              R
                           
                         with exactly one (a, r, t) ∈ S for each a ∈ A. A triple (a, r, t) ∈ S represents a being scheduled on r at time t. For (a, r, t) ∈ S and (a′, r, t′) ∈ S with t′ ≥ t such that no (a′′, r, t′′) ∈ S with t < t′′ < t′ exists we say that a′ immediately follows a.

A solution S is called feasible if

                           
                              •
                              for each (a, r, t) ∈ S we have Ta
                                  ≤ t ≤ La
                                 , that is, each aircraft lands in its landing window,

for each pair (a, a′) of aircraft such that a′ immediately follows a, we have (a, r, t) ∈ S and (a′, r, t′) ∈ S with 
                                    
                                       
                                          t
                                          ′
                                       
                                       −
                                       t
                                       ≥
                                       
                                          s
                                          
                                             w
                                             
                                                (
                                                a
                                                )
                                             
                                             ,
                                             w
                                             
                                                (
                                                
                                                   a
                                                   ′
                                                
                                                )
                                             
                                          
                                       
                                       ,
                                    
                                  that is, the minimum separation time is satisfied.

The problem, then, is to find a feasible solution S which minimizes

                           
                              (1)
                              
                                 
                                    
                                       ∑
                                       
                                          (
                                          a
                                          ,
                                          r
                                          ,
                                          t
                                          )
                                          ∈
                                          S
                                       
                                    
                                    
                                       c
                                       
                                          w
                                          (
                                          a
                                          )
                                       
                                    
                                    
                                       (
                                       t
                                       −
                                       
                                          T
                                          a
                                       
                                       )
                                    
                                 
                              
                           
                        among all feasible solutions. We refer to this problem as the ALP in the following sections.

In this section, we present a MIP formulation of the ALP as defined in Section 2.1. The sets, parameters, and variables of the model are shown in Table 3
                        . We use binary variables, 
                           
                              
                                 γ
                                 
                                    a
                                    ,
                                    
                                       a
                                       ′
                                    
                                 
                              
                              ,
                           
                         to indicate if aircraft a′ immediately follows aircraft a. Additional binary variables, far
                         and lar
                        , indicate the first and last aircraft on each runway. Variable Ca
                         represents the assigned landing time for each aircraft.

The MIP with successive separation requirements can be stated as follows.

                           
                              (2)
                              
                                 
                                    Minimize
                                    
                                    F
                                    =
                                    
                                       ∑
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                    
                                       c
                                       
                                          w
                                          (
                                          a
                                          )
                                       
                                    
                                    
                                       (
                                       
                                          C
                                          a
                                       
                                       −
                                       
                                          T
                                          a
                                       
                                       )
                                    
                                 
                              
                           
                        subject to the constraints

                           
                              (3)
                              
                                 
                                    
                                       T
                                       a
                                    
                                    ≤
                                    
                                       C
                                       a
                                    
                                    ≤
                                    
                                       L
                                       a
                                    
                                    
                                    ∀
                                    a
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       C
                                       a
                                    
                                    +
                                    
                                       s
                                       
                                          w
                                          
                                             (
                                             a
                                             )
                                          
                                          w
                                          
                                             (
                                             
                                                a
                                                ′
                                             
                                             )
                                          
                                       
                                    
                                    ≤
                                    
                                    
                                       C
                                       
                                          a
                                          ′
                                       
                                    
                                    +
                                    M
                                    
                                       (
                                       1
                                       −
                                       
                                          γ
                                          
                                             a
                                             
                                                a
                                                ′
                                             
                                          
                                       
                                       )
                                    
                                    
                                    ∀
                                    a
                                    ,
                                    
                                       a
                                       ′
                                    
                                    ∈
                                    A
                                    ;
                                    a
                                    ≠
                                    
                                       a
                                       ′
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       C
                                       a
                                    
                                    ≤
                                    
                                    
                                       C
                                       
                                          a
                                          ′
                                       
                                    
                                    
                                    ∀
                                    a
                                    ,
                                    
                                       a
                                       ′
                                    
                                    ∈
                                    A
                                    ;
                                    
                                       T
                                       a
                                    
                                    <
                                    
                                       T
                                       
                                          a
                                          ′
                                       
                                    
                                    ;
                                    w
                                    
                                       (
                                       a
                                       )
                                    
                                    =
                                    w
                                    
                                       (
                                       
                                          a
                                          ′
                                       
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       ∑
                                       
                                          
                                             a
                                             ′
                                          
                                          ∈
                                          A
                                       
                                    
                                    
                                       γ
                                       
                                          
                                             a
                                             ′
                                          
                                          a
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          r
                                          =
                                          1
                                       
                                       R
                                    
                                    
                                    
                                       f
                                       
                                          a
                                          r
                                       
                                    
                                    =
                                    1
                                    
                                    ∀
                                    a
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       ∑
                                       
                                          
                                             a
                                             ′
                                          
                                          ∈
                                          A
                                       
                                    
                                    
                                    
                                       γ
                                       
                                          a
                                          
                                             a
                                             ′
                                          
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          r
                                          =
                                          1
                                       
                                       R
                                    
                                    
                                    
                                       l
                                       
                                          a
                                          r
                                       
                                    
                                    =
                                    1
                                    
                                    ∀
                                    a
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       ∑
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                    
                                    
                                       f
                                       
                                          a
                                          r
                                       
                                    
                                    ≤
                                    1
                                    
                                    ∀
                                    r
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    R
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       ∑
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                    
                                    
                                       l
                                       
                                          a
                                          r
                                       
                                    
                                    ≤
                                    1
                                    
                                    ∀
                                    
                                    r
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    R
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       C
                                       a
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    a
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       γ
                                       
                                          a
                                          
                                             a
                                             ′
                                          
                                       
                                    
                                    ,
                                    
                                       f
                                       
                                          a
                                          r
                                       
                                    
                                    ,
                                    
                                       l
                                       
                                          a
                                          r
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ;
                                       1
                                       }
                                    
                                    
                                    ∀
                                    
                                    a
                                    ,
                                    
                                       a
                                       ′
                                    
                                    ∈
                                    A
                                    
                                    ∀
                                    r
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    R
                                 
                              
                           
                        
                     

The objective function (2) sums up the total delay cost of all aircraft landings incurred by the delay of the respective aircraft’s scheduled landing time, Ca
                        , from its target time, Ta
                        . Constraint (3) ensures that each landing is scheduled within the respective time window, [Ta, La
                        ]. The separation requirement for all pairs of subsequent aircraft that land on the same runway is ensured by constraint (4): if 
                           
                              
                                 γ
                                 
                                    a
                                    
                                       a
                                       ′
                                    
                                 
                              
                              =
                              1
                              ,
                           
                         
                        i.e., a lands immediately before a′ on the same runway, the respective landing times, Ca
                         and 
                           
                              
                                 C
                                 
                                    a
                                    ′
                                 
                              
                              ,
                           
                         must be separated by at least 
                           
                              s
                              
                                 w
                                 
                                    (
                                    a
                                    )
                                 
                                 w
                                 
                                    (
                                    
                                       a
                                       ′
                                    
                                    )
                                 
                              
                           
                        . Otherwise, if 
                           
                              
                                 γ
                                 
                                    a
                                    
                                       a
                                       ′
                                    
                                 
                              
                              =
                              0
                              ,
                           
                         the equation is valid for a large enough M, e.g.,
                        
                           
                              M
                              ≥
                              
                                 L
                                 a
                              
                              +
                              
                                 S
                                 
                                    w
                                    
                                       (
                                       a
                                       )
                                    
                                    w
                                    
                                       (
                                       
                                          a
                                          ′
                                       
                                       )
                                    
                                 
                              
                              −
                              
                                 T
                                 
                                    a
                                    ′
                                 
                              
                              
                              ∀
                              a
                              ,
                              
                                 a
                                 ′
                              
                              ∈
                              A
                           
                        .

A key property of aircraft classes is that an FCFS sequence within each class can be assumed (Briskorn and Stolletz, 2014). In (5), this property is implemented by forcing aircraft of a particular class to land in increasing order of target times. Constraints (6) and (7) ensure that each aircraft, a, has exactly one predecessor (unless it is the first aircraft landing on its runway) and exactly one successor (unless it is the last aircraft). Each runway has at most one aircraft landing first and one aircraft landing last, as stated in (8) and (9).

We propose a dynamic programming algorithm based on the framework proposed by Briskorn and Stolletz (2014). Briskorn and Stolletz (2014) developed a DP approach to prove that the ALP can be solved polynomially in |A| but exponentially in W and R. Their approach was not implemented, as they argue that the size of the state space is too large for a straightforward implementation.

We define each state of the dynamic program as a tuple (k
                        1, …, kW, rop), where

                           
                              •
                              
                                 kw, w = 1, …, W, is the number of aircraft of class w that have been scheduled, and


                                 rop is a runway occupation profile (ROP). It is defined as a vector

((O
                                 1, w
                                 1), …, (OR, wR
                                 )) that contains the time Or
                                  and aircraft class wr
                                  of the latest landing on each runway r.

A runway with no operations scheduled is denoted in a ROP as ( − 1, −1). Note that the state tells us which aircraft have already been scheduled to land due to the FCFS assumption within each class, and the earliest possible time of the next landing for each class on each runway.

The initial state of the program is (0
                           W
                        , ( − 1, −1)
                           R
                        ), i.e., no landings have been scheduled yet. A feasible state transition

                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             (
                                             
                                                k
                                                1
                                             
                                             ,
                                             …
                                             ,
                                             
                                                k
                                                W
                                             
                                             ,
                                             
                                                (
                                                
                                                   O
                                                   1
                                                
                                                ,
                                                
                                                   w
                                                   1
                                                
                                                )
                                             
                                             ,
                                             …
                                             ,
                                             
                                                (
                                                
                                                   O
                                                   R
                                                
                                                ,
                                                
                                                   w
                                                   R
                                                
                                                )
                                             
                                             )
                                          
                                       
                                       
                                          ⇒
                                       
                                       
                                          
                                             (
                                             
                                                k
                                                1
                                                ′
                                             
                                             ,
                                             …
                                             ,
                                             
                                                k
                                                W
                                                ′
                                             
                                             ,
                                             
                                                (
                                                
                                                   O
                                                   1
                                                   ′
                                                
                                                ,
                                                
                                                   w
                                                   1
                                                   ′
                                                
                                                )
                                             
                                             ,
                                             …
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             (
                                             
                                                O
                                                R
                                                ′
                                             
                                             ,
                                             
                                                w
                                                R
                                                ′
                                             
                                             )
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        corresponds to the scheduling of the (kw
                         + 1)th aircraft in class w, namely a, on runway r, that is, we have

                           
                              •
                              
                                 
                                    
                                       
                                          k
                                          
                                             w
                                             ′
                                          
                                          ′
                                       
                                       =
                                       
                                          k
                                          
                                             w
                                             ′
                                          
                                       
                                    
                                  for each w′ ≠ w,


                                 
                                    
                                       
                                          k
                                          w
                                          ′
                                       
                                       =
                                       
                                          k
                                          w
                                       
                                       +
                                       1
                                       ≤
                                       
                                          |
                                          
                                             A
                                             w
                                          
                                          |
                                       
                                    
                                 ,


                                 
                                    
                                       
                                          (
                                          
                                             O
                                             
                                                r
                                                ′
                                             
                                             ′
                                          
                                          ,
                                          
                                             w
                                             
                                                r
                                                ′
                                             
                                             ′
                                          
                                          )
                                       
                                       =
                                       
                                          (
                                          
                                             O
                                             
                                                r
                                                ′
                                             
                                          
                                          ,
                                          
                                             w
                                             
                                                r
                                                ′
                                             
                                          
                                          )
                                       
                                    
                                  for each r′ ≠ r, and


                                 
                                    
                                       
                                          (
                                          
                                             O
                                             r
                                             ′
                                          
                                          ,
                                          
                                             w
                                             r
                                             ′
                                          
                                          )
                                       
                                       =
                                       
                                          (
                                          max
                                          
                                             {
                                             
                                                T
                                                a
                                             
                                             ,
                                             
                                                O
                                                r
                                             
                                             +
                                             
                                                s
                                                
                                                   
                                                      w
                                                      r
                                                   
                                                   ,
                                                   w
                                                
                                             
                                             }
                                          
                                          ,
                                          w
                                          )
                                       
                                    
                                  with 
                                    
                                       
                                          O
                                          r
                                          ′
                                       
                                       ≤
                                       
                                          L
                                          a
                                       
                                    
                                 .

This transition is associated with a cost, 
                           
                              
                                 c
                                 
                                    w
                                    (
                                    a
                                    )
                                 
                              
                              
                                 (
                                 
                                    O
                                    r
                                    ′
                                 
                                 −
                                 
                                    T
                                    a
                                 
                                 )
                              
                           
                        . The cost of a state s can be defined via a Bellman recursion as

                           
                              (13)
                              
                                 
                                    Z
                                    
                                       (
                                       s
                                       )
                                    
                                    =
                                    
                                       min
                                       
                                          
                                             s
                                             ′
                                          
                                          ∈
                                          Π
                                          
                                             (
                                             s
                                             ,
                                             a
                                             ,
                                             t
                                             )
                                          
                                       
                                    
                                    
                                       (
                                       Z
                                       
                                          (
                                          
                                             s
                                             ′
                                          
                                          )
                                       
                                       +
                                       
                                          c
                                          
                                             w
                                             (
                                             a
                                             )
                                          
                                       
                                       
                                          (
                                          t
                                          −
                                          
                                             T
                                             a
                                          
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        where Π(s, a, t) is the set of states for which a feasible transition to s by landing a at time t exists, and Z(0
                           W
                        , ( − 1, −1)
                           R
                        ) = 0.

We consider the set Π of terminal states with s = (|A
                        1|, …, |AW
                        |, rop) for each s ∈ Π. The ALP then can be solved by finding a state

                           
                              (14)
                              
                                 
                                    
                                       s
                                       *
                                    
                                    =
                                    arg
                                    
                                       min
                                       
                                          s
                                          ∈
                                          Π
                                       
                                    
                                    
                                       {
                                       Z
                                       
                                          (
                                          s
                                          )
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        The actual schedule can be derived by tracking the sequence of transitions that transform the initial state into s*, inducing Z(s*).

This DP approach corresponds to the approach by Briskorn and Stolletz (2014). Both the states and the transitions are defined in a similar fashion. However, because we do not consider early landings incurring additional costs, the number of transitions and the state space of the DP are significantly smaller. In Briskorn and Stolletz (2014), for each transition there is a multitude of possible landing times for the next scheduled landing. Without early landings, it is optimal to schedule the next landing as early as possible. Different papers on the aircraft landing problem state that the benefit of early landings is limited. Thus they either assume that an aircraft’s target landing time is also the earliest possible (Bianco et al., 1999; Venkatakrishnan, Barnett, and Odoni, 1993), or they limit the possible earliness to a small value, e.g., 60 seconds, (Kupfer, 2009; Lee and Balakrishnan, 2008). Our approach allows early landings, if they are not associated with additional costs.

This section develops a reduction of the state space that is actually searched by employing a dominance criterion and by removing symmetry. We traverse the state space in order by considering states with the smallest number of aircraft being landed yet first. After all states with q aircraft scheduled have been evaluated, we then proceed to those states having q + 1 aircraft scheduled to land. However, before proceeding to states with q + 1 aircraft, we sort the R entries of the ROP for each state with q aircraft according to the non-decreasing class of the last aircraft that landed and use the last landing time as a tie-breaker. Note that this does not change the basis for scheduling further aircraft because we assume that the runways are identical and independent. This sorting step will lead to states with symmetric ROPs to be identified in the check for dominated states described as follows.

Using the ROP of a state (k
                        1, …, kW, rop) and the separation requirements, we define 
                           
                              
                                 p
                                 
                                    w
                                    r
                                 
                              
                              =
                              
                                 O
                                 r
                              
                              +
                              
                                 s
                                 
                                    
                                       w
                                       r
                                    
                                    ,
                                    w
                                 
                              
                           
                         as the earliest possible landing time for the (kw
                         + 1)th aircraft of class w on runway r for all runways r = 1, …, R and all aircraft classes w = 1, …, W.

We say that ROP rop dominates ROP rop′ (rop≻rop′) if each runway, r, is available for the next aircraft of each class, w, earlier or at the same time, i.e., if 
                           
                              
                                 p
                                 
                                    w
                                    r
                                 
                              
                              ≤
                              
                                 p
                                 
                                    w
                                    r
                                 
                                 ′
                              
                           
                         holds for each w = 1, …, W and r = 1, …, R. Then we say that a state, s, dominates another state, s′, (s≻s′) if

                           
                              •
                              at least the same number of aircraft kw
                                  of each class w have already been scheduled (kw
                                 (s) ≥ kw
                                 (s′) for each w ∈ W), and

the cost of s does not exceed the cost of s′ (Z(s) ≤ Z(s′)), and

the ROP of state s dominates the ROP of state s′ (rop(s)≻rop(s′)).

A dominated state s′ can be removed from further consideration, that is, we do not consider any transition that starts in s′.

Note that we should (at least implicitly) check for dominance between each of the pairs of states that is reached. We can reduce the computational burden of these dominance checks, as we carefully traverse the state space by evaluating the states in a non-decreasing order of aircraft that are scheduled. It is then easy to observe that only the dominance needs to be checked between states having the same number of aircraft scheduled for each class.

In Section 4.1, we demonstrate the efficiency of the new algorithm by comparing its computation time with that of a standard MIP solver using the formulation presented in Section 2.2. We use two standard data sets from the scientific literature (Bianco et al., 1999) and 10 randomly generated, realistic data sets.

We solve each problem instance using four different cost functions:

                        
                           •
                           linear increase of delay cost (with rate 1 monetary unit/second)

no delay cost during first minute, then linear increase (with rate 1 monetary unit/second)

no delay cost during first 5 minutes, then linear increase (with rate 1 monetary unit/second)

cost increase doubling every 5 minutes (with rate 1 monetary unit/second during the first 5 minutes)

The second and third cost functions can be used to allow early landings (without additional costs). We assume a limited time window of 30 minutes for each aircraft (La
                      = Ta
                      + 30 minutes) in all problem instances in this study. We performed additional tests with smaller time windows (La
                      = Ta
                      + 15) minutes and open time windows (La
                      = ∞), but we could not observe significant changes in the computation times, neither for the MIP, nor for our DP approach.

Next, in Section 4.2 we analyze the sensitivity of the algorithm’s performance to problem size (40, 50, 60, 70, 80, 90, and 100 aircraft) and to the average inter-arrival times of 30, 35, 40, 50, and 60 seconds. We solve 10 randomly generated data sets for different combinations of the aforementioned parameters on R = 2, 3, and 4 runways. In Section 4.3, we show the impact of the state-space reduction presented in Section 3.2 on the computation times.

For all randomly generated problem instances, we use the separation matrix in Table 1. All calculations are performed on an Intel Core i5 computer (2.5 gigahertz, 8 gigabytes RAM). The MIP formulations are solved with CPLEX 12.2; our new algorithm is implemented with Java JDK 1.6. The computation time limit is set to 60 minutes for each problem instance.


                        Bianco et al. (1999) provide two realistic sets of aircraft with target times and separation requirements. These sets are also used in numerical studies, e.g., by Ernst et al. (1999) and by Briskorn and Stolletz (2014). Set 1 consists of |A| = 30 aircraft divided into W = 4 classes, and set 2 consists of |A| = 44 aircraft divided into W = 2 classes. By scheduling each of these sets on R = 1, 2, and 3 runways, we obtain a total of six problem instances.


                        Table 4
                         compares the computation times of our algorithm and of the MIP formulation from Section 2.2. The “gap to lower bound” shows the difference between the best feasible solution found by CPLEX after 1 hour and the respective lower bound. The “gap to opt. objective” shows the difference between the solution of our algorithm and the best feasible solution found by CPLEX. Our new algorithm optimally solves all instances in less than a second, regardless of the cost function. For R = 1, CPLEX cannot find proven optimal solutions within 1 hour, with one exception.

For the second comparison, we generate 10 data sets using the following parameters. Each data set consists of |A| = 50 aircraft divided into three classes, with the separation matrix shown in Table 1. By analyzing the inbound traffic of nine major American airports, Willemain, Fan, and Ma (2004) show that a Poisson arrival process (i.e., exponentially distributed interarrival times) is a realistic approximation of the inbound traffic of an airport. We use one set of exponentially distributed interarrival times in 10 different randomized orders, with the first target time, Ta
                        , of 0. Therefore, the last target time, max 
                           a
                        
                        Ta
                        , is the same for all 10 resulting profiles. Each target time is randomly assigned to an aircraft class out of a set of exactly 20 percent small aircraft, 40 percent large aircraft, and 40 percent heavy aircraft, which is a realistic configuration (Balakrishnan and Chandran, 2010). We choose an average interarrival time of 40 seconds. The resulting distributions of target times and aircraft classes for all 10 profiles are shown in Fig. 1
                        .


                        Table 5
                         shows the optimal solutions to our randomly generated problem instances for all four cost functions. Each profile is scheduled on R = 2, 3, and 4 runways. Due to the limited time windows, none of the problem instances has a feasible solution for R = 1.

For the linear cost function, our new algorithm outperforms the MIP solver in all instances. All instances are solved in less than 1 minute, while CPLEX exceeds the 1 hour time limit in most cases with R = 2 and 3. In particular, for R = 2 the gap to the optimal solution is quite large. When R = 4, the runway utilization is unrealistically low and the two have a comparable performance.

For the cost functions “doubling every 5 minutes” and “1 minute free, then linear”, the computation times are not significantly different from the linear cost function. For the cost function “5 minutes free, then linear”, our approach obtains fast and optimal results for R = 2 while the MIP hits the time limit in all cases and returns non-optimal solutions. For cases with low runway utilization, R = 3 and R = 4, however, the optimal objective value is 0, that is, all aircraft can land with less than 5 minutes delay. The MIP can solve these cases in seconds, while our approach takes up to 5 minutes for R = 4. For the most important cases with high runway utilization, that is, the cases where sequencing has a real impact, the DP finds optimal solutions within seconds regardless of the shape of the cost function.

We tested how the number of aircraft affects the computation times for problem instances with |A| = 40, 50, 60, 70, 80, 90, and 100 aircraft, using a linear cost function. The other parameters remain unchanged (40 seconds average interarrival times, 30 minutes time windows). Table 6
                         shows the average and maximum computation times for 10 problem instances of each size. For |A| = 60 aircraft or less, the computation took less than 1 minute in all of the test cases. The average computation time increases with the number of aircraft, but even for |A| = 100 aircraft, the 1 hour time limit was never reached.

To observe how the load on the runway system affected the computation times, we used problem instances with i = {30, 35, 40, 50, 60} seconds for problems with |A| = 50 aircraft and a 30 minute time window. Table 7
                         shows the computation times for 10 problem instances for each configuration. For short interarrival times (i = 30) and R = 4 runways, the time limit was exceeded in one problem instance. If this particular instance is excluded, the average computation time for i = 30 and R = 4 is only 19 seconds. All of the problem instances with an average interarrival time of 40 seconds or longer were solved in under 1 minute.

The following tests show that the algorithm presented in Section 3.1 performs well only with the state-space reduction presented in Section 3.2. We generated a set of small problem instances, with |A| = 10, 15, and 20 aircraft, with the same parameters as our problem instances from Section 4.1. We solved these instances both with and without state space reduction. Table 8
                         shows the average computation times (in seconds) and the average number of states created for 10 problem instances in each setting. The table entries “>3600” or “n/a” indicate that the algorithm did not return a solution after 1 hour.

Without state-space reduction, the dynamic solution approach is not solvable. The number of states created is up to 400 times larger than with state-space reduction. The state space contains a vast number of symmetric and sub-optimal states that make even small problem instances intractable.

As stated in the introductory section, we assume to have precise data on the upcoming aircraft landings 45–60 minutes in advance, as soon as the aircraft reach the terminal manoeuvering area (TMA) of the airport. When the respective aircraft reach their final approach path, about 20 minutes before landing, their trajectory and thus their position relative to other aircraft may no longer be changed. Thus, for each runway, the sequence of aircraft entering the final approach path is the same as the sequence of landings. The time in between (that is, 25–40 minutes) can be used to optimize the order and the runway assignment of the approaching aircraft.

A number of authors (e.g., 
                     Venkatakrishnan et al., 1993, Furini, Persiani, and Toth (2012)) propose to adapt their solution approaches to a dynamic scenario by embedding it in a rolling horizon framework: The landing schedule for the aircraft in the TMA, which have not reached the final approach path yet, is optimized; then, iteratively, after a certain amount of time passed, the schedule of the aircraft closest to the final approach path is fixed and a new schedule is calculated, taking into account the aircraft that entered the TMA in the meantime.

In peak times, major European airports like Frankfurt/Main or London-Heathrow have about 90 aircraft movements per hour, or about 40–60 aircraft in a time window of 25–40 minutes, respectively. With the ability to optimally schedule this number of aircraft in less than a minute, it is possible to use our solution approach in this iterative fashion, as well. To ensure the separation requirements between the fixed schedule and the schedule obtained in the subsequent iteration, the state, that represents the time and aircraft class of the last scheduled landing on each runway, has to be used as the initial state of the next iteration of the optimization algorithm.

This article presents a dynamic programming algorithm that is capable of efficiently solving the ALP with different aircraft classes on multiple runways with positive target landing times and limited time windows. Based on a DP formulation by Briskorn and Stolletz (2014), we develop a dominance criterion that eliminates states from the state space while maintaining optimality. The numerical study reveals that the algorithm quickly and optimally solves large problem instances and outperforms the standard MIP solver, CPLEX. The study also shows that the new dominance criterion significantly improves the performance of the dynamic programming approach.

In future research, we will extend the solution approach to require less restrictive assumptions than are discussed in the scientific literature regarding the ALP: Some authors allow early landings (Ca
                      < Ta
                     ) with penalty costs, assume discontinuous landing time windows (Artiouchine, Baptiste, and Dürr, 2008), assume heterogeneous and interdependent runways, or assume both, take-offs and landings. For the latter, the ground holding problem (Rossi and Smriglio, 2001) has to be taken into consideration. In addition, our approach may serve as a framework for heuristic solution methods such as beam search, to make even larger problems tractable.

@&#ACKNOWLEDGMENTS@&#

This research was partially supported by the Erich-Becker-Stiftung, a foundation of the Fraport AG, and by the Julius Paul Stiegler Memorial Foundation.

@&#REFERENCES@&#

