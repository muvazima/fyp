@&#MAIN-TITLE@&#Conversion cost and specification on interfaces of key-value stores

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Design an interface description model to abstract interface characteristics.


                        
                        
                           
                           Quantify and evaluate the difference of two interfaces.


                        
                        
                           
                           Propose a prototype interfaces as a reference of the interface specification.


                        
                        
                           
                           Provide guidance for the design of key–value stores' interfaces.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Key-value stores

Interoperability

Conversion costs

Interfaces specification

@&#ABSTRACT@&#


               
               
                  Due to the quick growth of data created and analyzed by industry and business requirements become more complex, many companies come to employ more than one key-value store together to serve different tasks. Considering key-value stores currently define their own interfaces which have different attributes and semantics, interoperability among these key-value stores is weak. To get the best interoperability, we may choose the store whose interfaces are similar to the others, or we may define an interface specification such as SQL specification in relational databases. We propose an interface description model (IDM for short) to abstract interfaces of different key-value stores, and an algorithm to quantify their differences, named as conversion cost. With the help of these algorithms, we can measure and compare the interoperability of given two stores. After studying the interoperability of many stores, we propose an interface prototype, which has the minimum conversion cost to the interfaces of other stores, as a reference to the interface specification of key-value store. Experiments show the features of interfaces, and prove that the proposed prototype has the best interoperability to other typical stores.
               
            

@&#INTRODUCTION@&#

With the rapid development of information technologies, the scale of data created and analyzed by industry grows larger and larger. Traditional relational databases, which organize data into relational models, meet a performance bottleneck when querying and managing big data in such situations [1]. To break the limitation of relational databases, NoSQL database such as key-value store emerged in recent years. Data relationship in key-value store is simplified and transactional property for ACID is generally given up [2]. Varieties of key-value stores are designed in different architectures to meet different requirements, but all of them follow key-value data model which will be explained in Section 3. Due to their great performance and flexibility, key-value stores are widely used in industry in support of the big data management [3].

Different databases, especially databases in different categories, are in different architectures. If multiple databases are employed within a system, each database has its own advantages when handling some specified types of data, and is efficient in specified scenarios. Using and maintaining more than one database within a system help to reduce the heavy burdens caused by various use cases. Each use case corresponds to the most appropriate database, therefore the efficiency and scalability of system are guaranteed. And for techniques such as data warehouse and data integration, due to the variety of big data, heterogeneous databases are often employed for storing data. Besides, the system, which can employ multiple databases, has better portability. It avoids vendor lock-in by changing existing database easily, compared with the system that only locked on one database. The last but not least, applications should access multiple databases via a uniform interface. Therefore, the diversity and complexity of the underlying databases are transparent to the developers.

Because of the previous reasons, the usage of multiple key-value stores becomes more common and used frequently in industry. For an operational system, performance is the key issue, and diverse data are required to meet various requirements. Multiple databases support the diverse data well with high performance. For analytical systems, it is frequent to perform data analysis on the massive and various data. We tend to store data in heterogeneous databases because of the different equipment or different approaches it takes during data collection. The middleware of query driven data integration, which access multiple databases with a uniform interface, is frequently adopted in data analysis system.

Actually, most Internet companies like Facebook have already deployed multiple databases into their development environments. Facebook adopts several key-value stores to meet its various business requirements: HBase for messages service and monitoring, Haystack for photo store and Memcached for in-memory data store. Twitter employs Cassandra for atomic counting and HBase to power its search engine. E-business sites like Amazon adopts key-value store such as MongoDB and Riak to record users' click stream, and Redis to achieve effective static pages serving or caching of product related data. The Chinese online shopping platform, named TaoBao, also adopts the in-memory database, transaction supported key-value database, massive contents oriented key-value store and achieved oriented storage to support its business. Interoperability, representing the ability to share data and work together among key-value stores, is necessary [4]. From another perspective, considering the compatibility, portability, extensibility and reusability of system, it is underlying databases that dominate these properties. It is beneficial if a system could change their underlying databases easily, or support heterogeneous databases. For instance, the uniform interface of data access layer and the lower cost of mapping database interface which will contribute to the portability.

Existing key-value stores, such as HBase, SimpleDB, CouchDB, Riak and MongoDB, have similar data model but distinctive architectures. They provide the similar interfaces, but the same concept may correspond to different terms and structures. Most key-value stores now provide interfaces to access data directly through HTTP protocol that is RESTful API (Application Program Interface) [5]. However, when invoking interfaces through HTTP protocol, users must create a HTTP request and then parse the data appended in the HTTP response, and the corresponding key-value store defines the particular data format of HTTP messages. Due to the difference of interfaces in format, it is inevitable to develop specialized programs, which are costly and less of scalability, for data exchange and data integration needs among key-value stores. Interoperations among database based applications and programming on data access frameworks are hard to achieve as well.

Considering interfaces of key-value stores are more or less distinctive, users have to understand many interface formats. Data access turns to be inefficient and tedious. If there is a specification on interfaces of key-value store, as same as SQL of relational databases, the problem of interoperability and vendor lock-in could be solved. When replacing existing key-value stores, such kind of specification helps to choose the appropriate one among alternative stores, which has less conversion cost to achieve interoperations with key-value stores remained in the system. And it can also provide guidance for the design of related database interfaces and standards through finding relatively less costly interface format. Unfortunately, there is no such specification so far and few researches study the conversion costs of interfaces of key-value stores. In this paper, based on the “Information technology, cloud data storage and management, part 5, specification on interfaces of Key-value store” [6], which is the project issued by “Information Technology Standardization Administration of China”, we define and evaluate the conversion cost on interfaces of key-value stores, and provide a reference to the specification on them.

In this paper, database refers to key-value store since which is not a proper database; interface refers to an operational one in database, such as insert interface and delete interface; (interface) distance is a cost of adapting one interface into another. Database interfaces refer to all operational interfaces of database; database distance is an aggregated cost of adapting interfaces of one database into those of another database correspondingly. Based on the previous description, there are several pending questions which may help to the interface specification of key-value stores. (1) Given interfaces of two databases, what is the conversion cost between them, how to quantify the cost. (2) Whether there is an existing key-value store which has the minimum conversion cost to other databases; (3) Theoretically, whether an interface, whose conversion cost to the other interfaces is minimum, could be defined. (4) How to design and estimate the interface specification. As much as our knowledge, several research works, which are explained in Section 2, are focus on the similar topics.

In this paper we present an interface description model to describe interfaces of key-value stores, and the model highlights the crucial structure that makes the interface distinctive among others. Each interface is abstracted into a tree structure through this model and we propose a quantification algorithm to evaluate the difference, named as “distance”, between interfaces. Essentially, given two interfaces of the same operation in two key-value stores, the distance is the cost it takes when adapting one interface into another. Referring the edit graph algorithm, the distance can be calculated, and then, the interfaces which have the minimum distances to the others indicate a theoretic specification. Experimental results prove that the proposed specification has less distance than other interfaces from existing key-value stores. Our contributions in this paper are listed as follows. (1) Propose an interface description model to abstract interface characteristics. (2) Propose a general way to quantify and evaluate the difference between two RESTful interfaces defined by key-value stores and represent the difference as distance. (3) Based on the conversion costs of interfaces of existing key-value stores, we have discussed the use of the proposed approach and propose an interface specification (a referenced one).

The rest of this paper is organized as follows. Following the introduction, Section 2 introduces the related work. Section 3 introduces the definitions of interface description model and Section 4 explains the algorithms of distance quantification. Section 5 discusses several potential scenarios of the conversion cost and Section 6 introduces several proposed database interfaces as a prototype of national specification on interfaces of key-value store. And in Section 7, we evaluate the distance of HBase, SimpleDB, CouchDB, Riak, MongoDB and our Prototype. The experiment result shows that Prototype has these minimum conversation costs than others comprehensively. Finally, conclusions and future works are summarized in Section 8.

@&#RELATED WORK@&#

To guarantee the interoperability of traditional relational databases, some researchers suggest integrating multiple autonomous database systems as a federated database [7,8,9]. The federation database mainly maintains mappings to data structures or schemas of any two different databases. Although the solution has solved data integration problem among different databases, however, it tends to build a management system over existing databases. It is hard to maintain the system and fails to fix the problem from the perspective of high scalability and interoperability. In fact, interoperability could be simply improved if all databases follow an interface specification, such as SQL language in relational databases. SQL-like query is also an effective implementation to access data stored in different key-value stores. In the data integration, SQL queries express data conditions to filter data in various key-value stores and relational databases. Those conditions also help to organize data into a predefined schema that is easier to access and analyze [10,11,12,13].

Atzeni et al. proposed a common programming interface [14], which plays a meta-layer role when users access to key-value stores, to reduce the heterogeneity of interfaces during the development. This common interface is designed in an object-oriented manner and provides three simplified operations, put, get, and delete, for users to interact with key-value stores. By calling corresponding methods and passing specified parameters, the details and constraints of underlying key-value stores are transparent to users and developers.

Marinos et al. presented a series of patterns that make relational databases accessible through Web services possible [15]. Haselmann et al. proposed a group of universal APIs to support unified APIs used for diversity of Data-as-a-Service systems [16]. The paper introduced a feasible way to design universal APIs and discussed the features of universal APIs'. These APIs, such as querying data and defining schema, are RESTful, resource-oriented, and intuitional URIs. However, they lack the comprehensive definitions of HTTP request and response, so that these universal APIs are not completed and impractical. These APIs inspire our work because they are not only compatible with traditional relational databases and XML databases, but also NoSQL databases. However, the weakness is that the generalization makes these APIs redundant and hard to describe even represented in REST style. No evaluation standard or experiment is proposed in the paper, it is hard to estimate the effectiveness and efficiency.

The similar interface definitions are WADL [17]. It formalizes the description of HTTP-based applications, which provide programmatic access to the internal data, with more formal specifications such as XML schema for XML-based data formats. If the structural similarity of XML document is calculated, it can represent the distance of interface. Nierman et al. proposed the algorithm to evaluate XML documents' structural similarity, which derive from the same DTD but have distinct structures, and its similarity calculation is mainly based on two kinds of operations: insert and delete, both operations are performed on a single node or an entire subtree [18]. However the overall complexity of the algorithm is O(n
                     2). Combined methods of tree edit distance and semantic similarity based on information retrieval was proposed by Tekli et al. [19]. In general XML document similarity based on tree edit distance needs to compute pair wise similarity and hence there is huge computational complexity and has scalability issues.

As the structure of WADL, We abstract HTTP-based database operation interfaces to the tree structures. Compute cheapest edit sequence operations that can transform one tree to another, then the conversion cost of two interfaces is simplified to edit distance of trees. Tai was first to introduce non exponential algorithm for finding minimum edit distance between trees [20]. Shasha et al. provided an edit distance algorithm in which they allow insertion, deletion and relabeling of single nodes anywhere in the tree [21], however insertion and deletion of entire sub trees were not considered which are necessary in the interface structure. Another solution is decomposing an unordered tree into a set of tree signatures and quantifies the difference in structural of two interfaces [22]. Besides, Edit graph is an auxiliary structure first used to find the longest common subsequence between two sequences and the shortest edit script for one sequence to another [23]. It provides an effective way to measure the difference of two hierarchical data through reducing the problem of calculating distance of two hierarchical structures into the problem of finding a minimum cost edit script in edit graph. Akutsu et al. presented efficient exponential time algorithms for the unordered tree edit distance problem [24], which has been proved to be NP-hard by Zhang's work [25]. Thus, extra adjustments are required when quantifying the difference between two hierarchical data based on edit graph. In this paper, we upgrade the edit graph to quantify the distance.

In this section, an Interface Description Model (IDM for short) is proposed for modeling the typical structures of interfaces provided by key-value stores. IDM is a tree structure which describes the relationship among components. The distance, which is a cost of adapting one interface to another, is defined as the time complexity of exchanging one tree to another. In this section, the IDM is well defined, and the algorithm for calculating the distance is explained in the next section.

In key-value stores, data is accessed through a key-value data model. The key-value data model is one of the simplest non-trivial data models, and richer data models often base on it. Take Fig. 1
                      as a general example, a table consists of rows, and a row consists of a unique row key and many objects. An object is key-value pairs associated with different timestamps, in which keys with different timestamps are same, but values with which are different. Referred by Entity-Relation conceptual model, a row stands for an entity, and objects are attributes of the entity, in which keys are attribute names, and values are attribute values, while timestamps represent the different versions of attributes.

Most key-value stores provide RESTful interfaces which are implemented in HTTP protocol, but HTTP protocol highlights the communication details rather than interaction contracts. To emphasize structural features and evaluate the distance of interfaces, IDM follows the structure of HTTP protocol. In IDM, we redefine all of the primitive concepts of HTTP protocol, such as request, response, status line and head fields, as hierarchical structures. The following definitions describe these in detail.

Node will be introduced first in this section to describe basic components of HTTP protocol. Message and operation are two kinds of nodes defined to represent data transmission and interface operation following the definition of node. According to these definitions, each database operation through interface corresponds to an operation tree containing a set of nodes and then the conversion cost between interfaces is equal to the cost it takes to transform one operation tree into another. Each node-level atomic process, like insert or delete, on operation tree is defined as an adaptation.
                        Definition 1
                        Node


                        Node is the basic component of an interface. Comparing node in hierarchy, it can describe interface's structure. A node o is a triple, o
                           =<key, value, sub
                           >. The key and value are string which used to identify name and value of this node, respectively. The sub is a set of child nodes of current node. The value and sub of a node are exclusive, and o.sub could be null when o.value is defined, vice versa. ∀ o
                           
                              i
                           , o
                           
                              j, if o
                           
                              i
                           .key equals to o
                           
                              j
                           .key semantically, then o
                           
                              i
                            and o
                           
                              j
                            are similar nodes no matter their values or children are same or not. Any two sub nodes of one node are not similar.

According to HTTP/1.1 specification, HTTP message consists of three parts: request line or status line, header and body, then each part contains different details. As defining two special nodes, message and operation, all of these parts are represented into nodes.
                        Definition 2
                        Message


                        Message is a special node which represents a data transmission through database interface. Message m has two child nodes, ms and md. Message state ms describes basic information and constraints of message and message data md describes the transmitted data.

Message corresponds to request and response of HTTP protocol, so message state is a node whose key is enumerable and nominal values, whose value is null, and whose sub is a set of nodes containing basic information and constraints of request and response; message data is a node which represents hierarchical data appended in the body of request and response.
                        Definition 3
                        Operation


                        Operation is a special node which represents an operational interface of key-value store. Each operation opt has two child nodes: msg_req and msg_resp which are two messages, representing the request and response, respectively.

When interacting with database through HTTP protocol, opt defines both the interface of sending request to a database and the interface of receiving response from a database. It is a global description of an interface. Since the node is hierarchical, each HTTP based interface is also a hierarchical structure. Traversing the node opt and its children recursively, it turns out to be a hierarchy. As shown in Fig. 2
                     , a hierarchical structure of operation is an unordered tree, named as an operation tree, because the order in which the children of node are listed is irrelevant.

In conclusion, each operation tree is a simplified description of interface, and IDM is a forest of trees which represent all interfaces defined in a key-value store. The distance, which is a cost of adapting one interface to another, refers to the time complexity of exchanging one tree to another. We will discuss the algorithm calculating the distance of two interfaces.
                        Definition 4
                        Adaption


                        Adaptions are the node-level atomic processes. The process of adapting an interface to another includes a series of atomic processes (adaptions), and these adaptions form an ordered set named adaption queue. Since the interface is modeled as nodes, the adaption is the computation on nodes.

There are three kinds of adaptions: append, remove and modify. For two operation trees T
                     1, T
                     2, the append adaption apd(o
                     1, o
                     2) appends node o
                     2 into the position of node o
                     1 in T
                     1; the remove adaption rm.(o
                     1) removes node o
                     1 from T
                     1; the modify adaption mod(o
                     1, o
                     2) modifies o
                     1.key and o
                     1.value according to the key and value of o
                     2.

The cost of adaption is measured as its complexity. When appending a node into the target position, it needs to assign both the key and value of new node, so the cost of append is 2. Similarly, the cost of the remove adaption is 2 because both key and value of target node need to be removed. As to the modify adaption, the keys of two nodes are checked firstly to see whether they share the same key, if they do, only the value of target node is required to be modified, the cost is 2; otherwise, both of its key and value must be modified, then the cost is 3. The costs of adaptations are denoted as Eq. (1).
                        
                           (1)
                           
                              
                                 
                                    
                                       cost
                                       
                                          append
                                       
                                       =
                                       2
                                       ,
                                       cost
                                       
                                          remove
                                       
                                       =
                                       2
                                    
                                 
                                 
                                    
                                       cost
                                       
                                          modify
                                       
                                       =
                                       2
                                       
                                       when
                                       
                                       
                                          n
                                          1
                                       
                                       .
                                       key
                                       =
                                       
                                          n
                                          2
                                       
                                       .
                                       key
                                       ,
                                       cost
                                       
                                          modify
                                       
                                       =
                                       3
                                       
                                       when
                                       
                                       
                                          n
                                          1
                                       
                                       .
                                       key
                                       ≠
                                       
                                          n
                                          2
                                       
                                       .
                                       key
                                    
                                 
                              
                           
                        
                     
                     
                        Definition 5
                        Distance


                        Let T
                           1 and T
                           2 be two interfaces (operation trees), then distance of them, denoted as |
                              T
                           1, T
                           2
                           |, is the cost of adapting one root node into another when T
                           1 and T
                           2 are similar, and is the cost of adapting an empty node to T
                           2 when T
                           1 and T
                           2 are dissimilar. Adapting an empty node to operation tree also means building a new operation tree. Let M
                           1 and M
                           2 be interface description models of two databases, then database distance of them, M
                           1 to M
                           2, denoted as |
                              M
                           1, M
                           2
                           |, is the aggregation of distances of all corresponding interfaces.

Based on Definition 4, the process of adapting T
                     1 to T
                     2 is an adaption queue. So |
                        T
                     1, T
                     2
                     | represents the result aggregating the cost of all adaptions in the queue. We will explain the algorithm of finding the queue in the next section. And database distance is calculated as Eq. (2).
                        
                           (2)
                           
                              
                                 
                                    M
                                    1
                                 
                                 
                                    M
                                    2
                                 
                              
                              =
                              
                                 
                                    ∑
                                    
                                       
                                          T
                                          i
                                       
                                       ∈
                                       
                                          M
                                          1
                                       
                                    
                                 
                                 
                                    Min
                                    
                                       
                                          T
                                          j
                                       
                                       ∈
                                       
                                          M
                                          2
                                       
                                    
                                 
                              
                              
                                 
                                    T
                                    i
                                 
                                 
                                    T
                                    j
                                 
                              
                           
                        
                     
                  

As defined above, the process of adapting operation trees T
                     1 to T
                     2 is represented as an adaption queue and the distance of T
                     1 and T
                     2, marked as |
                        T
                     1, T
                     2
                     |, is calculated by aggregating the cost of all adaptations in the queue. In this section we study the algorithm of calculating the distance of two interfaces, named as conversion cost quantification algorithm. Edit distance is a way of quantifying how dissimilar two sequences are by counting the minimum number of operations required to transform one sequence into the other [23]. Treating an operation tree as a sequence, we adopt the edit distance to find the adaption sequence and then calculate the distance.

However, during the transformation from a tree into a sequence, the orders among sibling nodes in operation trees have to be handled carefully. Improper order among sibling nodes in an operation tree may lead to higher computational cost and an overestimate of interfaces' conversion cost when measured with other interfaces. Fig. 3
                      shows different traversal results of two trees sharing the common nodes r and s. Although the sub node s is both contained in two trees, nodes s aren't placed at the same position whichever tree traversal it takes. In that case, take preorder traversal as an example, edit graph won't treat s as a common node and take more costly operations to handle it. So before computing conversion cost, two operation trees need to be pre-processed to make sure the similar nodes (nodes with same keys, see Definition 1) are placed at the corresponding positions.

Many solutions can be deployed for the transformation between unordered trees and ordered trees. However, no matter which solution we choose for the transformation, each pair of nodes, which are located at the same level in two operation trees and have similar parent node, should be determined whether they are similar or not. This process is inevitable and necessary, and it is the dominating cost of the transformation. The cost depends on the amount of nodes contained in two operation trees. As to the position where each pair of similar nodes is placed, it depends on the specific transformation algorithm and is inconsequential for the following quantification algorithm.

There are two sub algorithms included in the conversion cost quantification algorithm, the ordering algorithm and the edit distance algorithm, for pre-processing operation tree and calculating distance, respectively. The ordering algorithm places each pair of similar nodes at the first positions of corresponding similar nodes in two operation trees and the edit distance algorithm quantify the difference between two repositioned operation trees.

When comparing two operation trees, we measure the difference of the nodes level-wised. It leads to inconsistent result if similar nodes in two operation trees are ordered arbitrarily, so compared operation trees are required to be sorted through the ordering algorithm. Given root nodes of two operation trees, they are similar otherwise the distance of them are meaningless. The ordering algorithm ensures any two similar sub nodes of them are placed at the same order and the same goes for the children of the two similar sub-nodes, recursively. The pseudo code of ordering algorithm is shown in Algorithm 1.
                        Algorithm 1
                        The ordering algorithm
                              
                                 Image 1
                                 
                              
                           
                        

The ordering algorithm searches for the similar nodes contained in both operation trees and repositions them. It traverses two operation trees sequentially. Let M and N denote the amount of nodes in each operation tree, respectively, the time complexity of the ordering algorithm is represented as Eq. (3).
                        
                           (3)
                           
                              cost
                              
                                 ordering
                              
                              =
                              O
                              
                                 MN
                              
                           
                        
                     
                  


                     Fig. 4
                      shows an example of ordering algorithm. The algorithm starts from the first layer of two operation trees firstly and as algorithm goes on, each node's child nodes are placed at a proper position among other sibling nodes. For example, when the ordering algorithm is adjusting the node with the key b at 2nd layer, named node_b, this node is shared by both operation trees, so node_b is a similar node. The node_b in T
                     1 has two sub nodes, node
                     
                        b
                     .sub
                     1
                     ={node_d, node_e }, and which in T
                     2 has two sub nodes, node_b.sub
                     2
                     ={node_e, node_h}. The node_e is the sub node of node_b both in T
                     1 and T
                     2, so node_e is placed in front of other sibling nodes which are node_d in T
                     1 and node_h in T
                     2.

As operation trees are ordered, we can implement the calculation of distance through the edit graph. The edit graph is an auxiliary structure for the comparison of sequences. In edit graph, x-axis represents the source sequence and y-axis represents the target sequence. There are three editing operations for elements defined in edit graph. They are insert, delete and update, represented by a vertical edge, a horizontal edge and a diagonal edge, respectively, and mean to insert current target element into source sequence, remove current element from source sequence and update current source element with current target element, respectively. Each path in the edit graph starting from the top left corner and ending to the bottom right corner represents an adaption sequence adapting source sequence to target sequence. Take Fig. 3 as an example, for source sequence seq
                     _
                     s
                     =< a,b,e,g,h,c,f,i,g,d
                     >and target sequence seq
                     _
                     t
                     =< a,b,e,g,h,d,c,f >, the edit graph of these two sequences is depicted in Fig. 5
                     . The bold path describes an available path adapting seq
                     _
                     s into seq
                     _
                     t, which represents the editing operation sequence {update, delete, insert, update, …, delete, delete, insert}.

When comparing ordered operation trees using edit graph, both source sequence and target sequence represent the preorder traversal of operation trees. Following the definition of adaption in the previous section, element-level operations of edit graph, insert, delete and update, correspond to the node-level adaptions, append, remove and modify. Thus, any available path in edit graph is a possible adaption queue of adapting interface. Based on the Definition 5, the distance of two interfaces, which is the minimum cost of all possible adaption queues, is the minimum cost of all available paths in edit graph.

To explain edit distance algorithm, Fig. 6
                      shows the edit graph for two operation trees with all available paths. Some edges in the edit graph are hidden because the sub-tree of a non-leaf node is required to be appended or removed completely when insert or delete operation is performed, respectively. Take node b in the source tree as an example, there are only vertical edges from (1, 1) to (1, 5) in Fig. 6 because once the node b is removed, in turn, its descendant nodes e, g, h must be completely removed.

According to existing researches, the time complexity of edit graph algorithm is O(M
                     +
                     N), where M and N are the sizes of operation trees [26]. By the edit distance algorithm, the distance of two interfaces is the minimum cost of adaption two corresponding sequences, and then following the Definition 5, the database distance is the aggregation of their interface distances.

In this paper, we proposed the approach of “measuring conversion cost of two database interfaces”. Interfaces of key-value stores are distinctive, so developers have to understand many interface formats to access key-value stores, which turns to be inefficient and tedious. The conversion cost measures the difficulty of interface adaptation crossing multiple databases essentially, and there are many potential scenarios in which the conversion cost helps to make a decision.

The proposed approach, on one hand, acts as an effective way to quantify the interoperability among databases. Clients will benefit from taking the interoperability of databases into consideration when they choose database as a service or evaluate the complexity of operations over databases. The dependency of application on databases, which is a quantity indicating the portability and compatibility of applications, can also be measured as the conversion cost of data access interfaces and database interface.

On the other hand, the proposed approach provides guidance for the interface design and improves the interoperations of databases. It benefits the database vendor or service provider to design their compatible interfaces because of which are competitive in the market. The programmer will be inspired to implement the query driven data integration with an interface that takes the lower costs to interact with key-value stores. It also provides guidance for standard interfaces of data access in a big corporation which employs heterogeneous key-value stores, or even an interface specification of key-value stores which may be treated as equivalent as a SQL specification of relational databases. Furthermore, nowadays lots of cloud services such as PaaS, IaaS and DaaS provide a RESTful interface. We can generalize the proposed approach to measure interoperability over any systems with RESTful interfaces.

To users of database, if they introduce a new database to applications with heterogeneous databases environment, it is better to check the interoperability of each candidate and choose the one whose interfaces mostly compatible with those of the existing databases, thus there is less effort to adapt the data access procedure to the selected database.

To users of applications, it is necessary to evaluate applications' dependency on databases. Strong dependency may lead to the problem of vendor lock-in, lower reusability and compatibility, and difficult to migrate to other databases. In this case, the conversion cost model quantifies the database dependency of applications.

To developers of applications, they can easily estimate the efforts of implementing the applications with the heterogeneous databases, such as query-driven data integration. Conversion cost model is also helpful to design the data access layer of such applications by estimating whether the data access interface is compatible with the interfaces of heterogeneous databases.

To providers of database services, it is more competitive in the market if the new service is more compatible with the well-known one. Therefore, the service providers use the conversion cost model to estimate the interoperability of new interface.

To designers of specification, the database interface specification is a set of interfaces aimed at providing a uniform data access for clients, for example, a data access specification across the enterprise. During the design of uniform interface, we need to consider all interfaces of existing databases. Conversion cost model helps to find the optimal interface that interacts with databases efficiently.

In this paper, the proposed interface description model and algorithms have been applied successfully to the “specification on interfaces of key-value stores” in China through estimating the interoperability of each interface defined in the specification. For database vendors who tend to provide their own particular interfaces rather than unified interfaces, data migration among different databases is laborious. This specification is aimed at providing a set of referred interfaces for the interaction of data management service in key-value stores. It is convenient for users to choose the database service which meets their requirements and migrates data seamlessly from one database to another. It can also provide reference during the design for interfaces of new database.

Notice that, the specification is a set of reference rather than ones that must completely accept. Currently, the existent key-value stores likely will not change their interface to the specification. The proposed specification provides guidance for the design of new service interfaces with better interoperability. And the specification is not an exclusive one and does not allow extra operations. The interface prototypes defined in the specification are guidelines to achieve efficient service with high interoperability, and key-value stores could extend the prototype according to their own requirements.

We have studied many widely used key-value stores in different categories, such as HBase, SimpleDB, MongoDB and so on, and evaluated interoperability of each key-value store according to interface description model. The interface specification should take the conversion cost of existing database interfaces to it into consideration since such consideration is not the only but a necessary one. We propose a prototype of specification by finding or defining the database interfaces whose distances to the other databases are minimum. Considering key-value stores in different architectures may provide some particular operations, for example, “retrieve region information” in HBase and “documents related operations” in CouchDB. It is hard to find potentially matched operations in another database. Besides, the conversion cost model cannot measure the operation without RESTful interfaces, for example, operations in Cassandra. So in the Prototype we only consider and define seven operations on data access. They are Create Table, Delete Table, List Tables
                     , 
                     Query Metadata, Insert Data, Delete Data and Query Data. The Create Tables, Delete Table, List Table and Query Metadata are table-level operations, and the rest are row-level operations. These seven operations defined in the prototype are common and frequently used in most of key-value stores and involve both table-level operations and row-level operations. It is easy to find these interfaces' counterparts in other stores, which makes it feasible to evaluate the interoperability of a given key-value store. We verify the efficiency of Prototype with experiments in the next section. Table 1
                      shows the comparison of HBase, CouchDB and Prototype on List Tables operation. The full version could be accessed via [6].

Besides, database is also adopted to evaluate the interoperability of a key-value store. Lower database distance means better interoperability. In the case that heterogeneous key-value stores exist in the same system for diverse requirements and performance guarantees, users may select the most qualified key-value store from alternatives according to the database distance. The complexity of mediator-based data integration and ETL process in data warehouse will also decrease through IDM and database distance.

@&#EXPERIMENTS@&#

In this section, we plan several experiments to evaluate the IDM and algorithms. Firstly, we verify the validity of our quantification algorithm on conversion cost by comparing it with true cost and costs calculated by two similar algorithms. Then, we evaluate the distance among the Prototype and five typical, widely used key-value stores. All quantification algorithms are implemented in Java 6 and the whole process of adaption is executed on an Intel i5–2300 2.80Ghz Windows 7 Professional workstation, equipped with 8GB RAM.

In this section, for the purpose of verifying the distance quantification algorithm proposed in this paper, we have implemented other two similarity evaluating algorithms on hierarchical data, then we calculate the distance of corresponding operations in two key-value stores respectively, and aggregate all interface distances as the global measurement. Nierman et al. proposed the algorithm to evaluate structural similarity of XML documents which derive from the same DTD but have distinct structures. The similarity calculation is mainly based on two kinds of operations: insert and delete, which are performed on a single node or an entire sub-tree [18]. Zhang et al. proposed the algorithm that adopts editing distance to describe the similarity of two unordered labeled trees. It applies dynamic programming to find global minimum cost mappings [25]. We also implement the program for converting two interfaces. The true distance of two interfaces, which is time consumption of conversion program, is also compared.

The experiment is performed on MongoDB and CouchDB, and seven basic operations, Create Table, Delete Tables, List Table, Query Metadata, Insert Data, Delete Data, and Query Data are measured. The distances calculated by four approaches have difficult dimensions and ranges. For comparing easily, the conversion cost of Delete Table is treated as one unit, and the other distances are normalized to the ratio of which. The results are shown in Fig. 7
                        .

In Fig. 7, the distances calculated by three algorithms are basically consistent with the true distance. Distances of Create Table and Query Metadata are relatively larger than those of other operations because the metadata of different key-value stores are various, and the messages required in requests and responses are various too, then the conversion is costly. The distance of Delete Table is smallest because no extra parameter is required but a table name. However, distances calculated by IDM match the true distance better than distances calculated by Nierman or Zhang's algorithm. Take List Tables and Insert Data as an example, the List Tables cost less than Insert Data operation according to IDM algorithm, but from Andrew's point of view, the conclusion is opposite. The relationship between true distances and measured distances should stratify: (1) Positively correlation. It means the latter accords with the former, and measurement is basically right; (2) Linear relationship. It means the latter is proportionally equal to the former, and measurement is accurate. As described in the Fig. 8
                         in the paper, true distances and measured distances are all positively correlated. Subsequently, we define that the algorithm whose measured distances have the strongest linear relationship with the true distances is the best. Fig. 8 shows the linear relationship between distances of algorithms and true distances (microsecond).

According to data points in Fig. 8, the linear relationship between IDM distances and true distances are the strongest. Pearson Coefficient, which reflects the linear relationship of two variables, is also listed in Fig. 8. The proposed IDM is better than Nierman and Zhang's algorithm since it matches the true distances well.

To evaluate the Prototype proposed in Section 6, several widely used key-value stores are required to make comparisons. We have studied lots of interface of key-value stores. When evaluating interface specification, it is better to analyze as many key-value stores as possible to make the specification more representative. However, for abbreviating only five typical key-value stores in different categories are selected to compare the distance between interfaces for the same operation in the paper. They are HBase, Riak, SimpleDB, CouchDB and MongoDB. These stores all follow the key-value data model to access data, but their storage models are various. HBase and SimpleDB represent data as columns, MongoDB and SimpleDB represent data as documents, and Riak of three represent data as tuples. They all provide RESTful interfaces. Table 2
                         summarizes the seven basic operations in the selected key-value stores. According to Table 2, these stores tend to use different naming approaches even for operations with same semantic. Riak does not provide a full support for the seven basic operations, and MongoDB adopts a third party RESTFul API [27]. Both interface distance and database distance are compared. However, key-value store may have defined some distinctive operations that cannot match the corresponding one in other key-value stores, in that case applying the quantification algorithm is meaningless. So only seven basic operations, Create Table, Delete Table, List Tables
                        , 
                        Query Metadata, Insert Data, Delete Data and Query Data are considered in experiments.

Several widely used key-value stores are evaluated in this section through conversion cost quantification algorithm and the distances represent interoperability of key-value stores. Fig. 9
                         shows the details on all evaluated key-value stores for these seven basic operations. As Riak does not provide RESTful interfaces for Create Container and Delete Container operations, no distance on Riak is listed in corresponding operations.


                        Fig. 9-a shows the distances among each corresponding operation in key-values stores by a matrix of polygons. Then row and column positions of each polygon stand for the name of two databases, and in each polygon the indexes 1 to 7 represent seven operations. Fig. 9-b shows the average database distances which are results of averaging the database distances between the evaluated database and other databases available in the experiment environment (see Eq. (2)). Legends for operations in each polygon is shown in Fig. 9-c. According to Fig. 9-c, the operation with low distance, compared between two databases, turns to have better interoperability. Firstly, for each database, distances among Query Metadata are generally larger than distances among other operations because different databases have different forms of metadata; while distances among delete operations, including Delete Table and Delete Data, are smaller than those among other operations because delete operations have the simplest interfaces in both request and response. Secondly, the distances among row-level operations are generally smaller than those among table-level operations because the former are designed according to the logic data models which are similar, and the latter are designed according to the architectures which are various. Thirdly, in the Fig. 9-b, the average database distance of CouchDB is the least among the key-value stores, so it means the interoperability of CouchDB is better. But the proposed interfaces, named as Prototype, whose database distance is less than CouchDB, so that our design meets the requirement well. Since the Prototype is not a real database but an interface definition, it is treated as a specification and reference. Lastly, in our experiment, Riak does not provide full support of RESTful interfaces for its operations, and SimpleDB and HBase have poor interoperability. Our Prototype has the best interoperability. Since it is possible that other key-value stores which are not included in the experiment may get better results, however, the current experiments prove that the proposed model and algorithm are effective.

The prototype is designed to be the only one whose conversion cost is the minimum to the rest data stores. We plan to prove the effectiveness of prototype so that the one with the best interoperability is chosen in our experiment. We define the average distance of an operation in a database is average value of five distances between the operation in the given database to all the corresponding operations in the other five databases. We compare seven average distances in Prototype with those in other five databases, and the results are shown in Fig. 10
                        . There is a merged radar chart, which represents the comparisons among Prototype and five key-value stores. A radar chart is a graphical method of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes starting from the same point. The relative position and angle of the axes are uninformative. It consists of seven equi-angular spokes, with each spoke representing one of seven operations. The data point of each spoke represents the average distance of specified operation in one of key-value stores or Prototype. The closer to the left a data point is, the higher distance of corresponding database on specified operation gets, and the worse interoperability it achieves. Six lines, which are Prototype and five key-value stores, are drawn connecting the data values (average distances) for each spoke (operation). A connected line is star-like appearance, and each star represents a database. Take Prototype and HBase as an example, the average distance of every operation in Prototype is smaller than that in HBase because the HBase star is in the Prototype star. It is also easy to compare the interoperability of every operation in HBase and Prototype. The sharps of Prototype star and HBase star are similar, which means the interoperability of operations in HBase and Prototype is dominated by their functionalities, and optimized by interface structures. The same results could also be drawn by other stars. Especially, the Prototype star almost overlaps CouchDB star, and Riak line is not a closed loop because two operations are undefined.

In Fig. 10, the average distance of every operation in Prototype is close to that in CouchDB, and the slight improvement of Prototype is achieved through removing specific elements and parameters of interfaces. Compared with other key-value stores, such as HBase, SimpleDB and MongoDB, Prototype has the best distance of each operation.

In this paper, we study the conversion cost and specification on interfaces of key-value stores. Considering key-value stores tend to define their own interfaces and the same semantics may have different representations, the interoperability between them is poor without defining an interface specification. The conversion cost between two interfaces is not only but an important consideration when an interface specification is defined, otherwise the existing databases are too hard to follow the specification. Based on this idea, we propose an interface characteristic model and a quantification algorithm to describe interfaces and quantify the interface conversion cost, also named as distance, when interacting with other databases, respectively. Our works are as follows: (1) abstracting characteristics of an interface and model them into an operation tree; (2) re-ordering the operation tree; (3) calculating the distance of two interfaces based on re-ordered edit graph; (4) designing a prototype interfaces as a reference of the interface specification; (5) explaining the interface model and quantification algorithm also contribute to evaluating the interoperability of any RESTful interface based systems; (6) verifying proposed distance quantification algorithm through comparing our distance with true distance and distances calculated by other two algorithms, and then comparing the interoperability of proposed Prototype with five typical key-value stores.

In the future, we will optimize the IDM and quantification algorithm to make them support the RESTless interfaces, such as command based or programing based interface; and one-to-many interface conversion.

@&#ACKNOWLEDGEMENTS@&#

Supported by the National Natural Science Foundation of China under Grant No. 61433008 and 61502090; the Natural Science Foundation of Liaoning Province under Grant No.201403314; the Science Foundation of China Post-doctor under Grant No. 2013M540232.

@&#REFERENCES@&#

