@&#MAIN-TITLE@&#Geometry curves: A compact representation for 3D shapes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel surface representation, called geometry curves.


                        
                        
                           
                           Geometry curves capture the essence of the shape geometry and topology compactly.


                        
                        
                           
                           For the geometry, we extract feature lines of shapes based on the mean curvature.


                        
                        
                           
                           For the topology, we record the fundamental polygons of shapes.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Geometry curve

Feature line

Fundamental polygon

Compression

Shape editing

@&#ABSTRACT@&#


               
               
                  We propose a novel compact surface representation, namely geometry curves, which record the essence of shape geometry and topology. The geometry curves mainly contain two parts: the interior and boundary lines. The interior lines, which correspond to the feature lines, record the geometry information of the 3D shapes; the boundary lines, which correspond to the boundary or fundamental polygons, record the topology information of the 3D shapes. As a vector representation, geometry curves can depict highly complex geometry details. The concept of geometry curves can be utilized in many potential applications, e.g., mesh compression, shape modeling and editing, animation, and level of details. Furthermore, we develop a procedure for automatically constructing geometry curves which obtain an excellent approximation to the original mesh.
               
            

@&#INTRODUCTION@&#

In the traditional areas of computer aided geometry design, shape representation and geometry analysis are the main research directions. These research directions originated from industry applications, e.g., the ship lofting and aircraft design. For the shape representation, Non-Uniform Rational B-Splines (NURBS) and implicit algebraic surfaces [1] are generally used and describe smooth surfaces well. In the 1990s, taking advantage of 3D laser scanners, people became capable of acquiring digital models with more details. The main representation of scan models is in the form of the triangular mesh, which discretely approximates to the original surface. The triangular mesh has two main advantages. First, it represents the models in a more detailed way; second, it provides a more direct mapping to the hardware devices used for rendering. However, this representation also has two obvious disadvantages. One is that it requires more storage space when representing models with more details. The other is that it is a type of low level representation, which is closer to hardware rendering devices, but farther away from human perception of shapes.

The most important characteristics of 3D models are their geometry and topology. For the mesh representation, the geometry information is computed from the vertex’s position, and the topology information can be computed from the mesh connectivity. Isenburg et al. [2] introduce the concept of the connectivity shape that is based solely on mesh connectivity. They describe its natural geometry as a smooth embedding in space with uniform edge lengths. However, this representation depends on the mesh tessellation, and since two different shapes may have the same mesh tessellation, some information about the geometry is lost. Sorkine et al. [3] introduce the least-squares mesh as the shape representation, which contains a set of control points with a prescribed connectivity. Control points are selected based on the geometry and contain some geometry information, but generally do not coincide with important parts as selected by humans. Cole et al. [4] suggest that viewers interpret the shaded shape and the line drawn version very similarly, suggesting that feature lines can express shape information effectively. Cole et al. [5] indicate that line drawings based on differential properties of the underlying surface can be as effective in depicting shape as drawings made by artists. Therefore, the mathematical feature lines can depict shape geometry effectively, which inspires us that the shape geometry can be recorded in feature lines. Furthermore, we observe that surfaces can be reconstructed using the feature lines’ positions and mean curvatures. More precisely, the feature lines record the geometric contour of shapes, and the mean curvatures record the details of shapes. We present a novel algorithm to extract feature lines based on the variation of the mean curvature, which not only record the shape contour, but also record the mean curvature of the shape.

Another important characteristic of shapes is their topology, which describes the structure of shapes. It is well known that closed orientable surface can be classified by its genus, thus the genus is the inherent property of the shape’s topology. We can record fundamental polygons in the boundary geometry curve, and discard the mesh connectivity which is not inherent in topology.

In this paper, we propose a novel compact surface representation, namely geometry curves, which allow easy and intuitive manipulations of the shape (Fig. 1
                     ). This representation records the essence of shape geometry and topology. For the geometry, we design a novel algorithm to extract the feature lines of the shape, and record the positions and mean curvatures on their two sides. For the topology, we record fundamental polygons of the shape.

The main contribution of this paper is the idea of introducing geometry curves as the surface representation, which can be utilized in many potential applications, e.g., shape compression, shape deformation, animation, feature preserving smoothing and simplification.

@&#RELATED WORK@&#

Numerous algorithms for extracting feature lines from smooth surfaces exist in the literature. A classical approach is the Canny operator [6], which is a low level operator and difficult to extract integrated lines from surfaces. Ridge-valley lines [7] define the feature lines based on the extrema of the principal curvatures along their curvature directions. This algorithm is close to our requirement, but still cannot satisfy our requirement that mean curvatures need to be diffused from feature lines to approximate the original ones. Cole et al. [5] conclude that most of the lines drawn by artists can be explained by currently known definitions. Moreover, Cole et al. [4] suggest that line drawings based on these definitions can successfully depict shapes. There are also view dependent algorithms. Hertzmann et al. [8] introduce silhouette lines based on geometric duality. However, silhouette lines alone are quite limited in conveying geometric details of the shape interior. DeCarlo et al. [9] propose suggestive contours which extend contours and ceases. Based on the variation of shading, Judd et al. [10] introduce apparent ridges which generalize ridge-valley lines in a view dependent manner. Xie et al. [11] propose photic extremum lines which generalize the Canny operator to 3D surfaces. Inspired by the Laplacian-of-Gaussian edge detector in image processing, Zhang et al. [12] define Laplacian lines on 3D surfaces, which interactively illustrate large scale models efficiently. Since our feature lines do not need view dependent properties, these algorithms also cannot satisfy our requirement.

There are numerous shape representations, only the works which are very relevant to ours are discussed. Lee et al. [13] introduce the displaced subdivision surface, which represents a detailed surface model as a scalar-valued displacement over a smooth domain surface. Unfortunately, the extraction of the domain mesh is still a challenging problem. Guskov et al. [14] define the normal mesh as a multi-resolution mesh where each level can be written as a normal offset from a coarser version. Isenburg et al. [2] visualize the connectivity graph of a mesh using the connectivity shape that is based solely on mesh connectivity. However, the geometry has been lost. Sorkine et al. [3] introduce the least-squares mesh, which approximates a set of control points with a prescribed connectivity in a least-square sense. The least-squares mesh has zero mean curvature on the free points, therefore it approximates a minimal surface in essence. Gu et al. [15] introduce the geometry image to record geometry as a simple 2D array of quantized points. Surface signals like normals and colors are stored in similar 2D arrays using the same surface parametrization. However, due to the fixed parametrization boundary, models of high genus may produce high distortions. There are some shape representations which record the surface details based on the differential coordinate [16,17]. Li et al. [18] introduce the arterial snake model to represent the detailed and interleaving structure, but this model is limited to tubular objects. Liu et al. [19] propose a spectral method to compress the geometric shapes. This method decomposes a mesh into two components: the harmonic and the Dirichlet components. The harmonic component is similar to the least-squares mesh, which is reconstructed by diffusing positions from the boundary and feature lines. The Dirichlet component is reconstructed by applying spectral shape analysis, which adds details to the harmonic component. Since the calculation of the Dirichlet manifold harmonics basis is based on the mesh connectivity, the original mesh must be resampled, and user-specified feature lines are needed to preserve salient features. In our method, the mean curvature information records the details of the surface, and the feature lines are extracted automatically based on the variation of the mean curvature, without the need for user interactions. Bessmeltsev et al. [20] propose a design-driven approach for the quadrangulation of closed 3D curves created by sketch-based systems. Since it lacks global context for the topology information, the ambiguous situation always exists.

It is well known that vector graphics is often limited to represent complex color gradients. Sun et al. [21] introduce the gradient mesh to represent vector images, in which the colors over the mesh face are interpolated by the user specified values on the vertices of a quad mesh. However, it is difficult to create the gradient mesh, since it requires a skillful and patient user. Orzan et al. [22] represent an image by vectorizing edges and sampling curve attributes (e.g., colors, blur values), which is based on the fact that most color variations in an image can be assumed to be caused by edges. Finch et al. [23] extend diffusion curves and explore a higher-order fairing technique to enable more natural interpolation and greater expressive control. Jeschke et al. [24] use the diffusion curves to represent texture images. This technique can preserve sharp edges when the textures map onto the surface. Takayama et al. [25] introduce diffusion surfaces to represent volumes, which is an extension of diffusion curves to 3D case. Hnaidi et al. [26] use the diffusion curve technique to generate terrains. Since the terrain and image can be viewed as height fields, there is no essential difference between them. Unlike representing the volume or terrain, we cannot easily use diffusion curves to represent the surface. Since surfaces do not have the common domain, we cannot reconstruct the shape by simply diffusing positions from feature lines.

In this section, we will describe the representation of geometry curves. Then we will propose an algorithm to recover the surfaces from geometry curves. Finally, the automatic generation of geometry curves will be discussed.

Geometry curves are 2D curves (Fig. 2
                         left), which contain two parts: the interior lines {ci
                        } and boundary lines {bi
                        }. The interior lines, which correspond to feature lines, record the geometry information; the boundary lines, which correspond to the boundary or fundamental polygons, record the topology information. Each geometry curve gi
                         is defined as a cubic B-spline specified by a set of control points (Fig. 2 right). It is associated with the 3D position x of the curves and mean curvatures on both sides {hc,l
                        ,
                        hc,r
                        }. If gi
                         is a boundary line, it is associated with the mean curvature on one side only. Note that the mean curvatures {hc,l
                        ,
                        hc,r
                        } on each side might be different. Thus we diffuse the mean curvatures on each side of the feature lines instead of across them.

Geometry curves are continuous forms of surface representation. We would like to transform them into a discrete form, e.g., triangular mesh, which facilitates rendering (Fig. 3
                        ).


                        Discretizing geometry curves: Geometry curves are represented as cubic B-splines. We have to discretize the curves into discrete points and line segments for the calculation purpose. More precisely, we sample the curves uniformly based on some user specified sampling density, and reconstruct the curves by connecting the samples with line segments.


                        Constructing triangular mesh connectivity: The triangular mesh consists of two main parts: vertex positions and mesh connectivity. We first construct a triangular mesh in the 2D plane, and then use it as the mesh connectivity. This can be done by applying the constrained Delaunay triangulation method [27]. Using the sampled geometry curves as constraints, user can choose some vertex sampling method, which depends on the applications and users, to construct the vertices. Here, we choose the uniform sampling method. Finally, we fuse the mesh boundary based on the fundamental polygon information.


                        Diffusing mean curvature from geometry curves: Besides the mesh connectivity, we also have the mean curvature constraints on two sides of the interior curves and one side of the boundary curve. We observe that the feature lines capture the major changes of the mean curvature, thus the changing rate of the mean curvature in the other regions would be as uniform as possible. Harmonic function has the property that it makes the gradient of mean curvature as constant as possible. More precisely, the changing rate should be as uniform as possible. Thus we can use a harmonic function to approximate the mean curvature. Inspired from diffusion curves [22], we diffuse the mean curvatures to the entire mesh by solving a Poisson equation:
                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Δ
                                                   H
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                   =
                                                   0
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                   )
                                                   =
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         c
                                                         ,
                                                         s
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 s
                                 =
                                 lorr
                              
                           
                        where Δ is the uniform Laplacian operator, and hc
                        
                        ,
                        
                           s
                         is the mean curvature on one side of the geometry curves (s
                        =
                        l or r). vc
                         denotes the vertices on geometry curves and vu
                         denotes the other vertices.


                        Fig. 4
                        a shows a discrete form of geometry curves. The green vertices on the geometry curves have known mean curvature values with them, and the other black vertices have unknown mean curvatures. Since the interior geometry curves are associated with mean curvatures on both sides, we can duplicate the vertices and think of it as a virtual hole as shown in Fig. 4c. Note that the mean curvatures on each side of the geometry curve are different: hl
                         on the left side and hr
                         on the right side. The exception is that the end points (the blue vertices in Fig. 4c) of interior geometry curves only have one mean curvature value. Thus we have mean curvatures on the boundary of each virtual hole. This is actually a regular linear system, and can be solved efficiently.


                        Reconstructing the surface by Poisson equation: So far, we have the mean curvatures on the entire mesh, and the position constraints on the geometry curves. Thus we can reconstruct the surface by solving the equation:
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   LX
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                   =
                                                   2
                                                   AHN
                                                
                                             
                                             
                                                
                                                   X
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                   )
                                                   =
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where L is the cotangent Laplacian operator, X is the vertex position, A is 1/3 of the one ring neighborhood area, H is the mean curvature on the vertex, N is the vertex normal, xc
                         is the vertex position constraint on the geometry curves, vc
                         is the vertex on geometry curves and vu
                         is the other vertex.


                        
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             Algorithm 1
                                          : Solving Eq. (2)
                                       
                                    
                                 
                                 
                                    
                                       Given the mesh connectivity C, mean curvature H on the entire mesh and position constraint xc
                                           on the geometry curves.
                                    
                                    
                                       
                                          
                                             Step 1
                                          : Make H equal to zero.
                                    
                                    
                                       
                                          
                                             Step 2
                                          : Use the uniform Laplacian operator to get a least-squares mesh.
                                    
                                    
                                       
                                          
                                             Step 3
                                          : Update A, N and cotangent Laplacian operator L.
                                    
                                    
                                       
                                          
                                             Step 4
                                          : Solve Eq. (2) using H obtained from Eq. (1) and A,
                                          N,
                                          L obtained from Step 3, and then update mesh.
                                    
                                    
                                       
                                          
                                             Step 5
                                          : Iterate step 3 and step 4 until the mesh does not change.
                                    
                                 
                              
                           
                        This is a highly nonlinear equation, which we address in an iterative approach (see Algorithm 1): First, we make all the mean curvatures equal to zero, and then we use the uniform Laplacian operator to obtain a least-squares mesh. After that we calculate the cotangent Laplacian operator, A and N using current mesh information. The equations become linear now, and can be solved efficiently. We repeat these steps iteratively until the result converges. Since our geometry curves record the major geometric features, we have a good initial mesh for the iterative method. Generally, we can obtain the converged result in only 2 or 3 iterations (Fig. 5
                        ).

Automatically converting surfaces to geometry curves is challenging, since surfaces often contain a wealth of details, and there is no common domain for all the surfaces. We observe that topology is inherent in the surface structure, thus we can classify the surface structure by its genus. More precisely, we can record surface topology in the form of fundamental polygons, and discard the mesh connectivity which is not inherent in topology. For the geometry, the mean curvature depicts the details of the surface. In order to obtain the mean curvatures for the entire surface, we have to diffuse them from feature lines. Since traditional feature lines are oblivious to this property (Fig. 6
                      left), we have to develop a novel algorithm to extract feature lines, which reveal significant variations of the mean curvature. The feature lines defined by our method are proved to record the inherent geometry well (Fig. 6 right).

Here is our geometry curve generation procedure overview (Fig. 7
                     ). Starting from the orientable mesh R, we first estimate its mean curvature H. Next, we calculate the gradient G of the mean curvature H. Since we would like to obtain the mean curvatures for the entire mesh by diffusing them from feature lines, we extract the feature lines based on the gradient G. More precisely, we define the feature lines as the magnitude extrema of the gradient G along their corresponding directions. Once we get the feature lines, we apply an optimization to calculate the mean curvatures on their two sides. This gives us the geometric data for the shape. Next, we record the topology of mesh R in the form of fundamental polygons. First, we cut the mesh into disk topology, and then map the mesh onto the plane using a shape-preserving parameterization method. The cut edges record the fundamental polygons, which are mapped to the boundary of the corresponding 2D mesh. The 3D feature lines are also mapped onto the 2D plane. Finally, we use cubic B-splines to fit the discrete curves, resulting in continuous geometry curves. We define the 2D feature lines and fundamental polygons as geometry curves.

Our feature lines record both the geometry contour of the surface and major changes of the mean curvature. It can be observed that the lines along the extrema of the mean curvature gradient satisfy our requirement.


                        Discrete mean curvature: There are two possible ways to calculate the mean curvature: the discrete and continuous methods. Since we want to recover the surface from Eq. (2), we use the discrete method, and find it very stable. We define the mean curvature normal as:
                           
                              (3)
                              
                                 
                                    
                                       H
                                    
                                    
                                       →
                                    
                                 
                                 =
                                 H
                                 ·
                                 N
                                 =
                                 
                                    
                                       A
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 LX
                                 /
                                 2
                              
                           
                        where H is the mean curvature, N is the vertex normal, L is the cotangent Laplacian operator and A is 1/3 of the one ring neighborhood area. The mean curvature is the second order of the differential quantity. In practice, the estimation of the mean curvature based on Eq. (3) is sensitive to noise. For the models without much noise, as shown in Fig. 8
                        , the estimation of the mean curvature is fine for our application. For noisy mesh data, we adopt a multi-resolution approach to make the estimation robust to noise: after calculating the mean curvature, we smooth the surface a little [28]. We repeat this calculation 3 times, and make the mean curvature as the average value. The computation of mean curvature based on the multi-resolution approach is independent of the density of the mesh (Fig. 8) [28].


                        Mean curvature gradient: The discrete mean curvature is a piecewise linear scalar field. Every vertex has a value, and the value on the face is interpolated as defined below:
                           
                              
                                 H
                                 (
                                 v
                                 )
                                 =
                                 
                                    
                                       Φ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 v
                                 )
                                 ·
                                 H
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       Φ
                                    
                                    
                                       j
                                    
                                 
                                 (
                                 v
                                 )
                                 ·
                                 H
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       Φ
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 v
                                 )
                                 ·
                                 H
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       k
                                    
                                 
                                 )
                              
                           
                        where vi
                        ,
                        vj
                        ,
                        vk
                         are the neighborhood vertices of the face and Φ is a linear function:
                           
                              (4)
                              
                                 
                                    
                                       Φ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       δ
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                   i
                                                   =
                                                   j
                                                
                                             
                                             
                                                
                                                   0
                                                   ,
                                                   i
                                                   ≠
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Thus every face has a constant gradient:
                           
                              (5)
                              
                                 
                                    
                                       G
                                    
                                    
                                       →
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                                 ∇
                                 
                                    
                                       Φ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 v
                                 )
                                 ·
                                 H
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                       A
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          3
                                       
                                    
                                 
                                 H
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 N
                                 ×
                                 E
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           
                        where A is the face area, N is the unit face normal, E(vi
                        ) is the edge vector across from vi
                        . We define the magnitude of the gradient as Gm
                        , and its direction as 
                           
                              
                                 
                                    
                                       
                                          G
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    d
                                 
                              
                           
                        . The gradient of each vertex is defined by averaging the gradients of its neighborhood faces.


                        Feature vertex detection: We define the feature vertex as the extrema of the gradient’s magnitude Gm
                         along its corresponding direction 
                           
                              
                                 
                                    
                                       
                                          G
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    d
                                 
                              
                           
                        . Considering the derivatives of Gm
                         along 
                           
                              
                                 
                                    
                                       
                                          G
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    d
                                 
                              
                           
                        , we define 
                           
                              e
                              =
                              ∂
                              
                                 
                                    G
                                 
                                 
                                    m
                                 
                              
                              /
                              ∂
                              
                                 
                                    
                                       
                                          G
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    d
                                 
                              
                              =
                              ∇
                              
                                 
                                    G
                                 
                                 
                                    m
                                 
                              
                              ·
                              
                                 
                                    
                                       
                                          G
                                       
                                       
                                          →
                                       
                                    
                                 
                                 
                                    d
                                 
                              
                           
                         The calculation of ∇Gm
                         is the same as calculating the gradient of H. Next, we check the following conditions for every mesh edge [vi
                        ,
                        vj
                        ]:
                           
                              (6)
                              
                                 e
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 e
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 <
                                 0
                              
                           
                        This verifies whether e has a zero-crossing on [vi
                        ,
                        vj
                        ]. Finally, we apply a simple derivative test to determine whether e attains a maximum on [vi
                        ,
                        vj
                        ]:
                           
                              (7)
                              
                                 e
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 [
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ·
                                 
                                    
                                       
                                          
                                             G
                                          
                                          
                                             →
                                          
                                       
                                    
                                    
                                       d
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ]
                                 >
                                 0
                              
                           
                        If Eqs. (6) and (7) are satisfied, we use a linear interpolation to approximate the zero-crossing of e on [vi
                        ,
                        vj
                        ]:
                           
                              (8)
                              
                                 P
                                 =
                                 
                                    
                                       |
                                       e
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       |
                                       ·
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       +
                                       |
                                       e
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       |
                                       ·
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                    
                                    
                                       |
                                       e
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       |
                                       +
                                       |
                                       e
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       |
                                    
                                 
                              
                           
                        We define p as a feature vertex.


                        Tracing feature lines: We traverse all the faces of the mesh. If two feature vertices are detected on edges of the same face, we connect them by a line segment. If there are three feature vertices on the same face, we connect them to the centroid of the face.


                        Weights adjustment: We measure the weight of a feature line by the integral of Gm
                         along the line. We can ignore the lines whose weights are less than a threshold T (generally T
                        =1.5, and all the models in our paper are uniformly scaled in the range [−1,1]).


                        Feature lines’ attributes: Every feature line has two attributes: the vertex position and mean curvature on its two sides. The mean curvature attribute needs to be optimized so that it can be diffused to recover the original mean curvatures. We apply an optimization to get the mean curvatures on both sides of the feature lines. In particular, only one side of the boundary lines has mean curvatures:
                           
                              (9)
                              
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             h
                                          
                                          
                                             c
                                          
                                       
                                    
                                 
                                 
                                    ∑
                                 
                                 ‖
                                 
                                    
                                       H
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 -
                                 
                                    
                                       H
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 ‖
                              
                           
                        such that
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         LH
                                                      
                                                      
                                                         r
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                   =
                                                   0
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         r
                                                         ,
                                                         s
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         c
                                                      
                                                   
                                                   )
                                                   =
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         c
                                                         ,
                                                         s
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 s
                                 =
                                 lorr
                              
                           
                        where L is the uniform Laplacian operator, hc
                        
                        ,
                        
                           s
                         is the mean curvature on one side of the feature line (s
                        =
                        l or r), Ho
                         is the original mean curvature, vc
                         is the vertex on the feature line and vu
                         is other vertex. We formulize the optimization as the following minimization problem by considering (10) as soft constraints in (9):
                           
                              (11)
                              
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             h
                                          
                                          
                                             c
                                          
                                       
                                    
                                 
                                 
                                    ∑
                                 
                                 (
                                 ‖
                                 
                                    
                                       H
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 -
                                 
                                    
                                       H
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 ‖
                                 +
                                 w
                                 ‖
                                 
                                    
                                       LH
                                    
                                    
                                       r
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                                 )
                                 ‖
                                 )
                              
                           
                        where w is a weight for balancing the two terms. The minimization can be optimized by solving a sparse linear system. Generally, we set w
                        =1000. By means of the Green function in Eq. (10), Hr
                         can be expressed explicitly in terms of the boundary constraints, and then added to Eq. (9) for the optimization. Readers who are interested in it can refer to the paper [29] for details.

We now describe how we record the surface topology. If the surface is closed, we have to cut it into disk topology for parameterization [30–33]. In our procedure, we first cut the mesh into disk topology, and then record the fundamental polygons. Finally, we map the mesh onto a plane using a shape-preserving parameterization method. The cuts become the boundary of the 2D mesh, and contain the entire topology information. Thus the mesh topology can be recovered from the 2D fundamental polygons, and the mesh connectivity can be discarded.


                        Fundamental polygon: Every closed surface can be constructed from an even-sided oriented polygon in the sense of topology. We call this polygon a fundamental polygon [34]. An orientable closed surface of genus n can be viewed as a sphere gluing n tori together, and we can cut it step by step until getting a 4n-sided polygon, recorded as 
                           
                              
                                 
                                    A
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    1
                                 
                                 
                                    -
                                    1
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                                 
                                    -
                                    1
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    2
                                 
                                 
                                    -
                                    1
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                                 
                                    -
                                    1
                                 
                              
                              ⋯
                              
                                 
                                    A
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    n
                                 
                                 
                                    -
                                    1
                                 
                              
                              
                                 
                                    B
                                 
                                 
                                    n
                                 
                                 
                                    -
                                    1
                                 
                              
                           
                        , where AiBi
                         is a cut and the symbol −1 represents the opposite orientation (Fig. 9
                        ).


                        Parameterization: Finally, we map the mesh onto a plane using a shape-preserving parameterization method. Most of the existing parameterization methods first cut the mesh into disk topology, and then flatten it. In our method, the geometry curve representation is not sensitive to the boundary cuts, since the fundamental polygons can glue the boundary cuts. What should be considered is the mapping distortion. Since we want to diffuse the mean curvatures from the feature lines to recover the original values, being more isometric will lead to a better mapping. Specifically, the method [30] is adopted to cut the mesh into a disk-like piece. Then the as-rigid-as-possible (ARAP) parameterization method [36] is applied to flatten the open mesh to the 2D plane, where the ABF++ method [35] is used as an initial parameterization. This is a free boundary parameterization method with low angle and area distortions, which satisfies our requirement.


                        B-spline fitting: Feature lines consist of a sequence of vertices associated with the position and mean curvature information. To make it more compact, we represent the feature lines as B-splines. Specifically, we use the open source Potrace software [37]to convert the feature lines into B-spline curves.

@&#RESULTS@&#

We have tested our algorithm on a number of models. All of the examples presented in this paper were generated on a dual-core 3GHz machine with 4G memory.

When we reconstruct the surface from geometry curves, the mesh connectivity needs to be constructed first. In Fig. 10
                     , we show several different mesh tessellations for the surface recovering. We use the method described in Cignoni et al. [38] to measure the approximation error. The surface of the reconstructed mesh is first sampled uniformly. For each sampled point, we find its corresponding point on the original surface by means of the minimal distance. The L
                     2 approximation error is calculated as a percentage of the object bounding box. From the results of the third row, it can be concluded that the difference in mesh tessellations has little effect on the final results.

We have done an error analysis for the mean curvature and the recovered surface. In the third row of Fig. 11
                     , the approximation error of the recovered mean curvatures is shown by its absolute value. The more feature lines are used, the less the approximation error is. In the fourth row of Fig. 11, we have analyzed the approximation error of the recovered mesh. The last row is the approximation error of the recovered normal, which is measured by the normal vector angle. It can be noted that, although the feature lines are sparse, the approximation error is still low.

Mesh parameterization plays an important role in creating geometry curves. As we discussed before, since the mean curvatures are obtained by diffusing the values from feature lines, being more isometric will lead to better mapping. If the parameterization has high distortions, the distribution of mesh vertices may be non-uniform. Here we compare two different parameterization methods: the mean value coordinates [39] and the as-rigid-as-possible method [36]. It can be observed in Fig. 12
                      that the upper parameterization method has more distortions due to the fixed boundary mapping. The recovered mesh also has more distortions, and the distribution of the mesh vertices is non-uniform.


                     Fig. 13
                      illustrates the effect of different fundamental polygons on the recovered mesh. Fundamental polygons are recorded in cut edges, which are used for gluing the cuts on surfaces. Only the parameterization results will be affected by the cut edges. Thus if the distortion of the parameterization is low, the effect of different fundamental polygons on the recovered mesh will also be minor.

Eq. (2) is a highly nonlinear equation, and we solve it using an iterative approach. Generally it will converge after iterating 2 or 3 steps in all of our experiments. Since our geometry curves record the major features of the geometry, we have a good initial mesh to start the iterative method. However, if we deliberately remove the most of the position constraints on the feature lines, we cannot guarantee the iterations will converge. In Fig. 14
                     , most of the feature lines are removed, and the mean curvatures are maintained. It can be observed that the initial mesh is not good enough to guarantee the convergence of the iteration, especially for the head part, since there is no feature line there. After several iterations, the head part does not converge. This experiment also demonstrates that the functions of feature lines include not only recovering the mean curvatures, but also recording the main geometry of the shape.

We have listed the computation time in Table 1
                     . The computation time of the feature lines contains 4 parts: discrete mean curvatures, mean curvature gradients, feature vertex detection and feature line attributes. This module does not cost much time, but the computation of parameterization may cost a little more time. The main cost is the ABF++ parameterization [35], which is a nonlinear method, and may iterate several times to get the final result. For the module of reconstructing surfaces from geometry curves, the time cost is determined by the number of vertices. Although this is a nonlinear system, we generally iterate 2 or 3 steps to get the recovered mesh. In general, this is a highly efficient algorithm.

Our geometry curve representation is suitable for a variety of shapes: both open and closed surfaces under varying number of genus as shown in Figs. 11–13 and 15
                     . The human face model in Fig. 15 is an open surface, so we can map it onto a plane directly. For the closed surface, we cut it into disk topology. Since our geometry curve representation is based on the feature lines, our algorithm can tackle organic alike models, like the cat and vase models in Fig. 15. Our algorithm can also handle the CAD models, like the Fandisk model in Fig. 15. For high genus models shown in Figs. 11–13, our geometry curves can represent them with low distortions.

As a vector representation, geometry curves have many potential applications, e.g., mesh compression, shape modeling and editing, animation, mesh stylization and level of details. We will describe some major applications in the followings.


                        Mesh compression: It is quite tempting to investigate the potential of applying geometry curves in mesh compression, which has been an active area in computer graphics research for a long time. However, the existing literature has mainly targeted compressing the pure mesh data structure, not the essence of the shape information. In contrast, geometry curves record the two key parts of a shape: feature lines and fundamental polygons. For the geometry, there is no need to store every vertex position, since storing some sparse feature lines is sufficient. For the topology, we only need to store fundamental polygons. When recovering the surface, we can construct the mesh connectivity based on the application needs. We compare our approach with the OpenCTM algorithm [40], which is an open source project for compressing 3D triangular meshes. The compression is based on the lossless entropy reduction. We also compare our approach with the Dirichlet harmonic shape compression method [19], which applies the spectral shape analysis in the 2D parametric domain. This method provides a progressive compression mechanism to trade-off between bit-rate and shape quality. Since it needs some user specified feature lines, we use our feature line detection algorithm to obtain the same feature lines used in geometry curves. Table 2
                         shows the results of compression experiments. The original mesh is stored in the OBJ format file, and the error is in the L
                        2 approximation manner expressed as a percentage of the object bounding box. It can be observed that geometry curves obtain better compression rates while keeping low approximation errors. Furthermore, as a vector representation, the size of geometry curves will not increase with the number of vertices in the original mesh, but will increase with the geometry details.


                        Shape modeling and editing: Another interesting application is shape modeling and editing. Due to the natural curve representation, we can easily edit the shape in a semantic manner. Also, we can sculpt model surface details as shown in Fig. 16
                        : we draw some curves on the plane and assign the mean curvatures and position constraints to them. Crane et al. [41] provide a similar deformation UI. They specify deformations as painting a function on the surface in a sculpture manner, altering its curvature. Andrews et al. [42] also provide a curve editing UI, which specifies Cauchy constrains instead of curvature constrains. However these UIs are not intuitive for people who are unfamiliar with the concept of curvature and Cauchy constrains. Our approach exhibits the same problem. In the future work, we want to design an intuitive way for users to assign the curvature.


                        Level of details: It can be observed in Fig. 11 that, when more geometry curves are used, the recovered mesh has more details. Therefore, we can apply geometry curves in level of details. More details of this are included in the attached video.

We have presented a novel compact surface representation which records the essence of the shape and offers benefits in many aspects, such as mesh compression, shape modeling and editing, animation, mesh stylization and level of details. There are two key components in our surface representation. One is the novel definition of the feature line which not only records the geometry of the surface, but also records the mean curvatures. The other is the fundamental polygon which records the topology information. For the mesh connectivity, we can reconstruct it using fundamental polygons.

At present, we use the uniform sampling method to reconstruct the mesh connectivity. In the future work, some geometry aware sampling method will be considered. As a counterpart in vectorized images, our geometry curve is a vector representation for mesh surfaces. It is known that vector graphics can hardly represent complex images such as textures. For complex meshes with high-frequency details, we may need to use a large amount of curves to represent small structures, thus making the vector representation inefficient and difficult to manipulate. As a future work, we will investigate some other representation for small details.

@&#ACKNOWLEDGMENTS@&#

Thanks to the reviewers for their constructive comments. Thanks also to Andy Xia for the video voice recording, Shen Yu, Kun Liu, Haibin Huang and Stephen Giguere for helpful discussions. This work is supported by the National Natural Science Foundation of China (61070071, 61222206) and the National Basic Research Program of China (2011CB302400).

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.gmod.2013.05.001.


                     
                        
                           Supplementary video 1
                           
                              Geometry curves.
                           
                           
                        
                     
                  

