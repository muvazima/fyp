@&#MAIN-TITLE@&#Requirements for computational rule checking of requests for proposals (RFPs) for building designs in South Korea

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We analyze objects and methods required for checking automated design compliance.


                        
                        
                           
                           We analyze 27 RFPs for various types of large public buildings in South Korea.


                        
                        
                           
                           Only 14% of over 9800 RFP sentences are analyzed as being computer-interpretable.


                        
                        
                           
                           Three types of objects and 29 types of methods are derived.


                        
                        
                           
                           The sufficiency of the objects and methods is validated using additional RFPs.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Request for proposal (RFP)

Design rule checking

Design compliance checking

Building information modeling (BIM)

Context-free grammar (CFG)

@&#ABSTRACT@&#


               
               
                  This study reports on the requirements for developing computer-interpretable rules for checking the compliance of a building design in a request for proposal (RFP), especially in the building information modeling (BIM) environment. It focuses on RFPs for large public buildings (over 5million dollars) in South Korea, which generally entail complex designs. A total of 27 RFPs for housing, office, exhibition, hospital, sports center, and courthouse projects were analyzed to develop computer-interpreted RFP rules. Each RFP was composed of over 1800 sentences. Of these, only three to 366 sentences could be translated into a computer-interpretable sentence. For further analysis, this study deployed context-free grammar (CFG) in natural language processing, and classified morphemes into four categories: i.e., object (noun), method (verb), strictness (modal), and others. The subcategorized morphemes included three types of objects, twenty-nine types of methods, and five levels of strictness. The coverage applicability of the derived objects and methods was checked and validated against three additional RFP cases and then through a test case using a newly developed model checker system. The findings are expected to be useful as a guideline and basic data for system developers in the development of a generalized automated design checking system for South Korea.
               
            

@&#INTRODUCTION@&#

A request for proposal (RFP) lists the main function, form, usability, and other requirements of a building. A designer then interprets the RFP into a physical form based on his experience and knowledge [1]. During this design phase, the RFP acts as a design guide throughout all design phases and establishes criteria for design assessment [2]. However, RFP-compliance checking is cognitively challenging for designers for several reasons. First, a building is composed of many pieces of elements, which are geometrically complex and interwoven [3], so manual design checking is error-prone and the results are unreliable [2]. Second, designers may misinterpret design requirements in an RFP due to the ambiguous nature of natural language or through human error [4,5]. Third, RFP-based design checking is very time consuming and labor intensive. According to a survey by McGraw Hill Construction Research and Analytics [6], nearly half of architects and owners spend more than 26h on code checking on a typical project. Our own early survey shows that architects check their design against an RFP far more frequently than against building codes and other types of design references and they consider an RFP more important than building codes and regulations as a design reference, as shown in Fig. 1
                      
                     [7]. Fourth, manual checking results in redundant data input, especially in a collaborative design environment, due to the difficulties in data and rule sharing [8].

These problems of complexity, ambiguity, inefficiency, and redundancy can be dramatically reduced by automating the design checking process. An example can be found from medical informatics, where physicians often make mistakes of omitting certain tests or treatments. These errors were reduced by developing an automated reminder for certain treatments and tests based on medical practice guidelines [9].

Interest has been increasing in automated design checking to improve the efficiency of labor and safety at construction sites [10,11]. The advent of advanced data-rich computer aided design, referred to as building information modeling (BIM), has enabled automate checking of building codes and spatial requirements for notable examples such as the courthouse design guidelines of the U.S. General Services Administration (GSA), the International Building Code of International Code Council (ICC), and the Americans with Disabilities Act (ADA) standard for accessible design [2,12–14]. Although code-compliance checking has been the object of many studies for a long time [15], RFP-compliance checking has not been a major focus. Previous research topics have perhaps leaned towards code-checking rather than RFP-checking because building codes are the minimum legal requirements and strictly regulate design and construction submittals for permits. However, building codes do not describe an owner’s specific requirements; thus, improvements in the quality of a building and owner satisfaction require an understanding and proper reflection of the owner’s requirements in an RFP – one without errors or omissions on the design, especially in a competitive bid.

The aim of this paper is to specify the computational requirements for developing computer-interpretable rules for checking the compliance of a building design in a request for proposal (RFP), especially in the building information modeling (BIM) environment. The paper is organized into eight sections. Following this introduction, the next section describes the research scope and method. The third section reviews existing work in the field of automated rule-based design checking. The fourth section briefly introduces the concept of context-free grammar (CFG) and describes how RFP sentences are parsed into a computer-interpretable form using the CFG approach. The fifth section reports the results of RFP sentence analysis and the objects and methods derived from RFPs. The sixth section validates the derived objects and methods using three RFP cases. The seventh section demonstrates the applicability of design rules created using the objects and methods derived in this study using a newly developed BIM model checker and a translator. Finally, the conclusion section discusses the contributions, limitations, and the future direction of this work.

RFPs may differ by building type, year, regions, and building size [2,8,15]. If a building is small or simple, the RFP may not contain many requirements. Hospitals may have different requirements from office buildings, but even if the building types are the same, requirements in the 1980s may differ from those in the 2000s. Requirements for a residential complex in South Korea may also differ from those for similar complexes in the US.

This study limits its scope to the RFPs published for the past five years (2008–2012) for public buildings in South Korea with budgets over USD 5million. The RFPs were collected from the South Korean on-line e-procurement system [16] called ‘Nara-jang-teo (national market)’. Nara-jang-teo is run by the Korean Public Procurement Service (PPS) to solicit bids for all kinds of goods and services that are ordered by the Korean government and public institutions. An RFP for buildings provides a summary of a project, the project goal, a delivery method, and detailed project requirements. The research team collected and analyzed RFPs over the course of approximately 10months (from 2013 to 2014) through the following steps:
                        
                           •
                           
                              
                                 Step 1 (Data collection and setup):
                               RFPs for building projects from 2008 to 2012, which were over USD 5 million, were collected from Nara-jang-teo, the South Korean on-line e-procurement system. A total of 113 RFPs satisfied these criteria. However, among the 113 RFPs for building projects, a majority of the RFPs were for construction projects and only 27 RFPs were for building design projects. These 27 RFPs were associated with six types of buildings: residential complex, office building, exhibition facility, hospital, courthouse, and sports facility. Among these 27 RFPs, 23 RFPs were set as analysis data for deriving objects, methods, and the level of strictness required to develop computer-interpretable design rules for automated RFP-compliance checking and four RFPs, each from the residential complex, office, exhibition facility excluding courthouse and sports facility categories that had only one case per building type, as well one hospital RFP, were set as validation cases. Details are described in Section 4.1.


                              
                                 Step 2 (Preprocessing):
                               Some sentences included more than one rule. Thus, the first step of preprocessing was to divide each sentence into sentences that were equivalent to one rule. Then, each sentence in an RFP was examined and categorized into computer-interpretable and non-computer-interpretable sentences. Non-computer-interpretable sentences are those that are difficult for a machine to determine “satisfied” or “failed” without additional guidelines. Most of those sentences included qualitative expressions such as ‘high quality,’ ‘beautiful,’ and ‘proper’. Details are described in Section 4.2.


                              
                                 Step 3 (Sentence parsing):
                               Each computer-interpretable sentence was broken down into morphemes. Each morpheme was then categorized into four types [object (noun), method (verb), strictness (modal such as ‘must’ and ‘should’), and others] deploying the context-free grammar (CFG) approach in natural language processing (NLP) [17]. The CFG is used in this study since it provides a widely accepted framework for analyzing and rebuilding well-formed machine-readable expressions (i.e., rules in this study) from natural language [18]. Details are described in Section 4.3.


                              
                                 Step 4 (Analysis – Derivation of objects and methods):
                               All sentences were divided into morphemes using a simple automated word extractor developed by the research team, but each morpheme had to be manually classified into object (noun), method (verb), strictness (modal), and others by the researchers due to the general challenges in natural language processing, such as synonym and ambiguity issues. We developed a thesaurus to avoid redundancy between similar terms. The extracted objects, methods, and modals were examined and terms with similar meanings were merged. Modal auxiliaries were categorized into four levels to express the strictness of each rule [19]. Details are described in Sections 5.1–5.3.


                              
                                 Step 5 (Translation – Rule creation):
                               The sentences were translated into computer-interpretable Semantic Web Rule Language (SWRL) rules [20] using the objects and methods derived from the previous steps. SWRL is a rule specification language based on the Web Ontology Language (OWL) and the Rule Markup Language (RuleML). Details and examples are described in Section 5.


                              
                                 Step 6 (Validation):
                               The coverage and applicability of the objects and methods derived from previous steps were validated using four validation cases (RFPs). The list includes four types of facilities: residential complex, office building, exhibition facility, and hospital. After applying methods to the projects that were left out, methods were updated based on the validation results through steps 2–5. Details are described in Section 6.


                              
                                 Step 7 (Applicability test):
                               As the final step, the applicability of specified rules was tested using ‘abimo Checker,’ a newly developed BIM model checker developed for this study. We also developed a SWRL-to-Python translator for the applicability test because ‘abimo Checker’ used Python as a rule-checking scripting language. Details are described in Section 7.

The following section briefly reviews previous studies and their importance.

In order to reduce design errors, a considerable number of studies have focused on the causes of design errors and effective methods to prevent them [21–23]. The theoretical background of error management studies is often grounded in quality control theories in manufacturing such as ‘six sigma’ [24]. The quality control theories stress the importance of understanding and analyzing customers’ needs and satisfaction in reducing errors and achieving the target quality of outcomes [25,26].

In the architecture, engineering, and construction (AEC) industry, a checklist is normally used for design quality management. A checklist is ‘a list of action items or criteria that allow the user to record the presence/absence of the individual items listed to ensure that all are considered or completed [27].’ However, the manual design checking method, whether a checklist is used or not, is very ineffective in detecting mistakes or omissions and also does not guarantee the accuracy of check results [10]. The use of an alternative – the BIM-based automated design error detection – is therefore increasing [28]. For example, Statsbygg, the Norwegian government agency in charge of construction and real estate matters, evaluated the compliance of a design with ISO 21542, the international standard that defines the accessibility and usability of the built environment [29], using a BIM model checker [30]. The U.S. General Services Administration (GSA) checked the circulation in a courthouse by different security levels specified in the courthouse design guide [31] using a BIM model checker [2]. These BIM implementation cases present the benefits of the accuracy of requirement checking and the efficiency of the work [28].

The use of computer-interpretable requirements by the AEC industry is rare when compared to other industries. In the field of medicine, the patient’s medical information is managed in a computer-interpretable form [32]. Requirements engineering (RE) also commonly uses computer tools such as IBM DOORS for requirements definition and management throughout a RE lifecycle (i.e., requirement elicitation, identification, analysis, specification, modeling, validation, and management) [19,33]. However, as the number of BIM-assisted projects increases in the AEC industry, the use of computers in design and requirements management is also increasing.

The method of design checking using BIM can be categorized into clash detection and rule-based design checking. Clash detection is a geometry-based checking method that detects the physical conflicts of objects in a BIM model. Rule-based checking is a method for checking the compliance of a design with rule sets based on the arithmetic operation and deduction of values set beforehand [34]. The clash detection approach is so generic that it can be applied to any models once the function is implemented in a BIM system. Naturally, clash detection has become the most popular way to use BIM currently [28,35]. However, the rule-based approach requires the development of rule sets for different design requirements and, even before that, the development of objects and functions (methods) required to specify the rules. If a model checker is a Compact Disc (CD) player, the rule sets are CDs. Thus, even if a well-developed model checker exists, a model cannot be checked without rule sets. For this reason, the implementation of rule-based design check is slow in practice, although several model checkers are already available in the market. Widely known automated rule-based model checkers include Revit [36], Navisworks [37], Solibri Model Check (SMC) [38], Express Data Manager (EDM) [39], and FORNAX [40].

Another reason for the slow adoption of automated rule-based design checking in the AEC industry is that each model checker specifies rules in its own format using different computer languages. Thus, the reuse or sharing of existing rule sets are impossible [34,41,42]. The development of rules in a sharable and reusable format is also critical for accelerating the adoption of automated design checking in the industry [42].

This study takes an approach of specifying rules in a standard rule description language, SWRL, and translating the rules specified in SWRL into a scripting language (e.g., Java and Python) that is used in a target model checker (e.g., Solibri). This strategy is based on an assumption that, in the future, a client will distribute an RFP with a separate design requirement rule set specified in SWRL and designers will automatically check their designs multiple times as the design develops by using any BIM model checker of their choice by importing the SWRL rules into the model checking system. However, the very first step is to understand the objects and methods required to specify requirements rules. The next section describes in detail how – and which – objects and methods required for automated design check of buildings in South Korea were derived.

The RFPs collected and set up to develop methods were for building projects over USD five million within five years. A total of 27 RFPs were selected and they were composed of six types of facilities. From these RFPs, 1331 computer-interpretable sentences were collected from 9833 sentences written in natural languages and each was made into a single sentence that has a verb. We parsed the computer-interpretable sentence to develop the method and object. This section describes the RFP analysis methods and results in detail following the analysis steps described in the second section.

As described earlier, the target of analysis was limited to RFPs that satisfied the following criteria based on an assumption that requirements in RFPs for small buildings can be covered by the objects and methods required by large buildings and that design requirements may vary by region and time:
                           
                              (a)
                              RFPs for buildings with budgets over USD five million: In South Korea, buildings with budgets over USD five million are classified as large buildings and are subjected to additional requirements in the bidding process, such as pre-qualification (PQ) and value engineering (VE). A high standard for design quality is also required.

Buildings constructed within the recent five years, i.e., from 2008 to 2012: Requirements for space and building services change over time as residents’ needs, cultures, and technologies change. We collected RFPs within the recent five years so that we could derive objects and methods that reflected the latest design trend. RFPs between 2008 and 2012 were collected because the analysis began in 2013.

Public buildings in South Korea: Beginning in the year 2016, PPS mandates the use of BIM in all public building projects in South Korea. The scope of this study was limited to the public buildings in South Korea because this study was conducted as one of preparation processes for the 2016 BIM initiative.

A total of 27 RFPs satisfied these criteria. The collection was composed of 13 residential complexes, five office buildings, three hospitals, three exhibition facilities, a sports center, and a courthouse. Residential complexes and office buildings accounted for 66% of the RFP types. Courthouses and sports centers over USD five million were rare. The project name, owner, gross floor area, and budget of each RFP are specified in Table 1
                        . Ten of the thirteen residential complex projects were ordered by the Government Employees Pension Service. Six new office building projects were associated with the relocation of government ministries to Sejong from Seoul. Two of three hospitals projects were affiliated with universities.

Before analysis, the 27 RFPs were divided into two groups. One group was for analyzing and deriving objects and methods required for developing design rules from RFPs. The other group was for validation of the derived objects and methods. The analysis case consisted of 23 RFPs and the validation case included four RFPs, one each from exhibition facilities, hospitals, office buildings, and residential complexes. No validation case could be set for the building types with just one RFP case such as sports center and courthouse. The validation cases were selected randomly.

The collected RFPs were analyzed from 2013 through 2014 for about 10months. The sentences in RFPs were first decomposed into shorter sentences until each sentence indicated one design rule. As a general rule of thumb, a single sentence usually contains a single verb, except for the cases where a single rule is composed of several conditions. The composite rules were rare. Some rules were also expressed in a table format. The table, for example, specified how many spaces were required, how large the spaces should be, and which department was the owner of a space. These tables also had to be analyzed and translated into rules. About 9800 sentences and 7000 rules in a table form were extracted from 23 RFPs, as shown in Table 2
                        . From the extracted 9833 sentences and 7040 rules in tables, only computer-interpretable sentences were chosen. The criteria for computer-interpretable sentences were (a) whether a sentence or data included quantitative or numerical values, (b) whether verbs could be translated into a computer-interpretable expression (function or method) and (c) whether a list of objects included in a sentence had a potential to be included in a BIM model. For example, the sentence stating that the height of the ceiling had to be ‘sufficient for the people’s residence’ could be translated differently depending on the interpreter and therefore could not be interpreted by a computer, while the sentence stating that the height of the ceiling had to be ‘five meters’ could be interpreted by a computer. Sentences with verbs such as ‘describe’ and objects such as ‘mood’ were also categorized as non-computer-interpretable. The sentences that provided general descriptions rather than design rules were also eliminated. As summarized in Table 2 total of 1331 sentences was selected as computer-interpretable sentences according the above criteria. The ratio of computer-interpretable sentences to the total number of sentences differed depending on projects and ranged 2–55%. In the case of the courthouse, 91 sentences out of 166 were computer-interpretable (55%). This number was exceptionally higher than that of the other cases. Generally, the ratio of computer-interpretable sentences in an RFP was low, with an average was 14%, as shown in Table 2. On the other hand, all 7040 table rules could be translated into computer-interpretable sentences. However, differences existed between RFPs in terms of use of tables in design requirement specification. For example, RFPs for medical facilities expressed many design rules in a table format whereas RFPs for residential complexes did not.

A total of 8380 rule instances were collected. The number of rules extracted from tables outnumbered those from sentences: 1130 rules were collected from sentences and 7040 rules from tables. The number of rules also varied dramatically by building type. Hospitals requested from 1000 to 3000 design rules whereas other types of buildings had fewer than 300 rules. This explains why hospitals are generally regarded as one of the most challenging building types to design.

In order to derive objects and methods required to specify design rules, the individual sentences were parsed into morphemes following the CFG approach. In linguistics, a morpheme is the atomic morphological unit. We categorized morphemes into four types of grammatical elements (i.e., nouns, verbs, modals, and others) so that we could later translate them into objects, methods, the levels of strictness, and properties. Modifiers such as adjectives and adjective phrases were also analyzed and later translated into properties or methods of an object.


                        Fig. 2
                         illustrates an example of a sentence that states that the area of a single patient room shall have a minimum clear floor area of 120 square meters. From this example, we can deduce that this rule requires two objects ‘room’ and ‘floor’ from two noun phrases and a method (function) ‘has’ from verb ‘have’. The verb ‘have’ defines the relationship between ‘room’ and ‘floor.’ This relationship can be translated in a function-argument form shown below. This function returns ‘True’ if a room has a floor.
                           
                              
                                 
                                 
                                    
                                       
                                          Boolean has(room, floor);
                                    
                                 
                              
                           
                        
                     

However, the room is not any room, but the single-patient treatment room and the floor has a specific minimum floor area requirement. Thus, two rules should be added.
                           
                              
                                 
                                 
                                    
                                       
                                          Boolean room(type, ‘single-patient treatment room’);
                                    
                                    
                                       
                                          Boolean (area(floor)>
                                          120
                                          
                                          m
                                          
                                             2
                                          );
                                    
                                 
                              
                           
                        
                     

When all three of these rules are satisfied, this design rule is marked as ‘Pass.’ Judging by the modal verb ‘shall’, this rule also has high strictness; that is, if a design fails this rule, the design will not be accepted by the client. Each sentence was analyzed and converted into rules through these steps. The analysis results are described in detail in the next section.

From 1331 computer-interpretable sentences and 7040 table rules, we derived three types of objects, twenty-nine methods, and four levels of strictness. The following sections describe them in detail.

We categorized nouns into three types of objects: space, building element, and equipment. This classification was created considering the compatibility with OmniClass [42] and Industry Foundation Classes [43]. Space is equivalent to IfcSpace in IFC [43] and space in OmniClass [44]. Building element is equivalent to IfcBuildingElement in IFC [45] and Elements in OmniClass [42]. However, IFC and OmniClass does not have a single entity that can be directly mapped to equipment because some RFPs require a space to accommodate certain types of furniture and electrical equipment (e.g., special medical equipment), but IFC and OmniClass have relatively little emphasis on these types of requirements. We used the term equipment broadly to include mechanical, plumbing, and electrical (MEP) equipment, furniture, and electrical appliances. Equipment includes IfcDistributionElement (MEP elements) and IfcFurnishingElement (furniture and the like) in IFC and equipment and furnishings in OmniClass table 21 (Elements). Electrical appliances such as monitors and medical devices are not included in IFC and OmniClass.

According to IFC, space is ‘an area or volume bounded actually or theoretically,’ and a building element is ‘a structural and space separating system of a building’ [43,45]. By equipment, we mean a non-building element that is a part of an air, water, or electric distribution system of a building, or essential furniture or an appliance that is required by a space to perform its target function.

Synonyms and similar terms existed in RFPs. In order to avoid redundancy, we developed a thesaurus and analyzed nouns in RFP sentences. Table 3
                         summarizes the distribution of noun types in RFP types.

As shown in Table 3, most design guidelines in RFPs focus on space. In particular, RFPs for the courthouse and office building had a much larger number of design guidelines related to spatial requirements (space objects) than the other RFP types did. Compared to other facilities, RFPs for the sports center, the residential complex and the hospital included a relatively large number of design guidelines related to building elements or equipment.

Verb is an action or occurrence that indicates a state of being [46]. Verbs in RFPs were translated into methods (functions). Translation of verbs to methods was less direct than translation of nouns. Human interpretation and intervention were unavoidable because of the ambiguity of a natural language. For example, design guidelines, ‘Two rooms must be placed closely,’ could mean the following three situations:
                           
                              (a)
                              Two rooms must be located side by side, but may not be directly accessible. (Room ‘c’ and ‘d’ in Fig. 3
                                 ).

Two rooms are accessible, but may not be adjacent. (Room ‘a’ and ‘c’ in Fig. 3).

Two rooms are placed side by side and accessible. (Room ‘a’ and ‘b’ in Fig. 3).

To derive a method from RFP sentences, we first grouped verbs by their role into object existence, quantity check, distance check, area, space location, circulation, window-wall ratio, and material property. The verbs in the eight groups were then translated into 29 methods. Fig. 4
                         illustrates the 29 methods grouped by object type and role. Table 4
                         lists their syntax, description, and example.

Similar to the translated sentence examples explained in Section 4.3, the final rules were specified in SWRL. About a half of the methods is Boolean type. For example, whether ‘Education’ space includes ‘Lecture Room’ space can be checked using the ‘isComposedOf’ method. This ‘isComposedOf’ returns True if ‘Lecture Room’ exists in ‘Education’ space, and returns False if the condition is not met. The syntax, described in plain English, and an example of the ‘isComposedOf’ method is as follows:
                           
                              
                                 
                                 
                                    
                                       
                                          Syntax: Boolean isComposedOf (Space ‘a’, Space ‘b’, [Space ‘c’], …)
                                    
                                    
                                       
                                          Description: 
                                          Space ‘a’ is composed of Space ‘b’, Space ‘c’, and other spaces.
                                    
                                    
                                       
                                          Example: 
                                          isComposedOf (‘Education’,’Lecture Room’)=
                                          True
                                       
                                    
                                 
                              
                           
                        
                     

The other half of the methods is Long type. For example, when a designer needs to check how many rooms are required, the ‘getNumberOfSpace’ method makes this possible. It is able to count the number of rooms in specific area, in a specific building. The ‘getNumberOfSpace’ method returns true if the Patient room exists in ‘Ward’, or returns false or error.
                           
                              
                                 
                                 
                                    
                                       
                                          Syntax: Long getNumberOfSpace (spaceType ‘a’, [zone ‘b’], [story ‘c’], [building ‘d’])
                                    
                                    
                                       
                                          Description: 
                                          There are several spaces ‘a’ in zone ‘b’ on the ‘c’ story of the ‘d’ building.
                                    
                                    
                                       
                                          Example: 
                                          getNumberOfSpace (‘Patient Room’,‘Ward’) = 4000
                                       
                                    
                                 
                              
                           
                        
                     

Some methods have option arguments. For example, the method ‘isVisibleFrom’ is used to check whether ‘Patient rooms’ are observable from the ‘Nurse station’. This visibility depends on the door type (with sight glass or not) and door status (open/closed). This door types are expressed as Type zero to two. Type zero means that nurses are able to see the inside space of a patient room through the opened door from the nurse station. This type is possible to apply to the nurse station in an emergency room that has no doors between stretchers. Type one means that nurses are able to see around the patient room because of a closed door. Type two means that nurses can look at the patient in the room through a window. Type two is utilized in infection zones or infant units. The method ‘isVisibleFrom’ returns true if the patient room and nurse station exists for all. This method returns true if the door type of the patient room fits well, otherwise it returns false.
                           
                              
                                 
                                 
                                    
                                       
                                          Syntax: Boolean isVisibleFrom (Space ‘a’, Space ‘b’, Type ‘c’)
                                    
                                    
                                       
                                          Description: 
                                          space ‘a’ is visible from space ‘b’ through door type ‘c’.
                                    
                                    
                                       
                                          Example: 
                                          isVisibleFrom (‘Nurse Station’, ‘Patient Room’, Type 1)=
                                          True
                                       
                                    
                                 
                              
                           
                        
                     

In the above two room example, ‘(a) Two rooms must be placed side by side, but may not be directly accessible’ was translated into ‘isAdjacent’ and ‘(b) Two rooms must be accessible, but may not be adjacent’ was translated into ‘isAccessble’. In case (c), the two rooms must be adjacent and accessible. Some methods included options. For example, ‘getSpaceWidth’ included an option to choose the distance between interior walls, between centerlines, or between the external surfaces of two opposite walls. The ‘getSpaceHight’ method included an option for ceiling-to-ceiling height and floor-to-floor, and floor-to-ceiling. The ‘checkSetBasedCirculation’ method was defined based on the algorithm proposed by Lee et al. [47].


                        Fig. 5
                         illustrates the frequency of use of 29 methods in RFPs. The ‘getFloorArea’ method (41%) is the most frequently used among the 29 methods followed by ‘getNumberOfSpace’ (28%), ‘isComposedOf’ (13%), ‘hasEquipment’ (8%), and ‘isAccessible’ (3%). If ‘getNumberOfEquipment’ (2%) is added to this list, these six methods cover 95% of the design guidelines. This analysis result clearly shows which method should be developed first when a new rule-based design checking system is developed. Even if only the three most frequently methods, ‘getFloorArea’, ‘getNumberOfSpace’, and ‘isComposedOf’, are implemented, over 80% (82%) of the design guidelines can be checked.

However, the remaining 23 methods should not be ignored although they cover only 5% of the design guidelines when the use of methods is analyzed without considering building type (Fig. 6
                        ). This is because each building type has special design requirements and the 23 methods play an important role in each RFP when the method use is analyzed by building type.

For example, 12 of the methods were used only for a certain type of building: Nine methods were found only in hospital RFPs and three only in office building RFPs. Hospital-specific methods were mostly related to equipment and they were ‘getNumberOfElement’, ‘getNumberOfEquipment’, ‘getSpaceWidth’, ‘getEquipmentWidth’, ‘getEquipmentHeight’, ‘getSpaceDistance’, ‘getElementDistance’, ‘isConnectedTo’ and ‘isVisibleFrom’. This is because a hospital requires a large amount of medical equipment and the space should be large enough to accommodate it. Similarly, office buildings are generally sensitive to parking lot and energy-saving issues and had ‘getLandscapeArea’, ‘getParkingLotArea’ and ‘getWindowWallRatio’ as office-specific methods. Table 5
                         summarizes which methods were used in which building type, focusing on which object type.

In general, many RFP sentences included modal auxiliaries to express the strictness level of the owner’s requests. From the RFP sentences, we derived four levels of strictness of design guidelines, as listed in Table 6
                        . The four levels were determined by the use of either must, should, might, or could. The term ‘must’ indicates that a design guideline is mandatory without an exception. In some sentences, this was expressed using terms such as ‘essentially’ or ‘absolutely.’ The term ‘should’ is still mandatory, but weaker than ‘must’; i.e., a minor exception might be allowed. ‘Might’ is a recommendation and is often expressed with words such as ‘is considered,’ and ‘if possible.’ ‘Could’ is for optional cases and can also be expressed using ‘can’.

Most design requirements (93%) were expressed using ‘should’. The other modal auxiliaries, i.e., ‘must’, ‘might,’ and ‘could,’ were very seldom used. Still, the result of the strictness level analysis can be used to express the weight of each design guideline and eventually, in the future, to quantify the overall compliance score of a design with a design guide. The objects and methods derived from 23 RFPs were validated using four validation cases. The next section reports the validation results in detail.

The sufficiency of the objects and methods derived from 23 RFPs as elements required to develop design rules for RPFs for buildings were validated by analyzing design guidelines described in four additional RFPs using the objects and methods and checking whether design guidelines existed that could not be expressed using the derived objects and methods. The four RFPs were for a residential complex, an exhibition facility, an office building, and a hospital. The four RFPs were randomly selected when the collected 29 RFPs were categorized into the analysis group and the validation group.

All the design requirements in the four RFPs could be expressed using the derived objects and methods and the sufficiency of the derived objects and methods was validated. All validation cases required all three object types. However, only some methods were used in the four cases: Among the 29 methods, the hospital RFP used 21 methods (72%), the office building RFP 13 methods (45%), the exhibition facility RFP 10 methods (35%), and the residential complex RFP only four methods (14%), as presented in Table 7
                     . However, we do not rule out a possibility of having an RFP for a building with very exceptional design requirements such as a data center or a nuclear plant in the future. In such cases, additional objects and methods may need to be specified.

And Table 7 compares which specific methods were required in the analysis cases and the validation cases by facility type. Differences appeared in the use of methods according to facility type, but not between the analysis case and the validation case. This means that if an RFP for a certain type of facility is newly created, it is likely that the same set of methods and objects used in existing RFPs will be required by the new RFP. This reconfirms that the objects and methods derived in this study are likely to be sufficient to develop computer-interpretable rules for new RFPs for, at least, hospitals, exhibition facilities, office buildings, residential complexes, sports centers, and courthouses in South Korea.

The objects and methods derived from the RFP analysis were implemented in a new BIM model checker, ‘abimo’ [48]. We specified a set of sample rules in SWRL using the objects and methods derived from the analysis and translated the SWRL rules to Python scripts using the SWRL-to-Python translator that we developed because ‘abimo’ uses Python as a rule description language. Translated rules were tested for the reliability and validity.


                     Fig. 7
                      illustrates an example of testing the ‘getElementWidth’ method. This ‘getElementWidth’ returns the width of a building element. The example rule states that the width of a door should be larger than the width of a stretcher. These rules are found mostly in hospital facilities. The red-colored doors in Fig. 7 are the ones that failed the design-compliance check. During the implementation, some methods were divided into several methods due to the internal data structure of ‘abimo’ and for the programming efficiency of implementation. Below is the getElementWidth example specified in SWRL and Python:
                        
                           
                              
                              
                                 
                                    <SWRL>
                                 
                                 
                                    
                                       rehabilitation(?x) ∧ door(?y) ∧ hasElement(?x,?y) ∧ hasWidth(?y,?a) ∧ swrlb:greaterThanOrEqual(?a, 115) 
                                          
                                             →
                                          
                                        
                                       AccenptEntity(?x)
                                 
                                 
                                    <Python>
                                 
                                 
                                    
                                       Import kbCheckModule;
                                 
                                 
                                    
                                       Checker
                                       =
                                       kbCheckModeule.kbChecker()
                                 
                                 
                                    
                                       SpaceList
                                       =
                                       Checker.FindSpace(‘rehabilitation’)for space in Spacelist
                                    
                                 
                                 
                                    
                                       
                                       Result
                                       
                                       =
                                       
                                       1
                                    
                                 
                                 
                                    
                                       ElementList
                                       =
                                       space.GetElement(‘Door’) for element in ElementList
                                    
                                 
                                 
                                    
                                       
                                       if element WidthGreatOrEqual(115)
                                       
                                       ==
                                       
                                       0;
                                 
                                 
                                    
                                       
                                       Check.SetErrorResult(1)
                                    
                                 
                                 
                                    
                                       
                                       Else Checker.SetErrorResult(0)
                                    
                                 
                              
                           
                        
                     
                  

Another test case was the ‘isAdjacent’ method, which checks whether two spaces are located sharing a wall or a ceiling/slab. Fig. 8
                      shows two spaces that are adjacent. Below is the ‘isAdjacent’ example specified in SWRL and Python:
                        
                           
                              
                              
                                 
                                    <SWRL>
                                 
                                 
                                    
                                       Food depots (?x) ∧ Kitchen (?y) ∧ isAdjacent(?x, ?y) 
                                          
                                             →
                                          
                                        
                                       AcceptEntity(?x)
                                 
                                 
                                    <Python>
                                 
                                 
                                    
                                       Import kbCheckModule;
                                    
                                 
                                 
                                    
                                       Checker
                                       
                                       =
                                       
                                       kbCheckModule.kbChecker()
                                    
                                 
                                 
                                    
                                       SpaceListA
                                       
                                       =
                                       
                                       Checker.FindSpace(‘food depot’)
                                    
                                 
                                 
                                    
                                       SpaceListB
                                       
                                       =
                                       
                                       Checker.FindSpace(‘kitchen’)
                                    
                                 
                                 
                                    
                                       for spaceA in SpaceListA:
                                    
                                 
                                 
                                    
                                       
                                       for spaceB in SpaceListB:
                                    
                                 
                                 
                                    
                                       
                                       IF Checker. IsAdjacent(spaceA,spaceB) ==1:
                                    
                                 
                                 
                                    
                                       
                                       
                                       Checker.SetErrorResult(1)
                                    
                                 
                                 
                                    
                                       
                                       Else: Checker.SetErrorResult(0)
                                    
                                 
                              
                           
                        
                     
                  

Many more test cases were developed and tested. A trial version of ‘abimo’ can be downloaded from a website (http://www.abimo.co.kr/) and tested.

@&#DISCUSSION AND CONCLUSION@&#

This study reported the analysis results of RFPs for buildings for deriving the objects and methods required to develop computer-interpretable rules for checking the compliance of RFPs in building design. RFP has received little attention in the automated rule-based BIM model checking field. However, many previous studies pointed out the inefficiency and unreliability of manual checking of the compliance of a design with an RFP and the efficiency of BIM-based automated design checking.

This paper collected and analyzed sentences from all the RFPs released for the past five years (2008–2012) for large public building designs in South Korea. A total of 27 RFPs for housing, office, exhibition, hospital, sports center, and courthouse projects were collected and separated into two groups; one for the analysis of objects and methods required to translate design requirements into computer-interpretable rules, and the other for validation of the analysis results. Hospitals had the largest number of sentences and included about 1800–1900 sentences per RFP. However, only 10–20% of sentences could be categorized into computer-interpretable sentences. On the other hand, in case of a courthouse RFP, over a half (55%) of 166 sentences could be categorized into computer-interpretable sentences. Some building types, such as hospitals and office buildings, also included many design rules specified in the form of tables rather than in natural language. In the case of hospitals, design rules specified in tables ranged from 1000 to 2600. As the next step, the sentences, categorized as computer-interpretable, were broken down into morphemes using the CFG approach. The morphemes were classified into four types: namely, object (noun), method (verb), strictness (modal), and others. The object were subcategorized into three types (space, building element, and equipment), and the method into 29 types, and the strictness into four levels. The frequency of their use was analyzed. Spaces were the most commonly appeared object in design rules. The ‘getFloorArea’ (41%) was the most frequently used method among 29 methods, followed by ‘getNumberOfSpace’ (28%), ‘isComposedOf’ (13%), ‘hasEquipment’ (8%), and ‘isAccessible’ (3%), and ‘getNumberOfEquipment’ (2%). The top five frequently-used methods covered 93% of design guidelines and the top seven frequently-used methods, including the top five methods, covered 96% of design guidelines.

However, the remaining 22 methods were also significant and some of them were essential in certain types of buildings depending on the special needs or regulations associated with a facility type. For example, hospital RFPs required certain types of equipment-related methods that were not required by other types of facilities. Only office buildings required methods associated with parking lots and landscape areas. The sufficiency of the derived objects and methods were validated using four validation RFP cases. All the computer-interpretable requirements in the four RFPs could be covered by the objects and methods derived through the analysis process. We also found that RFPs for the same type of facility used the same set of methods. Thus, we can conclude that the objects and methods derived in this study are likely to support translation of future RFPs, at least for projects such as residential complexes, office buildings, exhibition facilities, hospitals, sports centers, and courthouses, into computer-interpretable rules. However, this study also leaves a limitation that special building types such as the data center and the digital library may require more objects and methods than the ones derived in this study. In addition, a set of sample rules was created using the derived objects and methods and the applicability was tested in a newly developed BIM model checker for this study.

The results of this study are expected to be useful as a fundamental guide for model checker and rule developers who are interested in automating the compliance checking of a design with an RFP. The resultant automated design-compliance checking system and rules are expected to aid designers in effectively managing a design from frequent design change orders while keeping their clients’ requests. As a result, the designer can focus more on improving the quality of a design. These unambiguously defined design guidelines may also be used throughout the lifecycle of a facility when the design intents require reexamination.

@&#ACKNOWLEDGEMENTS@&#

This research was supported by a grant (14AUDP-C067817-02) from the Architecture & Urban Development Research Program funded by the Ministry of Land, Infrastructure and Transport of the Republic of Korea.

@&#REFERENCES@&#

