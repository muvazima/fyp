@&#MAIN-TITLE@&#Hierarchical Laplacian-based compression of triangle meshes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Efficient compression algorithm for triangle meshes is presented.


                        
                        
                           
                           Performance is demonstrated, in particular with respect to perceptual metrics.


                        
                        
                           
                           Hierarchical extension of mesh Laplacian is presented.


                        
                        
                           
                           Prediction of higher order residuals improves performance.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Compression

Perceptual metric

Laplacian

Discrete shape operator

Encoding

Distortion

@&#ABSTRACT@&#


               
               
                  In this paper, we present an algorithm for efficient encoding of triangle meshes. The algorithm preserves the local relations between vertices by encoding their Laplacian coordinates, while at the same time, it uses a hierarchy of additional vertex constraints that provides global rigidity and low absolute error, even for large meshes. Our scheme outperforms traversal based as well as Laplacian-based compression schemes in terms of both absolute and perceived distortion at a given data rate.
               
            

@&#INTRODUCTION@&#

Triangle meshes are getting increasingly popular as a new medium storing shapes of 3D objects, thanks to recent advances in 3D scanning and even 3D printing. Publishing 3D meshes representing products is an attractive new way of marketing, and sharing 3D meshes may be the next step in computer-aided social interaction. Efficient storage of this kind of data is essential in both allowing displaying of the information even on mobile devices with low bandwidth on the content consumer side, as well as in allowing storage of many highly detailed models on the side of the content distributor.

The task of mesh compression is to store the triangle mesh in a file that is as small as possible. As with other kinds of media, some precision loss is allowable in most applications in order to achieve even smaller file sizes. This problem has been studied for about two decades now, yet only recently scientists started to seriously analyse the perception-related issues arising from the problem. In particular, measuring the amount of distortion due to the precision loss has recently received much attention. New error metrics have been proposed that capture the perceived distortion much better than mean squared error (MSE) and its derivatives. Along with this progress, new compression algorithms have been suggested, which attempt to minimise the perceived distortion.

One of the most efficient algorithms in this regard is the high-pass coding (HPC) proposed by Sorkine et al. [13]. The idea is to express the mesh in terms of local details, using a combinatorial discrete Laplacian. These details are in turn transmitted to the decoder, which solves a linear inverse problem. The approach is very efficient and outperforms all previous methods in terms of perceptual metrics, which usually focus on local similarity of meshes. Despite these advantages, users seem reluctant in adopting this technique, mainly because it lacks a mechanism that would avoid error accumulation. As a result, the performance of HPC in terms of MSE is rather poor, and the algorithm is unable to provide a guarantee of maximum absolute dislocation of vertex positions. This in turn leads to problems when several meshes interact in 3D space by touching each other – even though the HPC compressed meshes show little perceptual distortion, they may intersect or not touch each other correctly, which is a disturbing artifact.

In this work, we propose an extension of the HPC algorithm which avoids this problem. We include additional data into the data stream, which describe the higher-level relations between vertices of the mesh, thus limiting the error accumulation and providing a considerable improvement as measured by MSE as well as perceptual metrics. Our extension is expressed in the terms of the original HPC encoding algorithm, and thus it does not require significant changes in the encoding/decoding implementation.

@&#RELATED WORK@&#

Compression of triangle meshes has been intensively studied in the past. Separate approaches have been proposed for compression of mesh connectivity and mesh geometry, and it has been shown that using information from connectivity improves the performance of geometry compression and vice versa. Most commonly, compression schemes build on encoding/decoding connectivity first, followed by a connectivity guided encoding of the geometry.

Several methods of connectivity compression have been proposed in the past. Connectivity is usually encoded without any data loss, while reindexing of indices is usually used in order to reduce the amount of data required. The Topological Surgery approach [15] encodes a vertex spanning tree and a triangle spanning tree that uniquely identify the connectivity. The Edgebreaker scheme [11] provides a guarantee of 4bits per vertex by encoding the so-called op-codes for each triangle. Valence based coding approaches [1,7] build on the fact that the main part of connectivity information is contained in the vertex degrees. A theoretical bound of 3.245bits per vertex has been derived [5] under the assumption that every possible connectivity is equally probable. The valence-based encoder provide performance even below this limit, exploiting the higher probability of highly regular (vertex degrees close to 6) nature of most practical meshes.

Encoding of mesh geometry is a task with much more freedom regarding the loss of precision. Most algorithms perform quantization of the floating point values at some stage, while some advanced algorithms have other sources of precision loss, such as neglecting high frequencies in the mesh.

One large class of algorithms works during a mesh traversal, which attaches vertices to the decoded part of the mesh one at the time. The new vertex is predicted in some way, such as using the parallelogram predictor [14] or some of its extensions [3,16]. Finally, a correction vector is encoded that is added to the prediction, yielding the decoded position of the vertex. If both the encoder and the decoder work with the same prediction, then this scheme effectively eliminates error accumulation. An alternative of this approach working with angles rather than position vectors has been also proposed [8].

There have also been more complex algorithms proposed, which do not work in the traversal-based fashion. An algorithm based on eigenvalue decomposition of the mesh connectivity matrix [6] uses transformation of the coordinate functions into a basis of the discrete Laplace operator. A basis reduction is applied to reduce the dimensionality of the data, and the remaining amplitudes are quantized and encoded.

The high-pass encoding [13,2] also builds on the discrete Laplace operator, only this time using it directly to transform the coordinate functions into the Laplacian (delta) coordinates. Together with the anchor points, this data allows the decoder to reconstruct the original vertex positions by solving a sparse system of linear equations. Since we build on this method, it will be described in more detail in Section 3.

Although mean squared error and Hausdorff distance have been used extensively for evaluation of the amount of distortion caused by mesh compression, it has been recently conclusively shown that these metrics provide only limited correlation with distortion perception [4]. User studies have been performed and metrics such as MSDM2 [9], FMPD [19] or DAME [18] have been proposed to provide better correlation with the results. Currently researchers are designing new compression algorithms that minimise the newly proposed metrics, while the traditional metrics keep their relevance in situations where multiple objects interact with each other. While the perception based metrics ensure that each object is visually indistinguishable from the original, the absolute metrics ensure that the interacting objects, such as touching hands or shoe touching a floor, stay in correct position with respect to one another.

Currently, high-pass coding provides the best results in terms of perceived distortion, while the traversal based methods work best in terms of mean squared error. In this paper, we propose an algorithm that outperforms both of these approaches both in terms of perceptual metrics and in terms of mean squared error.

A triangle mesh 
                        
                           M
                        
                      is defined as a set of vertex positions 
                        
                           
                              
                                 v
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 v
                              
                              
                                 V
                              
                           
                        
                     , representing points in 3D space and referred to as geometry, and a set of index triplets 
                        
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                           =
                           (
                           
                              
                                 t
                              
                              
                                 1
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 1
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 1
                              
                              
                                 3
                              
                           
                           )
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                           =
                           (
                           
                              
                                 t
                              
                              
                                 2
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                              
                                 3
                              
                           
                           )
                           ,
                           …
                           ,
                           
                              
                                 t
                              
                              
                                 T
                              
                           
                           =
                           (
                           
                              
                                 t
                              
                              
                                 T
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 T
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 T
                              
                              
                                 3
                              
                           
                           )
                        
                     , referred to as connectivity. We assume that the connectivity has been transmitted to the decoder, and thus it is available at both sides of the transmission. The task is to encode the geometry as efficiently as possible.

In the high-pass coding of triangle meshes, the positions of vertices are not encoded as absolute coordinates. Instead, for each vertex, the so-called Laplacian coordinates are computed:
                        
                           (1)
                           
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             1
                                          
                                          
                                             ‖
                                             N
                                             (
                                             i
                                             )
                                             ‖
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                ∈
                                                N
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                              -
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              ,
                           
                        
                     where 
                        
                           N
                           (
                           i
                           )
                        
                      is the set of all vertices incident with vertex 
                        
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                        
                     , also known as the 1-ring. The Laplacian coordinates represent the relative position of a vertex with respect to the centre of mass of its neighbours, i.e. it captures the local relations between vertices. Computing all Laplacian coordinates for all vertices can be expressed as a matrix multiplication 
                        
                           r
                           =
                           L
                           g
                        
                     , where 
                        
                           r
                           =
                           
                              
                                 (
                                 
                                    
                                       d
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       V
                                    
                                 
                                 )
                              
                              
                                 T
                              
                           
                           ,
                           g
                           =
                           
                              
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       V
                                    
                                 
                                 )
                              
                              
                                 T
                              
                           
                        
                      and L is in fact a matrix representation of a combinatorial Laplace operator on the mesh 
                        
                           M
                        
                     .

The intention is to transmit the vector 
                        
                           r
                        
                      instead of 
                        
                           g
                        
                     , because the values in 
                        
                           r
                        
                      have a much smaller entropy, yet they capture the necessary information about vertex relations. Unfortunately, the matrix L is rank deficient. In order to resolve this problem, additional rows are added to L, one for each connected component of the mesh. These rows contain only a single unit value at a position corresponding to one vertex of the connected component. The resulting rectangular matrix 
                        
                           
                              
                                 L
                              
                              
                                 ∗
                              
                           
                        
                      is then used to obtain an extended vector 
                        
                           
                              
                                 r
                              
                              
                                 ∗
                              
                           
                        
                     , which additionally contains coordinates of one vertex per connected component. This vector is quantized and transmitted to the decoder, which in turn solves the system 
                        
                           
                              
                                 L
                              
                              
                                 ∗
                              
                           
                           
                              
                                 g
                              
                              
                                 ‾
                              
                           
                           =
                           
                              
                                 
                                    
                                       r
                                    
                                    
                                       ∗
                                    
                                 
                              
                              
                                 ‾
                              
                           
                        
                     , where 
                        
                           
                              
                                 
                                    
                                       r
                                    
                                    
                                       ∗
                                    
                                 
                              
                              
                                 ‾
                              
                           
                        
                      is the decoded vector 
                        
                           
                              
                                 r
                              
                              
                                 ∗
                              
                           
                        
                     , which differs from 
                        
                           
                              
                                 r
                              
                              
                                 ∗
                              
                           
                        
                      slightly due to quantization.

The high-pass coding is very efficient at preserving the local distribution of vertices, since the encoded residuals (i.e. Laplacian coordinates) directly capture the local relations. On the other hand, the scheme does not prevent error accumulation in any way, and thus vertices that are located topologically far from anchor points may get reconstructed at positions that differ significantly from the original positions. This is captured by a rather poor performance of the algorithm in terms of mean squared error. Moreover, this effect is strongly affected by the random character of the accumulation of quantization error in areas that are distant from anchor points, and thus sometimes even increasing the precision of quantization actually leads to an increase of mean squared error.

In our extended version of the algorithm, we use additional equations that capture relations between topologically distant vertices as well, and build hierarchical “suspension” structure that is supported by the anchor points. These additional equations dramatically reduce the mean squared error. The following section describes the procedure in detail.

In our scheme, we classify the vertices into several layers. Each vertex is assigned an integer, which determines at which level of a hierarchical structure the vertex is located, while initially, all vertices are assigned to level 0. We aim at a uniform distribution of vertices into layers, and thus we use the procedure described in Algorithm 1. The steps of the algorithm are also illustrated by Fig. 1
                        .
                           Algorithm 1
                           Vertex level assignment. In our implementation, we use 
                                 
                                    maxCount
                                    =
                                    100
                                 
                              , i.e. new levels are added until there are less than 100 vertices on the highest level of the hierarchy. The asterisk at line 10 refers to Fig. 1 
                              
                                 
                                    
                                 
                              
                           

The level assignment algorithm ensures that no two neighbouring vertices are promoted to a higher level. It also provides a set of higher level neighbours 
                           
                              
                                 
                                    N
                                 
                                 
                                    level
                                 
                              
                              (
                              i
                              )
                           
                         for each higher level vertex. These neighbourhoods are then used for additional equations described in the next subsection. Note that we do not create additional equations for level 1 vertices, because they would create a too large number of additional residuals that would have to be encoded, while in our experiments, they did not bring a significant improvement of compression performance. Also note that the hierarchy itself does not require any additional data, since it can be constructed at the decoder from the mesh connectivity, using a predefined seed for the random number generator used in the algorithm.

Having the vertex hierarchy with the highest level M, we add an additional equation for each vertex 
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                           
                         such that 
                           
                              M
                              >
                              level
                              [
                              i
                              ]
                              >
                              1
                           
                        . The equation has the same form as (1) with the only difference that the higher level neighbourhood is used, i.e. we add euqations of following structure:
                           
                              (2)
                              
                                 
                                    
                                       d
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                ‖
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      level
                                                      [
                                                      i
                                                      ]
                                                   
                                                
                                                (
                                                i
                                                )
                                                ‖
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   ∈
                                                   
                                                      
                                                         N
                                                      
                                                      
                                                         level
                                                         [
                                                         i
                                                         ]
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                
                                             
                                          
                                          
                                          
                                             
                                                v
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 -
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                        where k is used as index of the additional equation. These additional equations capture the relations between more distant vertices of the mesh, and provide a certain kind of rigidity to the reconstruction, which is hard to achieve by only working with the 1-ring neighbourhoods. Note that we do not use equations on level M, instead, we use the vertices on level M as anchor points. This way, we build a stable structure, where the position of level M vertices is fixed, and positions of level 
                           
                              K
                              -
                              1
                           
                         vertices are directly connected to the positions of vertices on level K. This suspension structure effectively limits the error accumulation by ensuring that each vertex has an anchor point that affects it over no more than 
                           
                              O
                              (
                              log
                              (
                              V
                              )
                              )
                           
                         equations.

Each additional equation produces a residual (Laplacian coordinates with respect to a wider neighbourhood) which must be transmitted to the decoder. In contrast to the residuals obtained from the original Laplacian, the residuals at higher levels have generally much higher magnitude, as they relate vertices that are distant from each other. Moreover, despite of the level assignment procedure that attempts to distribute the levels evenly, it is often the case that the vertex lies at a position that differs considerably from the centre of mass of its neighbours, which leads to larger Laplacian coordinates. It is therefore desirable to perform a prediction of these in order to make their distribution more narrowly distributed around zero and thus reduce their entropy.

In the proposed scheme, the prediction is done for each level separately. The first step is equivalent to the high pass encoding, i.e. the decoder receives the residuals of all vertices with respect to their topological neighbourhood, and the quantized positions of the anchor vertices. This allows reconstructing the first approximation of the mesh geometry 
                           
                              
                                 
                                    
                                       
                                          g
                                       
                                       
                                          0
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                              =
                              
                                 
                                    (
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                          
                                       
                                       
                                          ‾
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                1
                                             
                                             
                                                0
                                             
                                          
                                       
                                       
                                          ‾
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                V
                                             
                                             
                                                0
                                             
                                          
                                       
                                       
                                          ‾
                                       
                                    
                                    )
                                 
                                 
                                    T
                                 
                              
                           
                         by solving 
                           
                              
                                 
                                    L
                                 
                                 
                                    ∗
                                 
                              
                              
                                 
                                    
                                       
                                          g
                                       
                                       
                                          0
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          r
                                       
                                       
                                          ∗
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                        . This in turn allows predicting the Laplacian coordinates corresponding to the additional equations related to level 1 vertices as
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             d
                                          
                                          
                                             k
                                          
                                       
                                    
                                    
                                       ^
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                ‖
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      1
                                                   
                                                
                                                (
                                                i
                                                )
                                                ‖
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   ∈
                                                   
                                                      
                                                         N
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                
                                             
                                          
                                          
                                          
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                             
                                                ‾
                                             
                                          
                                       
                                    
                                 
                                 -
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                          
                                             0
                                          
                                       
                                    
                                    
                                       ‾
                                    
                                 
                                 .
                              
                           
                        
                     

The encoder also evaluates this prediction and transmits only a correction 
                           
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                              =
                              
                                 
                                    d
                                 
                                 
                                    k
                                 
                              
                              -
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                           
                        . The decoder can now reconstruct the Laplacian coordinates as 
                           
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                              +
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ^
                                 
                              
                           
                        . The probability distribution of the corrections 
                           
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                           
                         is much narrower and their entropy is much smaller than that of the residuals 
                           
                              
                                 
                                    d
                                 
                                 
                                    k
                                 
                              
                           
                        .

The reconstructed residuals 
                           
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          k
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                         corresponding to equations related to vertices at level 2 are now appended to the vector 
                           
                              
                                 
                                    
                                       
                                          r
                                       
                                       
                                          ∗
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                        , forming an extended vector 
                           
                              
                                 
                                    
                                       
                                          r
                                       
                                       
                                          1
                                       
                                       
                                          ∗
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                        . We can now extend the matrix 
                           
                              
                                 
                                    L
                                 
                                 
                                    ∗
                                 
                              
                           
                         to 
                           
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                                 
                                    ∗
                                 
                              
                           
                         by appending rows corresponding to the additional equations related to level 2 vertices. This now allows solving for an improved reconstruction 
                           
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                                 
                                    ∗
                                 
                              
                              
                                 
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          r
                                       
                                       
                                          1
                                       
                                       
                                          ∗
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                        . The reconstruction 
                           
                              
                                 
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                 
                                 
                                    ‾
                                 
                              
                           
                         is used to predict the residuals 
                           
                              
                                 
                                    d
                                 
                                 
                                    k
                                 
                              
                           
                         related to level 3 vertices, allowing for another extension of the system matrix, until the highest level with matrix 
                           
                              
                                 
                                    L
                                 
                                 
                                    M
                                    -
                                    2
                                 
                                 
                                    ∗
                                 
                              
                           
                         is reached, which is used for the final reconstruction. The structure of the involved linear systems is illustrated in Fig. 2
                        .

After the encoding the whole geometry is represented by a set of V quantized residuals 
                           
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                           
                        , resulting from Eq. (1), quantized coordinates of anchor points (their number is determined by the number of vertices on the highest level), and quantized corrections 
                           
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                           
                         for each vertex on levels from 2 to 
                           
                              (
                              M
                              -
                              1
                              )
                           
                        . In our implementation, we use a simple uniform quantization, i.e. each floating point value is multiplied by a user specified constant Q and rounded to the nearest integer. We encode these integer values using a context adaptive binary arithmetic coder similar to the CABAC implementation [10]. We use a separate context for the residuals, anchor points, and for each level of corrections. At the decoder, the integers are then simply multiplied by 
                           
                              1
                              /
                              Q
                           
                        .

@&#RESULTS@&#

In our experiments, we have measured the amount of data required to encode the geometry, i.e. our numbers do not include the bits required for encoding of connectivity. Our scheme can be used with any connectivity compression algorithm, which is also true for all the state of the art algorithms we have compared against. For the comparison, we have used four error metrics:
                        
                           •
                           Mean squared error, which captures the absolute dislocations of vertices.

The visual error [6], which is in fact a combination of mean squared error and discrete shape operator difference. We are using the weighting constant 
                                 
                                    α
                                    =
                                    0.15
                                 
                               as suggested in [13]. This metric combines absolute and local error.

The FMPD [19] perceptual error metric.

The DAME [18] perceptual error metric.


                     Figs. 3–6
                     
                     
                     
                      represent the typical result of our algorithm in comparison to the high pass coding (HPC) [13], parallelogram prediction [14] and weighted parallelogram prediction [16] on a single high resolution model. Fig. 3 shows that our algorithm provides results on par with parallelogram prediction, and is only slightly worse than the weighted parallelogram scheme, while it provides a massive improvement against HPC. At the same time, Figs. 5 and 6 show that our scheme outperforms both parallelogram prediction and weighted parallelogram prediction schemes in terms of perceptual error, providing results on par with HPC. In terms of the visual error, which combines both local and absolute error, our algorithm provides the best results. Similar results were obtained for other models as well, as documented in Table 1
                     .

We have also compared our results against a simpler approach of increasing the number of anchor points in the HPC algorithm. The typical results are shown in Figs. 7 and 8
                     
                     . The figures show that by adding random anchor points, the mean squared error is indeed improved, however at the cost of an immediate performance drop with respect to a perceptual metric FMPD. The performance drop is caused by increasing the data rate by adding anchor points which are not predicted, i.e. have a rather high entropy. By adding more anchor points, the FMPD performance deteriorates further, while the improvement of MSE performance stops long before reaching the performance of the proposed algorithm, when about 3% of vertices are used as anchors. Adding even more anchors only leads to decrease in performance in all metrics.

Note that it would be possible to promote specifically those vertices with largest error to anchors, as done in [12], probably leading to better results. Although it is possible to quickly update the factorization after adding a single anchor, one still has to perform a (at least) linear step of solving the factorised system and finding the next vertex with largest error. Since the total number of anchors that have to be added is linear, it would lead to a quadratic complexity of the algorithm.

As for the computational complexity of our algorithm, is comparable with the HPC. The main bottleneck of the HPC (and our) algorithm is the factorization and solution of the extended Laplacian matrix, both of which work for sparse matrices in roughly linear time. More generally, if the factorization has a complexity of 
                        
                           O
                           (
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           (
                           V
                           )
                           )
                        
                     , where V is the number of vertices and 
                        
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           (
                           x
                           )
                        
                      is some implementation dependent function, and the solution of the system based on the factorization has a complexity of 
                        
                           O
                           (
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                           (
                           V
                           )
                           )
                        
                     , one can express the overall decoding complexity of HPC as 
                        
                           O
                           (
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           (
                           V
                           )
                           +
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                           (
                           V
                           )
                           )
                        
                     , while our algorithm runs in 
                        
                           O
                           (
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           (
                           V
                           )
                           log
                           (
                           V
                           )
                           +
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                           (
                           V
                           )
                           log
                           (
                           V
                           )
                           )
                        
                     , because the decomposition and solution of the system has to be performed 
                        
                           log
                           (
                           V
                           )
                        
                      times. If both functions 
                        
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           (
                           x
                           )
                        
                      and 
                        
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                           (
                           x
                           )
                        
                      are linear, then the complexity of the proposed algorithm is 
                        
                           O
                           (
                           V
                           log
                           (
                           V
                           )
                           )
                        
                      for both encoding and decoding. The Tables 2 and 3
                     
                      report the times required for encoding and decoding. The reported times show that our algorithm is indeed slower than the competing algorithms, yet the complexity remains feasible.

Should the encoding and/or decoding time pose a problem for applicability of the proposed algorithm, then it is possible to speed the algorithm up at the cost of sacrificing some of the compression performance. Table 4
                      shows that a majority of bytes 
                        
                           (
                           >
                           98
                           %
                           )
                        
                      is spent to encode the basis level (i.e. the normal Laplacian coordinates) and the first level of the hierarchy. Therefore by omitting the prediction for higher levels of the hierarchy, one can speed the algorithm up while impairing the compression performance only marginally. In such case the system is going to be solved only twice at the decoder, yielding a performance that is no more than twice slower than the HPC. Another possibility of improving the processing times would naturally be to carefully optimise the code.

Finally, Fig. 9
                      shows that the improvement achieved by our scheme is well visible in realistic situations. Our scheme provides a good performance in both absolute error (in contrast with HPC) and perceptual error (in contrast with traversal based algorithms). It is also interesting to note that visually, our result in Fig. 9 seems better than the one by HPC, although the measured perceptual distance is roughly equal in both FMPD and DAME. This seems to indicate that there exists a practical kind of artifacts that are well perceivable, yet not detected by these perceptually motivated metrics. It would be interesting to perform a subjective experiment involving the compression results similar to the ones depicted here, that would confirm our hypothesis.

@&#CONCLUSIONS@&#

We have demonstrated that by adding a support structure of additional equations it is possible to construct an algorithm that provides excellent results both in terms of perceived and absolute distortion. Results provided by our compression scheme are visibly better than those of the state of the art, and this conclusion is supported by the measured values.

The construction of intermediate reconstructions leads to an increase in running time, which is however only of order 
                           
                              O
                              (
                              log
                              (
                              V
                              )
                              )
                           
                         with respect to HPC. The algorithm running time remains within practical range.

In the future, we intend to focus on improving the performance of the algorithm, both in terms of efficient compression, as well as fast execution. We believe that the result of intermediate reconstructions can be used to accelerate the solution in the later steps, thus speeding the algorithm up.

Another topic of future research is the possibility of encoding the values in reversed order, which would allow the user to display an intermediate decompressed mesh even before the whole data stream has been decoded. Such feature is available in our implementation as well, however, the first approximation is only available after the data from the lowest level (which take up the largest part of the stream) are decoded. Reversing the order of encoding would allow displaying an intermediate reconstruction much sooner, however, the influence of such change on the compression performance is to be investigated.

Finally, our results seem to indicate that the used perceptual metrics fail to correctly evaluate the amount of perceived distortion in some cases. It is an interesting pointer for future research to confirm this by a statistically justified subjective experiment. We also believe that the character of the proposed compression method and the proposed hierarchical Laplacian may also be used as a starting point in search for a better error metric.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the European Regional Development Fund (ERDF), Project “NTIS – New Technologies for the Information Society”, European Centre of Excellence, CZ.1.05/1.1.00/02.0090, and by the UWB Grant SGS-2013-029 Advanced Computer and Information Systems (Pokročilé výpočetní a informační systémy).

@&#REFERENCES@&#

