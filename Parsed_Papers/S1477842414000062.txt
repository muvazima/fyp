@&#MAIN-TITLE@&#Model checking XSL transformations

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We develop a framework to model XSL transformations and XML Schema constraints.


                        
                        
                           
                           We use model checking to verify the correctness of XSL transformations.


                        
                        
                           
                           We provide a tool for XSL verification, including an advanced error reporting.


                        
                        
                           
                           We show how to interactively check and fix XSL transformations in our framework.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

XML technologies

XSLT language

Software verification

Model checking

@&#ABSTRACT@&#


               
               
                  The XSLT language is key technology to develop software which manipulates data encoded in XML, a versatile formalism widely adopted for information description and exchange. This motivates the adoption of formal techniques to certify the correctness (with respect to the expected output) and robustness (e.g., tolerance to malformed inputs) of the XSLT code. Unfortunately, such code cannot be validated using only static approaches (i.e., without executing it), due to the complexity of the XSLT formalism. In this paper we show how a software verification technology, namely the model checking, can be adapted to obtain an effective and easy to use XSLT validation framework. The core of the presented methodology is the XSLToMurphi algorithm, which is able to build a formal model of an XSLT transformation, suitable to be verified through the CMurphi tool.
               
            

@&#INTRODUCTION@&#

The eXtensible Markup Language (XML) [1] is a flexible tagged text format derived from the Standard Generalised Markup Language (SGML) [2], proposed in 1996 by the W3C Consortium [3] as a tool to standardise the format of all the documents used on the Web and to meet the challenges of large-scale electronic publishing. The XML language is extremely simple and versatile: the information is organised in a tree-structured fashion, which is both human readable and machine processable.

This W3C proposal had immediate success, becoming a de facto standard, and it is now being widely adopted for the description and the manipulation of data. Indeed, XML documents represent data structures in a clear, cross-platform and open format, which is ideal for the Web. This trend has been further pushed by the fact that applications can easily manipulate XML-structured data using specialised tools and languages like the XSL Transformations (XSLT [4]).

XSLT is a key technology for accessing XML data: indeed, by using XSLT it is possible to
                        
                           •
                           Perform complex data manipulation that would traditionally require server side programming.

Transform XML data in any text or XML based format.

Achieve a strong separation between the data and its representation, which could be otherwise obtained only using methodologies like the HTML templates [5,6].

These features make XSLT suitable to many scenarios, like data manipulation and presentation in XML databases [7–12], publishing of XML data through XHTML [13] or XSL-FO [14,15] and conversion between XML data structures [7,16–18]. Moreover, the introduction of XML-based standards in many research communities led to the adoption of XSLT for data manipulation tasks that were previously performed using traditional programming languages: for example, the XMI [19] standard made XSLT transformations a powerful tool in the software engineering field [20–22].

More recently, in XML databases, new languages like XQuery [23] are being used to perform XML data manipulation and transformation. XQuery and XSLT have the same expressive power, so both formalisms can be used alternatively [24].

@&#MOTIVATION@&#

XSLT is a powerful and widely used XML technology, and this motivates the adoption of the highest quality standards in the design and development of XSL transformations. This, in turn, implies big efforts to optimise the XSLT processing performances [25] and to check the correctness of XSLT transformations, i.e., verify that the transformation output has the expected format and properties.

In general, certifying the correctness of a system requires some kind of formal proof. Indeed, manually checking a system against a set of test cases, as it is usually done in the common programming practice, does not ensure that it would perform as expected in any situation. On the other hand, a formal proof guarantees that the system will always behave as specified.

The formal checking of XSLT has been already addressed in the literature: most of the current works (see Section 8) validate XSL transformations using static approaches like type checking or flow analysis, where the code is statically analysed without executing it. In the software/hardware programming practice, such kinds of approaches are always the best choice, when applicable, since they are usually very fast and effective: for instance, strictly typed programming languages prevent the user from making a lot of common mistakes.

However, often the code complexity makes such techniques not suitable for the complete formal validation of an application׳s behaviour. Indeed, when applied on complex code structures, the static source analysis often requires too much resources or turns out to be very approximated. These considerations are also valid for XSLT validation, due to the complexity of the XSLT/XPath constructs. Indeed, XSLT is Turing complete [26], so we know that its static validation is mathematically undecidable.

An answer to the static validation problems above comes from model checking: if we cannot certify that a given code is correct by statically reasoning on its structure, we can run (a suitably simplified model of) it and dynamically analyse its behaviour.

In particular, model checking techniques are used to exhaustively verify a system by automatically checking all its possible states against a set of user-defined assertions. The result of this verification is a certification that has the same value of a formal proof of correctness.

Indeed, model checking is being widely adopted in the development of critical systems, like embedded hardware [27], as well as in the verification of code written in statically typed programming languages, such as Java [28–30]. In other words, an effective framework that results in complete, in-depth code verification requires the integration of different, static and dynamic techniques, such as type checking and model checking.

To this aim, in this paper we show how model checking can be applied to XSLT validation. In particular, we describe the design and implementation of a complete model checking based XSLT verification process. The core of this process is the XSLToMurphi algorithm, which is able to translate XSLT stylesheets into models that can be verified through the CMurphi tool [31].

By exploiting techniques designed to handle large-scale software systems, our model checking approach can better deal with the complexity of the XSLT formalism, thus achieving a more precise and complete validation while keeping the whole process under reasonable complexity limitations.

Moreover, our approach is also able to check the transformation robustness, i.e., verify if it handles correctly (small) deviances from the expected input structure, and generate detailed descriptions of the input sequences that lead to transformation errors, to possibly detect and block them at runtime.

Finally, to make our approach suitable to real-world development processes, we designed it to be completely automatic and accessible to non-experts, too. Indeed, the underlying methodology is completely hidden to the user, and the validation outcome is either a success message or a set of clear and detailed “debugger-style” error messages that can be effectively used to locate and fix the transformation errors.

The paper is organised as follows. Section 2 gives a brief introduction to the main elements of XSLT and their semantics, whereas Section 3 introduces the model checking techniques and, in particular, the CMurphi model checker. Section 4 describes how model checking can be adapted to validate XSLT stylesheets and Section 5 shows the XSLToMurphi algorithm that implements the core of XSLT model checking. Section 6 shows our XSLT model checking process working on a case study, whereas Section 7 illustrates and discusses the tool experimentation. Finally, Section 8 offers an overview on the XSLT validation works in the current literature and Section 9 outlines the paper conclusions and illustrates our planned future work on XSLToMurphi.

The eXtensible Stylesheet Language Transformations (XSLT) is a W3C recommendation [4] and, in general, is used to transform an XML document into another XML document. This is done by defining transformation rules that describe the XML markup to be generated when certain elements are found in the transformation input. XSLT not only has a functional flavour, but also contains many common programming constructs like loops, conditional expressions and parametric function calls. All these statements make use of expressions written in the XPath query language [32].

Roughly speaking, XPath views the XML document as a set of nodes. Nodes represent the document elements, attributes, comments, text fragments, etc. and are connected through relations called axes (e.g., child, attribute, parent, etc.). An XPath expression is composed of a sequence of steps: each step selects the set of nodes that are on a specific axis w.r.t. the current node(s) and satisfy both a node test (e.g., a particular element name) and an optional filter (usually a predicate on the node contents and relations). The nodes selected by a step become the current nodes for the following one, and those selected by the last path step are the expression result.

Note that in this paper we will refer to XSLT 1.0 syntax: indeed, newer versions do not introduce interesting changes to the core XSLT formalism. Most notably, an enhanced support for XML Schema [33] types has been added in XSLT 2.0. However, its aim is only to allow type checking of result documents, whereas XSLT validation aims at validating all the possible stylesheet outputs once for all by analysing the stylesheet itself.

In the following we give a short description of the XSLT 1.0 formalism, enough to understand the model checking algorithm presented in this paper. Moreover, we will also make references to structures and semantics of the XML Schema formalism that are tightly related with some aspects of XSLT and required for its validation. The interested reader may refer, e.g., to [4] and [33] for a complete specification of these formalisms and their semantics.


                     Templates: The stylesheet consists of a sequence of transformation procedures, called templates, each defined inside a 
                        
                      element. The 
                        
                      attribute is used to associate a template with a class of XML elements through XPath pattern matching.

A simple XSLT document is shown in Fig. 1
                     , where four templates are defined: the first matches the document root, indicated by the XPath “/”, whereas the second and third templates match elements named b and elements c inside elements a (XPath “a/c”), respectively. The last template in Fig. 1 has no 
                        
                      attribute, but has a 
                        
                      (i.e., “footer”). In this case, the template is not associated with a specific element but can be explicitly called at any point of the transformation.


                     Output: The basic rule for the template interpretation is that anything in the template code which is not recognised as a part of the XSLT language must be output as it is: this happens, e.g., to the HTML string “
                        <
                        b
                        >
                        Found
                        
                        a
                        
                        B
                        :
                        <
                        /
                        b
                        >
                     ” in the second template of Fig. 1.

Moreover, the 
                        
                      element can be used to output data extracted or calculated from the source document using XPath: for instance, both the 
                        
                      in Fig. 1 output the textual value of the current node.


                     Template calls: Templates can call each other just like program subroutines. Calls can be by name, i.e., by specifying the template name through the 
                        
                      instruction and optionally passing parameters to it, or (more interestingly) by match. In the latter case, triggered by the 
                        
                      instruction, the stylesheet interpreter finds the most suitable template for a given node (or for every node in a given set) using XPath pattern matching. This not only makes the XSLT formalism very modular and versatile, but also introduces an execution complexity that may quickly make a stylesheet very hard to understand. In the example of Fig. 1, the main template issues an 
                        
                     . Therefore, every child of the root element a that is called b or c is passed (in document order) to the template that better matches it.

When a call is issued, the template status is pushed in the execution stack and restored when the control returns to the caller. The XSLT execution status, besides the current instruction pointer, includes two important values: the current 
                        
                     , used to further characterise the available templates, and the current position within the source document, i.e., the pointer to the current input of the transformation.


                     Loops: Loops in XSLT are accomplished using the 
                        
                      instruction, which executes the nested fragment of code using each of the nodes selected by an XPath expression as the current context. In Fig. 1, 
                        
                      is used to iterate on all the e elements nested inside a d element.


                     Conditionals: Conditional execution of template fragments is also possible through the 
                        
                      and 
                        
                      constructs, which behave as the common if and switch statements of many imperative languages. Here, however, the conditions are always expressed as XPath expressions. A 
                        
                      is used in the third template of Fig. 1 to execute a block of code only if the current element contains a child called d; otherwise, the HTML string “
                        <
                        i
                        >
                        …
                        no
                        
                        nested
                        
                        D
                        <
                        /
                        i
                        >
                     ” is output.

The XSLT language contains other minor constructs that we shall not address in detail here, such as variables, stylesheet inclusion statements, XML copy statements. Many of these constructs are indeed syntactic sugar that does not need special support.

To conclude our brief presentation of the XSLT formalism, we should note how this language contains the complete set of basic primitives of an imperative language, tailored for the manipulation of XML data structures. Even if the language itself is small, stylesheets written with XSLT can have a complex dynamics, especially due to the extensive use of pattern matching. Therefore, (model) checking XSL transformations is not a trivial task.

Generally speaking, model checking [34–39] can be defined as the formal process of verifying the validity of a set of assertions on the (formal) model of a (software) system. Model checking is applied in a scenario like the one depicted in Fig. 2
                     .

Given a software or a hardware system, we derive from it a system model, i.e., a suitable abstraction of the system functionalities that we want to verify. This is the most critical step of the whole process: indeed, the model should correctly reflect the system while simplifying it to remove all the details that are not of interest for the verification purposes. Failing to satisfy both these requirements would result in a verification whose outcome is not applicable to the real system or in a highly resource-consuming process. Most of the times, the system-to-model step is performed by hand: this means that the model checking techniques are available only to modelling experts, while remaining exposed to human errors.

After the model has been built, the system functional (e.g., correct event handling, absence of deadlocks, etc.) and non-functional (e.g., safety, performances, etc.) requirements are translated in an appropriate verifier-specific language (typically using logic statements). These constraints are fed to the verifier together with the model.

After some computation, the verifier exits with (1) a certification of the system correctness w.r.t. the given constraints, or (2) a counterexample (error trace) showing how the system can violate one of the constraints.

More formally, model checking tools verify a given set of constraints on all the reachable states in the transition graph of a system. The interested reader can refer, e.g., to [34–37] for further technical information on model checking algorithms.

The proof of correctness obtained through automatic verification makes the model checking techniques very appealing when the application is too complex to be statically proved as correct (e.g., by code analysis) or fully tested and/or it is used in a critical environment. On the other hand, the verification process can have very high resource requirements (i.e., memory and time) and the modelling phase usually requires the work of domain experts. However, a growing availability of low-cost hardware and high performance CPUs makes today the modelling phase the real obstacle to the adoption of model checking, especially in the design of non-critical software. Therefore, even if model checking can potentially help many kind of development processes, at present it is considered a low-level technique to be used only on a very small set of applications.

For our verification purposes, in this paper we will adopt the CMurphi tool [31], an extended version of the Murφ 
                        [38] model checker, originally developed to verify protocol-like systems. We choose CMurphi as our target verifier since its code is very easy to customise and it has the ability to use externally defined C/C++ functions in the modelling language. In this way, we can use the C/C++ language constructs to model the most complex aspects of the XSL transformation.

From a conceptual point of view, the CMurphi verifier takes as input a finite state system, described through a collection of constants, types, variables, functions and rules, and checks that a given set of invariant properties is satisfied in all the reachable states of the system.

The native CMurphi description language is a high-level programming language that embeds many constructs found in well known languages such as Pascal or C, e.g., user-defined data types, procedures, loops and conditional instructions.

The first step to describe a (software) system in CMurphi is to define the system global variables. The values of these variables must uniquely determine the current state of the system: indeed, global variables are usually addressed as state variables. The start state of the system is defined by declaring the initial values of all the state variables.

The system to be verified is then modelled through a set of language constructs called (transition) rules. Each rule consists of a block of code, that is the action which generates the next state when the rule is executed, and a guard, i.e., a boolean condition (usually based on the state variables) that determines the activation of the rule.

Finally, the constraints to be checked during the verification are declared through boolean expressions (that can have any complexity and call external functions, too) involving the state variables, called invariants. The verifier checks the invariants in the start state and each time a rule is activated generating one or more new states.

It is worth noting that CMurphi applies a number of strategies to decrease the resources needed to complete the verification task, in particular the required memory. For example, CMurphi can apply both bit compression 
                        [38] and hash compaction 
                        [40,41] and exploit the use of disk storage and state space caching [42].

In the following section of the paper we will illustrate a technique and a tool that allow to perform model checking on XSL transformations.

Model checking is usually applied to verify that a system always behaves as specified. In our case, the system is coded in the XSLT language. We may also have a formal description of the input the transformation is supposed to work on, given by a schema that defines the class of valid input documents. In this situation, we may want to embed the schema information in the transformation model to prune the transition graph by eliminating transitions due to invalid input sequences. However, we may also choose to ignore this information to check the robustness of the transformation against malformed inputs.

The behaviour of an XSL transformation can be defined in two ways:
                        
                           1.
                           From a programmer point of view, by checking that certain portions of code are executed in a given way and only in particular conditions (execution constraints);

From an end-user point of view, by checking that the transformation output respects the user׳s expectations (output constraints).

Execution constraints are at the heart of a growing number of XSLT checking tools that actually work as XSLT debuggers (see Section 8), i.e., they allow to track the XSLT engine internal actions, the control flow, etc.

On the other hand, output constraints are, in some sense, the most important in our context since they deal with the transformation visible result, i.e., what the user actually sees. In our framework, such constraints will be defined using the XML Schema language. This choice has many clear advantages: first, the XML Schema formalism should be already familiar to everyone using XSLT; second, an XML Schema is usually available for many widely used formalisms.

Therefore, although our framework also supports the specification of some kinds of execution constraints (using a specific XML-based language), for the reasons explained above, in the rest of the paper we will concentrate on the more interesting output constraints.


                     Fig. 3
                      shows how the general model checking process of Fig. 2 is applied in the XSLT context. In particular, the stylesheet code and an optional XML schema specifying the input grammar form the system to be verified, which is modelled within the verifier. The assertions to be verified are obtained from the schema of the expected transformation output.

The verification output is, in this case, the certification of a valid transformation with respect to the output schema.

The first step to encode an XSL transformation in CMurphi is to model the transformation process as a finite state system (FSS), since explicit model checking algorithms work only on this kind of systems. Therefore, in this section we briefly illustrate how the XSLT behaviour can be formally expressed in a FSS.

It is worth noting that, for model checking to be applied, we must adopt a concrete, operational view of the XSLT execution. This is obviously in contrast with the abstract, functional XSLT behaviour given by its specification, since it has to “fix” some choices, e.g., the evaluation order. However, XSLToMurphi, exploiting the model checking capabilities, tries to minimise this issue being mostly “XSLT implementation neutral” when dealing with the XSLT statements semantics. Indeed, it tries to check all the possible stylesheet behaviours, which may include, e.g., different evaluation orders.

First of all, let us briefly define a convenient formalism to represent (partial) XML trees. Since a complete formalisation of XML is out of the scope of the present paper, here we exploit a simple representation, which can be viewed as the result of a depth-first visit of the XML tree, where each element is indicated by the corresponding tag name and the children of a node are reported after it, enclosed in parentheses. Thus, for example, the expression 
                           a
                           (
                           b
                           ,
                           c
                           (
                           d
                           (
                           e
                           )
                           )
                           )
                         represents an XML document fragment rooted in a, with two children b and c: the former is empty, whereas the latter contains an element d which in turn contains an empty element e. Note that, for the sake of simplicity, we omit the textual content of elements here.

However, we also need to represent partial knowledge about XML trees. To this aim, we introduce the wildcard ?, which can be used to represent any sequence (also an empty one) of XML (sub)trees. Thus, we write 
                           ?
                           (
                           a
                           ,
                           b
                           (
                           c
                           (
                           ?
                           )
                           ,
                           d
                           )
                           )
                         to represent a partial XML tree which derives from an unknown XML tree (the first ?) and contains in turn an unknown list of subtrees, children of the c node (the second ?).

Finally, we need to mark a special node in the XML tree, called the current node, which will be used to represent the input position of the XSL transformer. Such a node will be indicated with an overline, e.g., 
                           c
                           (
                           
                              
                                 f
                              
                              
                                 ¯
                              
                           
                           (
                           ?
                           )
                           ,
                           ?
                           )
                         is an XML tree rooted at c, with a child f, which is the current node and has unknown content, possibly followed by other unknown children. We define three operations on XML trees: test, select and match. 
                           Definition 1
                           Let 
                                 h
                                 ,
                                 h
                                 ′
                               be two XML trees.
                                 
                                    •
                                    
                                       
                                          test
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                        is true iff 
                                          h
                                          ′
                                        can be merged with a child of the current node of h. Two XML (sub)trees can be merged iff they can be rewritten to the same tree by substituting arbitrary XML trees to each of their wildcards.


                                       
                                          select
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                        is the XML tree obtained by merging 
                                          h
                                          ′
                                        with a child of the current node of h, as described in the previous point. The current node of the resulting XML tree will be the current node of 
                                          h
                                          ′
                                       . If more merges can be performed, we always select the one which requires less instantiation (i.e., has more “?” wildcards). If there is more than one merge with minimal instantiation, we choose the first one (i.e., the leftmost in the XML tree expression, or the first in XML document order). If the XML trees cannot be merged, i.e., 
                                          ¬
                                          test
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                       , the result is undefined.


                                       
                                          match
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                        is true iff the current node of 
                                          h
                                          ′
                                        can be merged to the current node of h.

Let 
                                 h
                                 =?
                                 (
                                 a
                                 ,
                                 
                                    
                                       b
                                    
                                    
                                       ¯
                                    
                                 
                                 (
                                 c
                                 (
                                 ?
                                 )
                                 ,
                                 d
                                 )
                                 )
                               and 
                                 h
                                 ′
                                 =
                                 c
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       ¯
                                    
                                 
                                 (
                                 ?
                                 )
                                 ,
                                 ?
                                 )
                              . Then,
                                 
                                    •
                                    
                                       
                                          test
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                        holds since 
                                          h
                                          ′
                                        can be merged with the first child 
                                          c
                                          (
                                          ?
                                          )
                                        of the current node 
                                          
                                             
                                                b
                                             
                                             
                                                ¯
                                             
                                          
                                        of h by substituting 
                                          
                                             
                                                f
                                             
                                             
                                                ¯
                                             
                                          
                                          (
                                          ?
                                          )
                                          ,
                                          ?
                                        for its child wildcard.

Since 
                                          test
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                        holds, we can calculate 
                                          select
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                          =?
                                          (
                                          a
                                          ,
                                          b
                                          (
                                          c
                                          (
                                          
                                             
                                                f
                                             
                                             
                                                ¯
                                             
                                          
                                          (
                                          ?
                                          )
                                          ,
                                          ?
                                          )
                                          ,
                                          d
                                          )
                                          )
                                       .

Finally, we have that 
                                          ¬
                                          match
                                          (
                                          h
                                          ,
                                          h
                                          ′
                                          )
                                       . However, if we change the current nodes so that 
                                          h
                                          =?
                                          (
                                          a
                                          ,
                                          b
                                          (
                                          
                                             
                                                c
                                             
                                             
                                                ¯
                                             
                                          
                                          (
                                          ?
                                          )
                                          ,
                                          d
                                          )
                                          )
                                        and 
                                          h
                                          ′
                                          =
                                          
                                             
                                                c
                                             
                                             
                                                ¯
                                             
                                          
                                          (
                                          f
                                          (
                                          ?
                                          )
                                          ,
                                          ?
                                          )
                                       , then the match relation would hold.

Given an XPath x, we indicate with XMT(x) the smallest set of partial XML trees that represent all the possible matches of x. The current node of such XML trees is the XML element pointed by x.

As an example, the XPath 
                           a
                           /
                           b
                           /
                           c
                         would match any (sub)tree rooted in a, which contain at least a child b which, in turn, contains at least a child c. Thus, 
                           XMT
                           (
                           a
                           /
                           b
                           /
                           c
                           )
                           =
                           {
                           
                              a
                              (
                              ?
                              ,
                              b
                              (
                              ?
                              ,
                              
                                 
                                    c
                                 
                                 
                                    ¯
                                 
                              
                              (
                              ?
                              )
                              ,
                              ?
                              )
                              ,
                              ?
                              )
                           
                           }
                        . In the same way, 
                           XMT
                           (
                           a
                           [
                           b
                           /
                           c
                           ]
                           )
                           =
                           {
                           
                              
                                 
                                    a
                                 
                                 
                                    ¯
                                 
                              
                              (
                              ?
                              ,
                              b
                              (
                              ?
                              ,
                              c
                              (
                              ?
                              )
                              ,
                              ?
                              )
                              ,
                              ?
                              )
                           
                           }
                         and 
                           XMT
                           (
                           a
                           [
                           b
                           ]
                           /
                           c
                           ]
                           )
                           =
                           {
                           
                              a
                              (
                              ?
                              ,
                              b
                              (
                              ?
                              )
                              ,
                              ?
                              ,
                              
                                 
                                    c
                                 
                                 
                                    ¯
                                 
                              
                              (
                              ?
                              )
                              ,
                              ?
                              )
                              ,
                              a
                              (
                              ?
                              ,
                              
                                 
                                    c
                                 
                                 
                                    ¯
                                 
                              
                              (
                              ?
                              )
                              ,
                              ?
                              ,
                              b
                              (
                              ?
                              )
                              ,
                              ?
                              )
                           
                           }
                        .

Now we can recall the definition of finite state system and connect it to the XSLT behaviour and to the XML trees. 
                           Definition 3
                           A finite-state system (FSS) is a 4-tuple 
                                 (
                                 S
                                 ,
                                 I
                                 ,
                                 δ
                                 ,
                                 R
                                 )
                               where
                                 
                                    •
                                    
                                       S is a finite set (of states),


                                       I is the set of initial states,


                                       A is a finite set (of transition labels),


                                       δis a relation on S×A×S, which is usually called the transition relation.

To formally define the FSS for an XSL stylesheet, we must start by describing its states. Each state 
                           s
                           ∈
                           S
                         is a tuple 
                           s
                           =
                           (
                           p
                           ,
                           m
                           ,
                           h
                           ,
                           s
                           )
                         where
                           
                              •
                              
                                 
                                    p
                                    ∈
                                    Pos
                                  is the execution position. We write code(p) to indicate the XSL instruction at position p. We assume that Pos also contains the distinct “end of stylesheet” position, which we shall indicate with STY_END.


                                 
                                    m
                                    ∈
                                    Modes
                                  is the current execution mode. We assume that Modes also contains the “undefined mode” 
                                    ⊥
                                 , which is the default mode for XSL execution.


                                 h is the current input horizon, i.e., a (possibly partial) XML tree whose current node represents the input cursor position.


                                 
                                    s
                                    =
                                    〈
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          m
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    
                                       
                                          〉
                                       
                                       
                                          i
                                       
                                    
                                  is the execution stack. Each triple in the stack is called entry and is composed of a code position, a mode and a horizon.

The initial state of a stylesheet-FSS is 
                           
                              
                                 
                                    
                                       s
                                    
                                    
                                       0
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       begin
                                    
                                 
                                 ,
                                 ⊥
                                 ,
                                 h
                                 ,
                                 ∅
                                 )
                              
                           
                        where the current position is the main template starting position, denoted by M
                        
                           begin
                        , the current mode is undefined, the stack is empty and h is either a fully unspecified XML tree (i.e., ?) or something more detailed, depending on the input structure hints given by the optional input schema.

Given the definition above, to keep S finite, we must make some considerations:
                           
                              •
                              Since the stylesheet represented by the FSS is always limited, then the number of valid execution positions is finite, thus Pos is finite.

In the same way, the number of modes used in the stylesheet represented by the FSS is always limited (as modes may appear only on certain statements) thus Modes is finite.

The size of the input XML tree must be limited. To this aim, we assume a bound on the tree height (i.e., the maximum element element nesting allowed) of K
                                 
                                    ih
                                 , on the node degree (i.e., the maximum number of children for an element) of K
                                 
                                    id
                                  and on the node name (i.e., the tag length) of K
                                 
                                    it
                                 . As an example, setting 
                                    
                                       
                                          K
                                       
                                       
                                          id
                                       
                                    
                                    =
                                    100
                                 , 
                                    
                                       
                                          K
                                       
                                       
                                          ih
                                       
                                    
                                    =
                                    100
                                  and 
                                    
                                       
                                          K
                                       
                                       
                                          it
                                       
                                    
                                    =
                                    10
                                  should be enough to contain XHTML documents as well as XML documents written in many other widespread XML grammars.

Finally, we set the maximum execution stack depth to K
                                 
                                    sd
                                 , which is a user-specified mandatory parameter of the verification process. In the XSLT practice, a stack depth of 10 would be enough to fit the most complex stylesheet. This, together with the finiteness of each stack entry (derived from the limits on its components discussed above), makes the execution stack finite.

The restrictions above represent the basis of our abstraction of the real XSL transformation. As described in Section 3, a model should correctly reflect the system while simplifying it to remove all the details that are not of interest for the verification purposes. Thus, abstraction is needed to focus the aspects to verify while simplifying the system in order to avoid unnecessary complexity. In particular, the approximations to the stylesheet state we just discussed are enough to have a finite state space, that is also small enough to be effectively handled by an automatic tool. On the other hand, the ability of model checking algorithms to handle very large models allows us to limit the abstraction level (i.e., impose only realistic restrictions, as noted above) and create realistic models.

Transition labels A are XML trees. We say that an XML tree 
                           h
                           ′
                         is enabled on a state with horizon h if and only if 
                           test
                           (
                           h
                           ,
                           h
                           ′
                           )
                         holds. Then, for any state 
                           t
                           =
                           (
                           p
                           ,
                           m
                           ,
                           h
                           ,
                           s
                           )
                           ∈
                           S
                         and any label 
                           h
                           ′
                           ∈
                           A
                        , if 
                           h
                           ′
                         is not enabled on s (
                           ¬
                           test
                           (
                           h
                           ,
                           h
                           ′
                           )
                        ), then 
                           δ
                           (
                           t
                           ,
                           h
                           ′
                           )
                           =
                           t
                        , i.e., the transition does not change the FSS state. Otherwise, the value 
                           δ
                           (
                           t
                           ,
                           h
                           ′
                           )
                         depends on the instruction code(p) as follows.


                        Conditionals: Let 
                           code
                           (
                           p
                           )
                           =
                           
                              
                                 
                              
                           
                         and let 
                           p
                           ′
                         be the execution position of the instruction immediately following the “choose” block. Moreover, let B
                        
                           begin
                        , B
                        
                           end
                        , 
                           B
                           
                              
                                 ′
                              
                              
                                 begin
                              
                           
                         and 
                           B
                           
                              
                                 ′
                              
                              
                                 end
                              
                           
                         be the execution positions of the first and the last instruction of the inner blocks B and 
                           B
                           ′
                        , respectively, then for any XML tree 
                           h
                           ′
                         
                        
                           
                              
                                 δ
                                 (
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             (
                                             
                                                
                                                   B
                                                
                                                
                                                   begin
                                                
                                             
                                             ,
                                             m
                                             ,
                                             h
                                             ,
                                             s
                                             )
                                             ,
                                          
                                          
                                             h
                                             ′
                                             ∈
                                             XMT
                                             (
                                             x
                                             )
                                          
                                       
                                       
                                          
                                             (
                                             B
                                             
                                                
                                                   ′
                                                
                                                
                                                   begin
                                                
                                             
                                             ,
                                             m
                                             ,
                                             h
                                             ,
                                             s
                                             )
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 δ
                                 (
                                 (
                                 
                                    
                                       B
                                    
                                    
                                       end
                                    
                                 
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 δ
                                 (
                                 (
                                 B
                                 
                                    
                                       ′
                                    
                                    
                                       end
                                    
                                 
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 (
                                 p
                                 ′
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                              
                           
                        
                     

Note that 
                           
                         statements are translated similarly, as a 
                           
                         with a single 
                           
                         and no 
                           
                        .


                        Template calls: Let 
                           code
                           (
                           p
                           )
                           =
                           
                              
                                 
                              
                           
                         and let 
                           p
                           ′
                         be the execution position of the instruction immediately following the “apply-templates” block. Moreover, let 
                           
                              
                                 T
                              
                              
                                 start
                              
                           
                           ,
                           
                              
                                 T
                              
                              
                                 end
                              
                           
                        , and 
                           
                              
                                 T
                              
                              
                                 mode
                              
                           
                         be the first instruction position, the last instruction position, and the mode of a template T, respectively. Then, for any XML tree 
                           h
                           ′
                           ,
                           h
                           ″
                         
                        
                           
                              
                                 δ
                                 (
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 {
                                 
                                    
                                       
                                          
                                          
                                             h
                                             ′
                                             ∈
                                             XMT
                                             (
                                             x
                                             )
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   T
                                                
                                                
                                                   begin
                                                
                                             
                                             ,
                                             m
                                             ′
                                             ,
                                             select
                                             (
                                             h
                                             ,
                                             h
                                             ′
                                             )
                                             ,
                                             s
                                             ·
                                             〈
                                             (
                                             p
                                             ,
                                             m
                                             ,
                                             h
                                             )
                                             〉
                                             )
                                             ,
                                          
                                          
                                             ∧
                                             ∃
                                             T
                                             |
                                             (
                                             match
                                             (
                                             select
                                             (
                                             h
                                             ,
                                             h
                                             ′
                                             )
                                             ,
                                             
                                                
                                                   T
                                                
                                                
                                                   match
                                                
                                             
                                             )
                                          
                                       
                                       
                                          
                                          
                                             ∧
                                             m
                                             ′
                                             =
                                             
                                                
                                                   T
                                                
                                                
                                                   mode
                                                
                                             
                                             )
                                          
                                       
                                       
                                          
                                             (
                                             p
                                             ′
                                             ,
                                             m
                                             ,
                                             h
                                             ,
                                             s
                                             )
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In other words, if there exists an XML tree 
                           h
                           ′
                         matching x and a template with the required mode whose 
                           
                         attribute matches the XML tree obtained by merging the current horizon with 
                           h
                           ′
                        , then we push in the stack the current execution information and jump to that template. Otherwise, we continue with the normal execution flow.

Moreover, we define the “template end” transitions as follows: 
                           
                              
                                 δ
                                 (
                                 (
                                 
                                    
                                       T
                                    
                                    
                                       end
                                    
                                 
                                 ,
                                 m
                                 ′
                                 ,
                                 h
                                 ′
                                 ,
                                 s
                                 ·
                                 〈
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 )
                                 〉
                                 )
                                 ,
                                 h
                                 ″
                                 )
                                 =
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                              
                           
                        
                        
                           
                              
                                 δ
                                 (
                                 (
                                 
                                    
                                       T
                                    
                                    
                                       end
                                    
                                 
                                 ,
                                 m
                                 ′
                                 ,
                                 h
                                 ′
                                 ,
                                 ∅
                                 )
                                 ,
                                 h
                                 ″
                                 )
                                 =
                                 (
                                 STY
                                 _
                                 END
                                 ,
                                 m
                                 ′
                                 ,
                                 h
                                 ′
                                 ,
                                 ∅
                                 )
                              
                           
                        where states marked with the code position STY_END represent the final states of our FSS. In other words, when a template ends we restore the last execution information from the stack and continue from there. If the stack is empty, then the stylesheet execution ends.


                        Loops: Let 
                           code
                           (
                           p
                           )
                           =
                           
                              
                                 
                              
                           
                         and let 
                           p
                           ′
                         be the execution position of the instruction immediately following the “for-each” block. Then, for any XML tree 
                           h
                           ′
                         
                        
                           
                              
                                 δ
                                 (
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             (
                                             
                                                
                                                   B
                                                
                                                
                                                   begin
                                                
                                             
                                             ,
                                             m
                                             ,
                                             select
                                             (
                                             h
                                             ,
                                             h
                                             ′
                                             )
                                             ,
                                             s
                                             )
                                             ,
                                          
                                          
                                             h
                                             ′
                                             ∈
                                             XMT
                                             (
                                             x
                                             )
                                          
                                       
                                       
                                          
                                             (
                                             p
                                             ′
                                             ,
                                             m
                                             ,
                                             h
                                             ,
                                             s
                                             )
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 δ
                                 (
                                 (
                                 
                                    
                                       B
                                    
                                    
                                       end
                                    
                                 
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                                 ,
                                 h
                                 ′
                                 )
                                 =
                                 (
                                 p
                                 ,
                                 m
                                 ,
                                 h
                                 ,
                                 s
                                 )
                              
                           
                        
                     

The second step to verify an XSL transformation is to encode the output constraints given by an XML Schema in a way that can be understood by a model checker such as CMurphi.

In particular, CMurphi supports checking of safety properties (i.e., “something bad never happens”), called invariants, written as first-order logic formulas. Giving details about the formalism actually used to express safety properties is beyond the scope of the present paper, thus in this Section we will restrict our attention to some interesting examples.

Roughly speaking, we need to derive from the schema declarations a set of logic formulas that must be never satisfied for the transformation output to be correct. These formulas will be checked in every state of the transformation FSS, and the verifier will stop and generate a counterexample (see Section 6) if at least one property is satisfied.


                        Fig. 4
                         shows a simple XML Schema. Let us focus on the first declaration, which can be read as “the element p can contain zero or more of the elements b and i , in any order”.

To express this property as a logic formula, we first need to define some support predicates that can be evaluated in each state of the FSS:
                           
                              •
                              
                                 E
                                 
                                    in
                                  means that the current output is directly nested inside an element E, which we shall call the current parent.


                                 E
                                 
                                    open
                                  and E
                                 
                                    close
                                  mean that the element E is being opened and closed, respectively. It is clear that E
                                 
                                    in
                                  could be expressed by an appropriate formula using E
                                 
                                    open
                                  and E
                                 
                                    close
                                  but here, for the sake of simplicity, we assume it to be given.


                                 E
                                 
                                    n
                                  means that the n-th child of the current parent is E.

It is worth noting that the limitations given in Section 4.1 for the XML trees apply also in this case, so the number of predicates above is always finite.

Now we can write the formula that must not be true in any state of the FSS: 
                           
                              
                                 
                                    
                                       
                                          p
                                       
                                    
                                    
                                       in
                                    
                                 
                                 ∧
                                 (
                                 ∃
                                 E
                                 ,
                                 j
                                 |
                                 E
                                 ≠
                                 
                                    i
                                 
                                 ∧
                                 E
                                 ≠
                                 
                                    b
                                 
                                 ∧
                                 
                                    
                                       E
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           
                        
                     

That is, if we are inside an element p, and there exists a child that is not an element i or b, then we have an output error.

The second declaration says “the element ul must contain a nonempty sequence of li elements, and nothing else”, which corresponds to the following formula: 
                           
                              
                                 (
                                 
                                    
                                       
                                          ul
                                       
                                    
                                    
                                       in
                                    
                                 
                                 ∧
                                 (
                                 ∃
                                 E
                                 ,
                                 j
                                 |
                                 E
                                 ≠
                                 
                                    li
                                 
                                 ∧
                                 
                                    
                                       E
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 )
                                 ∨
                                 (
                                 
                                    
                                       
                                          ul
                                       
                                    
                                    
                                       close
                                    
                                 
                                 ∧
                                 ¬
                                 
                                    
                                       
                                          li
                                       
                                    
                                    
                                       1
                                    
                                 
                                 )
                              
                           
                        
                     

The first part of the formula is similar to the previous example, whereas the second says that, if the current element ul is being closed, then having no li children is an error.

Clearly, more articulated content models may require more complex expressions to be checked. However, it is worth noting that formulas of the type “the element must not contain…” (content correctness) should be checked only when a (child) element is opened, whereas formulas of the type “the element must contain…” (content completeness) should be checked only when an element is closed. Indeed, in the implementation, we will optimise such checks so that only the properties that could have been violated are checked in each state.

Once we have defined a suitable way to model an XSL transformation, we can describe the algorithm that, given an XSLT stylesheet, creates the corresponding abstraction and formally encodes it in order to apply model checking. Moreover, we should define a methodology to create a set of properties (to be verified) from the output constraints illustrated in Section 4.2. Since our target verifier is CMurphi, the stylesheet and constraints encoding should produce a valid program written in the CMurphi input language (see Section 3.1).

The algorithm we developed to this aim is called XSLToMurphi, and its overview is shown in Fig. 5
                     . The algorithm is written in C++ and logically subdivided into six modules (called generators) that output the corresponding CMurphi description sections: constants, types, variables, functions, rules and invariants. XSLToMurphi basically performs two tasks:
                        
                           •
                           Generates the model of an XSL transformation. That is, the algorithm takes an XSLT stylesheet and outputs a set of CMurphi rules that mimic the stylesheet behaviour. Actually, the resulting model implements the FSS derived from the XSLT as illustrated in Section 4.1. To build the model, the algorithm applies all the abstractions and limitations discussed in Section 4.1 and, in particular, it can further constrain the XML trees used as transition labels using the input XML Schema, if given.

Generates a set of invariants that encode the output constraints given by an XML Schema, as described in Section 4.2. To this aim, the algorithm also adds some state variables to the model in order to contain the output abstraction needed to verify the invariants.

The output of the XSLToMurphi algorithm can be fed to the CMurphi verifier to validate the stylesheet with respect to the given constraints.

The soundness of the XSLToMurphi algorithm described in the next sections has been validated through an intensive testing (as described in Section 7), whose results showed that all the issues detected in the generated model are actually violations of the XSLT transformation to the given set of constraints.

The first four modules of the XSLToMurphi algorithm analyse the stylesheet to produce a corresponding finite state system encoded as a CMurphi model. The code that implements the stylesheet analysis and model synthesis is quite complex, but it substantially follows the modelling rules illustrated in Section 4.1.

In the following we give some highlights on the actual implementation of the most interesting steps of the modelling phase, and then show an example of XSLT-derived finite state system encoded in the CMurphi input language. It is worth noting that, for the sake of simplicity, in the rest of this section we only consider the most general case, where no input schema is given to the algorithm.

The stylesheet analysis is performed in a loop implemented by the genDiagram function, whose (simplified) control flow is shown in Fig. 6
                        . The function loops over a block of XSLT instructions (e.g., a 
                           
                         or 
                           
                         body) and applies a specific translation rule on each statement, possibly making recursive calls to handle compound statements and nested code blocks. The execution of each translation rule generates a FSS that genDiagram suitably merges with the overall FSS representing the complete code block, which is finally returned by the function.

More technically, given a statement s and a set of (initial) states fst, the genDiagram function
                           
                              1.
                              Generates the FSS G corresponding to the instruction s.

Connects all the states in fst to the initial state of G through appropriate transitions.

Puts the final states of G in the set of pending states pst.

If there is no statement following s, genDiagram returns pst. Otherwise, the function assigns pst to fst (i.e., the pending states become the initial states for the next iteration) and starts the translation of the statement following s in the current block.

In other words, a call to genDiagram on a statement s and a set of states fst returns the final states of the FSS, having fst as initial states, that models the behaviour of s.

As an example, let us illustrate in detail some of the translation rules applied by genDiagram to produce the FSS described in Section 4.1 for the most interesting XSLT instructions.

Before starting, let us recall that CMurphi models have transitions (also called transition rules) as their main component, whereas states are defined by the values set in the model state variables after crossing a transition. This is not the usual way to formally define an FSS, and may make the model difficult to understand. Basically, in the following, when the algorithm “creates a new state” s, then “creates a transition with action a” from another state t to it, and finally “adds the code P” to s, we are formally getting a reference to the state obtained by updating with P the state t, and then adding a rule in the transition function of the FSS that goes from t to s with action a.


                        Templates: To translate a 
                           
                        , genDiagram works as shown in Fig. 7
                        (a): the algorithm recursively translates the template instructions and, when the template ends, connects the final states of the resulting FSS to the states following the template call in the overall stylesheet FSS by restoring the execution status that was pushed before the call to the current template procedure.

Actually, to this aim in the CMurphi code the algorithm adds a call to the library function tReturn, whose code is shown in Fig. 8
                        . This function also handles the return from the main template (i.e., empty stack) by setting the execution position to a predefined constant STY_END which marks the end of the transformation.


                        Conditionals: To illustrate how 
                           
                         instructions are handled, let us suppose that it is called with a set of (initial) states fst and the instruction s=
                           
                         as parameters. The code that handles this case is described in Fig. 9
                        (a): for each nested 
                           
                         and 
                           
                         statement, genDiagram proceeds as follows:
                           
                              1.
                              Creates a new state nst.

Determines the statement guard: for 
                                    
                                  statements, it is given by the 
                                    
                                  attribute (obtained using getMatch). Obviously, for 
                                    
                                  statements the guard is the negation of the 
                                    
                                  attributes of all the 
                                    
                                  statements.

Recursively processes the 
                                    
                                  or 
                                    
                                  code, creating a FSS that has nst as its start state. The final states of the FSS are added to the set tst.

Connects the states in fst to nst. The transition action is set to the guard which is determined in the previous step (i.e., the a 
                                    
                                  transition will be active only if the current horizon matches its 
                                    
                                 ).

Finally, if the 
                           
                         contains an 
                           
                        , then its complete FSS has tst, i.e., the final states of all the nested 
                           
                         and 
                           
                        , as its final states (pst). Otherwise, the final states include both tst and fst, since in this case the 
                           
                         statement can be skipped (if there is no matching 
                           
                        ).


                        Loops: The 
                           
                         loops are translated to simpler FSS, as shown in Fig. 9(b). The initial state nst of the loop is obtained by pushing the execution status on the stack and updating the horizon as required by the 
                           
                         attribute. The previous horizon is later popped from the stack in the final states of the loop body, which are also connected to the initial state nst, to obtain the “loop” behaviour. The final states pst of the complete 
                           
                         FSS include fst, since the loop could be skipped (i.e., executed zero times).


                        Template calls: Finally, a state that issues an 
                           
                         should trigger a runtime pattern matching process that finds the appropriate template (see Section 2). To this aim, genDiagram creates the corresponding FSS as shown in Fig. 7(b): after pushing the current execution status in the stack, it updates the state following the 
                           
                         requirements and sets the current execution position to the predefined constant TPL_MATCHING_DEFAULT_START. Thanks to this kind of translation, the “template lookup” XSLT process simply relies on the “enabled rule lookup” of the CMurphi model checker (see Section 3.1). Indeed, template matching is performed implicitly by transition actions and, if more than one transition can be crossed, the model checker tries all the possible outcomes.

Actually, the state updates required by 
                           
                         calls are handled by the ApplyTemplates CMurphi function, shown in Fig. 10
                        .


                        Fig. 11
                         shows a fragment of the CMurphi model encoding the FSS for the transformation in Fig. 1. Note that the model code is based on a set of static functions and variables that XSLToMurphi reads from external files.

As an example, lines 16–17 correspond to the beginning of a template with 
                           
                        =“c”, whereas lines 7–8 correspond to an 
                           
                         with 
                           
                        =“b/c”.

Once the stylesheet model has been created, the XSLToMurphi algorithm processes the output constraints to produce a set of invariants.

To this aim, the user must only make the output XML Schema available to the constraint generation module of XSLToMurphi, without writing other forms of specification. This feature, together with the direct XSLT-to-model translation described in the previous section, makes the use of XSLToMurphi easy also for nonexpert users. Moreover, the user is free to feed the algorithm with only fragments of the schema (i.e., disjoint element declarations): in this case, the model checker will validate only the given elements and ignore the others, making the whole process faster and aimed to the interesting elements only. As an example, the user may use a fragment of the XHTML specification to check an XSL transformation for a looser conformance.

The generated invariants will be checked during the stylesheet execution after each significant instruction, like an element opening or closing, a template activation. Actually, the algorithm adds to the system state a set of structures which are used to encode a fragment of the XML output, and adapts the model rules so that the invariant checks are performed after the instructions that may violate them.

The constraint generation algorithm loops over all the element declarations in the given schema and, for each of them, calls the functions genOpenInvariants and genCloseInvariants that are illustrated in Fig. 12
                        (a) and (b), respectively. These functions actually write the CMurphi code to check the corresponding safety conditions, as described in Section 4.2.

Basically, these checks are accomplished by matching the current element contents against the corresponding content model, if it was specified. If the matching fails, an appropriate error message is generated. Content models are encoded by XSLToMurphi as regular expressions 
                        [43] and element contents are interpreted as strings, whose letters are the element names. In this way, checking the validity of a content model is easily and quickly accomplished using a pattern matching algorithm.

In particular, when a new element is opened, the algorithm matches its parent׳s children sequence (which includes the newly open element) against a prefix of the corresponding content model (since the parent is currently open, its content model could not be complete yet). If the parent׳s type is simple, then the check always fails since simple types do not allow nested elements. On the other hand, when an element is closed, the algorithm matches its children sequence against its full content model. Indeed, if an element is closed, its contents must be complete.

More technically, the checks generated above are collected in two functions, CheckInvariantsOnSubstateOpen and CheckInvariantsOnSubstateClose, that actually represent the invariants evaluated by CMurphi during the verification when an element is opened and closed, respectively.

To see how the checking actually works, let us consider the simple schema in Fig. 4: it defines the elements body, p and ul and some nested elements, namely 
                           p
                           /
                           b
                        , 
                           p
                           /
                           i
                         and 
                           ul
                           /
                           li
                        . Some of these elements have a content model (e.g., body itself, that must contain a nonempty sequence of ul and p) whereas others have a simple type (e.g., 
                           p
                           /
                           b
                         has string type).


                        Fig. 13
                         shows a simplified version of the code generated by XSLToMurphi to check the schema above. When an element is opened, CheckInvariantsOnSubstateOpen looks in the nesting stack to see if the current element׳s parent is one of body, p, ul, 
                           p
                           /
                           b
                        , 
                           p
                           /
                           i
                         or 
                           ul
                           /
                           li
                        . Elements like 
                           p
                           /
                           b
                         and 
                           p
                           /
                           i
                        , which cannot have children, immediately report an error. Otherwise, the code calls the matches_partially function to check the parent׳s children sequence against the corresponding content model. The implementation of matches_partially uses the CMurphi capability to link external functions to call the PCRE library [44] that offers a fast and reliable regular expression matching engine.

Note that the function matches_partially performs a partial match, i.e., it returns true if a prefix of the given regular expression matches the children sequence. This is needed since, as already noted, a content model may not be complete until its parent element is closed. On the other hand, the function CheckInvariantsOnSubstateClose uses the matches function to match the child sequence against a full regular expression.

The XSLToMurphi algorithm currently handles several other aspects of XML Schema, including the following:
                           
                              •
                              Attributes are treated by the algorithm as special elements, which are suitably encoded in the containing element content model, thus the generated attributes can be checked against the schema declarations.

Similarly, substitution groups, when used, are expanded as a choice between the group members.

Elements with built-in simple types can be matched against the output of the stylesheet (i.e., constant string literals and/or result types of 
                                    
                                  instructions, if an input schema is given) for type consistency.

Finally, the algorithm handles common uses of 
                                    
                                  and 
                                    
                                 , two of the most complex XSLT constructs. Only keys for the containing root element and with at most two fields are currently supported.

Note that the last two features, i.e., simple type checking and key handling, are still experimental, and make the verification more time- and space-consuming. Therefore, the XSLToMurphi algorithm was designed to be modular: the support for each construct, besides the main ones, can be programmatically enabled or excluded. In this way, it is possible to fine-tune the complexity/completeness tradeoff of the verification with respect to the required level of accuracy.

If these features are enabled, some other auxiliary information is selectively added to the model state. In particular,
                           
                              •
                              If 
                                    
                                 /
                                    
                                  checking is enabled, a key pool is used to store the element keys and key references, which are later checked and matched at the end of the stylesheet execution.

If simple type matching is enabled, a structure (with limited size) is added to the state to collect information about the text segments generated in the currently open element. This structure is then checked when the element is closed using regular expressions and explicit type casts.

Therefore, it is clear that the completeness of the XSLToMurphi algorithm, i.e., its ability to detect and correctly report all the violations of the XSLT transformation to the given set of constraints, is influenced by the user-enabled checking features and by the abstractions used to build the transformation model. Indeed, XSLToMurphi is not currently complete with respect to all the constraints that can be defined in an XML Schema. However, while working to increase the XML Schema/XPath support (see Section 9), we practically tested (see Section 7) that the current completeness level is satisfying with respect to the most common XSLT validation requirements and XML Schema usage.

As a general rule, a good validation tool must have a good error reporting system to help locating and fixing the error sources. To this aim, as the final step of our XSLT model checking process, we created a software module that captures the output of the verification process, in particular the error traces generated by the invariant checking functions above, and translates the technical information output by CMurphi into user friendly messages, thought to be easily understood by users having basic XSLT development skills, but detailed enough to further speed up the work if handled by a programmer. Indeed, in the following section we will see how a stylesheet can be iteratively checked and efficiently corrected using XSLToMurphi.

In this section we show the complete verification process involving the XSLToMurphi algorithm and the CMurphi verifier. To this aim, we reuse the running example of Section 5, namely the transformation in Fig. 1 and the XML Schema shown in Fig. 4.

To perform the verification, the user simply runs a shell script provided with XSLToMurphi, having set the appropriate environment variables to point to the CMurphi and XSLToMurphi distribution directories. Of course both tools must have been previously compiled and installed. The script takes two arguments, namely the XSLT file and the XML Schema file, and performs the following actions:
                        
                           1.
                           Runs XSLToMurphi to generate the CMurphi model from the given stylesheet and schema. The output consists of two files, model.m and patterndefs.h. The former contains the model, whereas the latter contains the C++ code that builds the regular expressions representing the content models and the simple types.

Invokes the CMurphi compiler that generates the C++ source file for the verifier.

Compiles the verifier and the external C++ sources generated by XSLToMurphi, linking them with the regular expression library PCRE.

Executes the resulting verifier, writing its output to a file. By default, the tool is given 8MB of memory to store the state space during the verification. This value can be increased to work on large or particularly complex stylesheets.

Analyses the verifier output to generate the final validation report.

If an error occurs, the final report identifies the error condition and shows the structure of the output document generated so far, where the element that caused the error is highlighted. The report also shows the XSLT instruction that caused the error and some other information useful to track the stylesheet execution up to that point.

At a first glance, the simple transformation in Fig. 1 could appear correct, but actually, it contains at least two violations to the XHTML rules. Indeed, if we run the verification process we obtain the following output: 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

The result says that there is something in the body element that should not be there. The error was detected while opening the element i, that is very likely to be the error source. Indeed, if we look at the document structure described in the report, we see that the currently opened elements are html, body and i, in this order. However, i elements can be only contained in p elements, as described by the schema of Fig. 4. The error is clearly marked, and the report indicates that the XSLT instruction that caused it is the 
                        
                      at row 29, column 13 of the source transformation.

To further help finding the condition that caused the error, the report also contains some information about the stylesheet execution up to the error position:
                        
                           •
                           The execution trace shows the main actions taken by the transformation: the execution of the main 
                                 
                               (line 4) that triggered the execution of the 
                                 
                               for element 
                                 a
                                 /
                                 c
                               (line 17), and finally the 
                                 
                              .

The call stack contains POS_2, which is the return position for the main template.

The elements in horizon are unknown, i.e., the verifier has no information about the input document structure being processed at this point.

The offending input path, i.e., 
                                 /
                                 a
                                 /
                                 c
                                 [
                                 not
                                 (
                                 d
                                 )
                                 ]
                              , describes the input pattern that leads to the error. That is, when the error occurred, the stylesheet was evaluating a c element, nested inside an a root element, that does not contain any d child.

A quick look at the indicated stylesheet line shows the error source: the 
                        
                      statement (triggered by the absence of a d child, as indicated by the reported offending XPath) prints “
                        
                     ” outside a paragraph. We can therefore correct this mistake by substituting the code above with “
                        
                     ” and re-run the verification. Again, we have an error 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

This time something required is missing in the contents of element ul, which is being closed. The current document structure shows that the generated ul has no children, whereas the schema requires ul to contain at least one item (li). The report indicates that the error position is on row 23, column 17 of the stylesheet, where indeed we output an ul element. An analysis of the transformation code around the specified point, driven also by the offending input path 
                        /
                        a
                        /
                        c
                        [
                        d
                        ]
                        [
                        count
                        (
                        d
                        /
                        e
                        )
                        =
                        0
                        ]
                     , reveals that, since li elements are created inside a 
                        
                      loop, the error may occur when the loop is executed zero times (i.e., there is no 
                        d
                        /
                        e
                      element in the input). We can (temporarily) fix the problem by adding a default list item that is always present. Once again we run the verification, and the result is satisfactory: 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

So, the final stylesheet is certified as valid with respect to the given schema, regardless of the input. The final report shows the verification time and some other model checking related statistics.

As a side effect of our verification, we also collected two offending input paths, that is 
                           /
                           a
                           /
                           c
                           [
                           not
                           (
                           d
                           )
                           ]
                         and 
                           /
                           a
                           /
                           c
                           [
                           d
                           ]
                           [
                           count
                           (
                           d
                           /
                           e
                           )
                           =
                           0
                           ]
                        . Besides being useful to locate the stylesheet errors, these paths can be used to build a specific input verifier.

Indeed, in this example we were able to fix all the errors, making the transformation completely “safe”. However, in many cases, we may not be able, or may not want, to change the stylesheet. In these cases, we can still avoid the detected problems by pre-verifying the input XML through the offending input paths: if some of them match a fragment of the document, then it cannot be transformed using the stylesheet, since it would generate an erroneous output.

This process has several clear advantages: matching some XPaths against a document may be in general faster than validating it against a schema. Indeed, with our approach, we can choose to make the stylesheet correct with respect to any source document, so avoiding validation at all, or use the algorithm-generated offending paths to quickly check the document before the transformation, since these XPaths only address the source structures leading to errors, not the entire document organisation.

Moreover, in some cases, a schema may be deliberately left free to generate document structures that are not used in practice. This is usually done to keep the schema complexity under a reasonable limit, since excluding some unwanted element combinations may lead to complex rewritings and to the introduction of several new rules. Such unwanted structures, however, are likely to be ignored in the stylesheet design. In this case, when the stylesheet is verified using the schema as input description, there may be errors due to unexpected input. However, in our approach, this would lead to the identification of several XPaths, acting as a “fingerprint” of such unwanted structures, that can be used to perform runtime verification and exclude only documents that (maliciously or erroneously) contain them, allowing all the others.

The current prototype of the XSLToMurphi tool has been first tested using several “malicious” ad hoc created stylesheets, as the running example of this paper (Fig. 1), to stress the most complex XSLT aspects and embed both typical and hard-to-catch output errors. The output languages for these stylesheets were XHTML, WSDL [45], SVG [46] as well as several custom XML languages. These experiments were mainly used to debug the automatic XSLT modelling and abstraction algorithm shown in Section 5.1 and to progressively refine the whole process in terms of speed and XSLT coverage. It is worth noting that, in this phase, advanced features like key/keyref matching and simple type validation (see Section 5.2) were turned off since they require additional debugging and are not part of the XSLToMurphi core algorithm.

After this first experimentation phase, XSLToMurphi has been proposed as a learning/exercitation tool to the students of a XML technologies course. The aim of this experiment was to investigate the potentials of the XSLT verification approach in practice, i.e., how and how much it can assist the stylesheet developers. To this aim, the students were asked to design several different XSLT transformations, with increasing complexity, that generate XHTML representations of some source XML data.

Half of the students used XSLToMurphi to validate the correctness of the resulting code against an XHTML schema and exploited the verification results to fix the stylesheet errors. The other students checked and corrected their code in a more “traditional” way, by manually executing the transformation on different data sources and validating the results using the online W3C XHTML validator.

Once all the students were satisfied with their work, we re-validated all the produced stylesheets both using XSLToMurphi and by manually applying them to a test suite of data sources (which were not known to the students) and checking the conformance of the generated XHTML.

The results are in Table 1
                     , grouped by the level of XHTML knowledge of the participants (basic, average, advanced). For each group, the table shows the average values for the Time taken to complete each stylesheet, the number of check-and-fix Iterations, the number of Lines of the produced XSLT code, and the number of Errors found on the resulting code by the final re-validation through XSLToMurphi (column XSL2M) and through our test suite with manual validation (column Suite). It is worth noting that the reported times include both the time taken by the XSLToMurphi execution(s) and the time used by the students to develop and bug-fix the stylesheet. However, each XSLToMurphi execution took no more than a few seconds.

As we may expect, the time and iterations needed by the students applying XSLToMurphi are lower than the ones spent by the other students. However, the higher the XHTML knowledge, the smaller the difference between these values, since a good XHTML writer is able to prevent many common mistakes when writing the code. On the other hand, the length (and therefore the complexity) of the produced code is not influenced by the XHTML knowledge or the validation method, since it is mainly due to the XSLT expertise of the participants.

The stylesheets validated using XSLToMurphi did not report any problem in our final re-validation, whereas the manually checked ones presented some errors. Again, experienced XHTML writers did not make simple mistakes, i.e., detectable by our manual test suite, but XSLToMurphi still found some errors, mostly deadlocks or loops in the code. Stylesheets written by less experienced programmers, instead, contained errors that were partially identifiable also using the manual test suite. However, all the errors detected through the suite were also signaled by XSLToMurphi.

It is worth noting that the final re-validation made through the manual test suite took much more time than the XSLToMurphi verification, and that the suite preparation itself required time and effort. Therefore, XSLToMurphi confirmed as an effective and quick way to validate XSLT code.


                     Table 2
                      shows the most common errors detected by XSLToMurphi during the experiments. “Real” errors are those that were actually present in the code, whereas “False positives” turned out to be XSLToMurphi detection problems. As we can see, the number of false positives is low. In most of the cases, a debugging of the verification session indicated that these false positives were due to a misinterpretation of advanced XPath expressions (e.g., using filters and axes), which led the verifier to enable too many transitions and execute wrong pieces of code. This is not surprising, since our XPath interpreter has been built from scratch and is currently capable only to understand basic XPath expressions (that are most common, anyway). As illustrated in Section 9, a major part of our future work will consist in embedding a complete XPath interpreter in the XSLToMurphi verifier.

Finally, we asked the students who used XSLToMurphi to fill an evaluation questionnaire about the tool and its use. All the students were satisfied with the tool ease of use, and most of them (82%) were able to find and fix the errors indicated by XSLToMurphi. Some students (43%) suggested that the technical information given by the tool as a result of an error detection was too verbose: indeed, most of the times only the first two elements (reported error and location), together with the generated document structure, were enough to identify and correct the problem. This led us to add a switch in the XSLToMurphi command line to adjust the verbosity level of the verifier output by selecting the error report sections to display. Finally, as a meaningful value, 56% of the students admitted that they would not be able to identify one or more errors in their code without the help of XSLToMurphi.

@&#DISCUSSION@&#

The results of the experimentation above are very encouraging. In particular, we can make the following considerations:


                        Algorithm soundness: In our experiments, all the issues reported by the verifier were stylesheet errors, with a small number of false positives. This suggests that the stylesheet model correctly describes the most common XSLT code and the related XML Schema constraints. False positives, as remarked early in this section, are mainly due to a lack in the XPath support, that is being addressed as part of our future work.


                        Algorithm completeness: XSLToMurphi is still under development, and currently the algorithm understands a significant fragment of XSLT, XPath and XML Schema that is comparable to most of the other XSLT validation approaches (see Section 8). The support for all the formalisms above can be improved to raise the completeness level: thanks to the modular design of XSLToMurphi, new features will be easily added to our framework without changing the core algorithm (see Section 9).


                        Validation performances: Stylesheet verification is a one-time, offline process, so it is always worth spending a little time to check the code and make it safer. The running example of Section 6 shows that XSLToMurphi took only 0.1s to validate the sample XSLT of Fig. 1. Without advanced features such as keyref matching and simple type checking, which are still under testing and were not included in the experiments proposed in this section, students spent most of the time in locating the errors reported by the tool, understand their causes and try to fix them.

The memory usage in all the experiments reported in the paper was at most 8MB, i.e., the default setting as discussed in Section 6. This low value is not surprising, since model checking algorithms are developed to handle huge models, thus they are optimised for the highest memory saving.

Since model checking is, in general, a complex task and the code of the current XSLToMurphi prototype has not been optimised, the tool performances are not comparable with, e.g., the ones of static validation approaches (see Section 8). However, by relying on tools and technologies designed to check large, complex software systems using reasonable time and space, and working to make our XSLT models as simple (and fast) as possible, we feel that XSLToMurphi performances may not be an obstacle to the use of its advanced error detection capabilities.

Finally, it is worth noting that, thanks to the input verifier generation feature of our algorithm, we could be able to improve also the online execution time of the validated XSLT transformation.


                        Tool usability: Starting from a well known but complex technology, we developed a completely automatic tool that hides all the complexity of the modelling and checking phases, so being accessible to any XSLT developer, as confirmed by our experiments. In particular, our error reporting system has an adjustable detail level that ranges from “compiler-like” notices to “debugger-like” technical information related to the XSLT engine, and is also able to generate input and output samples to exemplify the error conditions.

As outlined in Section 9, many enhancements are planned to complete the XSLToMurphi project. However, given the first results above, we feel that our tool and its underlying technique may effectively help to quickly analyse and fix XSLT stylesheets.

@&#RELATED WORK@&#

In this section we give some related work in the field of XSLT validation. For information about the model checking techniques, the reader may refer to Section 3.

The validation of XSL transformations is addressed by several works in the literature. This task is generally considered very complex: indeed (see [47,48]), as non-trivial subsets of XSLT are addressed, the validation problem quickly becomes EXPTIME-hard.

The world of model checking and the one of XML are actually already in touch. In most cases, XML is being used as an aid for describing system models or constraints. In other few cases, model checking is being applied to verify software manipulating XML [49]. The latter approaches are, however, very general. To the best of our knowledge, model checking has never been applied to XSLT validation.

However, XML documents can be formally viewed as elements of a regular tree language (RTL): in this setting XML Schemas become regular tree grammars (or, more precisely, a subtype of regular tree grammars, see [50]) and XML manipulators can be formalised as regular tree transducers (RTT, see, e.g., [51]). Thus, a research area closely related to XSLT checking is the model checking of (regular) tree transducers. It is worth noting that, in some sense, in this work we also implicitly apply this regular-language-view on XML and XML Schemas, since we use regular expressions to validate transformation results against the corresponding schema content models.

Model checking techniques have been applied to systems whose states are words from RTL and the state transitions are generated by RTT. A pioneer work in this field is [52], although the paper focuses only on a specific optimisation technique for such a task. Unno et al. [53] model tree transformations as (higher order) multi-parameter tree transducers (HMTT), to apply the higher-order model checking algorithm already introduced by Kobayashi et al. [54]. The paper explicitly cites the verification of “XML processing programs” as an interesting application of this technique (although it gives no related examples or results), which could be also able to model multi-source transformations, which are achieved in XSLT through the document function. However, the examples of HMTT encoding of simple transformations given in the paper clearly show that a translation of all the XSLT core constructs would result in very complex models that, given the complexity of the corresponding model checking algorithm, which is EXPTIME-hard, would make it hardly usable on real-world transformations without further optimisations.

Another interesting issue pointed in [53] is that many works on the verification of tree transducers are mature enough to be applied on XML transformations, too, but they often address not-Turing-Complete transducers, which are clearly not suitable to represent XSLT, which is actually Turing complete [26].

There are also many works that do not directly address the XSLT checking problem, but deal with model checking and XML technologies, thus they are worth to be cited here. As an example, De La Riva et al. [55] propose an algorithm to translate XML Schemas in Promela data structures and the corresponding XML documents in finite state systems to be used with the SPIN model checker [39]. Here, document elements are states, and document navigation is represented by means of transitions. This kind of modelling is very efficient for the specific aim of the paper, i.e., verifying if the document structure, although valid w.r.t. the given schema, may not be suitable for the execution of a particular XPath, whose “execution constraints” are in turn modelled as LTL expressions. On the other hand, in the present work we use FSS to model transformations, which are at the heart of the XSLT model checking, and pattern matching to check the transformation results against regular expressions deriving from the output schema.

A similar work from Fu et al. [56] introduces a different XML Schema encoding in Promela and also encodes XPath expressions as Promela functions, to support modelling of XML manipulators. In the present paper we focus on modelling of XSLT constructs as templates, loops, pattern matching, etc., leaving XPath matching to an auxiliary function which can be incrementally enhanced to support more XPath functionality without modifying the core translation algorithm. Thus, the ideas about XPath modelling illustrated in [56] could be profitably applied for future extensions of our XPath engine.

Another research area whose results have been applied to XSLT verification is type checking. Indeed, type checking (i.e., static verification) of XML processing languages is a very active field, although the current results are still incomplete. An interesting survey on some of the main works in this field can be found in [57].

Typically, type checks are performed on the transformation code using some kind of schema as an output type specification. Some approaches (e.g., [58]) perform a backward type inference to deduce, from the transformation and its output schema, the required input type, i.e., the input schema, that may be possibly compared with the actual schema declared for the stylesheet input to check for compatibility.

Milo et al. [59] introduce the k-pebble tree transducers, which are explicitly stated as equivalent to a (unspecified) fragment of XSLT, and encode DTD XML grammars [1] as regular tree automata. Type checking is then applied to check the transformation given its input and output grammars. Engelfriet et al. [60] enhance this formalism by introducing “invisible pebbles” to expand the fragment of XSLT which can be modelled with pebble tree transducers, in particular to better address the recursion mechanisms. The new model is used to perform checks on two XSLT sub-languages, namely DTL and TL. However, also in these works the authors claim that the major disadvantage of their technique is its highest complexity. Another notable issue of these approaches is that they are still far from covering all the XSLT constructs, and therefore lack of automated processes to map real XSLT stylesheets to their formalisms.

Thus, although very promising, current type checking approaches to XSLT are very limited and, therefore, cannot be considered realistic as the work presented in this paper. In particular
                        
                           1.
                           Only the element nesting is usually considered. Attributes and textual element content are not checked.

DTDs are used as input/outpout grammars.

Very common XSLT actions like arbitrary copies (i.e., processing the same input elements more than once) and deletion (i.e., not processing some input) are usually not considered, since they are known to make the type checking problem quickly intractable.

XPath is not fully supported: usually, only child relations are considered.

In this work, we present the first prototype of our tool with the same restrictions of (1) and (4), but not for complexity problems. Indeed, as described in Section 9, checking of textual output and full XPath support can be easily accomplished in our framework. On the other hand, we already use XML Schemas as input language and support all the main XSLT constructs, so overcoming the limitations (2) and (3).

The model checking verification proposed in this paper is very flexible. Indeed, many kinds of constraints can be described, and XML Schemas are only a (natural) choice to express some of them. Moreover, from our point of view, checking that a transformation, given an input that respects a particular schema, outputs a document valid with respect to another given schema is only the first step of a complete validation framework. Stylesheets, considered in the whole as data manipulation programs, must be correct and robust.

Indeed, to make a parallel in the general programming field, with such an approach we are checking that a program, given a particular and well-described input sequence, performs (outputs) as expected. Unfortunately, there is no way to guarantee that the input presented to the program will be always as expected, just as there is no way to force the user to feed a stylesheet with documents valid with respect to a schema. Thus, we are also interested in verifying that the transformation is robust, i.e., its output has a given type (schema) even in the worst case scenario, when only partial or no information is given about the input type.

To this aim, in our approach, input schemas can be used in an incremental way. Indeed, the horizon used to select the active statements (see Section 4) can be completely “blind”, i.e., it may contain only the structural information deduced from the stylesheet 
                        
                     s, or filled with elements generated from a schema-processing algorithm that is automatically called in each step of the transformation.

Finally, most static validation techniques in the literature produce limited information about the detected errors, although some can output an example of erroneous document [47] or compiler-style error messages [61]. In our framework, an error message and an example of invalid stylesheet production are only part of the checking results: detailed information about the stylesheet instruction, routines and input that caused the error (like those output, e.g., by C debuggers) are generated, providing an effective help to find the error source and fix it.

To the best of our knowledge, the most comprehensive tool for XSLT validation is still the one presented in [61]. The authors describe a tool that “is shown to handle typical cases with sufficient precision and performance to be practically useful”. The tool uses an approximated algorithm that, after applying a set of abstractions and simplifications both on the XSLT code and its XPath expressions, combines it with an input specification to produce a structure called XML graph. The language generated by such graph is then compared with the language defined by an output schema to find possible incongruence. The tool approximations are based on the statistical analysis of a benchmark set of stylesheets, and therefore may result in false error notices.

The approach presented in [61] is very powerful and, with respect to our approach, appears faster and could possibly require less resources than a model checking based algorithm. It shares some limitations with the algorithm presented in this paper, e.g., it is approximated (can report false positives), but needs more information to work (e.g., both an input and an output schema) and has still limited error reporting capabilities (see Section 6). Moreover, the process of building the XML Graph, as in any control flow generation algorithm, may require much time and memory if the code to analyse is complex. Thus, the application may run out of memory error before the actual verification starts.

Actually, this is not surprising, but reflects the situation present in all the fields where static and dynamic checking coexist: static verification is always the preferred way, when it is applicable, because it is faster and often very accurate. However, the practice has shown that trapping any kind of error or unwanted behaviour that can rise from a complex code written in a “rich” programming language using only static analysis is a very difficult task.

Therefore, the tool described in this paper, which exploits a dynamic verification technique, should not be considered as an alternative to all the other static XSLT validation techniques, but rather as a further step in building a complete XSLT validation framework. In particular, model checking algorithms build the control flow graph on demand, and therefore they have to analyse and store in memory only the minimal amount of information needed to find an error or certify the code correctness.

Moreover, it is worth noting that the XML graph analysis of [61] can also be exploited to locate dead code and deadlocks in the transformation. This kind of debugging-oriented checks, also presented in other works like [62], which uses static analysis on XSLT to check for unreachable templates, termination problems, etc., is extremely simple to obtain through model checking (as an example, deadlock detection is built-in in the CMurphi verifier).

To conclude this overview on XSLT validation, we should mention the various XSLT debuggers [63–65] available on the market, that allow a step-by-step execution of the transformation. These tools may help in testing and developing the stylesheet, but cannot be considered as real validators.

@&#CONCLUSIONS@&#

The benefits deriving from XSLT validation are widely testified by the number of research works and tools in this field (see Section 8). In this paper we described a new technique to validate XSL transformations by means of a standard technology, i.e., model checking. In particular, our work focused on the full automatisation of the XSLT model checking process through an algorithm called XSLToMurphi, which completely hides the complexity of the model checking technology to the user.

Indeed, we first devised an algorithm that, starting from an XSLT stylesheet, is able to generate a transformation model suitable to be analysed by the model checker CMurphi. Then, we implemented another algorithm that translates XML Schemas (or fragments of them) into invariants that can be checked on each state of the transformation. Finally, we joined these two algorithms to the model checker CMurphi and added an output analyser that generates effective error reports to help fixing the detected problems. The resulting XSLT validation framework is extremely accurate and straightforward, as reported by our experiments, whose results are very encouraging.

The application of model checking techniques in any field, from the verification of code to the safety checking of internet protocols and to the validation of circuit design and software architectures, always produced some benefits, often integrating preexisting static verification approaches. Therefore, we feel that XSLToMurphi, as the first tool exploiting model checking in the XSLT context, will also offer a valuable support in this field, thanks to its ability to detect and guide the correction of all the XSLT errors, from the most common, e.g., missing elements, to the most subtle, like deadlocks or loops, on stylesheets of any complexity.

The current prototype of XSLToMurphi does not support the full XSLT and XML Schema specifications. However, most of the missing features have been studied and their implementation is planned in the next releases of the algorithm. In particular
                        
                           •
                           The current XPath interpreter of XSLToMurphi does not support the use of variables and limits the XPath expressions complexity. To achieve a full XPath compliance, we plan to use an external XPath parser and embed the parse results in the transformation model.

User-defined simple types are not considered in the validation process. To support them, we intend to extend the current type checking routines, which handle only built-in simple types.

Finally, we aim at supporting all the XSLT 2.0 advanced features.

Future enhancements of XSLToMurphi could also include some kind of context analysis: indeed, useful hints on the current document structure could be generated by better exploiting the instructions context, in particular looking at the 
                        
                      and 
                        
                      attributes. Moreover, the input verifier generation capability of XSLToMurphi, introduced in Section 6.1, may potentially be very useful in the XSLT practice. This feature is in a very early development, and the generated “offending paths” may still be too generic to be useful at this stage. However, we are working to refine this interesting feature, also by modifying the CMurphi verifier.

Finally, a variant of CMurphi, called FHP-Murphi [66], allows to express finite-horizon constraints using the probabilistic temporal logic PCTL [67] and perform probabilistic verification [68–70]. Both these techniques may result useful also in our framework, for example to check performance and safety aspects. In this way, the model generated by XSLToMurphi may be used for purposes that are beyond the simple XSLT validation issues.

@&#REFERENCES@&#

