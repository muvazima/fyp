@&#MAIN-TITLE@&#FSpH: Fitted spectral hashing for efficient similarity search

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We find that the projection of high-dimensional data on PCA axis has specific pattern.


                        
                        
                           
                           For efficiency, we use fitting function to fit this pattern to uniform distribution.


                        
                        
                           
                           Two binary hashing methods are proposed with Sigmoid function and Fourier function.


                        
                        
                           
                           The proposed methods are efficient and outperform current methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Spectral hashing

Sigmoid function

Fourier function

@&#ABSTRACT@&#


               
               
                  Spectral hashing (SpH) is an efficient and simple binary hashing method, which assumes that data are sampled from a multidimensional uniform distribution. However, this assumption is too restrictive in practice. In this paper we propose an improved method, fitted spectral hashing (FSpH), to relax this distribution assumption. Our work is based on the fact that one-dimensional data of any distribution could be mapped to a uniform distribution without changing the local neighbor relations among data items. We have found that this mapping on each PCA direction has certain regular pattern, and could be fitted well by S-curve function (Sigmoid function). With more parameters Fourier function also fits data well. Thus with Sigmoid function and Fourier function, we propose two binary hashing methods: SFSpH and FFSpH. Experiments show that our methods are efficient and outperform state-of-the-art methods.
               
            

@&#INTRODUCTION@&#

Similarity search, which is to find the most similar items from a collection for a query item, is an essential problem in the field of machine learning, computer vision and information retrieval. However, with the development of Internet and increasing amounts of data, similarity search faces following challenges: efficient storing millions of items in memory and quickly finding similar items to a query item. Recent work [1] shows that binary hashing methods are a powerful way to address those challenges:
                        
                           •
                           The highly compressed binary codes can be loaded into main memory efficiently.

Searching similar items can be extremely fast with Hamming distances calculated by bit XOR operation [2]: an ordinary PC today would be able to do millions of hamming distance computation in just a few milliseconds.

The basic idea of binary hashing is to formulate projections from items to binary codes, so as to approximately preserve a given similarity function of interest [3]. ”Good” binary codes should meet the entropy maximizing criterion. According to the information theory [4], the maximal entropy of a source alphabet can be attained by having a uniform probability distribution. If the entropy of binary codes over data set is small, it means that data are mapped to only a small number of codes, thus rendering the codes inefficient.

However, many state-of-the-art methods do not meet this criterion. One of the most well-known binary hashing methods is Locality Sensitive Hashing (LSH), which calculates binary codes by projecting data on random vectors with random thresholds, and as shown in [5] the hamming distance between binary codes will asymptotically approach the Euclidean distance between data items. The Kernelized version (KLSH) [6] widens the accessibility of LSH to generic normalized Kernel functions. Rather than using random vectors, the authors have pursued machine learning approaches, e.g. the restricted Boltzmann method (RBM) [7] and Boosting [8], to accelerate the document and image retrieval.

When data are uniformly distributed in a hyper-rectangle, spectral hashing (SpH) [9], derived from the spectral graph partition problem, meets the entropy maximizing criterion. Bits can be calculated efficiently by the eigenfunctions of the weighted Laplacian defined on 
                        
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                        
                     . This simple method outperforms above methods. However, the assumption of SpH is too restrictive in practice. In order to relax the restrictive assumption of SpH on data distribution, we propose an improved method fitted spectral hashing (FSpH). Our work is based on this obvious fact that any distribution of one-dimensional data could be mapped to a uniform distribution without changing the local neighbor relations among them. As shown in Fig. 1
                      the proposed method contains three main steps: First, data set is mapped on the selected PCA direction to gain one-dimensional projected data; Second, the projected data is fitted to the uniform distribution by Sigmoid function; finally, binary code is generated using eigenfunction on this uniform distribution. The main contributions are as follows:
                        
                           •
                           We have found that one-dimensional projection of high-dimensional data on the PCA direction could be fitted to the uniform distribution by Sigmoid function. Furthermore, we theoretically prove that Sigmoid function is the specific fitting model for this mapping. Since the Fourier function can approximate ’any’ function, we also use the Fourier function to fit data.

We integrate SpH with the above two fitting functions to approximately meet the entropy maximization criterion, and propose two binary hashing methods, Sigmoid fitting spectral hashing (SFSpH) and Fourier fitting spectral hashing (FFSpH).

@&#RELATED WORKS@&#

There are extensive researches on similarity search problem due to its importance in many applications. For low-dimensional data, structures using spatial partition (e.g. KD-tree) or data partition (e.g. R-tree) provide efficient searching performance [10]. However, the performances of tree based techniques degrade to linear scan in practice for high-dimensional data [11]. In contrast to tree based algorithms, where each item is found by making a series of binary decision to traverse the tree, recently proposed binary hashing-based methods use all binary codes in parallel to perform efficient retrieval.

The well-known hashing techniques LSH [5] and its variants [6,12,13] employ random hash functions and random thresholds, and thus may lead to quite inefficient long codes in practice. To generate more efficient binary codes, several techniques are proposed to obtain good data-aware hash functions. Data-oriented LSH uses the eigenvectors according to the largest eigenvalues of the dataset matrix as data adaptive hash functions [14]. PCA hashing (PCAH) [15] and its refined algorithm iterative quantization (ITQ) [16] choose the eigenvectors corresponding to the largest eigenvalues of the dataset covariance matrix as hash functions. The binarized dimensionality reduction technique Latent Semantic Indexing (LSI) [17] and its improved version Laplacian Co-Hashing (LCH) [18] use the left singular vectors of the whole data matrix as hash functions to get binary codes for documents. Via setting the threshold to be the median value of left singular vectors, they can make balanceable partition in the given collection. By using compact bilinear projections, Bilinear Projection based binary codes (BPBC) [19] can be very efficient for extremely high-dimensional features in terms of both time and storage.

It has been proven that seeking binary codes where the average Hamming distance between similar items is minimal is equivalent to spectral graph partition problem [9]. SpH follows the spectral graph partition strategy to use the analytical eigenfunctions of 1-D Laplacians as the hash functions. Like SpH, Self-Taught Hashing (STH) [1] is also related to the spectral graph partition, but uses ration-cut to address the entropy maximizing criterion and applies support vector machine (SVM) to yield hash codes for out-of-sample items. STH outperforms state-of-the-art algorithms but suffering from high computational cost. Different from STH, Anchor Graph Hashing (AGH) [20] is an approach computationally feasible, since it uses a traceable low-rank Anchor graph to approximate the affine matrix for spectral graph partition computation.

With label information, semantic hashing [7] uses a deep generative model based on stacked Restricted Boltzmann Machine (RBM) to learn the hash functions that map items with the same labels to similar binary codes. Similarity Sensitive Coding (SSC) [21] and Forgiving Hashing (FgH) [22] train AdaBoost classifiers with positive examples (pairs of items with the same labels) and negative examples (pairs of items with different labels), and then use the output of weak learners as binary codes. Li et al. proposed a method [23] to directly optimize the graph Laplacian with multiple image tags and then apply SpH for effective binary code learning. Linear Discriminant Analysis Hashing (LDAHashing) [24] perform LDA on descriptors before binarization to tackle supervision. Different from prior works, Kernel-Based Supervised Hashing (KSH) [25] utilize the algebraic equivalence between a Hamming distance and a code inner product in the objective function, and that can be optimized more effective on Hamming distances. Discriminative binary codes (DBC) [26] treats each bit as a visual attribute that can be both reliably discriminated and predicted from visual data. Semi-supervised hashing (SSH) [27] uses both the labeled items and unlabeled items. It learns hash functions that can minimize the empirical loss over the labeled training data with an information theoretic regularizer over both labeled and unlabeled data. For data from multiple heterogeneous domains, a novel Relation-aware Heterogeneous Hashing (RaHH) [28] can learn hash codes flexibly cope with the characteristics of different data domains.

In most existing binary hashing techniques, including those discussed above, the hash function is used to map high-dimensional data to discrete hash real-values. Those real-values can be converted into binary codes via thresholding. Techniques, like STH, LCI, LSI and AGH, which meet entropy maximizing criterion, set one threshold which is the median value of eigenvectors on each hash function to gain one bit code (two-layers AGH sets two thresholds on each hash function). Thus, all hash functions are treated equally. However, not all hash functions are equally suitable for hashing. Different from those methods, we propose FSpH to first fit the one-dimensional data to a uniform distribution. Then several hash functions (a periodic sine function with different parameters), whose binary codes can approximately meet entropy maximizing criterion, can be generated on each PCA direction. All those hash functions are candidates and those with smallest eigenvalues should be selected. Currently the proposed method is unsupervised, and how to utilize the label information is our further work.

Given a collection of n data points which are embedded in m-dimensional space 
                           
                              
                                 
                                    {
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    m
                                 
                              
                           
                        . Let X denotes the 
                           
                              n
                              ×
                              m
                           
                         data matrix: 
                           
                              
                                 
                                    [
                                    
                                       
                                          x
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          n
                                       
                                    
                                    ]
                                 
                                 
                                    T
                                 
                              
                           
                        . Suppose that the desired length of codes is k. Let 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    {
                                    -
                                    1
                                    ,
                                    1
                                    }
                                 
                                 
                                    k
                                 
                              
                           
                         be binary code for data point 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                        , where the pth element of 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                           
                         is 1 if the pth bit is on or −1 otherwise. We use Y to denote the 
                           
                              n
                              ×
                              k
                           
                         matrix: 
                           
                              
                                 
                                    [
                                    
                                       
                                          y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          n
                                       
                                    
                                    ]
                                 
                                 
                                    T
                                 
                              
                           
                        .

The binary code should be similarity preserving, which ensures to map similar data points to similar binary codes. We use W to represent the 
                           
                              n
                              ×
                              n
                           
                         similar matrix, where 
                           
                              W
                              (
                              i
                              ,
                              j
                              )
                              =
                              exp
                              (
                              -
                              ‖
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                              /
                              
                                 
                                    ∊
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . With this notation, the average Hamming distance between similar neighbors can be written: 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              W
                              (
                              i
                              ,
                              j
                              )
                              ‖
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              -
                              
                                 
                                    y
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                        . Thus, we obtain the following problem:
                           
                              (1)
                              
                                 
                                    min
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          ij
                                       
                                    
                                 
                                 
                                    
                                       W
                                    
                                    
                                       ij
                                    
                                 
                                 ‖
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       y
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       ‖
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 s
                                 .
                                 t
                                 .
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 
                                    
                                       {
                                       -
                                       1
                                       ,
                                       1
                                       }
                                    
                                    
                                       k
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 0
                                 ,
                                 
                                    
                                       1
                                    
                                    
                                       n
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                    
                                       T
                                    
                                 
                                 =
                                 I
                                 ,
                              
                           
                        where the constraint 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              =
                              0
                           
                         requires 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                           
                         to meet the entropy maximization criterion, and the constraint 
                           
                              
                                 
                                    1
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                                 
                                    T
                                 
                              
                              =
                              I
                           
                         requires the bits of 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                           
                         to be uncorrelated. If we relax the constraint 
                           
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    {
                                    -
                                    1
                                    ,
                                    1
                                    }
                                 
                                 
                                    k
                                 
                              
                           
                        , the objective function of Eq. (1) is equivalent to the well-known manifold learning algorithm, Laplacian Eigenmap (LapEig) [29]. Thus, relaxing this discreteness constraint Eq. (1) can be rewritten to the following LapEig problem:
                           
                              (2)
                              
                                 
                                    min
                                 
                                 
                                 trace
                                 (
                                 
                                    
                                       Y
                                    
                                    
                                       T
                                    
                                 
                                 (
                                 D
                                 -
                                 W
                                 )
                                 Y
                                 )
                                 ,
                                 s
                                 .
                                 t
                                 .
                                 
                                    
                                       Y
                                    
                                    
                                       T
                                    
                                 
                                 DY
                                 =
                                 I
                                 ,
                                 
                                    
                                       Y
                                    
                                    
                                       T
                                    
                                 
                                 D
                                 1
                                 =
                                 0
                                 ,
                              
                           
                        where D is a diagonal 
                           
                              n
                              ×
                              n
                           
                         matrix 
                           
                              D
                              (
                              i
                              ,
                              i
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                 
                              
                              W
                              (
                              i
                              ,
                              j
                              )
                           
                        . The solution of Eq. (2) is the k eigenvectors of 
                           
                              (
                              D
                              -
                              W
                              )
                           
                         with minimal eigenvalues. However, these eigenvectors only can compute the binary codes for training data set. For out-of-samples data, Nystrom method [30] is often used. However, the Nystrom extension is expensive for that its computational cost is linear in the size of training data set. Different from the traditional method, SpH provides a simple and efficient solution.

With the assumption that data point x is sampled from a probability distribution 
                           
                              p
                              (
                              x
                              )
                           
                        , the SpH problem can be written as:
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                min
                                             
                                             ∫
                                             ‖
                                             y
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             -
                                             y
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             
                                                
                                                   ‖
                                                
                                                
                                                   2
                                                
                                             
                                             W
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   x
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             p
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             p
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             
                                                
                                                   dx
                                                
                                                
                                                   1
                                                
                                             
                                             
                                                
                                                   dx
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                             ∫
                                             y
                                             (
                                             x
                                             )
                                             p
                                             (
                                             x
                                             )
                                             dx
                                             =
                                             0
                                             ,
                                             ∫
                                             y
                                             (
                                             x
                                             )
                                             y
                                             
                                                
                                                   (
                                                   x
                                                   )
                                                
                                                
                                                   T
                                                
                                             
                                             P
                                             (
                                             x
                                             )
                                             dx
                                             =
                                             I
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 
                                    
                                       {
                                       -
                                       1
                                       ,
                                       1
                                       }
                                    
                                    
                                       k
                                    
                                 
                                 .
                              
                           
                        
                     

In order to give a simple solution for out-of-sample extension, SpH makes an assumption that 
                           
                              p
                              (
                              x
                              )
                           
                         is a separable and multidimensional uniform distribution 
                           
                              Pr
                              (
                              x
                              )
                              =
                              
                                 
                                    ∏
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    u
                                 
                                 
                                    i
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , where 
                           
                              
                                 
                                    u
                                 
                                 
                                    i
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         is a one-dimensional uniform distribution on 
                           
                              [
                              a
                              ,
                              b
                              ]
                           
                        . Specifically for this case, the solutions are extremely well studied objects in mathematics. They correspond to the fundamental models of vibration of a metallic plate as follows:
                           
                              (4)
                              
                                 
                                    
                                       ϕ
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 sin
                                 
                                    
                                       
                                          
                                             
                                                π
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                k
                                                π
                                             
                                             
                                                b
                                                -
                                                a
                                             
                                          
                                          x
                                       
                                    
                                 
                                 .
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       λ
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 1
                                 -
                                 
                                    
                                       e
                                    
                                    
                                       -
                                       
                                          
                                             
                                                
                                                   ∊
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             2
                                          
                                       
                                       |
                                       
                                          
                                             k
                                             π
                                          
                                          
                                             b
                                             -
                                             a
                                          
                                       
                                       
                                          
                                             |
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

SpH uses Eq. (4) to code data points 
                           
                              
                                 
                                    {
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    n
                                 
                              
                           
                         directly. Specifically, the SpH algorithm consists of three steps: (1) Using PCA to align axes (2) Finding k smallest eigenfunctions (Eq. (4)). (3) Thresholding the eigenfunctions at zero to seek binary codes (For efficiency code ’−1’ is saves as ’0’).

However, this simple algorithm has an obvious limitation: it assumes data points are generated from a multidimensional uniform distribution. When dealing with the actual data, we have found that the SpH algorithm can hardly meet the entropy maximizing criterion as shown in Fig. 2
                        (b).

@&#PROPOSED METHOD@&#

The fitted SpH uses PCA to align the axes like SpH, but does not need the distribution assumption. It is based on the fact that any distribution of one-dimensional data could be mapped to a uniform distribution. Therefore, with a uniform distribution the fitted SpH algorithm can approximately meet the entropy maximizing criterion, and corresponding entropies
                           1
                           Let pr be the probability of one bit be 0, the entropy of pr is: 
                                 
                                    H
                                    (
                                    pr
                                    )
                                    =
                                    -
                                    
                                       
                                          prlog
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    pr
                                    )
                                    -
                                    (
                                    1
                                    -
                                    pr
                                    )
                                    
                                       
                                          log
                                       
                                       
                                          2
                                       
                                    
                                    (
                                    1
                                    -
                                    pr
                                    )
                                 
                              .
                        
                        
                           1
                         are shown in Fig. 2(c) and (d). There are three questions needed to be answered: (1) Does this mapping change local neighbor relations among data items on one PCA direction? (2) Does there exist a specific fitting model suitable for this mapping? (3) Could this fitting model be efficiently computed for out-of-sample items?
                           Proposition 3.1
                           
                              Let 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              be the projected values of 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              on arbitrary PCA axis, 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              be data, which obey uniform distribution, mapped from 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                              
                              . After this mapping, we claim that: (1) the entropy of binary coding 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              can be maximized. (2) If the mapping function f is monotonically increasing function, the sequence of 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              could be preserved by 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                              
                              . (3) The adjacency relationships among data items on one PCA direction can be preserved after this mapping.
                           

(1) q obey the uniform distribution on 
                                 
                                    [
                                    a
                                    ,
                                    b
                                    ]
                                 
                              , and are translated to 
                                 
                                    [
                                    0
                                    ,
                                    b
                                    -
                                    a
                                    ]
                                 
                               without loss. Since 
                                 
                                    q
                                    ∈
                                    
                                       
                                          
                                             0
                                             ,
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   2
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          ϕ
                                       
                                       
                                          k
                                       
                                    
                                    (
                                    q
                                    )
                                    >
                                    0
                                 
                              ; 
                                 
                                    q
                                    ∈
                                    
                                       
                                          
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   2
                                                   k
                                                
                                             
                                             ,
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          ϕ
                                       
                                       
                                          k
                                       
                                    
                                    (
                                    q
                                    )
                                    <
                                    0
                                 
                              , half of q on uniform distribution could be coded as 1 or 0 by Eq. (4) in the range 
                                 
                                    
                                       
                                          
                                             0
                                             ,
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                 
                              . Because Eq. (4) is a periodic function, the entropy of binary coding 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               in every range 
                                 
                                    
                                       
                                          
                                             0
                                             +
                                             (
                                             i
                                             -
                                             1
                                             )
                                             ×
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                             ,
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                             +
                                             (
                                             i
                                             -
                                             1
                                             )
                                             ×
                                             
                                                
                                                   b
                                                   -
                                                   a
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    k
                                 
                              , can be maximized. (2) 
                                 
                                    f
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          q
                                       
                                       
                                          i
                                       
                                    
                                 
                              , when 
                                 
                                    {
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    >
                                    
                                       
                                          p
                                       
                                       
                                          z
                                       
                                    
                                    >
                                    …
                                    >
                                    
                                       
                                          p
                                       
                                       
                                          j
                                       
                                    
                                    }
                                 
                              , because f is monotonically increasing function, then 
                                 
                                    {
                                    
                                       
                                          q
                                       
                                       
                                          i
                                       
                                    
                                    >
                                    
                                       
                                          q
                                       
                                       
                                          z
                                       
                                    
                                    >
                                    …
                                    >
                                    
                                       
                                          q
                                       
                                       
                                          j
                                       
                                    
                                    }
                                 
                              , the sequence of 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               is preserved by 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                              . (3) Thus, the adjacency relationships among data items on one PCA direction can be preserved with function f. □

The Proposition 3.1 indicates that the fitting function should be a monotonically increasing function. Based on the observed in the literature [31] that the density projections of large high-dimensional data sets onto a random line generally follow a normal distribution, we give the following proposition which proves that Sigmoid function is suitable for fitting this mapping.
                           Proposition 3.2
                           
                              Let 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              be data, which obey the normal distribution. If 
                              
                                 
                                    q
                                    =
                                    f
                                    (
                                    p
                                    )
                                 
                               
                              and 
                              
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               
                              obey the uniform distribution, we claim f should be the Sigmoid function 
                              
                                 
                                    f
                                    (
                                    x
                                    )
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          0
                                       
                                    
                                    ×
                                    
                                       
                                          
                                             
                                                1
                                                +
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  -
                                                                  (
                                                                  x
                                                                  -
                                                                  
                                                                     
                                                                        a
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  
                                                                     
                                                                        a
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          -
                                          1
                                       
                                    
                                    +
                                    
                                       
                                          a
                                       
                                       
                                          3
                                       
                                    
                                 
                              
                              , where 
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          0
                                       
                                    
                                 
                               
                              , 
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 
                               
                              , 
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                 
                               
                              and 
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          3
                                       
                                    
                                 
                               
                              are the 4 parameters of Sigmoid function.
                           

For arbitrary data point 
                                 
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                 
                              , there is a data point 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    f
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              . Thus, the derivation of f at 
                                 
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                 
                               is 
                                 
                                    
                                       
                                          f
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                q
                                             
                                             
                                                i
                                                -
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                p
                                             
                                             
                                                i
                                                -
                                                1
                                             
                                          
                                       
                                    
                                 
                              . Since data points 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                q
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               obey a uniform distribution 
                                 
                                    
                                       
                                          q
                                       
                                       
                                          i
                                       
                                    
                                    -
                                    
                                       
                                          q
                                       
                                       
                                          i
                                          -
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          const
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                const
                                             
                                             
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                p
                                             
                                             
                                                i
                                                -
                                                1
                                             
                                          
                                       
                                    
                                 
                              . Let G be the probability density function of 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                              . With an reasonable assumption that in the small interval 
                                 
                                    [
                                    
                                       
                                          p
                                       
                                       
                                          i
                                          -
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    ]
                                 
                               data points obey a uniform distribution, G at 
                                 
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                 
                               can be estimated
                                 2
                                 There is an inverse relation between the probability density value and the distance between adjacency points. Specifically, data points are close in high density region and the distance between adjacency points is small; Vice versa.
                              
                              
                                 2
                               by 
                                 
                                    G
                                    =
                                    
                                       
                                          
                                             
                                                const
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          -
                                          
                                             
                                                p
                                             
                                             
                                                i
                                                -
                                                1
                                             
                                          
                                       
                                    
                                 
                              . Thus, 
                                 
                                    
                                       
                                          f
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                const
                                             
                                             
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                const
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    G
                                    →
                                    f
                                    =
                                    
                                       
                                          const
                                       
                                       
                                          3
                                       
                                    
                                    
                                       ∫
                                       
                                          1
                                       
                                       
                                          n
                                       
                                    
                                    G
                                    (
                                    t
                                    )
                                    dt
                                 
                              , which indicates that the Cumulative Distribution Function (CDF) function of G could be used as fitting function to map the one-dimensional data, whose probability density function (PDF) is G, to a uniform distribution. Since 
                                 
                                    
                                       
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                               obey a normal distribution and Sigmoid function is the commonly used CDF of normal function
                                 3
                                 http://en.wikipedia.org/wiki/Sigmoid_function.
                              
                              
                                 3
                              , Sigmoid function is the specific fitting model for this mapping. □

For out-of-sample items, we have found that this mapping could be well fitted by Sigmoid function. Obviously it is a monotonically increasing function. For comparison, we also use the Fourier function which can approximate any function:
                           
                              (6)
                              
                                 
                                    
                                       f
                                    
                                    
                                       ∗
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 +
                                 
                                    
                                       a
                                    
                                    
                                       1
                                    
                                 
                                 ×
                                 cos
                                 (
                                 x
                                 ×
                                 w
                                 )
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       1
                                    
                                 
                                 ×
                                 sin
                                 (
                                 x
                                 ×
                                 w
                                 )
                                 +
                                 …
                                 +
                                 
                                    
                                       a
                                    
                                    
                                       8
                                    
                                 
                                 ×
                                 cos
                                 (
                                 8
                                 ×
                                 x
                                 ×
                                 w
                                 )
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       8
                                    
                                 
                                 ×
                                 sin
                                 (
                                 8
                                 ×
                                 x
                                 ×
                                 w
                                 )
                                 ,
                              
                           
                        where 
                           
                              
                                 
                                    a
                                 
                                 
                                    0
                                 
                              
                              ,
                              w
                              ,
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    a
                                 
                                 
                                    8
                                 
                              
                              ,
                              
                                 
                                    b
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    b
                                 
                                 
                                    8
                                 
                              
                           
                         are 18 parameters and more parameters ensure the low Sum of Squares due to Error (SSE) of Fourier function. Though with a little higher SSE, the computational cost of Sigmoid function is lower as showed in Experiments. There are many tools available to solve the fitting functions, and the Curve Fitting Toolbox
                           4
                           Curve Fitting Toolbox: fit curves or surfaces with linear and nonlinear library models and custom models. http://www.mathworks.cn/cn/help/curvefit/linear-and-nonlinear-regression.html.
                        
                        
                           4
                         in Matlab is used in this paper. For efficiency, we use a sub-sampled data set, instead of the whole data set, to speed up the fitting function calculation.
                           Algorithm 1
                           Fitted spectral hashing 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: Matrix 
                                                   
                                                      X
                                                      ∈
                                                      
                                                         
                                                            R
                                                         
                                                         
                                                            n
                                                            ×
                                                            m
                                                         
                                                      
                                                   
                                                , the number of bits k
                                             
                                          
                                          
                                             
                                                Output: Binary codes 
                                                   
                                                      Y
                                                      ∈
                                                      
                                                         
                                                            R
                                                         
                                                         
                                                            n
                                                            ×
                                                            k
                                                         
                                                      
                                                   
                                                , Mode M
                                             
                                          
                                          
                                             1: Compute eigenvectors and eigenvalues of 
                                                   
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      =
                                                      
                                                         
                                                            X
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ×
                                                      X
                                                   
                                                ;
                                          
                                          
                                             2: According to the order of eigenvalues, select k eigenvectors 
                                                   
                                                      {
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      }
                                                   
                                                 as the PCA directions and save them in M;
                                          
                                          
                                             3: for 
                                                i
                                                =1 to k 
                                                
                                                do
                                             
                                          
                                          
                                             4:Compute projected value p of X on the direction 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             5:Compute 
                                                   
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                 using Sigmoid function or Fourier function with p
                                             
                                          
                                          
                                             6: Evaluate the k smallest eigenvalues 
                                                   
                                                      {
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      }
                                                   
                                                 by Eq. (5)
                                             
                                          
                                          
                                             7: Save 
                                                   
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      {
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      }
                                                   
                                                 in M
                                             
                                          
                                          
                                             8: end for
                                             
                                          
                                          
                                             9: Select k eigenfunctions 
                                                   
                                                      {
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            k
                                                         
                                                      
                                                      }
                                                   
                                                 (Eq. (4)) according to the order of 
                                                   
                                                      λ
                                                   
                                                 in M and save them in M
                                             
                                          
                                          
                                             10: for 
                                                j
                                                =1 to k 
                                                
                                                do
                                             
                                          
                                          
                                             11: Find the direction 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                 according to 
                                                   
                                                      
                                                         
                                                            λ
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             12: Compute projected value p of X on the direction 
                                                   
                                                      
                                                         
                                                            V
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             13: 
                                                
                                                   
                                                      q
                                                      =
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      (
                                                      p
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             14: Threshold eigenfunctions 
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      (
                                                      q
                                                      )
                                                   
                                                 at zero to obtain binary codes 
                                                   
                                                      Y
                                                      (
                                                      :
                                                      ,
                                                      j
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             15: end for
                                             
                                          
                                       
                                    
                                 
                              
                           

We add the calculation of fitting function step (step 5th) and fitting data step (step 13th) into the original SpH algorithm and summary the new one in Algorithm 1. For training data, this algorithm first learns a fitting function on each selected PCA direction and then uses the fitting function to map data to the uniform distribution. Like SpH the proposed algorithm use Eq. (4) as hash functions to generate the binary codes for one-dimensional uniform data. For testing samples, model M is already learnt and the calculation of each bit of binary codes is efficient which only needs three steps: the 12th step to the 14th step. The cost of eigenvalue decomposition of matrix 
                           
                              
                                 
                                    X
                                 
                                 
                                    ∗
                                 
                              
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    m
                                    ×
                                    m
                                 
                              
                           
                         is lower than state-of-art methods dealing with 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                    ×
                                    n
                                 
                              
                           
                         
                        [1,17,18], where m is the dimensionality and typically far less than the number of samples n.

@&#EXPERIMENTS@&#

In this section, we conduct experiments to evaluate the performance of the proposed algorithms. We first compare them with state-of-the-art binary hashing methods. Then, we discuss their computational costs.

We compare the performance of the proposed algorithms, FFSpH and SFSpH, against other popular binary hashing methods including Locality Sensitive Hashing (LSH) [5], Spectral Hashing (SpH) [9], PCA Iterative Quantization (ITQ) [32], Bilinear Projection based binary codes (BPBC) [19],two-layer Anchor Graph Hashing (AGH) [20], Semantic Indexing (LSI) [17], Laplacian Co-Hashing (LCH) and Self-Taught Hashing (STH) [1]. These methods cover both entropy maximization cases and non-maximization cases. Specifically, LSH, SpH and BPBC can hardly meet the entropy maximization criterion while others can. To run the AGH, we use K-means to find its anchors and fix its parameters as in [20]. To run STH, we use the linear-SVM as in [1]. We use 50 iterations for ITQ and BPBC as in [32]. To run our methods, we adopt the curve tool box in matlab to learn the fitting functions. All our experiments are run on a PC with 2.83GHz Intel Core2 Quad CPU and 6GB RAM.

We follow the search procedure, Hamming ranking, for consistent evaluation. Hamming ranking measures the search quality by ranking data set points according to their Hamming distances to the query point [20]. In our experiments, we search within a Hamming radius 1 to retrieve potential neighbors for each query. We follow recent works [9,27,32] to use the following two evaluation protocols: (1) we use Euclidean neighbors as ground truth, and the nearest 100 neighbors are determined as true positives for the query; (2) We also use semantic neighbors as ground truth, and the neighbor points must share at least one label with the query point. The performances of binary hashing methods can be measured by precision and recall. Specifically, precision can be defined as the proportion of retrieved true neighbors in all retrieved neighbors, and recall can be defined as the proportion of retrieved true neighbors in all true neighbors of the query point.

We choose four well-known datasets, including real-world text dataset 20Newsgroups
                           5
                           http://qwone.com/ jason/20Newsgroups/.
                        
                        
                           5
                        , image dataset CIAFR-10(60K)
                           6
                           http://www.cs.toronto.edu/ kriz/cifar.html.
                        
                        
                           6
                        , hand-written digit dataset MNIST (70K)
                           7
                           http://yann.lecun.com/exdb/mnist/.
                        
                        
                           7
                         and web image dataset NUS-WIDE (270K).
                           8
                           http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm.
                        
                        
                           8
                         Descriptions of datasets are as follows:
                           
                              1 The 20Newsgroups corpus contains 18,846 documents distributed across 20 categories. The document data set has been pre-processed by stop word removal, Poster stemming, and TF-IDF weighting and represented by 25,714-D sparse feature vectors. We use 11,314 (60%) documents for training and 7532 (40%) documents for testing as in [18].

2 The tiny image data set CIAFR-10 contains 60K 
                                    
                                       32
                                       ×
                                       32
                                    
                                  color images of 10 classes and 6K images in each class. We extract 512-D GIST features for each image, and then use 80% images for training and 20% left for testing by default.

3 The MNIST data set consists of 70K images of handwritten digits from 0 to 9 and 7K images for each digit. Each image is normalized to the size of 
                                    
                                       28
                                       ×
                                       28
                                    
                                  pixels to form 784-D feature vectors. We use 80% images for training, 20% left for testing as in [20].

4 NUS-WIDE contains 270K web images associated with 81 concept tags. We use the 225-D block-wise color moments as feature vectors. For evaluation, we consider 30 frequent tags, such as ’boats’, ’train’, and ’plane’, each of which has an average 2K images. We randomly select 25% images for training with the rest as testing set.

As shown in the Fig. 3
                         the proposed methods, SFSpH and FFSpH, give the best results on 20Newsgroup, and top-3 results on CIAFR-10, MNIST and NUS-WIDE. Compared with SpH, our methods achieve average 60% improvement on 20Newsgroups, average 19% improvement on CIAFR-10, average 2% improvement on MNIST and average 51% improvement on NUS-WIDE. Because the proposed methods can approximately meet the entropy maximization criterion using fitting functions, their binary codes are more efficient than SpH’s.

Compared with other methods, the proposed methods achieve considerable performance. LSH uses random hash functions which renders its codes inefficient. BPBC is designed for high-dimensional descriptors and not suitable to produce short binary codes. LCH, LSI, STH, AGH and ITQ are state-of-the-art algorithms which can meet the entropy maximization criterion. Our algorithms can achieve similar performance with LSI on CIAFR-10 and NUS-WIDE, and with ITQ on MNIST, while better than STH, AGH and LCH. STH trains SVM to seek binary codes, when the scale of training data is small, as on the NUS-WIDE with 25% images for training, then its performance decreases. In order to get a lower computational complexity, AGH uses a low-rank matrix to approximate the affine matrix for graph Laplacians computation, and it may sacrifice some precision on some datasets.

Our methods, SFSpH and FFSpH, work almost the same on CIAFR-10 and MNIST. The performance of SFSpH is slightly better than FFSpH on 20Newsgroups and NUS-WIDE. Thus we claim that Sigmoid function used in SFSpH could fit data as well as Fourier function used in FFSpH, while with much less parameters.

As shown in Table 1
                        , compared with SpH the proposed methods can approximately achieve the maximum entropy for testing data. Because the entropy for the training data is already maximized by the learning stage, the entropy for testing data is a meaningful evaluation criterion for code efficiency. Since AGH, LCH, LSI and STH meet the entropy maximization criterion, their entropy values can also approximate maximum for testing data as the proposed methods.

However, the proposed methods have not significantly improved the MAP performance of SpH algorithm as shown in Table 1. Besides on the 20Newsgroups data set, the MAP performance of the proposed methods is close to the SpH’s. That’s because of that the proposed methods have not modified the SpH algorithm’s processes. They have applied the hash functions of SpH, thus may not improve the MAP performance of SpH. However, the proposed methods can improve the efficiency of binary codes. Since each code of our methods can give a near-balanced partition of the data set, each item can find its similar neighbors efficiently. Thus, the retrieval performance of the proposed methods can be better with a small number of codes than SpH’s.

As shown in Fig. 4
                         the computational cost of SFSpH is much lower than other methods’, only 60% of FFSpH’s, 25.3% of LCH’s, 25.2% of LSI’s, 11% of BPBC’s, 3% of STH’s and 3.1% of AGH’s, while a little higher than LSH’s, SpH’s and ITQ’s. Since LSH employs random hash functions and random thresholds, it’s the simplest and fastest. Because our methods need extra fitting function computation on each selected PCA direction, they cost more time than SpH. We use the curve tool box in matlab to compute the fitting function, and the tool box learns Sigmoid function faster than Fourier function. Therefore, the cost of SFSpH is lower than that of FFSpH. ITQ needs iterative procedures to find the rotation for the PCA-based binary codes, while with a small iteration number ITQ is very efficient.

The LCH and LSI need the SVD (singular vectors decomposition) of whole data matrix 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                    ×
                                    n
                                 
                              
                           
                         to compute projecting directions, thus the computational complexity is higher than proposed methods with matrix 
                           
                              
                                 
                                    R
                                 
                                 
                                    m
                                    ×
                                    m
                                 
                              
                           
                         (typically, the dimensionality m is far less than the scale of samples n). The time complexity of BPBC is 
                           
                              O
                              
                                 
                                    
                                       n
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      3
                                                   
                                                
                                                +
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      3
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                         
                        [19], where 
                           
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                              
                              *
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                              
                              =
                              m
                           
                        , this algorithm could be more efficient for high dimensional features in terms of both time and storage. The STH method has to construct the spectral graph with complexity of 
                           
                              O
                              (
                              
                                 
                                    mn
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        , and compute the eigenvectors of similar matrix 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                    ×
                                    n
                                 
                              
                           
                        , then train k SVM models to generate binary codes, therefore its cost is the highest. The main cost of AGH algorithm is to use Kmeans algorithm to calculate the ahchor points, which gives a heavy overhead of 
                           
                              O
                              (
                              tKmn
                              )
                           
                        . After learning the ahchor points, the AGH algorithm is efficient.

Using sampling strategy to reduce the scale of samples is an obvious way to cut down the computational cost of both algorithms. We randomly select a given proportion (sampling rate) of the samples from the training data. As shown in Fig. 5
                        , the performance of SFSpH on four data sets varies little under different sampling rates, while the performance of FFSpH may vary much. When the sampling is insufficient to reflect the true distribution, FFSpH may cause overfitting. Different from Fourier function, Sigmoid function is the specific fitting model that can fit the required mapping well, and thus even under the low sampling rate SFSpH gives almost as good result as with the whole data set. Thus, we consider SFSpH as a better algorithm than FFSpH.

@&#CONCLUSION@&#

In this paper, we propose two FSpH methods, SFSpH and FFSpH, to relax the strict distribution assumption of SpH. Sigmoid function is applied in the SFSpH algorithm based on the observation that one-dimensional projections of high-dimensional data on the PCA direction could be fitted to the uniform distribution by Sigmoid function. Besides, we theoretically prove that Sigmoid function is the specific fitting model for this mapping. Then, since Fourier function can approximate any function, it’s used in FFSpH algorithm.

The hashing codes of our methods can approximately meet the entropy maximizing criterion. Experiments show that two proposed FSpH algorithms outperform algorithms, like SpH, which do not meet the entropy maximizing criterion, while achieve comparable performance with algorithms, like LSI, which can meet this criterion but with a lower computational cost, and the performance of SFSpH is better and more stable than FFSpH’s. Furthermore, due to the efficiency, we claim that our methods can be efficient to train large data sets with short code lengths.

Although algorithms based on spectral graph partition problem, like SpH and the proposed methods, is widely used, we claim that their solution may be not the best. They uses the distance (like Euclidean distance or cosine distance) between items to represent their similarity, but this distance may be insufficient to reflect the real semantic relations, e.g. adjacent items in low density region may belong to different categories while in high density region adjacent items are prone to belong to the same category. It’s shown in semi-supervised learning [33] that cluster density information of data set could benefit the semantic relation computation. Thus, we plan to improve the proposed methods with cluster density information to gain better MAP performance in the further work. In additions our method is unsupervised, and we plan to utilize the label information to improve their MAP performance in the further work. Currently, there are many image search applications like product visualization [34] and social image search [35], and how to effectively utilize binary codes in those applications is another interesting direction.

@&#ACKNOWLEDGMENTS@&#

This work was supported in part by National Nature Science Foundation of China (61173054, 61100087), National High Technology Research and Development Program of China (2014AA015202), and National Key Technology Research and Development Program of China (2012BAH39B02).

@&#REFERENCES@&#

