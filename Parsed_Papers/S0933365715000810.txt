@&#MAIN-TITLE@&#A k-mer-based barcode DNA classification methodology based on spectral representation and a neural gas network

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We propose a new alignment-free method for the classification of DNA barcoding based on both a spectral representation and prototype-based unsupervised clustering.


                        
                        
                           
                           We investigate how much the characteristics of different species are related to their DNA barcoding spectral distribution.


                        
                        
                           
                           We compare the proposed method with six state-of-the-art machine learning classifiers and the results confirm our method overcome all the other classifiers when applied to short fragments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Alignment-free analysis

DNA barcode classification




                     k-Mer representation

Neural gas

@&#ABSTRACT@&#


               
               
                  Objectives
                  In this paper, an alignment-free method for DNA barcode classification that is based on both a spectral representation and a neural gas network for unsupervised clustering is proposed.
               
               
                  Methods
                  In the proposed methodology, distinctive words are identified from a spectral representation of DNA sequences. A taxonomic classification of the DNA sequence is then performed using the sequence signature, i.e., the smallest set of k-mers that can assign a DNA sequence to its proper taxonomic category. Experiments were then performed to compare our method with other supervised machine learning classification algorithms, such as support vector machine, random forest, ripper, naïve Bayes, ridor, and classification tree, which also consider short DNA sequence fragments of 200 and 300 base pairs (bp). The experimental tests were conducted over 10 real barcode datasets belonging to different animal species, which were provided by the on-line resource “Barcode of Life Database”.
               
               
                  Results
                  The experimental results showed that our k-mer-based approach is directly comparable, in terms of accuracy, recall and precision metrics, with the other classifiers when considering full-length sequences. In addition, we demonstrate the robustness of our method when a classification is performed task with a set of short DNA sequences that were randomly extracted from the original data. For example, the proposed method can reach the accuracy of 64.8% at the species level with 200-bp fragments. Under the same conditions, the best other classifier (random forest) reaches the accuracy of 20.9%.
               
               
                  Conclusions
                  Our results indicate that we obtained a clear improvement over the other classifiers for the study of short DNA barcode sequence fragments.
               
            

@&#INTRODUCTION@&#

The identification of living species through an analysis of their DNA sequences is an open challenge in bioinformatics. Many approaches for the classification of bacterial isolates, which use, for example, unsupervised clustering [1,2] and probabilistic methods [3], have been proposed. To improve the DNA analysis throughput, the use of well-defined gene regions has been investigated. These regions should contain sufficient information to allow an assignment to the proper taxa [4–6]. In the animal kingdom, the “cytochrome c oxidase subunit 1” (COI) gene, which is located in the mitochondrial DNA, has been proven to be a good marker for biodiversity [7,8]. At this time, the main publicly available repository for the collection and management of DNA barcode sequences is the on-line resource “Barcode Of Life Database” (BOLD) [9]. Although barcode sequences, approximately 650-base pair (bp) in length, are substantially shorter than the complete genome, they have been used for the identification and the assignment of the taxonomic rank of several species, including birds [10], fishes [11,12], and insects [13–15].

Traditional sequence analysis has been performed using classical multiple sequence alignment methods [16]. However, these methods exhibit some drawbacks: (1) they require the accurate tuning of the parameters, and (2) they are highly sensitive to the quality of the sequencing technique. For the purpose of taxonomic identification, alignment-free methods for the analysis of short sequences can overcome the drawbacks of classical methods [17], and several researchers have proposed different solutions based on phylogenetic reconstruction, machine learning and/or statistical methods [18]. For example, La Rosa et al. (2013) [19,20] have proposed two compression-based methods that implement the non-computable universal similarity metric (USM) class of distances [21]. This parameter-free approach allows us to obtain phylogenetic trees considering only the COI gene and exhibit a performance that is comparable to that obtained using standard evolutionary distances. Compression-based approaches have also been adopted for the clustering of bacteria datasets [22,23] and whole mitochondrial genomes [24]. Nevertheless, the proposed methods are sensitive to noisy experimental data because with noisy sequences, which have many undefined nucleotides, a low compression ratio is obtained, and consequently, a less accurate phylogenetic tree is computed.

Better results can be obtained using other alignment-free approaches based on spectral sequence representations. These models are obtained by extracting the frequency of fragments of fixed length k called k-mers from the DNA sequences. The k-mer frequencies are used as features to create a vector representation of DNA sequences with a size of 4
                        k
                     . This DNA sequence representation does not consider information related to the position of k-mers in the original sequence according to the bag-of-words model. To demonstrate how the analysis of DNA word distributions can be representative for many living organisms, Chor et al. [25] adopted this representation for whole-genome sequences when investigating the DNA k-mer distributions in the sequence spectrum.

Other alignment-free approaches for DNA barcode classification do not rely on a spectrum representation of the sequences. For example, in [26], the authors proposed a logic mining method to extract a set of classification rules based on the values, in terms of nucleotide letters, at selected sites in the sequences. The barcode recognition obtained with nucleotide exposes (BRONX) algorithm, presented in [27], aims to identify short variable sequence fragments and their stable flanking regions (called pretext and postext) inside a set of reference DNA barcodes. Then, during the classification phase, a query sequence is first matched against the regions extracted from the reference sequences, and if a match is found, a similarity score is computed between the query and the reference sequence. The reference sequence with the highest score is chosen for identification.

Finally, a text mining approach that considers DNA sequences as text documents and fixed length k-mers as words, was proposed in [28] for the classification of bacteria using another barcode gene, the 16S rRNA. In the above-mentioned work, a probabilistic topic model is trained using the latent Dirichlet allocation (LDA) algorithm [29]; the model is then used to classify unknown sequences according to their most likely topics by representing the probability distributions of the words (k-mers) in the sequences.

In this manuscript, we propose a new alignment-free method for the classification of DNA barcoding based on both a spectral representation and prototype-based unsupervised clustering. A spectral representation introduces the advantage of using fixed-length DNA k-mers, whereas unsupervised clustering allows us to define a set of prototype sequences (cluster centroids) that represent all the elements of the learning dataset. Because the spectrum representation of a DNA sequence defines the occurrence of a fixed number of features, we can consider the distance between two sequences to be the Euclidean distance between their respective features. Using this approach, we can identify some groups of sequences that share common properties (principal directions or discriminant features) by adopting an unsupervised neural network algorithm for prototype-based clustering. As stated by many researchers, these types of machine learning techniques, when applied to bioinformatics, can offer very intuitive and robust results [30–32]. In particular, we adopt the neural gas (NG) algorithm [33], which, compared with other unsupervised techniques, does not suffer from the problem of local minima or topological restrictions [34].

The main goal of this work was therefore to investigate the degree to which the characteristics of different species are related to their spectral distribution. To accomplish this goal, we did not account for the whole spectrum of a DNA sequence but only a small number of words (k-mers) with very high frequency. This choice offers the advantage of obtaining a robust system for the classification of barcode sequences with respect to both the original sequence length and the quality of the sequences in terms of undefined nucleotides. In the proposed representation the signature of the DNA sequence is defined as the smallest set of k-mers that can assign a DNA sequence to its proper taxon. The assignment is performed by considering the highest number of k-mers that are shared between a prototype and a test sequence.

The proposed approach has been tested for the analysis of short fragments with lengths of 300bp and 200bp that are randomly extracted from the original 650-bp barcode sequences. Unfortunately, it is not always possible to obtain a full-length barcode sequence (approximately 650-bp) for classification tasks. For example, in metagenomics applications, in which genetic sequences are extracted mainly from environmental species, only short sequences are available in many cases [35]. The BOLD database also stores short barcode sequences, of approximately 200–400bp. Furthermore, in recent studies [36,37], researchers have worked on the so-called mini-barcode, which is a barcode sequence shorter than 650-bp (approximately 100–200bp), to demonstrate that it is possible to accomplish classification tasks even with shorter barcode sequences.

Finally, we compared our method with six supervised classification algorithms: support vector machine (SVM) [38], random forest (RF) [39], ripper [40], naïve Bayes (NB) [41], ridor [42], and classification tree (CT) [43]. The obtained results show that our method is directly comparable, in terms of the classification metrics (accuracy, precision, and recall), with all the other classifiers for the analysis of full-length sequences. Conversely, our k-mer-based approach outperforms the other algorithms when used for the analysis of short DNA barcode sequence fragments.

The main goal of the proposed method, which is considered an extension of our previous work [44], is the classification of an unknown DNA sequence using the frequency of a small set of k-base “keywords”, i.e., k-mers.

In this section, we first describe the dataset that was used in our trials. The following procedures are then explained. The first procedure, which is shown in Fig. 1
                     , describes the DNA barcode spectral representation obtained from the extraction of k-mers with an appropriate length k. The second procedure regards prototype extraction and includes the workflow used to obtain the smallest number of sequence prototypes, namely cluster centroids, as depicted in Fig. 2
                     . The third procedure is the pipeline adopted to assign a taxon label to each cluster centroid and extract the most frequent k-mers, and this procedure is depicted in Fig. 3
                     . Finally, the last procedure, which is depicted in Fig. 4
                     , describes the classification of an unknown sequence.

For the experimental analysis, we used real DNA barcode datasets provided by BOLD (Accessed: 8 march 2013). Because BOLD collects a large number of barcode datasets from less than 15 separate projects that are representative of different phyla in the animal kingdom, we consider 10 datasets belonging to 10 different BOLD projects, which consist of 2212 barcode sequences. All the sequences downloaded from the BOLD database are already labelled according to their taxonomic rank, from phylum to species. These datasets differ from one another with respect to the number of species, the number of barcode sequences (specimens), the sequence length and the sequence quality, which is expressed in terms of sequences with undefined nucleotides. To develop a quantitative analysis in a consistent environment, we chose some criteria that are available in BOLD for downloading barcode sequences. More specifically, we removed all the sequences shorter than 500bp and longer than 800bp and those that are classified in BOLD as non-barcode compliant. In fact, because the typical sequence length of the COI barcode gene is approximately 650-bp [7], the longer sequences contain part of the information content related to other genes, whereas shorter sequences cannot possibly contain all the gene information. Finally, we manually removed all sequences that are unique exemplars of a specific species: in fact, if a species has only one specimen, no test algorithm will be able to identify those species with a cross-validation technique. Shorter test sequences (200bp and 300bp) have been obtained by randomly extracting 200 and 300 consecutive nucleotides, respectively, from the original full-length sequences.


                        Table 1
                         reports a complete list of the barcode datasets that were used in our experiments.


                        k-Mers are short fixed-length DNA snippets of length k. Several studies have been conducted to determine the appropriate value of k for the analysis of genomic sequences. The main issue is to obtain a good trade-off between the information content encoded in the k-mer and the corresponding computational complexity. For example, with a small value of k, i.e., approximately 2 or 3, we obtain a sequence spectral representation with a maximum size of 43
                        =64, but it is not possible to extract good information. Otherwise, considering a larger value of k, such as k
                        =8, we can obtain a rich information content, but a spectral representation of size 48
                        =65536 could introduce the so-called curse of dimensionality. Among other studies, rigorous studies on the genomic DNA k-mer distributions are presented in the literature [25,45–47]. In particular, in [45–47] a k-mer length of k
                        =5 provided the best trade-off between an adequate information content and a manageable computational complexity. Moreover, Chan and colleagues [46] noted that an increase in the value of k could deteriorate the assignment of DNA sequences to the correct category. For these reasons, we considered a k-mer length of 5, which resulted in up to 1024 different 5-mers to represent the DNA sequences.

Another interesting analysis was reported by Kuksa and colleagues, who, in addition to a standard spectral representation, introduced a mismatch kernel method that adds inexact sequence matching, thus increasing the barcode sequence spectrum density [45]. As a result, the new spectrum contains both words of length k that are obtained with a sliding extraction window over the DNA sequence and all the k-mers with at most m different bases compared with each extracted word. In this approach, information regarding the similarity among words (for less than m bases) is introduced, and the effectiveness of this mismatch representation for the DNA barcode sequences is empirically demonstrated; the results depend strictly on the choice of the correct values for k and m.

The spectral representation builder component of our method is described in Fig. 1. Ideally, we should consider an input sequence S and use a sliding window of size 5, that is shifted by 1 base at a time, as depicted in Fig. 1(a). The frequency of the 5-mer extracted from the sequence is updated and the window is moved to the next position. All the extracted k-mers are used by block B, which is the feature space conversion block, to build a frequency vector s
                        
                           seq
                        
                        =[s
                        1, s
                        2, …, s
                        
                           N
                        ], where s
                        
                           i
                         is the frequency of the i−th word (considering AAAAA as the 1st word, AAAAC as the 2nd word, and so on) in sequence seq, and N
                        =45
                        =1024 is the number of possible k-mers. Given a set of k-mers, a sequence can be represented as a vector of the frequencies of the k-mers. Of course, no information regarding the k-mer position in the original sequence is considered.

The representing vectors that are obtained using this simple technique are very sparse; for this reason, we also accounted for another sequence representation, as suggested by [45], which includes, for each k-mer, all the possible combinations of a single nucleotide mismatch, as depicted in Fig. 1(b). Using this method, the frequency of the k-mer AGCTA will increase by 20 different k-mer positions:
                           
                              •
                              considering the mutation of the first base, the frequency of the k-mers CGCTA, GGCTA, and TGCTA will be increased;

considering the mutation of the second base, the frequency of the k-mers AACTA, ACCTA, and ATCTA will be increased, and so on.

The prototype extraction procedure is shown in Fig. 2.

Sequence vector representations, which are obtained either with standard or 1-mismatch representations, can be considered a set of sequence spectra, and can be clustered using the NG algorithm.

The neural gas network is a self-organizing neural network that modifies the neural units to approximate the distribution of an input pattern set during the so-called learning or training process. The output of the NG tool is a set of clusters that identify a group of similar sequences. In our case, the n centroids of the clusters can also be considered the “reference spectra”, or prototypes, for the different groups of sequences. Each cluster centroid c
                        
                           i
                         has a frequency vector that does not correspond to a particular “real” input sequence but characterizes the sequence representation of all the elements in the cluster, similarly to how the coordinates of a pseudo centre in a point cloud approximate all the point coordinates of the point in a cloud. To identify the smallest number of clusters n
                        
                           s
                         that distinguish the different groups of spectra, we calculate the overall accuracy (OA) of the clustering as a function of the number of centroids n and take as n
                        
                           s
                         the minimum number of centroids that maximise the OA:
                           
                              (1)
                              
                                 
                                    n
                                    s
                                 
                                 =
                                 arg
                                 min
                                 {
                                 max
                                 {
                                 OA
                                 (
                                 n
                                 )
                                 }
                                 }
                                 }
                              
                           
                        The identified reference spectra are responsible for representing a group of sequences that belong to a specific taxonomic rank (such as phylum, class, and order). This taxonomic rank is assigned to each prototype according to the taxa of the largest number of elements that belong to that cluster.

The method presented in Fig. 2 is applied at each taxonomic level to obtain a set of reference spectra for each taxon in a hierarchical manner. For this reason, the learning process is repeated for all the taxonomic levels, and at the end of the training phase, we end up with a set of reference spectra for each taxonomic rank level. We used the implementation of the neural gas algorithm provided by the flexclust R package [48].

The DNA k-mer spectra obtained using the described technique present a highly irregular distribution of word frequencies, as was also previously noted by other researchers [45,25]. This uneven k-mer frequency distribution justifies the choice of the most frequent k-mers as distinctively characteristic of a sequence class.

To establish how many words are needed to identify the correct taxonomy of a DNA sequence with a good approximation, we search the smallest number of words that are able to assign the spectrum representation of a test sequence, 
                           
                              
                                 
                                    s
                                 
                              
                              
                                 
                                    seq
                                    t
                                 
                              
                           
                        , to its own reference centroid. For this purpose, we perform a two-step process to estimate the smallest number 
                           w
                         of high-frequency words (HFWs), i.e., the 
                           w
                         greatest components (the highest peaks in the frequency histograms) that are distinctive for a specific taxon. This process is shown in Fig. 3. At this point, each centroid is identified as a set of HFWs that characterises a specific taxon. If a taxon is represented by more than one centroid, we can account for this taxon as codified by more than one set of HFWs.

The first step (Block D in Fig. 3) is responsible for the association of each centroid c
                        
                           i
                         to a single taxon using pre-labelled DNA barcode training sequences through a majority voting mechanism.

The second step (Block E in Fig. 3) checks for the smallest value of 
                           w
                         by exploiting the Jaccard distance [49], J
                        
                           δ
                        , between the first 
                           w
                         
                        HFWs of each centroid c
                        
                           i
                         and the first 
                           w
                         
                        HFWs of all the sequences that belong to the same cluster of c
                        
                           i
                        , at the end of the NG training phase. The Jaccard distance J
                        
                           δ
                         between two finite sets A and B is defined as:
                           
                              (2)
                              
                                 
                                    J
                                    δ
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                A
                                                ∪
                                                B
                                             
                                          
                                       
                                       −
                                       
                                          
                                             
                                                A
                                                ∩
                                                B
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                A
                                                ∪
                                                B
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ∥·∥ is the number of element of a set. J
                        
                           δ
                        
                        ∈[0;1]: if J
                        
                           δ
                        
                        =0 the sets are equal, if J
                        
                           δ
                        
                        =1 the sets have no shared elements. We adopted the Jaccard distance because we wanted to find how many HFWs are in common between the centroids and the elements belonging to the same cluster, and J
                        
                           δ
                         provides a dissimilarity measure based on this comparison.

In more detail, for each centroid 
                           
                              
                                 
                                    c
                                 
                              
                              i
                           
                           =
                           [
                           
                              c
                              
                                 
                                    i
                                    1
                                 
                              
                           
                           ,
                           
                              c
                              
                                 
                                    i
                                    2
                                 
                              
                           
                           ,
                           …
                           ,
                           
                              c
                              
                                 
                                    i
                                    N
                                 
                              
                           
                           ]
                        , the vector components are ordered in decreasing order: 
                           [
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          1
                                       
                                    
                                 
                              
                           
                           ,
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          2
                                       
                                    
                                 
                              
                           
                           ,
                           …
                           ,
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          N
                                       
                                    
                                 
                              
                           
                           ]
                        , such that 
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          1
                                       
                                    
                                 
                              
                           
                           ≥
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          2
                                       
                                    
                                 
                              
                           
                           ≥
                           ⋯
                           ≥
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          N
                                       
                                    
                                 
                              
                           
                        . We then consider only the first 
                           w
                         components 
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          l
                                       
                                    
                                 
                              
                           
                        , where 
                           l
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           w
                        . The words that correspond to 
                           
                              c
                              
                                 
                                    i
                                    
                                       
                                          λ
                                          l
                                       
                                    
                                 
                              
                           
                         components, define a signature for the sequence. The values of this distance are between 1 (if two sets have no common words) and 0 (if two sets have the same words). Finally, we define the validation error 
                           
                              e
                              v
                           
                         at varying values of 
                           w
                        , 
                           
                              e
                              v
                           
                           (
                           w
                           )
                        , as follows:
                           
                              (3)
                              
                                 
                                    e
                                    v
                                 
                                 (
                                 w
                                 )
                                 =
                                 min
                                 {
                                 
                                    J
                                    δ
                                 
                                 
                                    |
                                    
                                       HFW
                                       =
                                       w
                                    
                                 
                                 (
                                 (
                                 
                                    
                                       
                                          s
                                       
                                    
                                    
                                       seq
                                       ∈
                                       
                                          
                                             
                                                c
                                             
                                          
                                          i
                                       
                                    
                                 
                                 )
                                 ,
                                 (
                                 
                                    
                                       
                                          c
                                       
                                    
                                    i
                                 
                                 )
                                 )
                                 }
                              
                           
                        As will be explained in the next section, to obtain a low error percentage, we calculate 
                           
                              e
                              v
                           
                           (
                           w
                           )
                         to determine how many words can discriminate a test sequence among the different classes of the taxonomy.

At this point, the spectral representation of test sequence 
                           
                              
                                 
                                    s
                                 
                              
                              
                                 
                                    seq
                                    t
                                 
                              
                           
                         is assigned to a reference centroid c
                        
                           ref
                        , where index ref is defined in Eq. (4). Because we account for only 
                           w
                         
                        HFWs, in this equation, we adopt the Jaccard distance, as described in Eq. (2). If both centroid c
                        
                           ref
                         and test sequence seq
                        
                           t
                         correspond to the same taxon, the sequence is well classified; otherwise, it is misclassified
                           
                              (4)
                              
                                 ref
                                 =
                                 arg
                                 
                                 
                                    min
                                    i
                                 
                                 {
                                 dist
                                 (
                                 
                                    
                                       
                                          s
                                       
                                    
                                    
                                       
                                          seq
                                          t
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          c
                                       
                                    
                                    i
                                 
                                 )
                                 }
                                 .
                              
                           
                        
                        Fig. 4 shows the workflow for the classification of unknown test sequences. In particular, after an unknown DNA sequence is translated into its own spectral representation (
                           
                              
                                 
                                    s
                                 
                              
                              
                                 
                                    seq
                                    t
                                 
                              
                           
                        ), we test the signature, i.e., its most frequent words, for example, at the phylum taxonomic (
                           
                              w
                              phylum
                           
                        ) level, by comparing its 
                           w
                         highest peaks with as many highest peaks of all the reference spectra that belong to the phylum taxonomy. The number of HFWs compared is the value found during the procedure described in the previous subsection. The test sequence is assigned to the taxonomic level whose reference spectrum shares the largest number of HFWs with the input sequence. The classification is performed in a hierarchical manner; in fact, after the predicted phylum is computed, the same comparison method will be performed at the family taxonomic level, and so on until the species level: this procedure is reported in Fig. 5
                        .

Our method has been compared with six other state-of-the-art supervised machine learning classifiers: SVM, RF, ripper, NB, ridor and CT. All the algorithms utilize the vector representation of input sequences obtained using the k-mer decomposition described in Section 2.2 and shown in Fig. 1. In this study, we used the SVM implementation provided by the R package e1071 
                        [50], which allows a simple interface with the library LibSVM 
                        [51]. SVM has been run with default parameters and a Gaussian radial basis kernel. For the CT, we used the implementation provided by the R package rpart
                        
                           1
                        
                        
                           1
                           
                              http://cran.r-project.org/web/packages/rpart/index.html.
                         considering a ten-fold cross-validation procedure to prune the trees and obtain the classification tree with the lowest error rate. The other classification algorithms, namely RF, ripper, NB, and ridor, were run with the default configurations using the “Experimenter” framework provided by the Weka 3.6.1 platform [52].

@&#EXPERIMENTAL RESULTS@&#

In this section, we report and discuss some experimental tests that were, used for checking the performance of the proposed method. To show the advantages of using the proposed method for DNA barcode sequence classification, we compared it with six supervised classification algorithms, i.e., SVM, RF, ripper, NB, ridor and CT.

As stated in Section 2.1, we tested our classification method on real DNA barcode datasets. More specifically, as shown in Table 1, we selected 10 datasets from different BOLD projects, which contained a total of 2212 sequences from 68 species. Moreover, four datasets (ANOD, BACA, EBFSF and PMF) contain more than one genus, and two of them (EBFSF and PMF) are separated into more than one family. For each dataset, all the sequences belong to the same order; for this reason, this field is not reported in the table. It is important to note that the dimensions of the datasets are not fixed; for example, the 2nd dataset (ANOD) contains 447 sequences, whereas the 7th dataset (LHSMI) contains only 103 sequences. Obviously, the specimens/species ratio is not constant for each dataset; in fact, a consistent difference is observed at the intra-species level for several datasets. For example, the 3rd dataset (BACA) has seven species: the larger species, called “Formica neorufibarbis_2”, is represented by 272 specimens, whereas the smaller species, called “Myrmica sp.1”, is represented by six specimens.

Unbalanced distributions of specimens over their respective species represent a problem for unsupervised clustering algorithms (such as neural gas) because these techniques aim to generate groups of sequences that are equally spread out and could emphasise any type of distortion. As we will demonstrate later, the proposed method can classify full-length sequences at least as well as the other classification algorithms and outperforms the other algorithms for the classification of short fragment sequences (300bp and 200bp) with respect to the high variability of the input distribution.

The validation of our method is divided into two parts: first, we want to show the efficacy of the representation technique that is used to create the feature space, and then, we perform a comparison among the proposed method and six other classifiers to show which classifier can better predict the taxonomic rank of the barcode sequences.

With regard to the representation technique, we considered both the standard spectral representation, that accounts for only the frequency of all the k-mers extracted with sliding windows (as explained in Section 2) and the modification introduced by Kuksa [45], which, in addition, accounts for all the single-base (1-mismatch) mutations for each k-mer.


                        Fig. 6
                         shows the comparison of the validation errors at the phylum taxonomic level between two different implementations of the proposed method: the curve labelled “standard spectrum” exploits the standard spectral representation, whereas the curve labelled “1-mismatch spectrum” performs the other implementation. To estimate the performance of the classification method, we adopted the “ten-fold cross-validation” statistical method.

The figure shows the number of high-frequency words (
                           w
                        ), ranging from 10 to 100, as a function of the validation error, 
                           
                              e
                              v
                           
                           (
                           w
                           )
                        , as defined by Eq. (3). The results clearly show how the training error percentage for both curves is very similar, and a low validation error was reached. For example, if we account for only 25 HFWs, then it follows that, with the “1-mismatch spectrum” representation, 
                           
                              e
                              v
                           
                           (
                           25
                           )
                           =
                           0.021
                         (we can classify a barcode sequence to the correct phylum at 97.8%), whereas with the “standard spectrum” representation, 
                           
                              e
                              v
                           
                           (
                           25
                           )
                           =
                           0.014
                         (we can classify a barcode sequence to the correct phylum at 98.6%). The results for the classification of a sequence into the correct family, genus and/or species are not reported in this manuscript, but we obtained a low 
                           
                              e
                              v
                           
                         (approximately 0.02÷0.03) and a low standard deviation with 30 HFWs for the family and genus levels and 35 HFWs for the species level. These results have already been published in our previous study [44].

Concerning the reduced sequences, to measure the performance with changes in the HFW number, we adopted the test pipeline presented in Fig. 5. In this case, no cross-validation technique was performed, because all the reduced sequences are tested in a single step. The results for the classification of 200-bp and 300-bp sequences are reported in Figs. 7 and 8
                        
                        , respectively, where the numbers of HFWs as function of testing error percentage are shown. In contrast to the previous graph, these two graphs show how the standard representation (without mismatch) can better preserve the information regarding the HFWs of the full-length sequences. This finding was obtained because k-mers that are generated artificially with mismatches introduce a type of redundancy that can be read as noise when only a portion of the sequence is taken into account. In other words, the “1-mismatch spectrum” representation does not allow us to preserve the same set of HFWs in both a full length DNA barcode sequence and its extracted sub-sequences.

To verify whether the lower scores obtained using the “1-mismatch spectrum” representation do not depend on our method, we used SVM while considering the standard and mismatch representations of the sequences. Again, as reported in Table 2
                        , we note a decrease in the classification results using the mismatch representation. For these reasons, from here on, all the reported results are computed while considering only the standard representation.

The bar charts presented in Figs. 9–11
                        
                        
                         show the comparisons in terms of the accuracy, recall and precision scores, respectively, among the proposed method and the other classifiers, considering the experimental dataset classification results for full-length, 300-bp and 200-bp sequences. These scores are reported according to the dataset and the taxonomic rank that was considered. We also obtained a specificity score for the classification results, but this score is not reported in this manuscript because the obtained scores are quite similar for all the seven classification methods.

For the analysis of full-length sequences, our method provides results in terms of the accuracy, recall and precision scores, which are directly comparable with the results obtained with the other classifiers. In fact, at the phylum level, our method reaches almost 99% accuracy compared with the 100% accuracy obtained with the other classifiers, but the CT method reaches an accuracy of 97%. At the family, genus and species levels, the accuracy decays to approximately 95% of the accuracy score obtained with the proposed method, compared with accuracies of 98-96% obtained for the other classifiers, but the accuracy obtained for the CT method decays to 81%. Four of the classifiers, i.e., RF, ripper, NB and ridor, appear to be more reliable for the analysis of full-length sequences in terms of precision, and in fact, at the species level, the precision score decays to 99–97% compared with the proposed method, SVM, and CT which, under the same conditions, reach a precision scores of 89.9%, 64.2% and 49%, respectively. We obtained a similar trend for the recall measure.

All three bar charts show a different trend when we consider short sequences, i.e., sequence fragments of 300bp and 200bp. In these cases, our approach demonstrated its robustness with regard to the sequence lengths for all the evaluation measures. In fact, even if the results that were obtained with the proposed algorithm are comparable with those obtained with the RF and NB classifiers at the phylum level, our method outperformed all the classifiers with regard to the family, genus and species levels. For example, at the species level, we obtained accuracy scores for 300-bp and 200-bp sequences of 72.0% and 64.8% with our method, against 58.1% and 20.5% with SVM, 42.7% and 20.9% with RF, 31.0% and 15.02% with ripper, 22.2% and 11.0% with NB, 19.6% and 14.1% with ridor, and 10.2% and 5.8% with CT, respectively. This trend is the same as that obtained for all the other taxonomic ranks considering both 300-bp and 200-bp fragments.

@&#CONCLUSIONS@&#

In this manuscript, we propose an alignment-free method for DNA barcoding classification. This technique employs a small number of the most frequent k-mers (signature) obtained from the spectral representation of barcode sequences. We use the neural gas unsupervised clustering algorithm to identify some groups of sequences that share common properties. The centroids of these groups define sequence prototypes that provide a reference spectrum for the elements belonging to that group. The classification is therefore performed by comparing only the signature of the prototypes and the unknown test sequences. We tested the method on 10 datasets from the BOLD database at different taxonomic levels (i.e., phylum, family, genus and species). We considered full-length sequences and both 300-bp and 200-bp sequences that were extracted from the original data to test the robustness of our method with regard to the sequence length. Comparisons were performed in terms of several metrics (accuracy, precision, recall, and specificity) with six supervised machine learning classification algorithms: SVM, RF, ripper, NB, ridor and CT. We considered these tools because they are state-of-the-art machine learning classifiers that utilize spectral representations (feature vectors) of input sequences. In future work, we plan to compare our method with other alignment-free barcode classifiers, such as the BRONX [27] tool and the algorithm proposed by [26], both of which implement different computational approaches. The obtained results imply that our method provides very similar results compared with those obtained from the other classifiers when considering full-length sequences. Most importantly, it outperforms all the other classifiers in the analysis of short fragments (300bp and 200bp) of DNA barcode sequences.

@&#REFERENCES@&#

