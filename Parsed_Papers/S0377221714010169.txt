@&#MAIN-TITLE@&#Pattern-set generation algorithm for the one-dimensional cutting stock problem with setup cost

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a two-stage approach for the one-dimensional cutting stock problem.


                        
                        
                           
                           Many patterns are generated in the first stage by a sequential grouping procedure.


                        
                        
                           
                           An integer programming model is solved to select the patterns in the solution.


                        
                        
                           
                           The sequential grouping procedure is efficient for pattern reduction.


                        
                        
                           
                           Solving the integer programming model can significantly reduce the total cost.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cutting

Cutting stock

One-dimensional cutting

Pattern reduction

Setup cost

@&#ABSTRACT@&#


               
               
                  The primary objective in the one-dimensional cutting stock problem is to minimize material cost. In real applications it is often necessary to consider auxiliary objectives, one of which is to reduce the number of different cutting patterns (setups). This paper first presents an integer linear programming model to minimize the sum of material and setup costs over a given pattern set, and then describes a sequential grouping procedure to generate the patterns in the set. Two sets of benchmark instances are used in the computational test. The results indicate that the approach is efficient in improving the solution quality.
               
            

@&#INTRODUCTION@&#

In the classical one-dimensional cutting stock problem (CSP), m item types with lengths (l
                     1, …, lm
                     ) and demands (d
                     1, …, dm
                     ) are cut from stock bars of length L to minimize material cost. The solution is a cutting plan that contains a set of different cutting patterns, each of which has specified frequency. The primary objective in the CSP is to minimize material cost. Auxiliary objectives (costs) exist in real-life production (Cherri, Arenales, Yanasse, Poldi, & Vianna, 2014; Kallrath, Rebennack, Kallrath, & Kusche, 2014), one of which is pattern reduction. It is necessary to adjust the positions of the cutting tools in the cutting machine each time a new pattern is set up. Reducing the pattern count (the number of different cutting patterns) of the cutting plan is useful to decrease setup cost, especially for the cases where setup cost is high. A typical case is the cutting of a large steel slab, where the cutting tools have large size, changing their positions incurs much additional cost and setup time.

A heuristic is presented in this paper for the CSP with pattern reduction (CSPPR). It solves the CSPPR in two stages. In the first stage, it calls a sequential grouping procedure (SGP) to generate a set of patterns. In the second stage, it uses the CPLEX optimizer to solve an integer linear programming (ILP) model that minimizes the sum of material and setup costs over the given pattern set. The proposed algorithm is called the SGPIP to denote that the SGP is used in the first stage to generate the patterns and an integer programing model (IP) is solved in the second stage over the patterns. Computational test is performed on two sets of benchmark instances to compare the algorithms for the CSPPR. The results show that the SGPIP yields the best average solution quality.

The remaining contents are arranged as follows. The literature is reviewed in the next section. The ILP model that minimizes the sum of material and setup costs over a given pattern set is established in Section 3, together with the general frame of the SGPIP. The SGP for generating the patterns in the pattern set is presented in Section 4. Computational results are reported in Section 5 and conclusions are given in the last section.

@&#LITERATURE REVIEW@&#

A simple literature review for the CSPPR is given in this section. A similar review can be found in Cui and Liu (2011).

An exact approach is presented in Vanderbeck (2000). It formulates the CSPPR as a quadratic integer programming problem. The objective is to minimize the pattern count, given the minimum number of bars required to meet the item demands. Sixteen practical instances were used in the experimental test, where the number of item types ranges from 5 to 32. Only 12 instances were solved to optimality because of the computation time limit (2 h per instance). This indicates that the approach is adequate for solving small instances.

Approximate algorithms that are based on the sequential heuristic procedure (SHP) are widely used to solve the CSPPR. The SHP in Haessler (1975) selects a pattern that satisfies the aspiration levels of trim loss and frequency. It is based on the observation that increasing the frequency of the current pattern is often useful for pattern reduction. The SHP in Vahrenkamp (1996) uses the same idea, where the current pattern is chosen from 200 patterns obtained from random bin packing. The algorithms in Cui, Zhao, Yang, and Yu (2008) and Cui and Liu (2011) generate the current pattern using a subset of the remaining items. This subset is determined to maximize the frequency of the current pattern, observing the constraint that both the number of included item types and the total length of the included items should not be smaller than the specified thresholds. Dikili, Sariöz, and Pek (2007) solved the CSPPR in two-stages. A simple heuristic generates a large set of cutting patterns in the first stage. In the second stage, a SHP selects some of the first-stage patterns to form the cutting plan.

The heuristic approach in Foerster and Wäscher (2000) solves the CSPPR in two stages. A cutting plan is generated at the first stage without considering pattern reduction. A pattern combination method is used for pattern reduction at the second stage. It iteratively combines two patterns to 1, 3 to 2 and 4 to 3, until the pattern count cannot be reduced further.

The heuristic approach presented in Umetani, Yagiura, and Ibaraki (2003) allows both surplus and shortage of the item types. It cannot solve the CSPPR of this paper because the CSPPR does not allow shortage of the items and takes surplus as waste. Their approach and the computational results will not be further commented for this reason.

A hybrid heuristic method is available in Yanasse and Limeira (2006). It solves the CSPPR in three stages. A SHP generates some patterns in the cutting plan at the first stage, subject to the constraint that each pattern must fulfill the demands of at least two item types. A residual problem is formed after all such patterns have been generated. It is also solved by the SHP without considering the previous constraint. The patterns of the first two stages form the complete cutting plan. The pattern combination method in Foerster and Wäscher (2000) is used at the third stage to reduce the pattern count further.


                     Belov and Scheithauer (2003) proposed an integer programming model for pattern reduction, and developed a branch-and-price algorithm to solve the model. The computational results show that the algorithm outperforms that of Foerster and Wäscher (2000) in solution quality. Later the authors extended the algorithm to deal with both pattern reduction and open stacks minimization (Belov & Scheithauer, 2007).


                     Mobasher and Ekici (2013) developed a mixed integer linear program model and proposed two local search algorithms and a column generation based heuristic algorithm.


                     Cui, Yang, Zhao, Tang, and Yin (2013) presented a sequential grouping heuristic for the two-dimensional cutting stock problem with pattern reduction, where sequential means that the patterns in a cutting plan are generated sequentially and grouping indicates that each next pattern is obtained from considering only the items in a selected subset of the remaining items. The idea will be used in this paper to design the SGP to generate the patterns.

This paper formulates the CSPPR as an ILP that minimizes the sum of material and setup costs over a given pattern set. The proposed algorithm SGPIP first calls the SGP to generate the patterns in the set, and then uses the CPLEX optimizer to solve the ILP over the set. The approach is heuristic because not all possible patterns are considered. Computational test on two sets of benchmark instances is performed to compare the algorithms for the CSPPR. The results show that the SGPIP performs the best in improving the solution quality.

Recently, a pattern-set generation algorithm (PSG) for the one-dimensional multiple stock sizes cutting stock problem is presented in Cui, Cui, and Zhao (2014). It also generates a set of patterns in the first stage and solves an ILP model over the generated patterns in the second stage. It differs from the SGPIP mainly in the following aspects: (1) The PSG uses a residual heuristic to generate the patterns in the first stage, whereas the SGPIP uses the SGP to obtain the patterns. The computational results later reported in Section 5.3 indicate that the residual heuristic used by the PSG may not be effective in pattern reduction. (2) The ILP model solved by the PSG does not consider pattern reduction.

The following notations are used:

                        
                           Z
                           ILP
                        
                        
                           objective value (sum of material and setup costs)

set of patterns, Q = {Q
                              1, …, QN
                              }

number of patterns in Q
                           

cost per bar

cost per setup (cost of each new pattern)

frequency of pattern Qj
                              
                           

0/1 variable denoting whether Qj
                               is used (ɛ
                                 j
                               = 1) or not (ɛ
                                 j
                               = 0)

number of type-i items in pattern Qj
                              
                           

upper bound of pattern frequency, 
                                 
                                    M
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       d
                                       i
                                    
                                 
                              
                           

set of non-negative integers

The SGPIP of this paper solves the ILP model in two stages. In the first stage, it calls the SGP (described in the next section) to generate the patterns in Q. Meanwhile a stage-one solution is obtained. In the second stage, it uses the CPLEX optimizer as optimization engine to solve the ILP model to obtain the stage-two solution. The stage-two solution may be not optimal (over set Q) because a limit is placed on the computation time. Hence the better one of the two solutions is selected.

Procedure SGP is called by the SGPIP in the first stage to generate the patterns in set Q and to obtain the stage-one solution. The following notations are used to describe it:

                           
                              Z
                           
                           
                              cost of the current cutting plan

cost of the best cutting plan obtained in performing the SGP. It is also the cost of the stage-one solution when the SGP is finished

ID of the current generation

number of maximum generations

current pattern, P = (p
                                 1, …, pm
                                 )

remaining demand of type-i items, i = 1, …, m
                              

maximum number of type-i items that can be used for generating the current pattern P, i = 1, …, m.

value of a type-i item

grouping parameter for generation G, G = 1, …, G
                                 max.

grouping parameter for generation G, G = 1, …, G
                                 max.

Call SetGroupPara() to set parameters αG
                                  and βG, G = 1, …, G
                                 max. Let ci
                                  = li, i = 1, …, m. Let Z
                                 SGP = +∞ and G = 0.

Let G = G + 1. Let ri
                                  = di, i = 1, …, m. Perform Steps 3 to 7 to generate the current cutting plan.

Call 
                                    
                                       GetCIList
                                       (
                                       
                                          α
                                          G
                                       
                                       ,
                                       
                                          β
                                          G
                                       
                                       )
                                    
                                  to determine bi, i = 1, …, m.

Solve the following bounded knapsack problem to obtain pattern P: 
                                    
                                       max
                                       
                                          (
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                
                                                   c
                                                   i
                                                
                                                
                                                   p
                                                   i
                                                
                                             
                                          
                                          )
                                       
                                    
                                 ; 
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          
                                             l
                                             i
                                          
                                          
                                             p
                                             i
                                          
                                          ≤
                                          L
                                       
                                    
                                 ; pi
                                  ≤ bi
                                  and integer, i = 1, …, m.

Add P to the current cutting plan and determine its frequency as f = min{⌊ri
                                 /pi
                                 ⌋| pi
                                  > 0}, i = 1, …, m. Let ri
                                  = ri
                                  − fpi
                                  to update the remaining demands, i = 1, …, m.

Call CorrectValues() to update the item values.

Go to Step 3 if 
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          r
                                          i
                                       
                                       >
                                       0
                                    
                                 ; otherwise add the patterns in the current cutting plan to set Q and go to Step 8.

If Z < Z
                                 SGP, let Z
                                 SGP = Z and record the current cutting plan as the best.

If G < G
                                 max then go to Step 2; otherwise return the best cutting plan as the stage-one solution.

Step 3 calls 
                           
                              GetCIList
                              (
                              
                                 α
                                 G
                              
                              ,
                              
                                 β
                                 G
                              
                              )
                           
                         to select a subset of the remaining items to generate the current pattern. The purpose is to increase the frequency of the pattern. Grouping parameters αG
                         and βG
                         determine the items that will be selected. They are obtained in Step 1 by callingSetGroupPara(). The contents of 
                           
                              GetCIList
                              (
                              
                                 α
                                 G
                              
                              ,
                              
                                 β
                                 G
                              
                              )
                           
                         will be described in Section 4.2 and those of SetGroupPara() in Section 4.3.

The item values are used in generating each pattern (Step 4). They are initialized to their lengths in Step 1 and updated in Step 6. The contents of CorrectValues() that updates the item values will be described in Section 4.4.

The function determines the items in the CI-list, where CI represents candidate items. The items in the CI-list are used in Step 4 of the SGP to generate the current pattern. The method to design the function is the same as that used in Cui and Liu (2011). The following notations and parameters are used:


                        
                           
                              B
                           
                           
                              CI-list. B = [b
                                 1, …, bm
                                 ], 0 ≤ bi
                                  ≤ ri
                                 . Type-i is said to be in the list if bi
                                  > 0

number of the item types currently in B
                              

total length of the items currently in B
                              

It is obvious that the larger the average frequency of the patterns, the smaller the pattern count. Increasing the frequency of the current pattern is often useful for pattern reduction. As part of our heuristic, we choose to set bi
                         = ⌊ri
                        /k
                        0⌋, i = 1, …, m, where k
                        0 is a positive integer. Then k
                        0
                        bi
                         ≤ ri, i = 1, …, m. From Step 5 of the SGP, the frequency of the current pattern f = min{⌊ri
                        /pi
                        ⌋|pi
                         > 0.} ≥ min{⌊k
                        0
                        bi
                        /pi
                        ⌋|pi
                         > 0.} ≥ k
                        0, because bi
                         ≥ pi
                         holds for i = 1, …, m. The CI-list is determined such that k
                        0 is maximized, observing the following two constraints to avoid low material utilization: (1) the number of included item types should not be smaller than αG
                        , and (2) the total length of the included items should not be smaller than βGL. If the constraints cannot be satisfied, all remaining items are added to the CI-list. The contents of 
                           
                              GetCIList
                              (
                              
                                 α
                                 G
                              
                              ,
                              
                                 β
                                 G
                              
                              )
                           
                         are as follows:

                           
                              Let k
                                 max = max{ri
                                 }, i = 1, …, m.

For k = k
                                 max down to 1


                                 Let nB
                                  = LB
                                  = 0.


                                 For i = 1 to m
                              


                                 Let bi
                                  = ⌊ri
                                 /k⌋. If bi
                                  > 0 then let nB
                                  = nB
                                  + 1 and


                                 
                                 LB
                                  = LB
                                  + bili
                                 .


                                 If nB
                                  ≥ αG
                                  and LB
                                  ≥ βGL then let k
                                 0 = k and


                                 exit from the function.

Let k
                                 0 = 1, bi
                                  = ri, i = 1, …, m.

The function determines the grouping parameters αG
                         and βG, G = 1, …, G
                        max. These parameters are used in Step 3 of the SGP to select the items that can be considered in generating the current pattern. Considering that αG
                         and βG
                         are unknown, we try all possibilities from a grid α ∈ {1, 2,…, α
                        max}, β ∈ {1, 1 + Δβ, …, β
                        max}. Initially let G = 0. The contents of the function are as follows, where α
                        max, β
                        max and Δβ are parameters:

                           
                              
                                 While G < G
                                 max
                              


                                 For α = 1 to α
                                 max  Step 1


                                 For β = 1 to β
                                 max  Step Δβ
                              


                                 Let G = G + 1, αG
                                  = α, βG
                                  = β.


                                 If G = G
                                 max then return.

The item values are updated by the function CorrectValues() in Step 6 of the SGP after the current pattern is generated. Let 
                           
                              
                                 U
                                 P
                              
                              =
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       
                                          p
                                          i
                                       
                                       
                                          l
                                          i
                                       
                                    
                                 
                                 /
                                 L
                              
                           
                         be the material utilization of the current pattern. λ and η are two parameters of real values, λ > 1 and 0 < η < 1. Let g
                        2 = ηpif/di
                         and g
                        1 = 1 − g
                        2. The formula for updating the item values is

                           
                              
                                 
                                    
                                       c
                                       i
                                    
                                    ←
                                    
                                       g
                                       1
                                    
                                    
                                       c
                                       i
                                    
                                    +
                                    
                                       g
                                       2
                                    
                                    
                                       
                                          l
                                          i
                                          λ
                                       
                                       /
                                       
                                          U
                                          P
                                       
                                    
                                 
                              
                           
                        The information of the previous patterns is considered in the first entry g
                        1
                        ci
                        , and that of the current pattern in the second entry 
                           
                              
                                 g
                                 2
                              
                              
                                 
                                    l
                                    i
                                    λ
                                 
                                 /
                                 
                                    U
                                    P
                                 
                              
                           
                        . The value of item-type i is updated only when it appears in the current pattern (pi
                         > 0). When U
                        P is small, the item types in the current pattern do not combine well. They get larger values so that they can be packed with high priority in generating the successive cutting plans. The term 
                           
                              l
                              i
                              λ
                           
                         with λ > 1 indicates that longer items are given priority in getting larger values.

Similar formulas for updating item values can be found in Belov and Scheithauer (2007) and Cui and Tang (2013). They are similar in the sense that all of them include the term 
                           
                              
                                 l
                                 i
                                 λ
                              
                              /
                              
                                 U
                                 P
                              
                           
                        .

Two sets of benchmark
                      instances are used to compare the SGPIP with published algorithms for the CSPPR. The SGPIP is coded in C++. It uses multiple threads in stage-one computation. The parallel implementation is similar to that in Cui and Tang (2013). The computer (Intel Core i7-3632QM CPU 2.20GHz, RAM 8GB) used has four cores. The number of threads used by the SGPIP is also 4. In stage-two of the SGPIP, CPLEX 12.5 with default settings is used as optimization engine; the value of the best SGP solution is used as bound so that the CPLEX can discard the branches with lower bound larger than the value; and the time limit for this stage is 1 s. Only different patterns are added to Q. The maximum number of patterns in Q is set to be 5000, that is, the patterns generated in stage-one of the SGPIP are not added to Q once the number of patterns in Q reaches 5000. The default parameters for the SGPIP are α
                     max = m, β
                     max = 5, Δβ = 0.3, η = 0.3, λ = 1.05, G
                     max = 500, the cost per bar u
                     b = L and the cost per setup u
                     s = 100. They are used in the subsections if their values are not specified.

It should be noted that the sensitivity analyses of the parameters α
                     max,
β
                     max,
Δβ,
η and λ are not performed in this paper. Analyses in the literature related with sequential heuristics and grouping technique (Cui et al., 2008; Cui and Liu, 2011; Cui et al., 2013) have demonstrated the following: The solutions may be slightly sensitive to the parameters, but not seriously.

The first set includes the 18 classes of benchmark instances in Foerster and Wäscher (2000). Each class contains 100 instances. The instances were reproduced by Cutgen1 (http://paginas.fe.up.pt/~esicup/tiki-index.php) using the same seed (1994) as that in Foerster and Wäscher (2000). According to Gau and Wäscher (1995), the reproduced instances should be the same as the original ones because the same seed was used. This set of instances is used to compare the SGPIP with the following two published algorithms: the YL in Yanasse and Limeira (2006), the SHPLAS in Cui and Liu (2011). The algorithms in Haessler (1975) and Cui et al. (2008) are not compared because they are outperformed by the SHPLAS (Cui & Liu, 2011). The features of the instances are shown in Table 1, where 
                           
                              d
                              ¯
                           
                         denotes the average demand of the item types.


                        The computational results for each class are summarized in Table 2, where NB
                         denotes the average bar count (number of bars), N
                        P denotes the average pattern count (number of patterns), and the superscripts denote the algorithms. 
                           
                              N
                              B
                              LB
                           
                         is the lower bound of the bar count. The authors obtained it by first using the column-generation method to solve the following relaxation of the classical one-dimensional cutting stock problem to obtain the optimal solution 
                           
                              (
                              
                                 
                                    x
                                    1
                                    0
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    
                                       
                                          |
                                          J
                                          |
                                       
                                    
                                    0
                                 
                              
                              )
                           
                        , and then letting 
                           
                              
                                 N
                                 B
                                 LB
                              
                              =
                              
                                 ⌈
                                 
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       x
                                       j
                                       0
                                    
                                 
                                 ⌉
                              
                           
                        :

                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             Z
                                             LB
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             min
                                             
                                                (
                                                
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         J
                                                      
                                                   
                                                   
                                                      x
                                                      j
                                                   
                                                
                                                )
                                             
                                             ;
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                q
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                j
                                             
                                             ≥
                                             
                                                d
                                                i
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             i
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             m
                                             ;
                                             
                                             
                                                x
                                                j
                                             
                                             ≥
                                             0
                                             ,
                                             
                                             j
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             
                                                |
                                                J
                                                |
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where J denotes the indexes of the cutting patterns generated in the solution process, xj
                         is the frequency of the j-th pattern, and 
                           
                              q
                              
                                 
                                 
                                    i
                                    j
                                 
                              
                           
                         is the number of type-i items in the j-th pattern. The best values for each class are highlighted with bold face.

The algorithm (denoted as the FW) in Foerster and Wäscher (2000) is not compared because of the following contradiction. The FW obtains 
                           
                              N
                              B
                              FW
                           
                         values smaller than the lower bounds 
                           
                              N
                              B
                              LB
                           
                         in Classes 7–8 and 13–18. For example, the average lower bound 
                           
                              N
                              B
                              LB
                           
                         is 50.24 for Class 7, whereas the average solution value 
                           
                              N
                              B
                              FW
                           
                         is 50.21 and is smaller than 
                           
                              N
                              B
                              LB
                           
                        . This contradiction was observed in testing the SGPIP. After checking our code carefully, we sent the instances to a known researcher in this field. In response to our request for help, the researcher checked Class 7 by running his code and obtained the same lower bound 50.24, suggesting that the lower bounds obtained from our algorithm are reliable.

The exact algorithm (denoted as the BS) in Belov and Scheithauer (2003) is also excluded from comparison because of the following observation. Belov and Scheithauer (2003) reported that the BS solved Class 211 (Class 7 in this paper) to optimality completely (see Table 3
                        
                         in their paper, where ΔK = 0 was used to guarantee the minimum bar count). The SGPIP of this paper obtained the minimum bar count (
                           
                              
                                 N
                                 B
                                 SGPIP
                              
                              =
                              
                                 N
                                 B
                                 LB
                              
                           
                        ) for each instance in this class. Subsequently both algorithms yielded the same bar count (50.24). The average number of patterns of the BS solutions is 7.57, and that of the SGPIP solutions is 6.40. The former is larger than the latter, indicating that bugs may exist in the implementation of the BS.

The number of classes in which an algorithm achieves the best number of bars is 18 for the SGPIP, 4 for the SHPLAS, and 0 for the YL. The number of classes in which an algorithm achieves the best number of patterns is 15 for the SGPIP, 0 for the SHPLAS, and 3 for the YL. These results indicate that the SGPIP is the most efficient in improving solution quality.

The 18 classes can be divided into three groups, each of which contains 6 classes that have the same li
                         range (see Table 1). The average bar count and pattern count of an instance for each group are shown in Table 3. The row of “Average” lists the average values counted over all instances. The last row shows the sums counted over all instances. It is seen that the sum (881,843) of the bar counts of the SGPIP solutions is close to the lower bound (881,840). There are only three instances with solution that does not reach the lowest material cost. This indicates that the SGPIP is powerful in improving material utilization.


                        Comparing SGPIP and SHPLAS. For a particular class, the average bar count of the SGPIP is not larger than that of the SHPLAS, and the average pattern count is smaller. This indicates that the SGPIP outperforms the SHPLAS in all classes. From the last row of Table 3, it is seen that a saving of 1453 (= 883,296 − 881,843) bars and a reduction of 14.29% (= 1 – 24,020/28,026) in pattern count can be obtained by using the SGPIP.


                        Comparing SGPIP and YL. The average bar count of the SGPIP is smaller than that of the YL in all classes. The average pattern count of the SGPIP is smaller than that of the YL in 15 classes and larger in 3 classes (Classes 1, 3 and 5). From the last row of Table 3, it is seen that a saving of 18,589 (= 900,432 − 881,843) bars and a reduction of 13.18% (= 1 – 24,020/27,666) in pattern count can be obtained by using the SGPIP. This indicates that the average performance of the SGPIP is better than that of the YL.

The average computation time of an instance is 1.14 s for the SGPIP. It is 2.675 s for the SHPLAS on a computer of CPU 2.80 GHz and RAM 512MB, and 7.83 s for the YL on a microcomputer Intel Celeron, 266 MHz, 128 MB RAM and a workstation Sun Ultra 30, 296 MHz 384MB RAM. The computation time of the SGPIP is reasonable.

There are 40 practical instances in the second set. They are available at http://www-sys.ist.osaka-u.ac.jp/~umetani/instance-e.html and are used to compare the SGPIP with the three algorithms (LSH, LSE and CGA) in Mobasher and Ekici (2013).

In Table 4 of Mobasher and Ekici (2013), the gaps to lower bounds of the algorithms are reported, but neither the lower bounds nor the solution values are given. This makes it impossible to compare the algorithms exactly. Only the case of u
                        b = L and u
                        s = 100 is used in the following approximate comparison, noting that in Table 4 of Mobasher and Ekici (2013), u
                        b = L is equivalent to c
                        p = 1 and u
                        s = 100 equivalent to c
                        s = 100.

The bar count in the solution of the ILP model in Section 3 cannot be smaller than the lower bound 
                           
                              N
                              B
                              LB
                           
                         obtained from solving Model (2) in Section 5.1. Subsequently the lower bound of the ILP solution cannot be smaller than

                           
                              
                                 u
                                 b
                              
                              
                                 N
                                 B
                                 LB
                              
                              =
                              L
                              
                                 N
                                 B
                                 LB
                              
                           
                        . The estimated gap to lower bound of the SGPIP is defined as:

                           
                              
                                 
                                    ga
                                    
                                       p
                                       0
                                    
                                    =
                                    
                                       
                                          L
                                          
                                             N
                                             B
                                             SGPIP
                                          
                                          +
                                          
                                             u
                                             s
                                          
                                          
                                             N
                                             
                                                P
                                             
                                             SGPIP
                                          
                                          −
                                          L
                                          
                                             N
                                             B
                                             LB
                                          
                                       
                                       
                                          L
                                          
                                             N
                                             B
                                             LB
                                          
                                       
                                    
                                 
                              
                           
                        Then the real gap to lower bound cannot be larger than gap0. The real gap is close to gap0 when u
                        s is small. We only consider the case of u
                        s = 100. The reason is that the other cases in Table 4 of Mobasher and Ekici (2013) have u
                        s > 100, using gap0 to estimate their gaps will lead to large error.


                        Table 4 lists the detailed computational results of the SGPIP for the instances in Set 2. The number of item types m and the bar length L are designated in the instance name. For example, “Fiber06_5180” indicates that m = 6 and L = 5180. Among the 40 instances, only one instance (Fiber28b_5180) is not solved to have the lowest bar count. The average value of gap0 is 0.24%. This indicates that the real gap of the SGPIP is not larger than 0.24%. The gaps of the LSH, LSE and CGA are respectively 2.04%, 0.90% and 0.43%. They are all significantly larger than 0.24%. The SGPIP performs the best because its gap is the smallest.

The average computation time of an instance is 1.445 s for the SGPIP. It is 99.87 s for the LSH, 1709.16 s for the LSE, and 2925.25 s for the CGA, using a computer with two 2.4 GHz Xeon processors and 4GB RAM. The SGPIP may be the fastest.

The items data of Instance Fiber29_9080 are shown in Table 5 and the solution is given in Fig. 1
                        . The text to the left of each pattern is in the form of ID*L*f and denotes the pattern ID, bar length and pattern frequency. The solution uses 35 bars and contains 7 patterns.

To demonstrate the effect of increasing the setup cost, the results obtained from running the SGPIP with u
                        s = u
                        b = L are shown in Table 6
                        . The following observations are obtained from comparing the results with those of Table 4 (see the last rows of Tables 4 and 6): (1) for the first 20 instances, the total number of bars is increased by 11 and the total number of patterns is reduced by 35; (2) for the last 20 instances, the total number of bars is increased by 3 and the total number of patterns is reduced by 6.

The first set of instances is used to perform specialized tests. The first test is used to evaluate how good is the best solution generated by SGP for the cost minimization problem, and which rate of improvement is obtained by solving the ILP. u
                        s = L and the other parameters assume default values. Recall that the 18 classes of instances have been divided into three groups in Section 5.1. Table 7
                         shows the computational results for the three groups and the whole set of instances, where 
                           
                              N
                              B
                              SGP
                           
                         denotes the total number of bars, 
                           
                              N
                              
                                 P
                              
                              SGP
                           
                         the total number of patterns, Z
                        SGP the total cost of the best SGP solutions;

                           
                              N
                              B
                              SGPIP
                           
                        , 
                           
                              N
                              
                                 P
                              
                              SGPIP
                           
                         and Z
                        SGPIP denote those of the SGPIP solutions. The following data are obtained from the last column of the table:

                           
                              
                                 
                                    
                                       
                                          
                                             N
                                             B
                                             SGP
                                          
                                          −
                                          
                                             N
                                             B
                                             SGPIP
                                          
                                       
                                       
                                          N
                                          B
                                          SGP
                                       
                                    
                                    =
                                    0.02
                                    %
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             N
                                             
                                                P
                                             
                                             SGP
                                          
                                          −
                                          
                                             N
                                             
                                                P
                                             
                                             SGPIP
                                          
                                       
                                       
                                          N
                                          
                                             P
                                          
                                          SGP
                                       
                                    
                                    =
                                    18.53
                                    %
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       
                                          
                                             Z
                                             SGP
                                          
                                          −
                                          
                                             Z
                                             SGPIP
                                          
                                       
                                       
                                          Z
                                          SGP
                                       
                                    
                                    =
                                    0.52
                                    %
                                 
                              
                           
                        They indicate that by solving the ILP, the rate of improvement is 0.02% on the bar cost, 18.53% on pattern reduction, and 0.52% on the total cost. The improvement on the total cost can be seen as significant.

The results related with the CPLEX solutions are shown in Table 8
                        . N
                        Optimal is the number of instances solved to optimality by the CPLEX. N
                        Improved is the number of instances in which the CPLEX solution is better than the best SGP solution. |Q| is the average number of patterns in Q. In interpreting the results, it should be recall that the ILP model is solved considering only the patterns in Q.

The number of instances solved to optimality increases with the decrease in |Q|. The percentage of solutions solved to optimality is 0.7 for the first group, 47.2 for the second group, 67.8 for the third group, and 38.6 for the whole set. The percentage of solutions improved by the CPLEX is 0.5 for the first group, 83.5 for the second group, 91.3 for the third group, and 58.4 for the whole set. For the first group in which the average item length is much smaller than the bar length, the number of patterns in Q is large and the CPLEX can only solve 4 instances to optimality and improve three solutions.

The second test is used to investigate the impact of setup cost on the solutions. The setup cost is allowed to vary and the other parameters retain the default values. The results for the whole set of instances are shown in Table 9
                        . It is seen that with the increase in setup cost, the total number of bars increases and the total number of patterns decreases. All instances can be solved to have the lowest bar cost when a much smaller setup cost u
                        s = 10 is used. This is true because the total number (881,840) of used bars is the same as the lower bound (See the column 
                           
                              N
                              B
                              LB
                           
                         in Table 3). When the setup cost increases from 10 to 100, the total number of bars is increased only by 3, whereas the total number of patterns is reduced by 1365.

The third test is used to demonstrate that using the SGP to generate the patterns in Q is a good choice, using the default parameters. Two cases are compared. The SGP is used to generate the patterns in the first case; whereas in the second case, a SHP slightly different from the SGP is used to generate the patterns. The two procedures differ only in Step 3 as follows:

Step 3 of the SGP: Call 
                           
                              GetCIList
                              (
                              
                                 α
                                 G
                              
                              ,
                              
                                 β
                                 G
                              
                              )
                           
                         to determine bi, i = 1, …, m.

Step 3 of the SHP: Let bi
                         = ri, i = 1, …, m.

That is, the SGP uses the grouping technique but the SHP does not. The other steps of the two procedures are the same. The total number of used bars and the total number of patterns obtained under the first case are respectively 881,843 and 24,020 (see Table 3). Those obtained under the second case are respectively 881,844 and 32,915. Although the numbers of used bars of the two cases are approximately the same, the difference between the numbers of patterns is large. Compared with the first case, the number of patterns in the second case is increased by 37%, i.e., (32,915 – 24,020)/24,020 = 37%. This indicates that using the SGP to generate the patterns is a good choice. Some approaches, such as the standard column generation method and the randomized greedy method, can also be used to generate the patterns, but they may be not as efficient as the SGP in pattern reduction.

@&#CONCLUSIONS@&#

The SGPIP has been described in detail. The computational results indicate that it is powerful in improving material utilization. When the default parameters are used (see the general part of Section 5), among the 1840 instances in two sets, only the solutions of four instances do not reach the minimum material cost.

Pattern reduction is important in some applications. The SGPIP is also effective in pattern reduction. Among the algorithms tested, the SGPIP is able to yield the minimum average number of pattern count, without increasing the material cost. The algorithm is easy to design. With the help of the CPLEX optimizer, software engineers can easily code it into applications.

Future research may include the extension of the SGPIP to deal with the one-dimensional cutting stock problem of multiple stock lengths.

@&#ACKNOWLEDGMENTS@&#

This research is part of projects 71371058 and 61363026 supported by National Natural Science Foundation of China.

@&#REFERENCES@&#

