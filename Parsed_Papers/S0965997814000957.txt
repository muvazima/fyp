@&#MAIN-TITLE@&#
               NiHu: An open source C++ BEM library

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We have developed a generic C++ library (called NiHu) for boundary elements.


                        
                        
                           
                           
                              NiHu generates optimised code for a large variety of BEM formulations.


                        
                        
                           
                           Template metaprogramming is extensively exploited for adaptive and optimal code.


                        
                        
                           
                           We demonstrate NiHu’s versatility, flexibility, and performance by examples.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Generic BEM library

C++ template metaprogramming

Boundary element methods

Object-oriented programming

Partial differential equations

Acoustics

@&#ABSTRACT@&#


               
               
                  This paper introduces NiHu, a C++ template library for boundary element methods (BEM). The library is capable of computing the coefficients of discretised boundary integral operators in a generic way with arbitrarily defined kernels and function spaces. NiHu’s template core defines the workflow of a general BEM algorithm independent of the specific application. The core provides expressive syntax, based on the operator notation of the BEM, reflecting the mathematics behind boundary elements in the C++ source code. The customisable Component library contains elements specific to particular applications such as different numerical integration techniques and regularisation methods. The library can be used for creating a standalone C++ application using external open source libraries, or compiling a Matlab toolbox through the MEX interface. By massively exploiting C++ template metaprogramming, NiHu generates optimised codes for specific applications, including heterogeneous problems. The paper introduces the main concepts of the novel development, demonstrates its versatility and flexibility and compares the implementation’s performance to that of other open source projects.
               
            

@&#INTRODUCTION@&#

Several engineering problems of electrodynamics, acoustics, elastodynamics or fluid mechanics are related to the solution of partial differential equations (PDE). PDEs are the governing equations of the underlying physical model, whereas the actual problem setup is defined by the geometry, material properties, and boundary conditions. As analytical solutions—if they exist at all—have very restricted limitations, numerical solution methods need to be utilised in most practical applications.

Boundary element methods (BEM) are based on a boundary integral representation of the PDE. Contrary to domain based solution techniques, like finite element (FE), finite volume (FV) or finite difference (FD) methods, the BEM solves the PDE by discretising the domain’s boundary only, hence reducing the dimensionality of the problem by one. Furthermore, the BEM provides a straightforward way of solving exterior problems defined over infinite domains. Due to these advantages the BEM is a very popular numerical technique, and is still being subjected to active research and development. Besides its advantages, the BEM has its drawbacks too. Opposed to the FE or FD methods, application of the BEM can result in the solution of linear equations with complex valued, dense system matrices. Furthermore, while solution schemes of the FE or FD methods are directly related to building blocks of the PDE, the application of the BEM requires knowledge of the PDE’s fundamental solution.

Although different engineering problems involve various PDEs and their integral representations, boundary element methods have a well established, unified mathematical background [1,2]. Specific fields of application are described by particular cases of the general framework with dedicated fundamental solutions, discretisation options and solution strategies.

In order to achieve good computational performance commercial boundary element software products are optimised for specific applications. Similarly, most of the open source tools and libraries available are implemented for narrow application segments, and typically support limited discretisation or solution strategies.

The present paper introduces NiHu, an open source C++ BEM library. Instead of developing yet another open source library for a specific application area, NiHu aims to serve as a generic programming environment for boundary element problems of various kinds.


                     NiHu consists of (1) a C++ core, (2) a C++ Component library and (3) a Matlab shell layer. The C++ core can be considered as a skeleton that defines boundary element problems in a generic way. Specific aspects of BEM implementations are contained in the corresponding C++ Component libraries of NiHu, which are designed to be easily customisable and extendible by researchers and developers. The Matlab shell layer provides extensive pre- and post-processing features and makes integration with other software tools straightforward. This concept allows a beneficial application of the library in education, and also in research, where the developer can focus on the improvement of smaller details, while having the implementation working as a part of a general system. Furthermore, the implementation is capable of solving problems of industrial size.

The foregoing parts of the paper are organised as follows. Section ‘Background’ gives a short introduction into boundary element methods and C++ template metaprogramming, followed by the description of NiHu’s main software concepts. Section ‘The C++ core and the Component library’ provides a structural description of the C++ core and briefly summarises the capabilities of the Component library. Versatility and performance of the software are demonstrated in Section ‘Numerical examples’ through an academic example, an industrial size application, and comparison of the library’s performance with that of other open source packages. Finally, Section ‘Introducing a new PDE into the NiHu framework’ demonstrates how the library can be extended to solve a boundary value problem with a newly defined PDE.

@&#BACKGROUND@&#

Let us consider the PDE
                           
                              (1)
                              
                                 A
                                 u
                                 (
                                 x
                                 )
                                 =
                                 b
                                 (
                                 x
                                 )
                                 
                                 x
                                 ∈
                                 Ω
                                 ,
                              
                           
                        where 
                           
                              Ω
                              ⊂
                              
                                 
                                    R
                                 
                                 
                                    d
                                 
                              
                           
                         is a bounded domain in the d-dimensional space, limited by the smooth boundary 
                           
                              Γ
                              ,
                              u
                           
                         is the solution function and 
                           
                              A
                           
                         denotes a differential operator. The weighted residual form of the PDE is
                           
                              (2)
                              
                                 〈
                                 w
                                 ,
                                 A
                                 u
                                 -
                                 b
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 =
                                 0
                                 ,
                              
                           
                        where w denotes a weighting function and the inner product is defined as
                           
                              (3)
                              
                                 〈
                                 w
                                 ,
                                 u
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 =
                                 
                                    ∫
                                    
                                       Ω
                                    
                                 
                                 w
                                 (
                                 y
                                 )
                                 u
                                 (
                                 y
                                 )
                                 d
                                 y
                                 .
                              
                           
                        By subsequent integrations by parts the partial derivatives of the solution u in (2) are eliminated. As a consequence, the adjoint operator 
                           
                              
                                 
                                    A
                                 
                                 
                                    ∗
                                 
                              
                           
                         acting on the weighting function w appears in a domain integral, and the weighted residual form is extended by boundary integrals containing boundary operators 
                           
                              
                                 
                                    B
                                 
                                 
                                    m
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    m
                                 
                              
                           
                         and their adjoints [2]:
                           
                              (4)
                              
                                 〈
                                 
                                    
                                       A
                                    
                                    
                                       ∗
                                    
                                 
                                 w
                                 ,
                                 u
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          m
                                       
                                    
                                 
                                 〈
                                 
                                    
                                       C
                                    
                                    
                                       m
                                    
                                    
                                       ∗
                                    
                                 
                                 w
                                 ,
                                 
                                    
                                       B
                                    
                                    
                                       m
                                    
                                 
                                 u
                                 
                                    
                                       〉
                                    
                                    
                                       Γ
                                    
                                 
                                 -
                                 〈
                                 w
                                 ,
                                 b
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 =
                                 0
                                 .
                              
                           
                        
                     

In order to eliminate the domain integral, the fundamental solution 
                           
                              
                                 
                                    u
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                           
                         of the PDE is used as the weighting function w. The fundamental solution is defined by the equation 
                           
                              
                                 
                                    A
                                 
                                 
                                    ∗
                                 
                              
                              
                                 
                                    u
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                              =
                              -
                              δ
                              (
                              y
                              -
                              x
                              )
                           
                        , where 
                           
                              δ
                           
                         denotes the Dirac delta function. With this choice, (4) simplifies to a boundary integral representation of the PDE:
                           
                              (5)
                              
                                 u
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          m
                                       
                                    
                                 
                                 〈
                                 
                                    
                                       C
                                    
                                    
                                       m
                                    
                                    
                                       ∗
                                    
                                 
                                 
                                    
                                       u
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 
                                    
                                       B
                                    
                                    
                                       m
                                    
                                 
                                 u
                                 
                                    
                                       〉
                                    
                                    
                                       Γ
                                    
                                 
                                 -
                                 〈
                                 
                                    
                                       u
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 b
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 ,
                                 
                                 x
                                 ∈
                                 Ω
                                 .
                              
                           
                        
                     

By means of the boundary integral representation the relationship of the solution function u and its derivatives 
                           
                              
                                 
                                    B
                                 
                                 
                                    m
                                 
                              
                              u
                           
                         on the surface 
                           
                              Γ
                           
                         is expressed in the form of a boundary integral equation (BIE). For this, a limiting process is evaluated with x approaching 
                           
                              Γ
                           
                        . On smooth boundaries the resulting integral equation reads as
                           
                              (6)
                              
                                 
                                    
                                       u
                                       (
                                       x
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          m
                                       
                                    
                                 
                                 〈
                                 
                                    
                                       C
                                    
                                    
                                       m
                                    
                                    
                                       ∗
                                    
                                 
                                 
                                    
                                       u
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 
                                    
                                       B
                                    
                                    
                                       m
                                    
                                 
                                 u
                                 
                                    
                                       〉
                                    
                                    
                                       Γ
                                    
                                 
                                 -
                                 〈
                                 
                                    
                                       u
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 b
                                 
                                    
                                       〉
                                    
                                    
                                       Ω
                                    
                                 
                                 ,
                                 
                                 x
                                 ∈
                                 Γ
                                 .
                              
                           
                        Solution of the PDE with a specific boundary condition is performed in two steps. First, the BIE (6) is solved to obtain the unspecified field variables on 
                           
                              Γ
                           
                        . Then, the integral representation (5) is applied to compute the solution in internal points of 
                           
                              Ω
                           
                        .

For the specific example of the Helmholtz equation governing steady state acoustic wave propagation, the PDE is specialised in the form
                           
                              (7)
                              
                                 A
                                 p
                                 (
                                 x
                                 )
                                 =
                                 p
                                 
                                    
                                       ,
                                    
                                    
                                       jj
                                    
                                 
                                 (
                                 x
                                 )
                                 +
                                 
                                    
                                       k
                                    
                                    
                                       2
                                    
                                 
                                 p
                                 (
                                 x
                                 )
                                 =
                                 0
                                 ,
                                 
                                 x
                                 ∈
                                 Ω
                                 ,
                              
                           
                        where p denotes the acoustic pressure and k stands for the wave number. Writing the PDE in weighted residual form, performing integration by parts twice, and replacing the weight function by the fundamental solution 
                           
                              
                                 
                                    p
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                           
                         of the Helmholtz equation yields the boundary integral representation of the Helmholtz equation:
                           
                              (8)
                              
                                 p
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∫
                                                   
                                                      Γ
                                                   
                                                
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                
                                                   
                                                      ,
                                                   
                                                   
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            y
                                                         
                                                      
                                                   
                                                
                                                (
                                                x
                                                ,
                                                y
                                                )
                                                p
                                                (
                                                y
                                                )
                                                d
                                                y
                                             
                                             
                                                ︸
                                             
                                          
                                       
                                       
                                          〈
                                          
                                             
                                                C
                                             
                                             
                                                1
                                             
                                             
                                                ∗
                                             
                                          
                                          
                                             
                                                p
                                             
                                             
                                                ∗
                                             
                                          
                                          ,
                                          
                                             
                                                B
                                             
                                             
                                                1
                                             
                                          
                                          p
                                          
                                             
                                                〉
                                             
                                             
                                                Γ
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                -
                                                
                                                   ∫
                                                   
                                                      Γ
                                                   
                                                
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                (
                                                x
                                                ,
                                                y
                                                )
                                                p
                                                
                                                   
                                                      ,
                                                   
                                                   
                                                      n
                                                   
                                                
                                                (
                                                y
                                                )
                                                d
                                                y
                                             
                                             
                                                ︸
                                             
                                          
                                       
                                       
                                          〈
                                          
                                             
                                                C
                                             
                                             
                                                2
                                             
                                             
                                                ∗
                                             
                                          
                                          
                                             
                                                p
                                             
                                             
                                                ∗
                                             
                                          
                                          ,
                                          
                                             
                                                B
                                             
                                             
                                                2
                                             
                                          
                                          p
                                          
                                             
                                                〉
                                             
                                             
                                                Γ
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where 
                           
                              
                                 
                                    p
                                 
                                 
                                    ,
                                    
                                       
                                          n
                                       
                                       
                                          y
                                       
                                    
                                 
                                 
                                    ∗
                                 
                              
                           
                         denotes the derivative of the fundamental solution with respect to the normal vector pointing towards 
                           
                              Ω
                           
                        , and 
                           
                              p
                              
                                 
                                    ,
                                 
                                 
                                    n
                                 
                              
                              =
                              q
                           
                         denotes the normal derivative of the sound pressure. The inner product notations in (8) relate the boundary integral representation to the general form (5), with 
                           
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                           
                         being the identity operator, and 
                           
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                              
                              =
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                           
                         denoting differentiation with respect to the normal.

The integral representation and the BIE is conveniently written using integral operator notations [3]:
                           
                              (9)
                              
                                 p
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             M
                                             p
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 -
                                 
                                    
                                       
                                          
                                             L
                                             q
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 
                                 x
                                 ∈
                                 Ω
                                 ,
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 p
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             M
                                             p
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 -
                                 
                                    
                                       
                                          
                                             L
                                             q
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 
                                 x
                                 ∈
                                 Γ
                                 ,
                              
                           
                        where 
                           
                              L
                           
                         and 
                           
                              M
                           
                         denote the single and double layer potential integral operators, respectively:
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             L
                                             u
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    ∫
                                    
                                       Γ
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ∗
                                    
                                 
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 u
                                 (
                                 y
                                 )
                                 d
                                 y
                                 ,
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             M
                                             u
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    ∫
                                    
                                       Γ
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       ∗
                                    
                                 
                                 
                                    
                                       ,
                                    
                                    
                                       
                                          
                                             n
                                          
                                          
                                             y
                                          
                                       
                                    
                                 
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 u
                                 (
                                 y
                                 )
                                 d
                                 y
                                 .
                              
                           
                        
                     

The solution of the BIE (6) is again based on the weighted residual method. Without the loss of generality, the solution procedure is demonstrated with the example of the Helmholtz BIE (10). The BIE is assumed to hold in a weak sense:
                           
                              (13)
                              
                                 〈
                                 v
                                 ,
                                 M
                                 p
                                 -
                                 L
                                 q
                                 -
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 p
                                 〉
                                 =
                                 0
                                 ,
                              
                           
                        where 
                           
                              v
                              (
                              x
                              )
                           
                         denotes an arbitrary test function chosen from the test function space 
                           
                              T
                              ⊂
                              Γ
                              →
                              R
                           
                        .

The numerical solution of the weak form is found by discretising the test space T and the domain spaces of the boundary integral operators 
                           
                              L
                           
                         and 
                           
                              M
                           
                        . The discretisation is performed by introducing the finite sets of basis functions 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    j
                                 
                                 
                                    M
                                 
                              
                           
                         and 
                           
                              
                                 
                                    d
                                 
                                 
                                    l
                                 
                                 
                                    L
                                 
                              
                           
                         :
                           
                              (14)
                              
                                 v
                                 (
                                 x
                                 )
                                 ≈
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 x
                                 )
                                 ,
                                 
                                 p
                                 (
                                 y
                                 )
                                 ≈
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                    
                                       M
                                    
                                 
                                 (
                                 y
                                 )
                                 ,
                                 
                                 q
                                 (
                                 y
                                 )
                                 ≈
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                       
                                    
                                 
                                 
                                    
                                       q
                                    
                                    
                                       l
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       l
                                    
                                    
                                       L
                                    
                                 
                                 (
                                 y
                                 )
                                 .
                              
                           
                        The discretised weak form of the BIE simplifies to a linear system of equations
                           
                              (15)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 〈
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 M
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                    
                                       M
                                    
                                 
                                 〉
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                       
                                    
                                 
                                 〈
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 L
                                 
                                    
                                       d
                                    
                                    
                                       l
                                    
                                    
                                       L
                                    
                                 
                                 〉
                                 
                                    
                                       q
                                    
                                    
                                       l
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 〈
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                    
                                       M
                                    
                                 
                                 〉
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                        or, using matrix–vector notations,
                           
                              (16)
                              
                                 Mp
                                 -
                                 Lq
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 Bp
                                 ,
                              
                           
                        where 
                           
                              M
                           
                         and 
                           
                              L
                           
                         are the dense system matrices and 
                           
                              B
                           
                         is a sparse matrix. The unknown field variables on the boundary are obtained by solving (16) for a particular set of unknowns.

Different solution formalisms can be defined by classifying the selection of function spaces in Eq. (15). Galerkin BEM refers to the choice, where the test function space coincides with the domain space of the solution: 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                              ≡
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                           
                        . In this case, the inner products are evaluated by double surface integrals. Collocational BEM denotes the case where the test function space is generated by Dirac delta functions located at the nodal locations 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         of the solution’s domain space: 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                              (
                              x
                              )
                              =
                              δ
                              
                                 
                                    
                                       x
                                       -
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        . In the collocational case, the inner products boil down to single surface integrals.

Although the Galerkin formalism requires an additional integration, and is therefore numerically more expensive, this technique has gained increasing popularity in the recent decade. Compared to collocation, the Galerkin discretisation approach can address a wider set of problems [4]. The Galerkin method can ensure the symmetry of the system matrices, a property useful in case of applying an iterative solver. Finally, but not least, the numerical cost of the additional outer integration is not significant when fast solution methods based on clustering techniques are used [5].

The template mechanism of the C++ language allows expressing algorithms and data structures in a generic way. A sorting algorithm, for example, can be implemented in the form of a function template:
                           
                              
                                 
                                 
                                    
                                       1 
                                             template
                                           <
                                             class
                                           
                                          T>
                                    
                                    
                                       2 
                                             void
                                           
                                          sort(T*v, 
                                             int
                                           
                                          size);
                                    
                                 
                              
                           
                        and called with a specific data type (T=double) as
                           
                              
                                 
                                 
                                    
                                       1 
                                             double
                                           
                                          v[] = {1., 2., 5., 4.};
                                    
                                    
                                       2 sort<
                                             double
                                          >(v, 4);
                                       
                                    
                                 
                              
                           
                        During the compilation process, the compiler substitutes the actual type into the template (specialisation), generates and compiles the code of the sorting function that finally processes the input vector runtime.

It has been discovered that—although it was not designed for such purposes—the template specialisation mechanism of the C++ language is Turing-complete [6]. Exploiting this feature to evaluate algorithms during compilation is called template metaprogramming (TMP).

C++ TMP can be considered as a sort of functional programming where immutable variables are represented by types or constants, conditionals are modelled by pattern matching in the template substitution process, and loops are imitated by recursive template substitutions. Using these building blocks any algorithm can be implemented that processes its inputs during compilation.

A boundary element software has lots of inputs which are not known during compilation: The actual mesh, boundary conditions, or material properties need to be processed runtime. However, the fundamental solution form, the discretisation formalism, the element and weight function types are known a priori, and can be used as input parameters of the template system to algorithmically generate the BEM code for a particular application.

This approach has several advantages. The BEM needs to be programmed in a way that provides a high level of polymorphic behaviour (static polymorphism [7,8]) and flexibility in the library. As the template parameters are substituted during compilation, the BEM implementation can adapt to its components with efficient algorithm and data structure selection when the executable is generated.

The template concept has drawbacks too. As it is the algorithm that adapts to its components during compilation, adaptation to several different components at the same time is impossible. Therefore, implementing heterogeneous problems—e.g.BEM algorithms that work on meshes containing different kinds of elements—is cumbersome. As a further consequence of the adaptive template behaviour, templated codes cannot be compiled in the form of a dynamically linked library, and subsequent linking to new components is impossible. Instead, a complete recompilation is needed for including each new specialised component. Finally, as the template substitution mechanism of the compilation process is invisible to the programmer, debugging template metaprograms is yet impossible.

In this paper three non-trivial BEM-related metaprograms are selected from the NiHu library for demonstration: (1) treatment of heterogeneous function spaces, (2) parallel kernel evaluations, and (3) compile-time merge of kernel complexity estimators.


                        NiHu is a C++ template library designed for the efficient discretisation of boundary integral operators in a generic sense. Strictly speaking, the library evaluates weighted residual system matrices of the form
                           
                              (17)
                              
                                 
                                    
                                       W
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 〈
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          
                                             K
                                             
                                                
                                                   d
                                                
                                                
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       Γ
                                    
                                 
                                 
                                    
                                       〉
                                    
                                    
                                       F
                                    
                                 
                                 =
                                 
                                    ∫
                                    
                                       F
                                    
                                 
                                 
                                    
                                       φ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 x
                                 )
                                 
                                    ∫
                                    
                                       Γ
                                    
                                 
                                 K
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                 
                                 (
                                 y
                                 )
                                 d
                                 y
                                 
                                 d
                                 x
                                 .
                              
                           
                        The inner integral over the boundary 
                           
                              Γ
                           
                         denotes the integral operation 
                           
                              
                                 
                                    
                                       
                                          K
                                          
                                             
                                                d
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 
                                    Γ
                                 
                              
                           
                        , like (11) or (12).

The outer integral over F is a general form of the weak statement. The appropriate selection of the test function space 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                           
                         allows the flexible and unified definition of collocation and Galerkin solution formalisms, setting 
                           
                              F
                              =
                              Γ
                           
                        . Furthermore, selecting 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                              =
                              δ
                              (
                              x
                              -
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         with 
                           
                              F
                              
                              ≠
                              
                              Γ
                           
                         corresponds to the evaluation of the integral representation (9) in field points 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                        . Finally, a general definition of 
                           
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                           
                         over 
                           
                              F
                              
                              ≠
                              
                              Γ
                           
                         can be used for solving coupled problems.

Calculating the weighted residual matrix 
                           
                              
                                 
                                    W
                                 
                                 
                                    ij
                                 
                              
                           
                         is performed in the following steps:
                           
                              1.
                              Definition of function spaces representing physical quantities over the discretised geometry (mesh).

Initialization of integral operators and precalculation of helper quantities to increase the performance of integration.

Evaluating the weighted residual integral over the function spaces.

The C++ code snippet below is a representative example code from the application interface (a typical NiHu-based main function relying on the core and the Component library).
                           
                              
                                 
                                 
                                    
                                       1 
                                             auto
                                           
                                          mesh
                                          
                                          =
                                          
                                          import_off_mesh ("mymesh.off", quad_1_tag(), tria_1_tag());
                                       
                                    
                                    
                                       2 
                                             auto
                                           &d
                                          
                                          =
                                          
                                          constant_view(mesh);
                                       
                                    
                                    
                                       3 
                                             unsigned
                                           
                                          N = mesh.get_num_dofs();
                                       
                                    
                                    
                                       4 MatrixXd L(N, N), M(N, N);
                                       
                                    
                                    
                                       5 
                                             auto
                                           
                                          L_op
                                          
                                          =
                                          
                                          create_integral_operator(helmholtz_3D_SLP_kernel(1.));
                                       
                                    
                                    
                                       6 
                                             auto
                                           
                                          M_op
                                          
                                          =
                                          
                                          create_integral_operator(helmholtz_3D_DLP_kernel(1.));
                                       
                                    
                                    
                                       7 
                                             auto
                                           
                                          I
                                          
                                          =
                                          
                                          create_identity_integral_operator();
                                       
                                    
                                    
                                       8 L ≪d * L_op[d];
                                       
                                    
                                    
                                       9 M ≪d * M_op[d] + d * (-.5 * I)[d];
                                       
                                    
                                 
                              
                           
                        
                     

The steps of calculating the weighted residual matrices are clearly followable in the example code. Line 1 imports a mesh consisting of linear quadrilateral and triangular elements from an external file. In line 2 a piecewise constant function space is created over the mesh. Lines 3–4 allocate matrices for storing the discretised operators. Lines 5–7 instantiate the boundary integral operators 
                           
                              L
                              ,
                              M
                           
                         at the wave number 
                           
                              k
                              =
                              1
                           
                        , as well as the identity operator 
                           
                              I
                           
                        . Finally, the matrices 
                           
                              L
                           
                         and 
                           
                              M
                              -
                              1
                              /
                              2
                              B
                           
                         of Eq. (16) are evaluated in a Galerkin BEM context in lines 8–9. The collocational BEM version of matrix 
                           
                              L
                           
                         is constructed by modifying line 8 to
                           
                              
                                 
                                 
                                    
                                       8 L ≪
                                          dirac (d) * L_op[d];
                                       
                                    
                                 
                              
                           
                        
                     


                        NiHu provides good computational performance by exploiting C++ TMP features [9] of the most recent C++11 standard [10]. The adaptive core behaviour is implemented with the exclusive application of static polymorphism, meaning that dispatching is completed during compilation.

Besides the C++11 standard, the lightweight C++ template library Eigen 
                        [11] is the only external dependency of the library. Eigen serves as the native matrix algebra language of NiHu, meaning that low level matrix manipulations are implemented using Eigen matrices.


                        NiHu is planned as a “matrix-to-matrix” application, where the input consists of mesh description matrices, and the outputs are the matrices of discretised boundary operators. This concept, when applied in a template environment, makes integration with external libraries easy. As an example, NiHu can be integrated with open source mesh importing libraries and high quality external solver routines to obtain a standalone executable, as shown in Fig. 1
                        . Particularly, the built-in Matlab matrix support facilitates Matlab integration through the MEX interface [12].

The main functionalities of the C++ Core are function space representations, kernel evaluations, numerical integration and matrix assembly. These modules are discussed in the sequel.

The relation of the main class templates modelling function spaces is schematically displayed in Fig. 2
                        . Class template Space represents a space of real or complex coordinates like 
                           
                              
                                 
                                    R
                                 
                                 
                                    n
                                 
                              
                           
                        . Class template Domain models finite subdomains of a coordinate space, and is used for defining the boundary elements’ reference domains 
                           
                              D
                              ⊂
                              
                                 
                                    R
                                 
                                 
                                    n
                                 
                              
                           
                         (like the standard line, triangle, square, or cube). Class template ShapeSet implements interpolation functions 
                           
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                              (
                              ξ
                              )
                           
                         defined over a reference domain. Class template Element represents a boundary element that is defined by the coordinate transform 
                           
                              x
                              (
                              ξ
                              )
                           
                         mapping the reference domain to the physical element. Hence, the element is defined by an interpolation shape set type and the nodal coordinate values.

In the NiHu terminology, a field is an element extended by an interpolation shape set, the so-called N-set. While the element describes the variation of the geometry over the reference domain, the field’s N-set describes the variation of a physical quantity over the element. Class template Field is capable of computing the N-set values 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              (
                              ξ
                              )
                           
                        , and can return the degree of freedom (DOF) indices of each N-set node. Each field defines the location of its block in the result matrix.

In general, the geometrical (L) and field interpolation shape sets (N) are defined independently. In lots of practical applications, however, the field information can be deduced from the element type and the function space’s dimensionality. For this reason, NiHu introduces the concept of field views. A FieldView is an Element templated to a field generation option and a dimension. A constant field view means that the N-set is a constant shape set over domain 
                           
                              D
                           
                        , and the DOF indices are related to the element’s element index. An isoparametric field view means that the N-sets equal the element’s geometrical interpolation shape set, and the DOF indices are related to the vertex indices of the element.

The mesh is the discretised model of the domain’s boundary 
                           
                              Γ
                           
                        . In the boundary element context, the mesh is a set of elements, heterogeneous in the sense that it can contain elements of different types (tria, quad, etc.). NiHu’s Mesh class template is a metaprogram that takes a compile time vector of element types as input (denoted by the template argument ElemTypeVector in Fig. 2) and generates a heterogeneous container of homogeneous submeshes. Each homogeneous submesh contains elements of the same kind in a vector container. The mesh provides element-type-specific iterator ranges for traversing its homogeneous subsegments, as shown in Fig. 3
                        . When the mesh object is populated with elements runtime, TMP-generated conditionals are used for inserting the elements into their submeshes. Similarly, when all elements of a heterogeneous mesh are traversed, TMP-generated loops traverse the homogeneous submeshes sequentially. The advantage of this technique is that traversing and processing a homogeneous submesh can be done without dynamic dispatching, allowing the programmer (or the code generating metaprogram) to work with different function interfaces for different element types, and allowing the compiler to inline and optimise function calls and unroll loops within a submesh.

As the mesh is a heterogeneous container of elements, the TMP-generated function space classes are heterogeneous containers of fields. Class template FunctionSpace is implemented using the same structure as class template Mesh: it is a heterogeneous container of homogeneous sub-functionspaces, each dedicated to a specific field type.

In lots of engineering applications it is sufficient to use a single geometry and extend all of its elements to constant or isoparametric fields, resulting in a—not necessarily homogeneous—constant or isoparametric function space. Similar to field views, NiHu provides a simple mechanism to generate lightweight function space views from meshes. FunctionSpaceView classes are implemented by overriding the Mesh’s element iterators to field view iterators that traverse the mesh’s elements, but return FieldView when dereferenced. This concept is implemented with no additional computational cost or memory requirement, which becomes especially useful when a mesh is extended into different kinds of function space views at the same time, such as in a collocational BEM.

The kernel function (fundamental solution) 
                           
                              K
                              (
                              x
                              ,
                              y
                              )
                           
                         of the integral operator can be evaluated in points x and y of the surface 
                           
                              Γ
                           
                        . However, as a general kernel depends not strictly on the locations only, but on the element geometry around the locations (element normals for example), the kernels in NiHu are defined in a more general way. The library defines class template Kernel to implement the bivariate function 
                           
                              K
                              (
                              
                                 
                                    γ
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    γ
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        , where the two objects 
                           
                              
                                 
                                    γ
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    γ
                                 
                                 
                                    2
                                 
                              
                           
                         are instances of different KernelInput classes. Frequently used KernelInput classes are the empty input 
                           
                              γ
                              =
                              {
                              
                              }
                           
                        , location input: 
                           
                              γ
                              =
                              {
                              x
                              }
                           
                         and location with normal input: 
                           
                              γ
                              =
                              {
                              x
                              ,
                              
                                 
                                    n
                                 
                                 
                                    x
                                 
                              
                              }
                           
                        .

The kernel function’s return value is computed by instantiating a KernelOutput object that stores intermediate results needed to generate the final kernel result. The Relations of classes KernelInput, KernelOutput and KernelResult are displayed in Fig. 4
                        , and are demonstrated by the examples of the single layer potential kernel 
                           
                              g
                              =
                              1
                              /
                              r
                           
                         and double layer potential kernel 
                           
                              g
                              
                                 
                                    ,
                                 
                                 
                                    n
                                 
                              
                              =
                              -
                              1
                              /
                              
                                 
                                    r
                                 
                                 
                                    2
                                 
                              
                              ·
                              r
                              
                                 
                                    ,
                                 
                                 
                                    n
                                 
                              
                           
                         of the 3D Laplace equation in Fig. 5
                        .

For the case of the single layer potential kernel, both KernelInputs are locations: 
                           
                              
                                 
                                    γ
                                 
                                 
                                    1
                                 
                              
                              =
                              
                                 
                                    
                                       x
                                    
                                 
                              
                              ,
                              
                                 
                                    γ
                                 
                                 
                                    2
                                 
                              
                              =
                              
                                 
                                    
                                       y
                                    
                                 
                              
                           
                        . The KernelOutput is split up into a hierarchical system (Wall class) of three bricks (Brick class), where each brick can be constructed from the two inputs and the previously constructed bricks. The topmost shaded brick is the actual kernel result. For the case of the double layer potential kernel, 
                           
                              
                                 
                                    γ
                                 
                                 
                                    1
                                 
                              
                           
                         is a location, while 
                           
                              
                                 
                                    γ
                                 
                                 
                                    2
                                 
                              
                           
                         is a location with normal type kernel input. The kernel output consists of five bricks.

The boundary integral representations (5) are generally formalised using a set of integral operators, containing the fundamental solution and its derivatives as kernels. These kernels typically share elements of their kernel inputs and intermediate results. The hierarchical brick system introduced above allows NiHu to automatically optimise parallel kernel evaluations.

If the user defines a parallel integral operator consisting of two or more kernel functions by the command
                              
                                 
                                    
                                    
                                       
                                          1 
                                                auto
                                              
                                             LM_op
                                             
                                             =
                                             
                                             create_integral_operator(
                                          
                                       
                                       
                                          2 
                                             laplace_3d_SLP_kernel(
                                             
                                             ),
                                          
                                       
                                       
                                          3 
                                             laplace_3d_DLP_kernel(
                                             
                                             ));
                                          
                                       
                                    
                                 
                              
                           then NiHu merges the input classes and output classes of the two kernels (Fig. 5(c)). Merging is performed using a template metaprogram that disassembles each wall into bricks, and rebuilds an optimal combination where each brick is contained only once. The combined kernel provides a tuple class (a generic container class of different types) as kernel result to store 
                              
                                 
                                    
                                       
                                          g
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                n
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                              
                           . All the mathematical operations needed to evaluate weighted residual matrices are implemented for the tuple kernel results, so the parallel evaluation of weighted residual matrices is performed in the same way as for single kernels:
                              
                                 
                                    
                                    
                                       
                                          1 (L, M) ≪d *LM_op[d];
                                          
                                       
                                    
                                 
                              
                           By means of expression templates [13], the tuple arithmetics compiles optimally to sequential evaluation of single-kernel weighted residuals, but repeated evaluation of kernel inputs and intermediate results (N-set vectors, Jacobians) is avoided.


                           Fig. 6
                            demonstrates the above by the example of the Helmholtz kernel 
                              
                                 
                                    
                                       e
                                    
                                    
                                       -
                                       i
                                       kr
                                    
                                 
                                 /
                                 4
                                 π
                                 r
                              
                            and its normal derivative, that are discretised to compute the matrices 
                              
                                 L
                              
                            and 
                              
                                 M
                              
                            from Eq. (16). The figure displays the CPU time needed to compute the two matrices separately and using the parallel method, for different numbers of degrees of freedom. Apparently, computing the matrices simultaneously requires only slightly more computation time than computing matrix 
                              
                                 M
                              
                           , whereas it costs 30–50% less time than evaluating 
                              
                                 L
                              
                            and 
                              
                                 M
                              
                            in a subsequent manner.

The relationship of the classes used for evaluating weighted residual forms are depicted in Fig. 7
                        . The class template WeightedResidual is responsible for evaluating the expression 
                           
                              
                                 
                                    W
                                 
                                 
                                    ij
                                 
                              
                              =
                              〈
                              
                                 
                                    φ
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    
                                       
                                          K
                                          
                                             
                                                d
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                 
                                 
                                    Γ
                                 
                              
                              
                                 
                                    〉
                                 
                                 
                                    F
                                 
                              
                           
                        . Sequential evaluation is carried out over homogeneous sub-function spaces, and for each of them the integrals are calculated over field pairs, implemented by the DoubleIntegral class template.

The element integrals (17) can be expressed analytically for simple kernels, element types and weighting shape functions. In the general case, however, the integrals need to be approximated by numerical quadratures.

Regular numerical quadrature schemes are characterised by the number of quadrature base points and the quadrature order—the maximal polynomial degree of the integrand that can be accurately represented. Class template ComplexityEstimator estimates the polynomial complexity of a regular integral over a test and a trial field. The overall polynomial complexity comprises that of the kernel, the weighting functions and the coordinate transform. The kernel’s polynomial complexity is computed by the class template KernelComplexityEstimator that can be specialised for different kernel types. After the polynomial complexity has been determined, an appropriate quadrature is selected, and the integration is performed using simple accumulation. Quadratures are accessed through a FieldTypeAccelerator template class that computes and stores the weights 
                           
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                           
                         and locations 
                           
                              
                                 
                                    ξ
                                 
                                 
                                    i
                                 
                              
                           
                        , as well as the shape function values 
                           
                              
                                 
                                    N
                                 
                                 
                                    k
                                 
                              
                              (
                              
                                 
                                    ξ
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         once a specific quadrature is referenced.

If the kernel is singular, special integration techniques need to be applied. Weak singularities—like 
                           
                              log
                              (
                              r
                              )
                           
                        -type in two dimensions or 
                           
                              1
                              /
                              r
                           
                        -type in three dimensions—can be cancelled out by quadrature transformation methods [14,15]. These transforms are “blind” in the sense that they can be used for any kernel having a specific singularity type.

The performance of most BEM algorithms is determined by the accuracy of the evaluation of strongly or hypersingular integrals [16]. The strongly singular integrals exist only in a Cauchy principal value (CPV) sense, while the hypersingular integrals need to be evaluated as Hadamard finite parts (HFP), which makes them impossible to cancel out by “blind” quadrature methods. The library implements Guiggiani’s method [17,18] with the recent improvement by Rong et al. [19] to handle CPV and HFP integrals in a generic way. Guiggiani’s method is a singularity subtraction technique in polar coordinates. The kernel’s strongly singular part is integrated analytically, and the remaining regular part is integrated by Gaussian quadratures in polar coordinates. The NiHu core enables the user to specialise Guiggiani’s general technique for a specific singularity type. An example of applying this technique is given later in Section ‘Introducing a new PDE into the NiHu framework’.


                        NiHu also provides a flexible mechanism, the class template SingularIntegralShortcut, by which dedicated analytical or semianalytical expressions for specific singular integrals can be defined. The shortcut class may be specialised for specific kernels, field types and discretisation formalisms to obtain a dedicated regularisation algorithm.

Expressive syntax in the outermost library layer is a key feature of the implementation. One of the main objectives of the development was to establish a syntactic layer that hides the template metaprogramming from the user and provides a “Matlab-like” simple interface in the C++ code. This is achieved by introducing a system of proxy classes representing the abstract mathematical structures of the BEM framework and implementing their operations. The expression tree of a typical weighted residual matrix expression (like line 8 in the prototype code) is plotted in Fig. 8
                        .

Class IntegralOperator itself is a proxy class that encapsulates a kernel instance and provides the “index” operator (the function named operator[] in C++) to evaluate the integral operator on a function space. The resulting object is an IntegralTransform proxy that can be tested by a test function space, the testing being implemented by the left multiplication operator. The result of testing is still a proxy object, called WeightedResidual that provides the “evaluation operator” (operator<< in C++) with a result matrix on the left hand side. All the presented mathematical structures are linear transformations so the basic superposition operations are implemented for them.

Thanks to the mechanism of expression templates, all these proxy objects and operator function calls are cancelled out during compilation, resulting in the sole instantiation of a single Assembly class. This class encapsulates the two function spaces, the kernel and the result matrix, and is able to perform the discretisation as shown in Fig. 7.

The Component library currently defines the single, double layer potential and hypersingular fundamental solutions of the Laplace and Helmholtz equations. These definitions are not restricted to the evaluation of kernel expressions, but provide several analytical and semianalytical regularised formulae for specific singular kernel integrals [20–22].

One specialised kernel complexity estimator type, the IntervalEstimator is supported currently. The IntervalEstimator divides the relative distance 
                           
                              r
                              /
                              
                                 
                                    l
                                 
                                 
                                    e
                                 
                              
                           
                         (physical distance divided by the element’s size 
                           
                              
                                 
                                    l
                                 
                                 
                                    e
                                 
                              
                           
                        ) between elements into ranges, and assigns a single polynomial order to a range. The estimator can be parameterised by an overall relative error requirement, and the actual intervals are predefined for each kernel.

It is worth mentioning that class IntervalEstimator is defined in a compile-time manner. This means that if two or more kernels are merged for parallel evaluations, then the resulting (couple) kernel’s intervals are computed by a metaprogram during compilation, saving execution time. The result of merging two different kernels with different complexity and intervals is illustrated in Fig. 9
                        .

To demonstrate the versatility of the NiHu C++ core, a simple academical problem was solved using different formalisms and discretisation options. The example case is an exterior Neumann radiation problem of the Laplace equation defined by a spherical boundary 
                           
                              Γ
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       
                                       
                                          
                                             u
                                             
                                                
                                                   ,
                                                
                                                
                                                   jj
                                                
                                             
                                             (
                                             x
                                             )
                                             =
                                             0
                                             ,
                                             
                                             x
                                             ∈
                                             Ω
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             u
                                             
                                                
                                                   ,
                                                
                                                
                                                   n
                                                
                                             
                                             (
                                             x
                                             )
                                             =
                                             
                                                
                                                   q
                                                
                                                
                                                   ¯
                                                
                                             
                                             (
                                             x
                                             )
                                             ,
                                             
                                             x
                                             ∈
                                             Γ
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        The prescribed potential derivative 
                           
                              
                                 
                                    q
                                 
                                 
                                    ¯
                                 
                              
                           
                         is defined as the response to a monopole source located at the centre of the sphere radiator. With this choice, the numerically computed potential u on the sphere boundary can be compared to the potential field induced by the point source, i.e.this is a transparent test problem.

Three separate executables were generated implementing (1) constant collocational, (2) constant Galerkin and (3) isoparametric Galerkin discretisations. Each code supported linear and quadratic triangular and quadrangular elements. To test the TMP-generated mesh and function space classes, the problem was solved using homogeneous and heterogeneous meshes, where half of the geometry is meshed using triangles and the other half was meshed using quadrangles. All three configurations were run using linear and quadratic geometrical shape functions. Table 1
                         displays the results for the 18 different configurations.

The results of the constant collocational case show that quadratic elements perform much better than linear discretisation. The number of degrees of freedom is reduced by a factor of 4, the elements provide a more accurate representation of the geometry, and the required quadrature order increases only by 2.

Due to the double integrations, Galerkin solutions are obviously much slower than collocational ones. For the case of the isoparametric Galerkin discretisation, the introduction of quadratic elements does not decrease the number of degrees of freedom, only the number of elements. The results are still more accurate than those with linear elements, but due to the large increase in the required quadrature orders, the price is double computation time.

Regardless of the timing and error comparisons, the most important result of the presented test is that the library is able to generate optimised executables for a large variety of discretisation options.


                        NiHu generates executables that can deal with problems of industrial size. Our demonstrative example is an acoustic exterior scattering problem, where the Helmholtz Eq. (7) is solved in three dimensions, in an infinite external domain. The problem domain’s boundary surface 
                           
                              Γ
                           
                         represents a standing person. The boundary is considered as being acoustically rigid, and is illuminated by a monopole radiating at the highest applicable wave number 
                           
                              k
                              =
                              2
                              π
                              /
                              6
                              
                                 
                                    l
                                 
                                 
                                    max
                                 
                              
                           
                         where 
                           
                              
                                 
                                    l
                                 
                                 
                                    max
                                 
                              
                           
                         denotes the longest edge of all of the boundary elements.

Two different meshes were used, both created by refining a freely available mesh [23] using refinement functions of NiHu’s Matlab shell layer. The sound pressure on the boundary was approximated using piecewise constant interpolation functions, and collocational formalism was applied to generate the system matrices 
                           
                              L
                           
                         and 
                           
                              M
                              -
                              1
                              /
                              2
                              B
                           
                         from Eq. (16).

System matrix generation and the solution of the linear system were performed in a standalone NiHu-generated C++ executable. For efficient memory usage, the system matrices were computed separately, so the optimised parallel matrix evaluation method was not exploited. Eigen’s built-in BiCGSTAB solver was utilised for solving the system of equations.

In case of the coarse mesh #1, the computations were performed on a desktop PC with Intel Core 2 Duo CPU running at 
                           
                              3.0
                              
                              GHz
                           
                         and 
                           
                              8
                              
                              GB
                           
                         RAM, using one processor core on Ubuntu Linux 12.04 operating system. For additional reduction of memory consumption, the elements of the system matrices were stored as single precision (32-bit) complex valued numbers.

The results for the fine mesh #2 were computed on one core (AMD Opteron 6174 CPU running at 
                           
                              2.2
                              
                              GHz
                           
                        ) of a supercomputer grid, where sufficient memory was available. In order to get better convergence of the iterative solver, the matrix elements were stored in double precision (64-bit) in this case. Specific details of the computations are displayed in Table 2
                        . Fig. 10
                         shows the total acoustic pressure field on the fine mesh.

To be able to adjudicate the computational performance of NiHu, it has been compared to other open source implementations. Since different packages support solutions to different PDEs and discretisation options, a thorough comparison using all possible combinations of discretisation options and weighting functions is not feasible. The following packages were available for comparison.
                           
                              1.
                              
                                 abemfull is a small BEM package by Kirkup [24]. It can calculate collocational Helmholtz BEM over 3-noded triangular elements using piecewise constant function spaces. In abemfull the regular integrals are evaluated by using the same quadrature rule independent of the distance of the collocation point and the test element. This specific point is marked as a possibility of optimising the code by Kirkup himself.


                                 BEM++ is a modern open-source C++/Python boundary element library [25]. BEM++ aims at incorporating several other open source packages, such as BLAS and BOOST to achieve efficiency and a high level of code reusing at the same time. The implementation is capable of calculating piecewise constant or piecewise linear Galerkin BEM using 3-noded triangular elements for the Laplace, Helmholtz and Maxwell equations. Beside the limitation of restricted discretisation options BEM++ has some advantages compared to NiHu. BEM++ is multi-threaded and it can perform the adaptive cross approximation (ACA) technique for the efficient solution of problems of large size. For the comparison BEM++ version 1.9 was used.

As a third option, the TMP-generated NiHu executable was compared to a previous C implementation written by the authors. The C code can evaluate constant collocation BEM discretisations of the Helmholtz equation using 3-noded triangular and 4-noded quadrangular elements. The C code performs kernel evaluation and matrix assembly in a parallel manner, and handles heterogeneous meshes with dynamic dispatching. The implementation already contains techniques that aim at optimising the computational performance, such as adaptive quadrature selection and precomputation of shape function values in quadrature points, and can be considered as a hand-written and optimised particular specialisation case of the NiHu template library.

The test problem chosen is an exterior Helmholtz radiation problem from a sphere with unit normal velocity defined over its whole surface. Two setups are investigated: constant collocation (for comparing abemfull, the older C code by the authors, and NiHu) and linear isoparametric Galerkin (for comparing BEM++ and NiHu). The geometry is discretised using 3-noded triangular elements.

All four packages were compiled from source with setting the compiler flags to maximal optimisation regarding speed. Two different NiHu executables were created: the first evaluated the system matrices 
                           
                              L
                           
                         and 
                           
                              M
                              -
                              1
                              /
                              2
                              B
                           
                         one after the other, whereas parallel integral operator evaluation was made use of in the second version. In BEM++ the ACA option was disabled, hence, all codes computed the system matrices in the traditional element-by-element manner.

All tests were performed using a single core of an AMD Phenom II X6 1090T CPU, running at 
                           
                              3.2
                              
                              GHz
                           
                        . Clearly, the resulting error of the solution depends on the applied quadrature rules and the inevitable error introduced by the discretisation of the geometry. The latter is assumed being negligibly small, especially in the case of the middle and large meshes. The mean error therefore is only an indicator in this examination by which the efficiency of the quadrature rule selection can be judged. The main parameter of the comparison is thus the time required to assemble the system matrices 
                           
                              L
                           
                         and 
                           
                              M
                              -
                              1
                              /
                              2
                              B
                           
                        .


                        Table 3
                         displays the results of the comparison. For the collocational case, it is evident that the adaptive quadrature selection (not implemented in abemfull) is of key importance for achieving good computational speed. The unnecessarily high number of quadrature points used over elements located relatively far from each other results in the dramatic increase of matrix assembly time without reducing the error of the solution in case of abemfull. Comparing to the older C code by the authors, improvement in performance is achieved thanks to the greatly reduced number of dynamically dispatched calls, provided by the TMP generated mesh and function space classes.

For the Galerkin case, it can be seen that NiHu provides good computational performance, comparable to (or slightly better than) that of BEM++ with the ACA technique deactivated. By using parallel kernel evaluations the matrix assembly time is reduced again, as shown already in Section ‘Parallel kernel evaluation’. Naturally, a full matrix assembly approach cannot compete with the ACA or fast multipole techniques regarding computational time, and therefore such a comparison is not an objective of this paper. Nevertheless, the results presented in Table 3 verify that from the heavily templated source code of NiHu executables of high performance can be compiled. Further improvement could be achieved by using multiple threads; however, this would require additional development.

This section demonstrates how a new family of BIE can be incorporated into the NiHu framework. The demonstrative example problem is three-dimensional linear isotropic elastostatics governed by the PDE:
                        
                           (19)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                σ
                                             
                                             
                                                ij
                                             
                                          
                                          =
                                          λ
                                          
                                             
                                                δ
                                             
                                             
                                                ij
                                             
                                          
                                          
                                             
                                                u
                                             
                                             
                                                k
                                             
                                          
                                          
                                             
                                                ,
                                             
                                             
                                                k
                                             
                                          
                                          +
                                          μ
                                          
                                             
                                                
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   
                                                      
                                                         ,
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         ,
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          μ
                                          
                                             
                                                u
                                             
                                             
                                                i
                                                ,
                                                jj
                                             
                                          
                                          (
                                          x
                                          )
                                          +
                                          
                                             
                                                
                                                   μ
                                                   +
                                                   λ
                                                
                                             
                                          
                                          
                                             
                                                u
                                             
                                             
                                                j
                                                ,
                                                ij
                                             
                                          
                                          (
                                          x
                                          )
                                          =
                                          0
                                          ,
                                          
                                          x
                                          ∈
                                          Ω
                                          ⊂
                                          
                                             
                                                R
                                             
                                             
                                                3
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     with the boundary conditions
                        
                           (20)
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    σ
                                 
                                 
                                    ij
                                 
                              
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ¯
                                       
                                    
                                 
                                 
                                    i
                                 
                              
                              (
                              x
                              )
                              ,
                              
                              x
                              ∈
                              
                                 
                                    Γ
                                 
                                 
                                    t
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (21)
                           
                              
                                 
                                    u
                                 
                                 
                                    i
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ¯
                                       
                                    
                                 
                                 
                                    i
                                 
                              
                              (
                              x
                              )
                              ,
                              
                              x
                              ∈
                              
                                 
                                    Γ
                                 
                                 
                                    u
                                 
                              
                              ,
                           
                        
                     where 
                        
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                        
                      denotes the displacement vector field, 
                        
                           
                              
                                 σ
                              
                              
                                 ij
                              
                           
                        
                      denotes the stress tensor, 
                        
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                        
                      denotes the traction vector, 
                        
                           μ
                        
                      and 
                        
                           λ
                        
                      are the Lamé-coefficients, 
                        
                           Ω
                        
                      denotes the solution domain, and 
                        
                           
                              
                                 Γ
                              
                              
                                 t
                              
                           
                        
                      and 
                        
                           
                              
                                 Γ
                              
                              
                                 u
                              
                           
                        
                      stand for its boundary with prescribed traction or displacement boundary conditions, respectively.

The corresponding boundary integral representation is formulated as
                        
                           (22)
                           
                              
                                 
                                    
                                    
                                       
                                          c
                                          (
                                          x
                                          )
                                          
                                             
                                                u
                                             
                                             
                                                i
                                             
                                          
                                          (
                                          x
                                          )
                                          =
                                          
                                             ∫
                                             
                                                Γ
                                             
                                          
                                          
                                             
                                                t
                                             
                                             
                                                ij
                                             
                                             
                                                ∗
                                             
                                          
                                          (
                                          x
                                          ,
                                          y
                                          )
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                          (
                                          y
                                          )
                                          d
                                          y
                                          -
                                          
                                             ∫
                                             
                                                Γ
                                             
                                          
                                          
                                             
                                                u
                                             
                                             
                                                ij
                                             
                                             
                                                ∗
                                             
                                          
                                          (
                                          x
                                          ,
                                          y
                                          )
                                          
                                             
                                                t
                                             
                                             
                                                j
                                             
                                          
                                          (
                                          y
                                          )
                                          d
                                          y
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          c
                                          (
                                          x
                                          )
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            1
                                                         
                                                         
                                                            x
                                                            ∈
                                                            Ω
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            1
                                                            /
                                                            2
                                                         
                                                         
                                                            x
                                                            ∈
                                                            
                                                               
                                                                  Γ
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                            ∪
                                                            
                                                               
                                                                  Γ
                                                               
                                                               
                                                                  u
                                                               
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 u
                              
                              
                                 ij
                              
                              
                                 ∗
                              
                           
                        
                      and 
                        
                           
                              
                                 t
                              
                              
                                 ij
                              
                              
                                 ∗
                              
                           
                        
                      denote Kelvin’s displacement and traction fundamental solutions, respectively:
                        
                           (23)
                           
                              
                                 
                                    u
                                 
                                 
                                    ij
                                 
                                 
                                    ∗
                                 
                              
                              =
                              
                                 
                                    (
                                    3
                                    -
                                    4
                                    ν
                                    )
                                    
                                       
                                          δ
                                       
                                       
                                          ij
                                       
                                    
                                    +
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          i
                                       
                                    
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    16
                                    π
                                    μ
                                    (
                                    1
                                    -
                                    ν
                                    )
                                    r
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (24)
                           
                              
                                 
                                    t
                                 
                                 
                                    ij
                                 
                                 
                                    ∗
                                 
                              
                              =
                              
                                 
                                    -
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          n
                                       
                                    
                                    (
                                    (
                                    1
                                    -
                                    2
                                    ν
                                    )
                                    
                                       
                                          δ
                                       
                                       
                                          ij
                                       
                                    
                                    +
                                    3
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          i
                                       
                                    
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    +
                                    (
                                    1
                                    -
                                    2
                                    ν
                                    )
                                    (
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          n
                                       
                                       
                                          j
                                       
                                    
                                    -
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          n
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 
                                    8
                                    π
                                    (
                                    1
                                    -
                                    ν
                                    )
                                    
                                       
                                          r
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ,
                           
                        
                     with 
                        
                           ν
                        
                      and 
                        
                           μ
                        
                      denoting the Poisson’s ratio and the shear modulus, respectively. The displacement kernel contains a weak 
                        
                           O
                           (
                           1
                           /
                           r
                           )
                        
                      singularity, and can be integrated using blind singular quadratures. The traction kernel is strongly singular, and its 
                        
                           O
                           (
                           1
                           /
                           
                              
                                 r
                              
                              
                                 2
                              
                           
                           )
                        
                     -type singularity needs to be handled in a CPV sense.

The BIE is incorporated into the library by introducing the fundamental solutions as suitable kernel functions in integral operators. The fundamental solutions are implemented in the following steps:
                        
                           1.
                           The kernel input, kernel output and kernel parameter classes (see Fig. 4) are defined and the expressions (23) and (24) are formulated in appropriate function objects.

The kernel classes are declared and their basic properties (asymptotic behaviour, symmetry, etc.) are defined in traits classes.

The kernel classes must be derived from the common kernel base class.

For the case of the strongly singular traction kernel 
                        
                           
                              
                                 t
                              
                              
                                 ij
                              
                              
                                 ∗
                              
                           
                        
                     , the definition of additional integral expressions facilitating the accurate evaluation of the CPV are also needed. This example demonstrates the application of Guiggiani’s method for collocation. The strongly singular part of the traction kernel is
                        
                           (25)
                           
                              
                                 
                                    t
                                 
                                 
                                    ij
                                 
                                 
                                    ∗
                                    0
                                 
                              
                              =
                              
                                 
                                    (
                                    1
                                    -
                                    2
                                    ν
                                    )
                                    (
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          n
                                       
                                       
                                          j
                                       
                                    
                                    -
                                    r
                                    
                                       
                                          ,
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          n
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 
                                    8
                                    π
                                    (
                                    1
                                    -
                                    ν
                                    )
                                    
                                       
                                          r
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ,
                           
                        
                     and the corresponding CPV integral in polar intrinsic coordinates reads as [17]
                     
                        
                           (26)
                           
                              I
                              =
                              
                                 ∫
                                 
                                    0
                                 
                                 
                                    
                                       
                                          ρ
                                       
                                       
                                          ˆ
                                       
                                    
                                    (
                                    θ
                                    )
                                 
                              
                              
                                 ∫
                                 
                                    0
                                 
                                 
                                    2
                                    π
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   ij
                                                
                                                
                                                   ∗
                                                   0
                                                
                                             
                                             (
                                             ρ
                                             ,
                                             θ
                                             )
                                             N
                                             (
                                             ρ
                                             ,
                                             θ
                                             )
                                             J
                                             (
                                             ρ
                                             ,
                                             θ
                                             )
                                             ρ
                                          
                                          
                                             ︸
                                          
                                       
                                    
                                    
                                       F
                                       (
                                       ρ
                                       ,
                                       θ
                                       )
                                    
                                 
                              
                              
                              d
                              θ
                              
                              d
                              ρ
                              ,
                           
                        
                     where 
                        
                           ρ
                        
                      denotes the distance from the collocational point in intrinsic coordinates, N and J stand for the shape function and Jacobian of the geometrical transform, respectively. In order to apply Guiggiani’s method, the Laurent series expansion of the integrand F in (26) needs to be defined in terms of the Taylor series expansions of the distance vector 
                        
                           y
                           -
                           x
                        
                     , the shape function and the Jacobian. The code segments in Appendix A show the implementational details.


                     Fig. 11
                      shows the results of an interior test problem with a cylindrical bar shaped enclosure characterised by the Poisson’s ratio 
                        
                           ν
                           =
                           1
                           /
                           3
                        
                     . The boundary conditions are mixed: zero displacement on the bottom, zero traction vector on the side and unit tangential traction vectors on the top of the cylinder. The bar is meshed by 224 curved quadratic quadrilateral elements, and the displacement and traction fields are interpolated using piecewise constant (vector) function spaces. The applied BEM discretisation formalism is collocation.

@&#CONCLUSIONS@&#

A recently developed open source C++ BEM template library called NiHu has been introduced. The template library is capable of discretising boundary integral operators and generating the coefficients of system matrices for a variety of different BEM problems and discretisation formalisms.

The main achievements of NiHu are its generality and flexibility. These aspects have been demonstrated by presenting the automatised discretisation of an academic problem using 18 different BEM formalisms, as well as demonstrating how a new PDE can be introduced into the matrix generation workflow.

By exploiting recent C++ technologies and template metaprogramming, the NiHu core generates optimised code and compiles on any architecture where a C++11 compiler is available. This feature has been demonstrated by presenting modelling results of a large-scale problem, where computations were run both on a desktop PC and on a supercomputer. Furthermore, the implementation’s performance has been compared to other open source libraries, proving that the executables generated by NiHu provide good efficiency.

Besides, the library compiles under Matlab through the MEX interface, providing a user-friendly environment for pre- and post-processing, and making an efficient BEM implementation available for Matlab users.

The library is published under the GNU General Public License and can be downloaded at http://last.hit.bme.hu/nihu, where the complete source code together with examples and tutorials are also available.

@&#ACKNOWLEDGEMENT@&#

Large scale computations were run on the Hungarian HPC infrastructure (NIIF Institute, Hungary).

For brevity, only the code segments corresponding to the strongly singular traction kernel 
                        
                           
                              
                                 t
                              
                              
                                 ij
                              
                              
                                 ∗
                              
                           
                        
                      are printed. The displacement kernel is implemented in a similar way, but the last step defining the Laurent coefficients of the strongly singular part can be omitted.

The traction kernel takes a simple 3D location as test input and a location and normal vector as trial input. The kernel is further parameterised by material properties, the shear modulus 
                        
                           μ
                        
                      and Poisson’s ratio 
                        
                           ν
                        
                     .

First, the kernel parameter class—a simple wrapper for a double data—is implemented to store the Poisson’s ratio. The shear modulus could also be incorporated into the parameter class, but as this parameter serves only as a scaling factor, it is omitted in the current implementation without the loss of generality.
                        
                           
                              
                              
                                 
                                    1 
                                          class
                                        
                                       poisson_ratio_data {
                                 
                                 
                                    2 
                                          public:
                                       
                                    
                                 
                                 
                                    3 
                                       poisson_ratio_data(double
                                        
                                       nu): m_nu (nu) {}
                                 
                                 
                                    4 
                                       
                                          double
                                        
                                       get_poisson_ratio(void)
                                        
                                       
                                          const
                                        { 
                                          return
                                        
                                       m_nu; }
                                 
                                 
                                    5 
                                          private:
                                       
                                    
                                 
                                 
                                    6 
                                       
                                          double
                                        
                                       m_nu;
                                    
                                 
                                 
                                    7};
                                 
                              
                           
                        
                     
                  

Next, a function object, called Tkernel is created that evaluates the traction kernel (expression (24)) on test and trial input and parameters. The functor defines the kernel’s return type as well.
                        
                           
                              
                              
                                 
                                    
                                       
                                       8 struct Tkernel {
                                 
                                 
                                    
                                       
                                       9 
                                       
                                          typedef
                                        
                                       Matrix3d return_type;
                                    
                                 
                                 
                                    10
                                 
                                 
                                    11 
                                       return_type 
                                       
                                          operator
                                       ()(
                                 
                                 
                                    12 
                                       location_input_3d 
                                       
                                          const
                                        &x,
                                    
                                 
                                 
                                    13 
                                       location_normal_input_3d 
                                       
                                          const
                                        &y,
                                    
                                 
                                 
                                    14 
                                       poisson_ratio_data 
                                       
                                          const
                                        &data)
                                    
                                 
                                 
                                    15 {
                                 
                                 
                                    16 
                                       
                                          double
                                        
                                       nu
                                       
                                       =
                                       
                                       data.get_poisson_ratio(
                                       
                                       );
                                    
                                 
                                 
                                    17 
                                       
                                          auto
                                        
                                       rvec
                                       
                                       =
                                       
                                       y.get_x(
                                       
                                       ) - x.get_x(
                                       
                                       );
                                    
                                 
                                 
                                    18 
                                       
                                          auto const
                                        &n
                                       
                                       =
                                       
                                       y.get_unit_normal(
                                       
                                       );
                                    
                                 
                                 
                                    19 
                                       
                                          double
                                        
                                       r
                                       
                                       =
                                       
                                       rvec.norm(
                                       
                                       );
                                    
                                 
                                 
                                    20 
                                       
                                          auto
                                        
                                       dr
                                       
                                       =
                                       
                                       rvec.normalized(
                                       
                                       );
                                    
                                 
                                 
                                    21 
                                       
                                          double
                                        
                                       rdn
                                       
                                       =
                                       
                                       dr.dot(n);
                                    
                                 
                                 
                                    22 
                                       
                                          auto
                                        
                                       drt
                                       
                                       =
                                       
                                       dr.transpose(
                                       
                                       );
                                    
                                 
                                 
                                    23 
                                       
                                          return
                                        
                                       (-rdn * ((1-2*nu)∗Matrix3d::Identity(
                                       
                                       ) +3*(dr*drt))
                                    
                                 
                                 
                                    24 
                                       
                                       + (1-2*nu)*(dr*n.transpose(
                                       
                                       )-n*drt))/(8*M_PI*(1-nu)*r*r);
                                    
                                 
                                 
                                    25}
                                 
                                 
                                    26 };
                                 
                              
                           
                        
                     
                  

Now the final kernel class is declared:
                        
                           
                              
                              
                                 
                                    26 
                                          class
                                        
                                       elastostatics_3d_T_kernel;
                                    
                                 
                              
                           
                        
                     and its properties are defined by specialising the template kernel_traits to the new kernel class:
                        
                           
                              
                              
                                 
                                    27 
                                          template
                                        <>
                                 
                                 
                                    28 
                                          struct
                                        
                                       kernel_traits <elastostatics_3d_T_kernel>
                                 
                                 
                                    29 {
                                 
                                 
                                    30 
                                       
                                          typedef
                                        
                                       location_input_3d test_input_t;
                                    
                                 
                                 
                                    31 
                                       
                                          typedef
                                        
                                       location_normal_input_3d trial_input_t;
                                    
                                 
                                 
                                    32 
                                       
                                          typedef
                                        
                                       collect <poisson_ratio_data> data_t;
                                    
                                 
                                 
                                    33 
                                       
                                          typedef
                                        
                                       single_brick_output <Tkernel>::type output_t;
                                    
                                 
                                 
                                    34 
                                       
                                          typedef
                                        
                                       asymptotic::inverse <2> far_field_behaviour_t;
                                    
                                 
                                 
                                    35 
                                       
                                          typedef
                                        
                                       gauss_family_tag quadrature_family_t;
                                    
                                 
                                 
                                    36 
                                       
                                          static bool const
                                        
                                       is_symmetric
                                             =false
                                       ;
                                 
                                 
                                    37 
                                       
                                          static bool const
                                        
                                       is_singular
                                             =true
                                       ;
                                 
                                 
                                    38};
                                 
                              
                           
                        
                     The first four typedefs define the kernel’s test and trial input types, the kernel’s parameter data type and the kernel’s output type. As mentioned before, NiHu provides a mechanism to split the kernel’s output expression into a series of subexpressions—called bricks—, and instantiate a complex output structure to allow optimised parallel kernel evaluations. For simplicity, this feature is not exploited in this example, and the kernel’s output is a single brick output, computed using the expression in functor Tkernel.

The following typedefs define the kernel’s regular far field behaviour. The asymptotic behaviour is 
                        
                           O
                           (
                           1
                           /
                           
                              
                                 r
                              
                              
                                 2
                              
                           
                           )
                        
                     , and regular integrals are to be computed using Gaussian quadratures.

The kernel class is derived from kernel_base using the CRTP pattern [8]. The class defines a constructor taking the Poisson’s ratio as its argument:
                        
                           
                              
                              
                                 
                                    39 
                                          class
                                        
                                       elastostatics_3d_T_kernel :
                                    
                                 
                                 
                                    40 
                                       
                                          public
                                        
                                       kernel_base <elastostatics_3d_T_kernel>
                                 
                                 
                                    41 {
                                 
                                 
                                    42 
                                          public:
                                       
                                    
                                 
                                 
                                    43 
                                       elastostatics_3d_T_kernel (double
                                        
                                       nu) :
                                    
                                 
                                 
                                    44 
                                       kernel_base <elastostatics_3d_T_kernel>(poisson_ratio_data(nu))
                                    
                                 
                                 
                                    45 {
                                 
                                 
                                    46 }
                                 
                                 
                                    47 };
                                 
                              
                           
                        
                     
                  

The kernel is defined as singular. This necessitates the definition of further options in the specialisation of template singular_kernel_traits:
                        
                           
                              
                              
                                 
                                    48 
                                          template <>
                                       
                                    
                                 
                                 
                                    49 
                                          struct
                                        
                                       singular_kernel_traits <elastostatics_3d_T_kernel>
                                 
                                 
                                    50 {
                                 
                                 
                                    51 
                                       
                                          typedef
                                        
                                       asymptotic::inverse <2> singularity_type_t;
                                    
                                 
                                 
                                    52 
                                       
                                          typedef
                                        
                                       elastostatics_3d_T_kernel singular_core_t;
                                    
                                 
                                 
                                    53 };
                                 
                              
                           
                        
                     The kernel’s singularity order is defined as 
                        
                           O
                           (
                           1
                           /
                           
                              
                                 r
                              
                              
                                 2
                              
                           
                           )
                        
                     . From this information the compiler deduces that the singularity is strong and needs to be evaluated in CPV sense.

In order to apply Guiggiani’s method, the Laurent series expansion of the integrand in (26) needs to be defined by specialising the template class polar_laurent_coeffs to the traction kernel. The specialisation must provide a static function eval that will be called by the code segments implementing Guiggiani’s method. This function takes the caller object as parameter that provides the Taylor series expansion of the distance vector 
                        
                           y
                           -
                           x
                        
                     , the Jacobian J, and the shape function N over the element. The Laurent coefficients need to be defined in terms of these quantities.
                        
                           
                              
                              
                                 
                                    54 
                                          template <>
                                       
                                    
                                 
                                 
                                    55 class polar_laurent_coeffs <elastostatics_3d_T_kernel>
                                 
                                 
                                    56 {
                                 
                                 
                                    57 
                                          public:
                                       
                                    
                                 
                                 
                                    58 
                                       
                                          template <class
                                        
                                       Caller>
                                 
                                 
                                    59 
                                       
                                          static void
                                        
                                       eval (Caller &obj)
                                    
                                 
                                 
                                    60 {
                                 
                                 
                                    61 
                                       
                                          auto const
                                        &r1
                                       
                                       =
                                       
                                       obj.get_rvec_series(_1(
                                       
                                       ));
                                    
                                 
                                 
                                    62 
                                       
                                          auto const
                                        &j0
                                       
                                       =
                                       
                                       obj.get_Jvec_series(_0(
                                       
                                       ));
                                    
                                 
                                 
                                    63 
                                       
                                          auto const
                                        &N0
                                       
                                       =
                                       
                                       obj.get_shape_series (_0(
                                       
                                       ));
                                    
                                 
                                 
                                    64 
                                       
                                          auto
                                        
                                       nu
                                       
                                       =
                                       
                                       obj.get_kernel_data(
                                       
                                       ).get_poisson_ratio(
                                       
                                       );
                                    
                                 
                                 
                                    65 
                                       Matrix3d res = ((r1 * j0.transpose(
                                       
                                       ))- (j0 * r1.transpose(
                                       
                                       ))) * (1.--2. * nu)
                                    
                                 
                                 
                                    
                                       
                                       
                                       
                                       
                                       /(1.-nu)/(8. * M_PI);
                                    
                                 
                                 
                                    66 
                                       obj.set_laurent_coeff (_m1(
                                       
                                       ), semi_block_product (res, N0));
                                    
                                 
                                 
                                    67 }
                                 
                                 
                                    68 };
                                 
                              
                           
                        
                     The kernel is now ready to instantiate integral operators and accurately evaluate CPV integrals even on higher order curved elements with the following expressions:
                        
                           
                              
                              
                                 
                                    1 
                                          auto const
                                        &d
                                       
                                       =
                                       
                                       constant_view(mesh, _3d(
                                       
                                       ));
                                    
                                 
                                 
                                    2 
                                          auto
                                        
                                       T
                                       
                                       =
                                       
                                       create_integral_operator(elastostatics_3d_T_kernel(.33));
                                    
                                 
                                 
                                    3 Mat ≪ dirac(d) * T[d];
                                    
                                 
                              
                           
                        
                     where the additional argument _3d () in function constant_view defines the vector valued function space.

@&#REFERENCES@&#

