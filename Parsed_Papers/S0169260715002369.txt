@&#MAIN-TITLE@&#High-quality slab-based intermixing method for fusion rendering of multiple medical objects

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A novel intermixing scheme is proposed for fusion rendering of multiple medical objects.


                        
                        
                           
                           High-quality intermixing results are acquired for intersecting and overlapping surfaces.


                        
                        
                           
                           Our method resolved aliasing and z-fighting problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Volume rendering

Surface rendering

Virtual zSlab

Visibility interpolation

Aliasing problem




                     Z-fighting problem

@&#ABSTRACT@&#


               
               
                  The visualization of multiple 3D objects has been increasingly required for recent applications in medical fields. Due to the heterogeneity in data representation or data configuration, it is difficult to efficiently render multiple medical objects in high quality. In this paper, we present a novel intermixing scheme for fusion rendering of multiple medical objects while preserving the real-time performance. First, we present an in-slab visibility interpolation method for the representation of subdivided slabs. Second, we introduce virtual zSlab, which extends an infinitely thin boundary (such as polygonal objects) into a slab with a finite thickness. Finally, based on virtual zSlab and in-slab visibility interpolation, we propose a slab-based visibility intermixing method with the newly proposed rendering pipeline. Experimental results demonstrate that the proposed method delivers more effective multiple-object renderings in terms of rendering quality, compared to conventional approaches. And proposed intermixing scheme provides high-quality intermixing results for the visualization of intersecting and overlapping surfaces by resolving aliasing and z-fighting problems. Moreover, two case studies are presented that apply the proposed method to the real clinical applications. These case studies manifest that the proposed method has the outstanding advantages of the rendering independency and reusability.
               
            

@&#INTRODUCTION@&#

The visualization of various types of multiple 3D objects has found its increasing usage in medical fields [1]. With the advance of the scanning device in the medical field, it is becoming one of common practice to simultaneously examine multimodality datasets such as CT (Computed Tomography)–PET (Positron Emission Tomography), MR (Magnetic Resonance)-CT, and MR-SPECT [2,3]. And the surgical planning in neurosurgery and implant surgery requires artificial or binary models (e.g., surgery tools or prior-segmented important organs, usually represented in polygonal models or attributed volume [4]) to be rendered along with a 3D scanned object [5,6]. In addition, a 2D cross-sectional image (e.g., transverse, coronal, and sagittal views) superimposed on a 3D object is needed frequently for more comprehensive information of object [7]. In all of those multiple-object rendering applications, the faster and the more accurate (i.e., rendering in a correct z-depth order) is the rendering, the higher is the user satisfaction.

Those 3D objects often come in various representations such as multi-modality, volumetric and polygonal, scan and attribute (often derived from a scan data) datasets. This heterogeneity in the data representation makes it difficult to render the multiple objects in a single rendering pipeline as each type of dataset requires a different visualization technique on its own. Even with multiple homogeneous datasets, the simultaneous rendering is not that simple when there is a difference in data configuration (e.g. acquisition precision, coordinate system, etc.) between them.

Many of previous multiple-object rendering approaches targeted at polygonal or volumetric datasets only. For the polygonal dataset, lots of approaches have been reported to intermix transparent surfaces in a correct z-depth order, in which the z-depth values for the surfaces projected to the same image pixel are stored in a buffer and then sorted for the intermixing in the correct z-depth order (referred as a buffer-based intermixing method) [8,9]. The buffer-based method has an advantage that the stored information can be reused as needed when constructing a final scene. However, this method cannot be easily extended to volumetric datasets because it just stores the information for discrete positions and thus it is not appropriate for representing volumetric surfaces including a fuzzy boundary.

For the volumetric datasets, instead, lots of previous methods adopted the volume ray-casting algorithm [10–12] while intermixing the samples from all the objects at each sampling position. This per-sample intermixing method exhibits high-quality rendering; however, it has some limitations when the datasets have different data configuration. Several approaches for rendering polygonal and volumetric objects simultaneously have been also presented, but they compute the intersection of polygonal and volumetric objects at each sample, resulting in high computational cost.

In this paper, we present a novel multi-objects rendering method which provides smooth and consistent visibility on intersecting and overlapping surfaces. We propose an in-slab visibility interpolation method, referred as opacity-based visibility interpolation (OVI), which better represents in-slab structures by avoiding the accumulated opacity from reaching to a high value too early even for high-opacity objects. In addition, we represent the infinitely thin boundary of polygonal surface as a slab with a thickness, called as virtual zSlab, with the intent to render polygonal and volumetric objects simultaneously using an identical mechanism of a slab-based visibility intermixing method. In the intermixing that involves surface geometry represented as infinitely thin boundary, there are artifacts (e.g., jagged edges and alternate visibility known as z-fighting) caused by binary-way visibility decision, which interfere with recognition of the mixing structures such as overlapping and intersecting surfaces. However, combined with our visibility interpolation, the proposed slab-based intermixing method brings more continuous and smoother visibility transition along with more natural intersection of surfaces, compared to the intermixing based on the conventional visibility interpolation. To achieve this easily, we propose a deferred intermixing scheme using multi-pass rendering pipeline [13–15], which considers, at any time, only two intermixing slab sequences in a single rendering stage.

The remainder of this paper is organized as follows. In the next section, we review previous works. Section 3 introduces the background and concept for our elaborate opacity-based visibility interpolation in sub-divided slabs. Section 4 describes the slab-based intermixing method along with virtual zSlab. Section 5 describes an implementation scheme for our intermixing pipeline in details. Section 6 presents our experimental results, followed by conclusion and future work in Section 7.

@&#RELATED WORKS@&#

As the visualization of various types of multiple objects in a single image causes complexity of computation as well as implementation, several methods have been suggested for the intermixing visualization of those different and multiple objects focused on efficient and flexible intermixing framework [1,16].

For multi-volume direct rendering (MDVR), Jacq et al. [11] introduced a multi-volume ray-casting which samples all participating volumes at a single ray step with simple merging rules. With regard to specific merging rule of different volume modalities (such as CT, MRI or PET), Cai et al. [17] and Ferre et al. [18] classified intermixing methods according to merging operation level in the intermixing stages. Wilson et al. [19] exploited different rendering styles as the merging rule based on accumulation level intermixing [17], which is used in our proposed intermixing method. However, the approaches above only focused on how to merge and fuse different volumes along a single ray.

Each volumetric dataset can have different resolution or geometrical orientation. This causes computational complexity and inflexible implementation for the rendering of multiple volumes. To resolve this problem, Plate et al. [20] introduced multi-volume ray-casting while preserving each volume's optimized data structure (e.g., hierarchical blocks). Lindholm et al. [21] employed BSP tree method to resolve this problem. However, those approaches still require a lot of high complexity if there are more than two overlapping volumes with different resolutions and orientations. In addition, because the minimum sampling distance among participating volumes is generally used, oversampling which causes performance overhead occurs. In this paper, we use similar approach with [20] for transparent MDVR. And, in the case of MDVR including an opaque surface DVR (e.g., iso-surface DVR [13,22] or attributed DVR [4]), we exploit deferred rendering strategy [13–15] so that our intermixing framework treats the opaque surface DVR as a single rendering stage. This provides sub-voxel precise determination [4] without oversampling as well as simultaneous sampling of all participating volumes on a single ray, which often cause more computational burden.

For intermixing visualization of volumetric and polygonal objects, Levoy [7] introduced a hybrid ray-casting. To render transparent polygonal geometry with volumetric object, Kreeger et al. [23] and Brecheisen et al. [10] suggested iterative ray-casting approach with polygonal rendering while Kainz et al. [24] suggested a deferred ray-casting approach by using previously rendered boundaries (as sorted depth layers) with a GPU optimized method. Those methods are based on a depth-peeling [8] method to read z-buffer of polygonal geometry, which is used in ray-casting. However, as complicated polygonal geometry leads to intrinsic transparency problem [9] which causes unbounded numbers of iterations or storage, the exact intermixing including transparent polygonal object with complicated geometry still remains unresolved problem. So, our proposed work considers limited representation of the transparent polygonal object with a constant size of storage for sorted depth layers and constant number of deferred rendering stage.

In order to achieve high-quality intermixing visualization on intersecting structures, Levoy [7] introduced visibility interpolation based on homogeneous medium for a subset slab's visibility when polygonal boundary intersects a slab. Our proposed method also uses a subset slab (call as subdivided slab or sub-slab) with different visibility interpolation which provides more simply analytic computation as well as better perception of in-slab structure. In addition, this provides anti-aliasing of edges in intersecting surfaces without additional use of edge anti-aliasing [25] and, with our proposed virtual zSlab, this provides a reasonable solution of z-fighting problem in overlapping surfaces.

The proposed multiple-object rendering is a slab-based approach, in which the visibility (i.e., color and opacity) is determined by an optical model describing the transport of light inside a slab filled with a medium. Under the simple emission–absorption optical model [26], the overall fraction of light that penetrates from a given depth t to front depth t
                        0, referred as a transmittance (i.e., 1 – opacity), is given by the following formula:
                           
                              (1)
                              
                                 
                                    T
                                    (
                                    t
                                    )
                                    =
                                    1
                                    −
                                    A
                                    (
                                    t
                                    )
                                    =
                                    exp
                                    
                                       
                                          −
                                          
                                             ∫
                                             
                                                
                                                   t
                                                   0
                                                
                                             
                                             t
                                          
                                          
                                             τ
                                             (
                                             z
                                             )
                                             d
                                             z
                                          
                                       
                                    
                                 
                              
                           
                        where τ(t) is an extinction coefficient function of the medium, and the integrating direction is front to back along a viewing z-direction for the ease of explanation in this paper.

If the emitted radiance at a depth z is 
                           
                              
                                 c
                                 ˜
                              
                              (
                              z
                              )
                           
                        , the total amount of color radiance, C, contributing to the final visibility of the medium is determined by integrating the emitted radiance attenuated by the participating medium from the front depth to the given depth along the viewing direction:
                           
                              (2)
                              
                                 
                                    C
                                    =
                                    
                                       ∫
                                       
                                          
                                             t
                                             0
                                          
                                       
                                       t
                                    
                                    
                                       
                                          c
                                          ˜
                                       
                                       (
                                       z
                                       )
                                       T
                                       (
                                       z
                                       )
                                       d
                                       z
                                    
                                    .
                                 
                              
                           
                        
                     

In this paper, a slab represents a region interval filled with an optical medium (which has homogeneous property in modified version for more continuous and smoother visibility transition), which has sampled visibility. And, thus we can integrate the color radiance across successive slabs as a Riemann sum. The final visibility (associated color [27] or opacity-weighted color [28], and opacity) integrated from the lth to mth slabs, C
                        
                           sum
                        , can be calculated by the discretized version of Eq. (2):
                           
                              (3)
                              
                                 
                                    
                                       C
                                       
                                          s
                                          u
                                          m
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          l
                                       
                                       m
                                    
                                    
                                       
                                          C
                                          i
                                       
                                    
                                    
                                       ∏
                                       
                                          j
                                          =
                                          1
                                       
                                       
                                          i
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          T
                                          j
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          l
                                       
                                       m
                                    
                                    
                                       
                                          C
                                          i
                                       
                                    
                                    
                                       ∏
                                       
                                          j
                                          =
                                          l
                                       
                                       
                                          i
                                          −
                                          1
                                       
                                    
                                    
                                       (
                                       1
                                       −
                                       
                                          A
                                          j
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        Eq. (3) can be evaluated iteratively by performing alpha blending in either front-to-back or back-to-front order. In this paper, we integrate the slabs in a front-to-back order along the viewing ray (for more intuitive description and affordable to the acceleration such as the early-ray-termination) as follows:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   i
                                                
                                                C
                                                =
                                                
                                                   ∑
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   C
                                                   +
                                                   
                                                      
                                                         1
                                                         −
                                                         
                                                            ∑
                                                            
                                                               i
                                                               −
                                                               1
                                                            
                                                         
                                                         A
                                                      
                                                   
                                                   
                                                      C
                                                      i
                                                   
                                                   ,
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   ∑
                                                   i
                                                
                                                A
                                                =
                                                
                                                   ∑
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   A
                                                   +
                                                   
                                                      
                                                         1
                                                         −
                                                         
                                                            ∑
                                                            
                                                               i
                                                               −
                                                               1
                                                            
                                                         
                                                         A
                                                      
                                                   
                                                   A
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Note that in all blending equations and visibility descriptions, we use associated colors.

When a slab has an intersecting surface represented as infinitely thin boundary (e.g., polygonal surface) in it, the slab should be subdivided to correctly visualize the intermixing units (i.e., slab and surface). For fragmented slabs resulting from the subdivision, referred as sub-slabs, it is necessary to determine the visibility of a sub-slab such that the visibility of the original slab is well preserved in its sub-slabs. During this, we try to avoid additional samplings causing performance loss and to provide consistent visibility transition on the interesting position.

Since there is no information on the medium filling a slab, we have to take some assumption for the medium. Assuming homogeneous medium, the extinction coefficient τ at a position in the slab is constant under the simple emission–absorption optical model. Using Eq. (1) and the relationship between transmittance and opacity, the accumulated opacity up to the depth t within a given slab (t
                        =0 at the front z-depth in the slab) is defined as:
                           
                              (5)
                              
                                 
                                    A
                                    (
                                    t
                                    )
                                    =
                                    1
                                    −
                                    exp
                                    (
                                    −
                                    τ
                                    t
                                    )
                                    .
                                 
                              
                           
                        For the slab having the thickness of d and its accumulated opacity of A
                        
                           d
                        , Eq. (5) is rewritten as:
                           
                              (6)
                              
                                 
                                    A
                                    (
                                    t
                                    )
                                    =
                                    1
                                    −
                                    
                                       
                                          (
                                          1
                                          −
                                          
                                             A
                                             d
                                          
                                          )
                                       
                                       
                                          t
                                          /
                                          d
                                       
                                    
                                    .
                                     
                                    (
                                    0
                                    ≤
                                    t
                                    ≤
                                    d
                                    )
                                 
                              
                           
                        Since this is derived from transmittance of homogeneous medium of Eq. (1), opacities of both sub-slabs (i.e., front sub-slab that is closer to the eye and back sub-slab that is far from the eye) can be defined using this equation, presented by Levoy [7]. We call this homogeneous visibility interpolation (HVI). As the color radiance 
                           
                              c
                              ˜
                           
                        , and the extinction coefficient function τ, and material's optical property are constant in homogeneous medium, the associated color of the front sub-slab is derived from Eqs. (2) and (6) with an original slab's visibility, (C
                        
                           d
                        , A
                        
                           d
                        ), as follows:
                           
                              (7)
                              
                                 
                                    C
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          c
                                          ˜
                                       
                                       τ
                                    
                                    (
                                    1
                                    −
                                    exp
                                    (
                                    −
                                    τ
                                    t
                                    )
                                    )
                                    =
                                    I
                                    A
                                    (
                                    t
                                    )
                                    =
                                    
                                       C
                                       d
                                    
                                    ×
                                    
                                       
                                          A
                                          (
                                          t
                                          )
                                       
                                       
                                          
                                             A
                                             d
                                          
                                       
                                    
                                    .
                                     
                                    (
                                    0
                                    ≤
                                    t
                                    ≤
                                    d
                                    )
                                    ,
                                 
                              
                           
                        where I is a medium color that is also an intrinsic color property of the medium, which is computed by 
                           
                              
                                 c
                                 ˜
                              
                              /
                              τ
                              =
                              
                                 C
                                 d
                              
                              /
                              
                                 A
                                 d
                              
                           
                         over the medium.


                        Fig. 1
                         shows two medium interpolation models in terms of the opacity along a ray-segment. The upper plot in Fig. 1 depicts homogeneous medium model that shows three cases of exponential behaviors based on Eq. (6). Assume that the surface intersection occurs at t in a slab and that the front sub-slab ranges from z
                        =0 to z
                        =
                        t (illustrated in Fig. 1). If the slab is filled with a high-opacity medium, the accumulated opacity of A(t) for a front sub-slab gets close to A
                        
                           d
                         (see the red and green lines in Fig. 1). In this case, the front sub-slab with such high opacity blocks the visibility of the back sub-slab and the intersecting medium to contribute to the final visibility, even when its thickness is very small. If the slab is determined by discrete sampling (i.e., ray-casting), this brings about discrete visibility transition over the slab intersection (see Fig. 2
                        ).

In order to visualize the intersecting structures smoothly and continuously even in the opaque slab without such discrete visibility transition, we introduce a new visibility–interpolation approach which makes the accumulated opacity of the front sub-slab increase linearly (see the bottom plot in Fig. 1). Actually, this can be regarded as an approximation model of the homogeneous medium model of Eq. (6). However, with the linear increment behavior of the front sub-slab's opacity and the blending rule for the back sub-slab's opacity, this enables smooth and continuous visibility transition for all kinds of slab-based intermixing.

The front sub-slab's opacity is simply defined in a linear form of the ratio of the sub-slab's thickness to the original slab's thickness.
                           
                              (8)
                              
                                 
                                    A
                                    (
                                    t
                                    )
                                    =
                                    
                                       t
                                       d
                                    
                                    
                                       A
                                       d
                                    
                                    .
                                     
                                    (
                                    0
                                    ≤
                                    t
                                    ≤
                                    d
                                    )
                                 
                              
                           
                        
                     

Exploiting the homogenous property of the material's color intensity and our approximation model of the opacity behavior over a single homogeneous medium, the associated color of the visibility is also defined similarly as in Eq. (8) by:
                           
                              (9)
                              
                                 
                                    C
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          A
                                          (
                                          t
                                          )
                                       
                                       
                                          
                                             A
                                             d
                                          
                                       
                                    
                                    
                                       C
                                       d
                                    
                                    =
                                    
                                       t
                                       d
                                    
                                    
                                       C
                                       d
                                    
                                    .
                                     
                                    (
                                    0
                                    ≤
                                    t
                                    ≤
                                    d
                                    )
                                 
                              
                           
                        
                     

Because the opacity of Eq. (8) is not derived from the strict optics transmittance model, the opacity of the back sub-slab has to be determined in order to make the opacity accumulated across the front and back sub-slabs identical to the accumulated opacity of the original slab for correct visibility. If the opacity of the front sub-slab intersected at the depth position t, having the value of A(t) by Eq. (8), the back sub-slab's opacity A
                        
                           b
                         can be derived from the blending operation of two successive slabs by Eq. (4). Thus, the visibility (associated color and opacity) of the back sub-slab is calculated as:
                           
                              (10)
                              
                                 
                                    
                                       A
                                       b
                                    
                                    =
                                    
                                       
                                          
                                             A
                                             d
                                          
                                          −
                                          A
                                          (
                                          t
                                          )
                                       
                                       
                                          1
                                          −
                                          A
                                          (
                                          t
                                          )
                                       
                                    
                                    ,
                                     
                                    
                                       C
                                       b
                                    
                                    =
                                    
                                       
                                          
                                             C
                                             d
                                          
                                          −
                                          C
                                          (
                                          t
                                          )
                                       
                                       
                                          1
                                          −
                                          A
                                          (
                                          t
                                          )
                                       
                                    
                                    ⋅
                                 
                              
                           
                        Eq. (10) is derived from the modified opacity based on the visibility correction. And the visibility of the original slab is well preserved in its sub-slabs. So, we call the proposed visibility interpolation as opacity-based visibility interpolation (OVI). In OVI, because both of the opacity and the associated color have the same form (Eqs. (8) and (9) for a front sub-slab's visibility and Eq. (10) for a back sub-slab's visibility), the visibility of each sub-slab can be efficiently computed with vector parallel operation in contrast to separate computations for the accumulated color and the opacity as in the HVI.

Regardless of the original slab's opacity, our OVI method enables enough transmittance for the back sub-slab to contribute the intermixing visibility while delivering smoothly increasing visibility contribution across the front sub-slab (see Fig. 2). About the sampling effect, the HVI behavior of the high-opacity slab is similar with the point sampling, which causes moire aliasing artifacts shown in Fig. 3(a). Whereas, OVI provides smooth and continuous visibility transition, which leads to anti-aliasing effects on the high-opacity slabs intersection shown in Fig. 3(b).

In a rendering of polygonal object, a surface geometry is conventionally represented as a z-depth boundary having infinitely thin thickness. Thus, when rendering overlapping and intersecting the surfaces, they contribute to the final visibility in a binary way based on a single z-test, resulting in some rendering artifacts such as randomly alternate dots or jagged lines at the intersecting and overlapping regions.

In order to resolve this problem, we introduce a concept of virtual zSlab which represents the infinitely thin surface boundary as a boundary with finite thickness along a viewing z-direction. Fig. 4
                         illustrates how the virtual zSlabs are constructed for various surfaces along a ray that starts at the camera origin and passes through a single pixel in an image plane. The visual influence of the virtual zSlab derived from virtual thickness appears only in the intersecting or overlapping region of surfaces.


                        Fig. 5
                         explains how the virtual zSlab provides the smooth and continuous visibility transition so that the intersection region exhibits continuous visibility change across thick boundary regions, of which the range is determined by the thickness of virtual zSlab. Virtual zSlabs with larger thickness enables more continuous and smoother visibility transition with anti-aliasing effects.

In Fig. 6(a), the surfaces of a cube and a sphere suffer from jagged lines on intersection based on the conventional z-testing (i.e., single z-test). However, when they are represented with virtual zSlabs, the jagged lines disappear, providing better intersections as shown in Fig. 6(b). One notable thing is that virtual zSlabs with too large thickness introduce over-blurring as shown in Fig. 6(c). To avoid this, the thickness of virtual zSlab should be carefully determined considering rendering conditions (e.g., in most cases, the smallest voxel pitch size is used when the scene includes volumetric object, and in some special cases, user's manually setting thickness is used).

Employing visibility interpolation presented in Section 3.2, each slab is sub-divided by the other slab's front and back depth boundaries. Aligned sub-slabs which share same front and back depth boundaries are supposed to be merged into an output slab sequence.


                        Fig. 7
                         illustrates how two different slab sequences intersect and merge each other. If one slab is intersected with the other slab's depth boundary, the intersected slab is subdivided into two sub-slabs. When there is no overlapping region (see case 1 in Fig. 7), each participating slab composes the output sequence by sorting it in a depth-order. Note that the sorting must be computed according to the slab's back-side depth boundary.

When there is only a partial overlapping region on the side of each slab (see case 2 in Fig. 7), each slab should be subdivided into an overlapping region and the other region. The visibility of each sub-slab can be determined by the visibility interpolation. The overlapping sub-slabs are merged to the fusion sub-slab. Due to the limitation of memory capacity (note that the output slabs are supposed to be stored in the memory), the fusion sub-slab does not need to directly join the output sequence supposed to be stored in buffer memory. Instead, we employ the integrated sub-slab as an element of the output sequence, which merges the foremost sub-slab and the fusion sub-slab. Accordingly, the number of elements of the output sequence is less than or equal to the number of the participating slabs. After generating the integrated sub-slab, the remaining part of the participating sub-slab, called remained ray-segment, is supposed to join the output sequence.

When a participating slab is aligned inside the other slab region (see case 3 in Fig. 7), the slab that covers the other one is supposed to be separated into three pieces of sub-slabs. In this case, the visibility of each sub-slab can be obtained by the iterative interpolation according to the front-to-back direction. The middle one of the sub-slabs and the other participating slab are merged to the fusion sub-slab. With the same merging manner of case 2 of Fig. 7, the output sequence can be obtained.

If there are more than two participating slabs, first two ray-segments are merged into the output sequence, and then the other slab are supposed to sequentially participate in the intermixing with the previously generated output sequence, one by one. Even if this strategy brings about different results according to the participating order of the slabs, this makes the intermixing simple to implement. As long as the final output sequence is obtained, the final visibility is then computed by accumulating with the slabs in the output sequence.

There are many methods to merge the aligned slabs [15,19]. In this paper, we focus on more continuous and natural visibility transition on mixing structures. In order to achieve this, we use the accumulation level intermixing proposed by Cai et al. [17]. This is well suited for our slab-based intermixing since the visibility of slab is determined by illuminated associated-color. The intermixing opacity A
                        
                           mix
                         is calculated to represent the accumulative effect caused by the opacities A
                        
                           i
                         from the aligned overlapping slabs of different slab sequences whose intermixing color intensity I (not associated color) is calculated by normalized sum:
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   A
                                                   
                                                      m
                                                      i
                                                      x
                                                   
                                                
                                                =
                                                1
                                                −
                                                
                                                   ∏
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      A
                                                      i
                                                   
                                                   )
                                                   ,
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   I
                                                   
                                                      m
                                                      i
                                                      x
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         ∑
                                                         
                                                            i
                                                            =
                                                            1
                                                         
                                                         n
                                                      
                                                      
                                                         
                                                            I
                                                            i
                                                         
                                                         
                                                            A
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                         
                                                            i
                                                            =
                                                            1
                                                         
                                                         n
                                                      
                                                      
                                                         
                                                            A
                                                            i
                                                         
                                                      
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         ∑
                                                         
                                                            i
                                                            =
                                                            1
                                                         
                                                         n
                                                      
                                                      
                                                         
                                                            C
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                         
                                                            i
                                                            =
                                                            1
                                                         
                                                         n
                                                      
                                                      
                                                         
                                                            A
                                                            i
                                                         
                                                      
                                                   
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   C
                                                   
                                                      m
                                                      i
                                                      x
                                                   
                                                
                                                =
                                                
                                                   I
                                                   
                                                      m
                                                      i
                                                      x
                                                   
                                                
                                                
                                                   A
                                                   
                                                      m
                                                      i
                                                      x
                                                   
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where n represents the number of overlapping slabs while i represents ith intermixing object.

@&#IMPLEMENTATION@&#

Since the more intermixing slab sequences, the more complicated slab-based intermixing cases, we have to focus on only two intermixing slab sequences by exploiting deferred rendering strategy as multi-pass rendering stages. Each rendering stage has two different slab sequences of which one is an input of previously rendered (or intermixed) slabs and the other one is an output which stores the intermixing slabs. The output is supposed to be sequentially the input of a next rendering stage. The intermixing of two different slab sequences proceeds with a single scanning of an input slab sequence during a traversing of current rendering slabs, which requires only O(N
                        +
                        M) complexity (M is the number of slabs in the input slab sequence and N is the number of current rendering slabs). Also, this provides simpler implementation and better optimization especially in GPU with limited branch operations and resources.

As our implementation scheme considers only two overlapping slabs in a single rendering stage and both slabs can be complete transparent (zero opacity) which leads to dividing by zero in Eq. (11), we use the modified formula using bidirectional blending and averaging for the associated color of the intermixing visibility, C
                        
                           mix
                        , as follows:
                           
                              (12)
                              
                                 
                                    
                                       C
                                       
                                          m
                                          i
                                          x
                                       
                                    
                                    =
                                    
                                       C
                                       1
                                    
                                    +
                                    
                                       C
                                       2
                                    
                                    −
                                    
                                       1
                                       2
                                    
                                    (
                                    
                                       C
                                       1
                                    
                                    
                                       A
                                       2
                                    
                                    +
                                    
                                       C
                                       2
                                    
                                    
                                       A
                                       1
                                    
                                    )
                                    ,
                                 
                              
                           
                        where C
                        1 and C
                        2 are associated color of each overlapping slab's visibility.

However, we have to consider priority of rendering objects because the final visibility is not invariant if intermixing order of high opacity objects changes. It means higher opacity and prior rendered object contributes more to the final intermixing visibility than lower and posterior ones do. Even with this limitation, our implementation scheme has a dominant advantage which enables flexible and simple intermixing. Also, based on our proposed OVI, the operations for the visibility interpolation on intersecting slabs are efficiently implemented by using parallel instructions.

A slab consists of back-side boundary depth (float type), thickness (float type), and non-zero visibility (RGBA, optional for byte channels or float channels). The size is 12 bytes or 24 bytes per slab. Each pixel on a frame-buffer stores such a slab sequence that the next rendering pass is able to use the slab sequence. As the storage size of a pixel is limited, the number of slabs has to be reduced. So, if there are several slabs over a pixel capacity, we integrate the posterior slabs to the last slab.

The proposed intermixing pipeline consists of three rendering phases to combine different rendering techniques. This is based on the buffer-based approach that the result of each rendering pass is used as an input of the next rendering pass similar to deferred rendering approach [13]. Fig. 8
                         depicts a high-level overview of our intermixing pipeline representing the three processing phases; (1) polygon rendering, (2) rearranging slabs with intermixing, and (3) volume rendering with intermixing.

In order to store the result of each rendering pass, we employ two types of frame buffer:
                           
                              •
                              RTT is a render-target-texture that stores the slab information of a surface per pixel through a single polygon rendering pass. RTT buffer consists of M number of RTTs, which means that a pixel consists of M number of slabs.

A pixel on OSS buffer stores the ordered slab sequence described as an output sequence. The pixel consists of N number of slabs.

Because OSS-buffer is used not only as an output of the current intermixing but also as an input of the next intermixing, two of OSS-buffers should be allocated in GPU implementation. We exploit the ping–pong strategy [32] to efficiently use OSS-buffer in the intermixing pipeline without additional allocation regardless of the number of rendering stages. Therefore, each pixel in the frame buffer requires (N
                        ×2+
                        M)×
                        size
                        
                        of
                        (slab) bytes in the entire intermixing pipeline.

In the polygon rendering phase, every polygon object calls L times of rendering passes, so that L number of transparent surfaces are stored into RTT-buffer by using dual-depth buffer scheme [8]. At every M times of polygon rendering passes, which implies that there could be pixels filled up with slabs in RTT-buffer, the slabs are to move into the OSS-buffer while sorting them in depth-order and removing the overlapping region (which is the rearrangement phase). Then, RTT-buffer is cleaned and recycled in the polygon rendering phase.

In the volume rendering phase, every volume object calls a single ray-casting pass, which includes the intermixing. Each sampling step during ray-casting generates a slab that is sorted in depth-order and has no overlapping, so that the rearrangement operation is not required. If volume rendering is the final rendering pass, the intermixing had better be performed during ray-casting, referred as on-the-flying intermixing. Otherwise, the volume rendering result is also stored in OSS-buffer with intermixing, referred as deferred intermixing.

@&#EXPERIMENTAL RESULTS@&#

All experiments were performed on an Intel i7 PC with a 3.2GHz Quad-core processor and 16GB of main memory. The system was also equipped with an NVIDIA GTX 580 GPU with 1.5GB of memory. The proposed intermixing pipeline including various types of renderings with our intermixing method was all accelerated by GPU programming using Direct3D 11 graphics API with HLSL shader model 5.0. All renderings were performed on 512×512 resolution of frame-buffers.

Considering a constant number of read-back buffers and its performance tradeoff, in this paper, we set the polygon rendering phase to treat four foremost transparent surfaces for each polygonal object model. The volumetric objects were rendered using a pre-integrated volume rendering [29] based on ray-casting. In addition, for high-quality iso-surface representation, all the ray-casting for a single volume adopted the surface refinement method [4,13] with 10-bisectional intersection. Also, our DVR employed the optimization techniques using block-based empty space skipping and early ray termination [30].

We already described how the effect of the visibility interpolation appears comparing HVI and OVI according to two intermixing scenarios: (1) infinitely thin surface intersecting high-opacity slabs, (2) two different high-opacity slabs overlapping together. As low-opacity slab guarantees enough transmittance of its sub-slabs and has little difference between Eqs. (6) and (8), we focused on the high-opacity slab intermixing scenario to show clear difference between HVI-based and OVI-based intermixing (see Figs. 2 and 3).

As described in Section 5.2, our intermixing pipeline is able to represent several transparent polygon models (without volumes) via the polygon rendering phase and the rearrangement phase using RTT-buffer and OSS buffer. Fig. 9
                         shows the intermixing result employing the virtual zSlab effect which is a novel feature of out intermixing method.

Our proposed intermixing pipeline can be used for the multi-volume direct volume rendering (MDVR) based on the deferred rendering approach (of course, our slab-based intermixing method is also available in the conventional multi-volume rendering but we focus on the deferred intermixing approach, proceeding the volume rendering, one-by-one). As the prior volume rendering fulfills the deferred intermixing and the final volume rendering fulfills the on-the-fly intermixing, a volume with more complex structures has to run the final volume rendering. Fig. 10
                         shows the comparison result of MDVR. Fig. 10(a) is performed based on the conventional MDVR, which is reference in this test. And, as the ellipsoid structure has smaller number of transparent layers, we choose the cube volume rendering as the final volume rendering supposed to run the on-the-fly intermixing (see Fig. 10(b)–(d)). More number of slab elements enables more accurate representation of overlapping structures (see Fig. 10(b) and (c)). As 4 elements OSS is able to represent enough transparent layers and fuzzy surface in the first volume rendering, Fig. 10(d) also shows the best quality image among our results. With similar manner of OSS-buffer and slab elements, our intermixing pipeline is able to represent several transparent.

It is attributed to the fact that the conventional MDVR does not refine the intersecting position of the objects (i.e., surface refinement) sampling the participating volumes at the same sampling position at each sample step. And, our slab-based intermixing method enables smooth and continuous visibility transition on intersecting regions. The visualization effect can be often identified in high zoom-in cases to see detailed parts of the intersecting structures. For the simple test, we set two of high-opacity volumes with low resolution voxels (see Fig. 11
                        ). Note that our deferred intermixing approach enables various optimization techniques (i.e., surface refinement, empty-space-skipping and early-ray-termination) to be easily applied to each volume rendering in contrast to the conventional MDVR. Fig. 11(b) shows severe aliasing artifact over the intersecting region. Fig. 11(c) well represents the intersection region as good as the supersampling result, Fig. 11(a).

The renderings of maxilla (i.e., upper jaw) stitched from two dental CT scans in Fig. 12
                         also show the similar case that MDVR exhibits the severe artifact at the stitching intersection of the two CT scans, while our method provides much better stitching intersection.

To evaluate further the quality of the proposed method, we describe some specific case studies based on our intermixing scheme. Fig. 13
                         shows the rendering of volumetric objects along with superimposed MPR (Multi-Planar Reconstruction) planes (one of planes is used for volume clipping plane) and additional polygonal widgets. In these renderings, CT volume datasets were rendered as opaque surface DVR clipped by one MPR plane. As shown in Fig. 13(a), the conventional DVR and surface rendering based on the single z-test exhibits severe jaggy artifacts in the intersection due to the binary-way visibility decision. Moreover, as different surfaces share a same plane (clipping MPR plane, clipped volume plane, and additional 3D widgets), alternate dots as well as randomly occluded structures appear by z-fighting (i.e., depth-fighting) [31]. By exploiting our proposed virtual zSlab and slab-based intermixing scheme, the anti-aliased intersections are achieved as well as alternate visibility artifacts by z-fighting are removed. Therefore, the important visibility of overlapping structures such as the CT's clipping plane in Fig. 13(b) and (c) can be well represented. When high opacity object goes through our deferred intermixing pipeline, which includes more than two intermixing stages with the HVI, discontinuous visible bands (as undesirable visibility error) on intersecting surfaces appear as shown in Fig. 13(b). Our OVI resolves this problem with more continuous and smoother visibility transition, delivering higher-quality and more natural visualization of in-slab structures in Fig. 13(c).

Our intermixing approach can be used in the visualization of attributed volumes with original volume [4,15]. Since each attributed volume can be represented as opaque surface in an independent rendering stage, we do not have to consider sampling of all participating volumes in a single ray-casting, which causes oversampling [11] as well as complex computation of overlapping volume boundaries [20,21]. Using the proposed virtual zSlab, the surface with virtual zSlab inside the original volume can be intermixed by the slab-based intermixing as shown in Fig. 14
                        . Our proposed OVI with the linear interpolation model provides more continuous and smoother visibility intermixing at the intersections and overlapping surfaces, delivering higher-quality and more natural visualization as shown in Fig. 14(c) compared to that based on HVI with the exponential interpolation model shown in Fig. 14(b).

In addition, by exploiting virtual zSlab with manually defined thickness, our intermixing approach can be extended to visualize occluded objects with opacity-derived depth cues. Fig. 15
                         shows an original CT object and its segmented objects, which were represented as polygonal objects. To show each segmented objects, which are occluded, Fig. 15(a) uses transparent DVR with on-the-fly intermixing method while Fig. 15(b) uses high opacity DVR with slab-based intermixing method based on the virtual zSlab, which has user defined thickness. With the OVI, the slab-based intermixing provides more comprehensive depth cue with more natural opacity change compared to that with HVI. This intermixing scheme is well suited for representation of occluded objects while providing the outmost structure without fully traversing of volume on ray-casting which brings severe sampling burden. Fig. 16
                         shows that our intermixing method works well with a variety of transparency and thickness of virtual zSlab. Our virtual zSlab model is able to enhance the visual perception of overlapping surfaces while preserving main structure's depth cues (see Fig. 16b).

For the performance evaluation of the computational efficiency, we measured three types of processing time. First, renderings preparation time is measured for read-back buffer operations and entire setting of meta information without rendering objects while still preserving rendering stages. Second, intermixing rendering time is measured for the entire objects renderings including slab-based visibility intermixing operations. Finally, independent rendering time is measured as the summation of each independent object rendering without intermixing (thus, there is no slab-based visibility intermixing operations). These two time measurements do not include renderings preparation time.


                        Fig. 17
                         plots each rendering time of our experiments described in Figs. 13–15. The more rendering stages, the more renderings preparation time especially in volume rendering which needs more read-back operations than raster-based polygon rendering. Because current graphics hardware has high enough memory bandwidth to efficiently support the read-back operations, the number of rendering stages (experimented in this paper) does not bring severe overhead to disturb real-time rendering. Preferably, this deferred rendering approach enables flexible optimizations for each object rendering while delivering higher performance and quality. Considering our experimental results, we can figure out that our intermixing operations do not bring severe overhead compared to entire independent rendering without intermixing operations. Even in most cases, because of ERT made up for our intermixing overhead by skipping shader process, some results show faster performance than that of independent rendering, which has no occlusion by other objects.

To experiment for our slab-based intermixing overhead in details, we take multiple transparent boundaries and slab sequences of transparent ray-casting without ERT into our intermixing pipeline. To do this, we used transparent superimposed MPR planes as an input slab sequence and highly transparent DVR for the full traverse of the entire volume. Fig. 18
                         depicts this experiment. Since there is no ERT, we can easily measure the time of slab-based intermixing operations by subtracting each rendering time and rendering preparation time. Fig. 19
                         shows that the overhead of slab-based intermixing operations increases with the number of intermixing slabs (i.e., superimposed MPR planes). When there are small number of read-back buffers (up to 7 planes in our experiment), we can ignore the overhead of slab-based intermixing overhead. However, when there are more than ten read-back buffers, the read-back operations bring considerable overhead because the operations work with a large set of texture memory, which causes low cache efficiency due to a sampling overhead.

As our implementation is based on GPU, it is important to fit all the intermixing objects inside GPU's dedicated memory to avoid memory swapping, which leads to serious performance loss. By exploiting our deferred rendering approach which treats each intermixing object independently, there could be additional optimization for efficient storage such as uploading of only available volume blocks or volume sampling without inflating of low resolution volume. This keeps memory consumption at acceptable levels while preserving efficient and flexible implementation.

However, this requires additional memory since read-back buffer stores the previously rendered information defined with visibility and depth of each boundary. Each visibility and depth uses 4 bytes per pixel and, with multiple read-back buffers for transparent boundary, we used 8N bytes per pixel (N is the number of transparent depth boundaries) as additional required memory. Fig. 18(f) with 512×512 resolution of frame-buffer requires 62MB for the output of superimposed MPR rendering stage as well as the input of transparent DVR and 1MB frame-buffer for the final rendering output. If there is an additional opaque rendering stage such as raster-based polygon rendering or opaque surface DVR, we have to use an additional read-back buffer for single opaque boundary (2MB).

This section presents the application examples of the proposed method for the rendering of various multiple objects in real clinical applications. Our method can be easily adopted into a multiple-object rendering framework without any severe modification of the built-in rendering technique of the framework. We applied the proposed method to two real applications for the rendering of heterogeneous medical datasets.

MPR is used to generate a 2D image showing the exact intra-structure of a volumetric scan data. In the practical usage, this MPR image is often required to be superimposed on the 3D DVR image of the scan data. For an accurate superimposition, both the MPR image and the DVR result should be inter-mixed in a correct z-depth order, not by just blending those two images.


                           Fig. 20
                            shows the intermixing result of an MPR image (regarded as a polygonal object with a single transparent surface in our method) and the visible human CT scan data. Fig. 20 also demonstrates the scenario that the advantage of our method becomes apparent. Our two-phase rendering method is very helpful when adjusting the visibility of individual data. For example, if the deferred intermixing is available (the OSS-buffer is able to contain enough slabs sequence or the geometry is simple), when users adjust the window level and width of the MPR image or the transfer function (TF) of the CT data, we just have to render the newly adjusted data while reusing the virtual zSlab buffer of the unchanged data.

In medical field, in order to take the full advantage of their diagnostic ability of individual scanning devices, multimodality datasets such as CT–PET, MR-CT, and MR-SPECT are examined simultaneously in the clinical practice. These multimodality datasets are typically registered prior to 3D rendering, and they are then rendered simultaneously for a diagnosis.

When rendering those multimodality datasets (e.g. CT–PET), users often change the transfer function (TF) of one dataset for more accurate diagnosis. In the conventional MDVR, the two datasets of CT and PET should be rendered simultaneously whenever users change the TF of the CT dataset only. In contrast, with our method, each dataset can be rendered independently and then be intermixed. Fig. 21
                            shows CT–PET multimodal visualization in which users adjust the TF of the body CT data (see the dotted rectangular region) to find the TF desired, and then intermix the CT data with the PET data already rendered. Fig. 22
                            also shows CT-PET (one CT and two PET) multimodal visualization example. Comparing to the conventional MDVR (Fig. 22(a)), our deferred intermixing approach provides acceptable results even if there might be some information loss of intersections.

@&#CONCLUSION@&#

In this paper, we proposed a novel intermixing scheme to improve the intermixing quality on overlapping and intersecting surfaces while maintaining real-time performance. This can be a reasonable solution to overcome aliasing intersection edges and z-fighting, which were conventional problems of fusion rendering of multiple objects. In addition, this provides special advantages in the case of intermixing with occluded objects as shown in Figs. 12 and 13. This provides flexible implementation in term of optimization complexity.

When the proposed method is adopted into real applications, it exhibits additional outstanding advantages as demonstrated in the case studies. As our method involves three phases of the individual object rendering and then the intermixing, individual objects can be rendered independently by using their own optimized visualization technique without being forcefully integrated in a single rendering pipeline. Moreover, as our method is a buffer-based method (or deferred rendering approach), the slab information stored in OSS-buffer can be reused as necessary. Those two advantages of the rendering independency and reusability are very profitable when building an interactive multiple-object rendering framework.

Since our proposed slab-based intermixing scheme is for two different slab sequences, this could be easily extended into two-volume ray-casting without alignment of each sample step (as a conventional MDVR approach) which causes oversampling (with global surface refinement). However, if there are two more volumes, we should take additional cares for optimal implementation of slab-based intermixing of several slab sequences. In the future work, we might be able to cope with the transparent MDVR by using advantages of our proposed slab-based intermixing method.

@&#ACKNOWLEDGEMENTS@&#

This research was partly supported by Basic Science Research Program through the National Research Foundation of Korea (NRF) funded by the Ministry of Science, ICT and future Planning (No. 2014R1A2A2A03002574). And this work was partly supported by the Industrial Strategic Technology Development Program (No. 10047039, Development of the real-time inspection SW and reverse engineering SW based on multiple 2D x-ray images and CT images) funded by the Ministry of Science, ICT and Future Planning. And this work was partly supported by the Seoul National University Bundang Hospital Research Fund (No. 13-2014-001).

@&#REFERENCES@&#

