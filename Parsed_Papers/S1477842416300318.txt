@&#MAIN-TITLE@&#Ann: A domain-specific language for the effective design and validation of Java annotations

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Ann is a domain-specific language for the design of dependent Java annotation types.


                        
                        
                           
                           It allows to design explicitly the constraints in the conceptual model behind them.


                        
                        
                           
                           The consistency validation of the constraints is performed using model finding.


                        
                        
                           
                           Automatic code generation enables validation of the annotations at compile time.


                        
                        
                           
                           Ann was tested in a real use-case of JPA annotations, obtaining successful results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Model driven engineering

Domain-specific languages

Code generation

Java annotations

Model finders

@&#ABSTRACT@&#


               
               
                  This paper describes a new modelling language for the effective design and validation of Java annotations. Since their inclusion in the 5th edition of Java, annotations have grown from a useful tool for the addition of meta-data to play a central role in many popular software projects. Usually they are not conceived in isolation, but in groups, with dependency and integrity constraints between them. However, the native support provided by Java for expressing this design is very limited.
                  To overcome its deficiencies and make explicit the rich conceptual model which lies behind a set of annotations, we propose a domain-specific modelling language. The proposal has been implemented as an Eclipse plug-in, including an editor and an integrated code generator that synthesises annotation processors. The environment also integrates a model finder, able to detect unsatisfiable constraints between different annotations, and to provide examples of correct annotation usages for validation. The language has been tested using a real set of annotations from the Java Persistence API (JPA). Within this subset we have found enough rich semantics expressible with Ann and omitted nowadays by the Java language, which shows the benefits of Ann in a relevant field of application.
               
            

@&#INTRODUCTION@&#

In 2004 the possibility of adding custom meta-data to programs was added to the Java language in the form of annotations.
                        1
                     
                     
                        1
                        
                           http://docs.oracle.com/javase/1.5.0/docs/guide/language/annotations.html
                        
                      Predefined annotations were available previously for very specific tasks, however, the huge amount of boilerplate code that many Application Programming Interfaces (APIs) required motivated their establishment as another general tool in the language. Schildt [33] suggests other reasons as motivation to the appearance of annotations in Java: the increasingly growing tendency of including the meta-data associated with a program within the program itself instead of keeping it in separate files; and the pressure from other programming languages which already included similar features, like C#.

Since their introduction in the language, annotations have become a success and are widely used in many important projects within the software development scene. We find them in frameworks like Seam
                        2
                     
                     
                        2
                        
                           http://docs.jboss.org/seam/latest/reference/html/annotations.html
                        
                      and Spring,
                        3
                     
                     
                        3
                        
                           http://spring.io/
                        
                      in the Object Relation Mapping of Hibernate,
                        4
                     
                     
                        4
                        
                           http://hibernate.org/orm/
                        
                      and also in proper Sun Java standards such as the Java Persistence API (JPA).
                        5
                     
                     
                        5
                        
                           http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html
                        
                     
                  

However, despite this success, the native support that Java provides for their construction is very poor. This is so as Java annotations are not defined using a specialised syntax, but reusing the syntax to create interfaces. This lack of specialised syntax greatly limits the ability to specify the elements where an annotation can be placed and further correctness conditions. Moreover, annotations are rarely conceived in an isolated way; instead they are usually part of a set with dependencies and integrity constraints. Currently there is no effective way in Java for making explicit the constraints underlying a set of annotations at design time, and validate that they are not conflicting. Instead, the usual path taken to overcome these deficiencies is to develop an extension to the Java compiler (called annotation processor) to ensure that such constraints are complied with, and rely on extensive manual testing of such processor.

As a first step towards the alleviation of this situation, we propose Ann, a textual Domain-Specific Language (DSL) [36] aiming to provide a more expressive and suitable syntactic support for the design of sets of annotations and their associated integrity constraints. We have developed an Integrated Development Environment (IDE) as an Eclipse plug-in, which integrates seamlessly with the Java IDE. The environment includes a code generator to translate the design and constraints expressed using Ann into Java code, which can be fully integrated into projects in such language. Moreover, Ann makes use of a constraint solver over models (a model finder [25]), which is able to detect whether the constraints posed by a set of annotations are unsatisfiable, and provide examples (annotated class mock-ups) of usages of the annotations. These examples could be used by designers to validate whether the encoded integrity constraints defined with Ann are according to their intentions. Ann has been tested using a real set of annotations from JPA, demonstrating that it can capture a wide set of the constraints in its specification, and showing advantages with respect to other approaches with similar goals in the state of the art. More information and the source code of the project can be found at http://irenecordoba.github.io/Ann.

This paper is an extended version of [6,7], where we have added validation mechanisms based on constraint solving, and integrated such mechanisms with the environment. Additionally, all sections have been enlarged with additional explanations and more details.

The rest of the paper is organised as follows. Section 2 analyses related work. Section 3 gives a more detailed overview on the current limitations of Java annotations. Section 4 introduces the main concepts of Model-Driven Engineering (MDE) and the different choices when building a DSL. Section 5 provides an overview of our approach. Section 6 describes the proposed DSL, Ann. Section 7 explains our approach to validate annotations. Section 8 contains the evaluation of Ann, including a detailed real case study and an evaluation of the efficiency of the model finder for annotation validation. Finally, Section 9 summarises the conclusions and future development. Two appendices detail the description of the textual concrete syntax of Ann, and the generated OCL invariants for the JPA case study.

Some research has been made in order to improve and expand the functionality of Java annotations. For example, Phillips in [28] aims at conciliating object oriented principles with the design of annotations by the introduction of a new one: composite. With it, he manages to support composition, allowing encapsulation and polymorphism of annotations.

A Java extension, @Java, is proposed by Cazzola and Vacchi [4] in order to expand the range of application of an annotation to code blocks and expressions, although some improvement in this respect has also been made natively in the latest version of Java.
                        6
                     
                     
                        6
                        Java 8 at the time of writing.
                     
                  

The expressiveness limitations of Java annotations are recognised in [5], where a proposal is made to embed DSLs into Java, with a more natural and flexible syntax. JUMP [1] is a tool to reverse engineer Java programs (with annotations) into profiled UML class diagrams.

Although the aforementioned approaches expand the features of Java annotations, they do not facilitate their design, nor address the limitations with respect to expressing integrity constraints within an annotation or between the annotations in an annotation set, which is the main goal of our work.

Just a few works are aimed at improving the design of annotations. Darwin [11] suggests a DSL, called AnnaBot, based on claims about a set of existing annotations, with a concrete syntax very similar to Java. With these claims, interdependency constraints can be expressed within a set of annotations. However, there is no possibility of characterising the valid targets of an annotation type (i.e., the valid elements in a program where the annotation can be placed). Moreover, no improvement is made with respect to the syntax for defining annotations in Java, given its heavy focus on existing sets of annotations and constraints between them, and not on isolated ones. Finally, the approach uses reflection to check the statements of its claims, which could and should be avoided.

Another approach is AVal [27], a set of meta-annotations (annotations which are placed at other annotations) to add integrity constraints at the definition of the annotation type. The drawback of this approach is that its expressiveness is rather restricted, given the limited flexibility which the structural characteristics of meta-annotations provide.

Pluggable type systems [2] provide a way to support improved analysis of programs by ensuring stronger type checking. Implementation of these systems exist for Java, like the JavaCOP framework [26]. Java 8 improves the support for such systems via type annotations. Pluggable type systems provide a customised semantics to sets of programming elements via the use of annotation sets. However, they normally do not provide a unified way to describe and validate the syntax and integrity constraints of a set of annotations.

Regarding constraint validation, constraint solving strategies are extensively used in connection with program testing [13]. Many times, constraint solving is used as a means to generate interesting test data for programs, perhaps derived from specifications [19], or making the program execute a certain path [8]. In [21] constraint solving is used to generate both test cases and mock-up classes, considering advanced features like reflection and annotations. Hence, while they can generate mock-up programs with annotations, they need to derive the needed constraints from the analysis of reflective Java code (i.e., at runtime), with the consequent loss of precision and drawbacks of runtime checking. Instead, for our purposes, it would be more desirable to have a language making explicit the annotation constraints at design time, which then can be analysed before such annotations are used.

Hence, as we have observed, there is currently a need for: (i) better syntactical support for the specification of Java annotations; (ii) explicit, high-level means to describe constraints for an annotation (e.g., regarding its valid targets), and between a set of annotations (e.g., expressing their dependencies); and (iii) ways to analyse such constraints to find inconsistencies, at design time. For this purpose, in the rest of the paper, we describe Ann, a DSL directed to describe both the syntax and well-formedness constraints of annotation families, to validate the correctness of the annotation constraints and to make explicit the design of such annotation set, allowing their immediate use on Java projects thanks to the code generation facility.

To help understanding the current limitations of Java annotations, in this section we describe how they are defined in Java (Section 3.1), their usage and limitations (Section 3.2) and how their correct use is checked (Section 3.3).

Java annotations do not constitute a type of their own. Instead, they are defined as special interfaces. There are many differences between annotations and interfaces, however we will only review those necessary to understand the design of Ann.


                        Listing 1 shows an example of the definition and usage of a simple annotation called Person. Such annotation definition is called an annotation type. As it can be noticed, the special nature of annotations is indicated by the @ character before the interface keyword (line 7). The zero-argument methods inside the container (lines 7–9) are the fields (the parameters) of the annotation. To assign a default value to those fields, the keyword default must be used. An annotation can have an arbitrary number of fields, which can be of primitive type, Class, String, an annotation type, or an array of the previous types. 
                           Listing 1
                           Annotation Person defined in Java. 
                                 
                              
                           

Since the goal of annotations is to add meta-data to Java programs by being placed at certain elements, it is important to know which elements are eligible as their targets. Annotations can be employed in the declaration of many constructions in Java; however with Ann we have focused on the most usual ones, namely types (classes, interfaces, enumerates, annotations), constructors, methods and fields.
                           7
                        
                        
                           7
                           Ann was started before the official release of Java 8, and hence some of its feature regarding annotations, like the possibility of defining type uses as targets is not currently supported, but left for future work.
                        
                     

Another important characteristic of annotations is that they can have three different levels of retention, which depends on the phase where they will be used: in the source code (they are discarded by the compiler); compiled but ignored by the Java Virtual Machine (JVM); and compiled and read by the JVM when the type that contains them is loaded. The last ones are accessible by the Java Reflection API at runtime, which can check the values in their fields.

Both the targets allowed for an annotation and its desired level of retention can be specified at design time by using the standard Java meta-annotations Target and Retention, respectively. As we will see in the next subsection, the former is very poor regarding its expressive power with respect to real and common use cases where annotations are used.


                        Listing 2 shows the use of the defined Person annotation. Annotations are considered as modifiers when using them on a target in Java. This is why, although in Listing 2, line 3, annotation Person appears above the class, it could perfectly be merged with the rest of the modifiers, but the former is the usual syntax. 
                           Listing 2
                           Usage of the annotation Person. 
                                 
                              
                           

Pairs key=value are used in order to specify the values of the fields of the annotation. It is mandatory to set a value for all the fields that do not have a default value predefined on the annotation type, and the order of the fields does not matter.

Traditionally only one instance of a particular annotation type could annotate a target; however with Java 8 it is possible to use several such instances if the corresponding annotation type is properly marked on its definition.

Line 5 of Listing 1 shows another example of an annotation being used: Target. In this case, the value is directly specified because the annotation has only one field and it is named value. By using the value TYPE of the enumeration ElementType, Person is restricted to be applied to classes, interfaces (including annotation types) and enumerations. However, there is no way to e.g., restrict its applicability to classes only.

We have presented a very simple example of an annotation type, but if we take a look at the JPA documentation, particularly the extensively used Entity annotation, we find that it can only be applied to classes meeting the following more elaborated requirements
                           8
                        
                        
                           8
                           
                              http://docs.oracle.com/javaee/7/api/
                           
                        :
                           
                              •
                              They must have a public or protected constructor.

They must not be final.

They must not have any final method.

Their persistent fields must be declared private, protected or package-private.

None of these constraints can be expressed nowadays with the syntax available for the definition of annotation types.

What is more, when designing annotation sets, it is common to have constraints involving several annotations, because the annotations are usually inter-related. For example, the JPA annotation Id is only allowed in attributes within classes annotated with Entity. We call such constraints the static semantics or integrity constraints of an annotation, or an annotation set. Given a large and complex set of requirements for an annotation set, it is easy to make mistakes, by requiring conflicting features from the different annotations, specially at design time. Just for the sake of illustration, if we require Id to be applicable on a public attribute, then it would make the Id annotation to be in conflict with Entity (as the latter requires non-public attributes), and hence inapplicable.

Therefore, what can be done to ensure the compliance of such outlined constraints and ensure their validity? The only remaining choices are to write a guiding comment for its use and signal an error at runtime. In addition, it is possible to develop extensions to the Java compiler, known as annotation processors, and rely on their extensive manual testing to validate that the annotation requirements are met by their implementation in the processor. In the next subsection we review these annotation processors, since they are one of the key components of Ann.

The Java package javax.annotation.processing provides a set of elements for processing annotations at compile time. An annotation processor is invoked by the compiler, and it can check the annotations attached to any program element, performing an arbitrary task. Typically, the processor will check the correctness of the annotation placement (i.e., its static semantics), and may perform further actions (e.g., generating code). Annotation processing works in rounds. In each round a processor may be required to process a subset of the annotations found in the source code and the binary files produced in the prior round. If a processor was executed in a given round, it will be called again in the next rounds.


                        Listing 3 shows the structure of a typical annotation processor. Line 1 specifies the annotation to be checked, Person in this case. The key method of the processor is process (lines 5–23), where the elements annotated with the particular annotation are looked up and checked. If any of them does not satisfy the checks, then an error is raised using the functionality provided by the processing package (lines 15–20). 
                           Listing 3
                           Structure of an annotation processor. 
                                 
                              
                           

It is important not to confuse annotation processing with reflection. While the former takes place at compile time, the latter is at execution time. The values of an annotation at a given program element can be checked at execution time via the Java Reflection API (if the annotation type is properly marked, as explained in Section 3.1), but it has several disadvantages, like an overhead in performance, the requirement of runtime permission (which may not be granted), and the possibility of breaking object-oriented abstractions.

In the context of checking the correctness of annotations, it is more appropriate to do it via annotation processors, because they can find and signal the errors without the need to execute the program. However, coding and testing such processors is tedious, cumbersome and error prone. It requires long cycles for coding, installing the processor, and testing. Moreover, we believe it would be advantageous to make explicit the underlying annotation constraints at a higher level, together with the annotation structure. In addition, this would facilitate the analysis of annotation conflicts at design time, with no need to install the processor to make those tests. For this purpose, we have created Ann, a DSL to define the structure and integrity constraints of Java annotations, and validate their correctness.

For the development of Ann we have followed what is called Model-Driven Engineering (MDE) [3,10], which is characterised by the use of models as the main component of the development process. A model is a simplified or partial representation of reality, defined in order to carry out a specific task or reach an agreement on some matter. A great advantage of MDE is that it fills the communication gap between the requirements and analysis phase and the implementation phase in a software project.

Modelling languages are extensively used in MDE, and are conceptual tools to describe reality in an explicit way, at some level of abstraction and from a certain point of view. They are composed and defined by three key elements:
                        
                           •
                           
                              Abstract syntax: It describes the structure of the language and the way in which the different elements can be combined.


                              Concrete syntax: It describes the particular representation of the modelling language, covering features such as the codification or visual appearance, and hence it determines how users visualise or create models. It can be graphical [24,29,32] or textual [36,14].


                              Semantics: It describes the meaning of the language elements and also the meaning of the different ways of combining them.

Modelling languages can be classified depending on their domain of application. A Domain-Specific Modelling Language (DSML) is a modelling language designed for a specific domain or context, with the purpose of easing the task of describing the elements in such domain. In contrast, General-Purpose Modelling Language (GPML) can be applied to a much broader context. This distinction is not always easy to draw as it depends on what we consider as a domain (e.g., we could consider the general problem of modelling as a specific domain).

Given that models play a key role in MDE, and they constitute an abstraction of the real world, a natural step is to represent them as instances of higher levels of abstraction, i.e., higher levels of models or meta-models. Consequently, using this definition, meta-models describe the set of models considered valid. They define the abstract syntax of a modelling language, since they are a way of describing all the types of models that can be represented with such language. We could iterate this abstraction levels and obtain meta–meta-models and so on. However, in practice, it has been shown that meta–meta-models are enough to describe themselves (see Fig. 1
                     ) [3].

The two main alternatives for defining the semantics of modelling languages are code generation and model interpretation [20]. They can be thought of as the analogous for compilers and interpreters in the case of programming languages, respectively. A code generator can be thought of as a model compiler that generates executable code from a high level model in order to create a functional application. This generation of code is usually done by using template languages like Acceleo
                        9
                     
                     
                        9
                        
                           http://www.eclipse.org/acceleo/
                        
                      or the Epsilon Generation Language [31]. On the other hand, model interpretation is based on implementing a general tool that translates and executes the model on the fly.


                     Fig. 2
                      shows a feature model [23] summarising the possible choices when designing a modelling language. The diagram is not meant to be exhaustive, but to gather the most common and typical choices. In the first place, a language can be designed taking as a basis a GPML, or a general purpose programming language. Using a GPML like the UML, one can design a profile [15], with stereotypes annotating the different UML elements and providing domain-specific concepts. This is the approach taken by JUMP [1]. A DSML can also be embedded in a general purpose programming language (the so-called internal languages). The flexible syntax and dynamic features of languages like Ruby make them especially amenable for this task [9]. Alternatively, one can use a GPML “as is”, but then domain-specific concepts have to be expressed as conventions (e.g., naming conventions), programming idioms, or remain at the level of APIs in the case of general purpose programming languages.

The alternative is the definition of a DSML independent of a base GPML. These are called external DSMLs. To define the abstract syntax, a meta-model can be used, as previously explained. While this is the standard choice when using MDE, it is not the only alternative. For example, it is possible to define a (Chomsky) grammar instead (especially if the language has a textual concrete syntax) [36], or a graph-grammar that defines the set of admissible models [16]. Deciding between graphical and textual concrete syntax is not exclusive, and there are languages featuring both [18]. Finally, interpretation and code generation are normally alternative choices. The figure shows in colour the choices made for Ann, whose rationale will be explained in Section 6.

Since the goal of Ann is to make explicit the conceptual model behind a set of annotations, using a modelling language is a robust choice, because that is what they are precisely designed for. We have decided to restrict the domain to Java annotations, and that is why we have developed a Domain-Specific Language (DSL).


                     Fig. 3
                      shows the working scheme of our approach to solve the problems outlined in Section 3 by using the DSL. The main idea is to describe the syntax and static semantics of the family of annotations to be built in a declarative way (label 1 in the scheme). The Ann DSL provides appropriate primitives for this task, beyond those natively offered by Java.

We have incorporated a model finder in our approach, in order to check conflicts between the integrity constraints of the different annotations. A model finder is a constraint solver over models [25]. This way, its goal is trying to find a model satisfying a number of constraints. In our implementation, we use the USE validator [25] (label 2), a model finder that takes as input a meta-model and a set of invariants expressed in the Object Constraint Language (OCL).
                        10
                     
                     
                        10
                        
                           http://www.omg.org/spec/OCL/
                        
                      As output, it produces a model, a valid instance of the meta-model that satisfies all OCL constraints. In our case, the sought model is a Java program that contains annotations satisfying all the designed integrity constraints. If a model does not exist, then there is some conflict in the annotation set. As the sought models are fragments of Java programs (in the form of models) containing the designed annotations (label 3), we can render them as textual Java programs. These could serve designers as a means for validation, as they can check whether the produced example fulfils their requirements and expectations about the designed constraints. Actually, this approach is very natural to be used in an iterative process, where the model finder is used to check conflicts and generate examples, and the results of the validation are used to re-design the annotation set, if needed.

Once the annotation design is satisfactory, the designer can make use of a code generator (label 4) that produces plain Java files with the annotation type definition and the annotation processors for the defined annotation (label 5). Then, the annotations can be safely used (label 6), because their definition does not contain conflicts, and their correct use in Java programs is checked by the generated annotation processors.

Altogether, using Ann has several advantages, including: (i) it allows to make explicit the structure and integrity constraints of a set of annotations in a high-level, declarative way; (ii) it provides automatic check of conflicts between constraints at design-time, as well as a generator of annotated example Java programs; and (iii) it automatically produces the annotation processors to check the correct use of annotations.

The next section explains the Ann DSL, including its supporting environment, while the details on how to express Ann constraints in OCL and the interaction with the model finder are left to Section 7.


                     Fig. 2 showed the different options when designing a DSML, showing in colour the design choices for Ann.

First, Ann has been designed as an external language. We could have opted for a UML profile, which could be a sensible choice, but we preferred a tighter integration with Java programming environment. An internal language within Java was also discarded, as the Java syntax currently does not offer great flexibility for language embedding.

Given that one of the goals of Ann is to give a more user-friendly syntax for Java developers defining annotations, mitigating the incoherences that can be found nowadays in the Java language, a textual concrete syntax has been chosen for it. An alternative graphical concrete syntax to facilitate expressing and visualising the integrity constraints within an annotation set could be interesting, but is left for future work. The abstract syntax was designed using a meta-model, which is the standard choice when using MDE.

For the semantics of Ann, code generation has been the adopted solution. While an interpreter was also possible, we opted for code generation in order to be able to use the generated annotation processors independently of Ann and its tooling. Moreover, the generated processors would normally be more efficient than processors based on interpretation of Ann models.

The next three subsections describe the abstract, concrete syntax and semantics of the Ann DSL.

The simplified meta-model that describes the abstract syntax of Ann can be found in Fig. 4
                        .

The Annotation meta-class contains both the attributes of an annotation and its associated constraints. Note that an annotation with no constraints is allowed, as in the Java language.

Details concerning attributes are shown in Fig. 5
                        . Meta-class ExternalAttr represents attributes declared externally to Ann, including enumerated types and other annotations. We also consider all possible primitive types for attributes, the possibility of default values and arrays.

Constraints are split into two types: requirements (class Require in Fig. 4) and prohibitions (class Forbid in Fig. 4). Multiple constraints over the same annotation type have AND semantics. In Fig. 6
                         we can see an expanded section of the meta-model of Fig. 4, in particular the one concerning the constraints.

Each statement represents a description of a Java element (like class, interface or field) over which the annotation is (dis-)allowed. Ann supports the characterisation of elements regarding their visibility, and whether they should be final, static or abstract. In order to enhance the expressive power of Ann, several statements are possible within the same constraint (e.g., if the same annotation can be applied to several targets). This is why in the case of requirements multiple statements have OR semantics; whereas AND semantics are applied in the case of prohibitions. Note that AND semantics for requirements would not add any additional expressive power since this is already granted by the multiplicity of Require objects. In the case of prohibitions, the expressive power is enhanced by allowing to forbid simultaneous characteristics in a Java target element: this kind of constraints is only violated if all the statements are satisfied by such element.

There is also the possibility of expressing constraints for specific target types (e.g., a field), which indicates that the given constraint only applies when the annotation is attached to that target type (e.g., a field).This corresponds to the attribute t_type of Constraint. An annotation isthus correctly placed at a target type if it satisfies some of the statements of the requirements whose t_type coincides with the given target, and none of the respective prohibition statements.

For these restricted types of constraints, there is a conceptual distinction depending on whether t_type is a Java container or inner type, since the statements will refer to characteristics of its inner or containing elements, respectively. For example, if the target type is field, then the statements will constrain the classes, interfaces or annotations that contain it; that is, the attribute t_type of an Statement inside such Constraint can only be one of class, interface or annotation.
                           11
                        
                        
                           11
                           This conceptual remark is also checked when validating the constraints.
                        
                     

These two types of constraints, and their combinations, provide enough expressive power to cover a large scope of the conceptual model behind a set of dependent annotations; as it will be shown in Section 8, in a real use case.


                        Fig. 7
                         shows an example annotation in abstract syntax. The annotation has Person as name and declares three attributes: name, age and weight. It declares two constraints: one requiring a public class and another one forbidding the class to have final fields. This is an example of an annotation placed at a container Java type (class) with statements that constrain its inner components (fields are forbidden to be final).

We have designed a textual concrete syntax for Ann. An excerpt of the concrete syntax definition for the constraints within an annotation can be found in Listing 4, represented in Extended Backus-Naur Form (EBNF). Appendix A includes the full definition. 
                           Listing 4
                           Concrete syntax excerpt for constraints in Ann. 
                                 
                              
                           


                        Listing 5 shows how the Java annotation type Person previously shown in Listing 1, and in Fig. 7, is described using the concrete syntax of Ann. A new keyword (annotation) is used on its declaration (line 3). Instead of using methods to define the annotation parameters (cf. Listing 1), we use the regular Java syntax for defining class attributes (lines 4–6 of Listing 5). 
                           Listing 5
                           Annotation Person defined in Ann. 
                                 
                              
                           

Regarding the restriction of the allowed targets, we can now express some more elaborated constraints, in this case that Person can only annotate public classes (line 8) with no final fields (line 10). We recall that with Java the closest we can get to this statement is that the annotation could have as targets classes, interfaces and enumerations, which is less specific than what we obtain with this annotation type definition.

In the concrete syntax for requirements, we also note the special keyword all. This would apply if, for instance, we would want that all the methods of the classes annotated with Person were also public. Then we would add the clause at class: require all public method.

In order to fully specify the semantics of Ann it is necessary to generate on the one hand the Java code associated with the definition of the annotations; and on the other hand the code of the processors. The latter will ensure that the constraints specified for each of the defined annotations are fulfilled.

For each of the annotations defined at most two processors will be generated, one for checking the requirements and the other for checking the prohibitions. The structure of the annotation processors generated complies with the one presented in Section 3: each of the relevant elements of the Java program is looked up to check whether its properties satisfy the specified requirements or prohibitions.

The different components of the Ann DSL have been developed using the Eclipse Modelling Framework (EMF) [34].

The meta-model has been described with the meta-modelling language Ecore,
                           12
                        
                        
                           12
                           
                              http://www.eclipse.org/ecoretools/
                           
                         which is based on a subset of UML class diagrams for the description of structural aspects. The Xtext
                           13
                        
                        
                           13
                           
                              http://www.eclipse.org/Xtext/
                           
                         framework, integrated with EMF and able to generate a fully customisable and complete editor for the defined language, has been used to define the textual concrete syntax. Finally, the code generator has been developed using Xtend,
                           14
                        
                        
                           14
                           
                              https://eclipse.org/xtend/
                           
                         a dialect of the Java language included in Xtext. Xtend is more expressive and flexible than Java and has facilities for model navigation. It also allows creating generation templates, what makes it specially useful for code generation. The tool also integrates the USE validator, in order to check constraint conflicts. The use of such model finder will be explained in Section 7.

The result is an Eclipse plug-in, which is seamlessly integrated within the Eclipse Java Development Tools (JDT).
                           15
                        
                        
                           15
                           
                              http://www.eclipse.org/jdt/
                           
                         A screenshot of the IDE is shown in Fig. 8
                        .

The advantage of using a high-level language, like Ann, to make explicit the integrity constraints of a set of annotations, is that they are amenable to analysis. We use model finding techniques for this purpose [22,25]. Model finders are tools supporting a high-level notation to describe features of models, and use constraint solving to find a model exhibiting such features. Typically, model features are described using structural data models (e.g., class diagrams with OCL constraints [25], or relational logic [22]), and rely on lower-level SAT or SMT solver engines (like KodKod [35] or Z3 [12]). Solvers typically perform a bounded search, so that only models up to a given size are sought. Nonetheless, according to the “small scope” hypothesis [22], a large proportion of errors in a system can be identified by considering only instances within a small scope. We use the USE model finder, which accepts as input a meta-model plus OCL invariants.

In order to perform the analysis, we have created a simplified meta-model of Java, containing only the elements that we consider in the Ann language. Then, annotation constraints are translated into OCL, and USE is employed to search for an instance of the previous Java meta-model satisfying all constraints. If no such model is found, then the annotation constraints are incompatible. Moreover, we can also search for Java models containing a combination of annotations of interest. This can be done by another OCL constraint explicitly demanding the occurrence of the desired combination of annotations.


                     Fig. 9
                      shows the Java meta-model we use for the validation and verification of annotations. A few OCL constraints have been added to different classes, for example restricting the visibility of Class to be default or public; demanding abstract methods to reside in abstract Classes; and forbidding cycles of class and interface inheritance.

For the analysis, the main idea is to enrich such meta-model with classes and constraints generated from the annotation definitions. If the resulting meta-model is satisfiable, then there is no conflict in the annotation definition. For example, Fig. 9 shows two classes: Person and Employee generated from two annotation definitions. The first one from the definition in Listing 5, while the second one just requires classes with package visibility and with a Person annotation. In Fig. 9, these generated classes are shown encircled in a dotted region. For class Person we generate an association to Class, which is its only allowed target. If an instance of Person is created, it needs to annotate a Class and therefore the cardinality of role targetPerson is 1. Similarly, another association is created for Employee. Additionally, the OCL constraints of Listing 6 are generated for both classes. 
                        Listing 6
                        Generated OCL constraints from the Person and Employee annotations. 
                              
                           
                        

The two invariant named redefs in lines 2–4 and 14–16 emulate the redefinition of the target role by targetPerson and targetEmployee in classes Person and Employee respectively. This is necessary, because for both annotations, Class is their only allowed target.Note that the target role is useful for annotations that do not explicitly declare a target, so that they can be placed anywhere. For Person we require the target class to be public (invariant require_public_class in lines 5–7), and to have no final fields (invariant at_class_forbid_final_field in lines 9–11). For Employee we require the target class to have package visibility (invariant require_annPerson_package_class, line 19), and be also annotated with the Person annotation (invariant require_ annPerson_package_class, line 20).

Feeding the meta-model of Fig. 9 and the generated constraints in Listing 6 to USE, it returns no model, and hence the constraints are unsatisfiable. On reflection, we realise that the designed constraints for the annotations are in conflict, because annotation Employee demands classes with package visibility, and to be annotated with the Person annotation, which requires classes with public visibility. Designers can then modify the constraints, for example requiring Employee to annotate public classes. Alternatively, they might drop the constraint on visibility, because it would be redundant with the similar constraint from Person.While this example is simple, in more complex cases, the user has the burden to find the reasons for the conflict. This is typically done by systematically trying all combinations of constraints within the considered set (by manually disabling combinations of constraints). Automated, more efficient support for this task (e.g., like the method proposed in [30]) is left for future work. Similarly, constraint redundancy can be (manually) investigated with solvers like USE [17], but automating this task is also left for future work.

Once the constraint for package visibility is deleted from Employee, USE would return a model like the one in Fig. 10
                     (a), proving that there is no conflict, and provide the designer with an example of use of the designed annotation. Fig. 10(b) shows a representation of the USE model in the textual syntax of Java, which could be useful to the designer, to see an example of use of the designed annotations.

We next provide a systematic description of how the Java meta-model is to be extended and how the OCL invariants are generated given an Ann model. For each Ann annotation named 
                        〈
                        ANN
                        〉
                     , we create a subclass of Annotation named 
                        〈
                        ANN
                        〉
                     . Then, additional OCL code is generated for the annotation׳s require and forbid constraints.

The code generation scheme for require constraints is shown in Table 1
                        . The second column of the table shows the generated OCL, as well as the extra elements to be created in the meta-model (using the textual notation of USE for class diagrams).

As explained in Section 6, requirements have an OR semantics. This means that some should be satisfied by the annotation. This way, we create an association between the generated class 
                           〈
                           ANN
                           〉
                         and every distinct 
                           〈
                           TYPEi
                           〉
                        . In the case of more than one requirement, we set the role cardinality in the part of the type to 
                           0
                           ‥
                           1
                        . If there is only one requirement, we set it to 1, as shown in Fig. 9 (and the name of the role is also simplified to 
                           target
                           〈
                           TYPEi
                           〉
                        ). Then, we conceptually redefine the generic target association end to a particular one by means of invariant redefs.

In case some require clause has a modifier, we generate another invariant for the class 
                           〈
                           ANN
                           〉
                        . The table shows the different possible modifiers, regarding visibility, or demanding the type to be abstract, static or final. All the stated modifiers apply to the 
                           〈
                           TYPEi
                           〉
                        , and therefore we and-concatenate the sub-expressions generated by every non-empty modifier. This is done by first checking if the corresponding association role is not empty. This checking is not needed if there is only one requirement (as in line 5 of Listing 6). Note that lines 11–16 in Table 1 represent the OCL invariant that corresponds to one single statement. In the event of more than one statement in a require (as the Ann syntax allows), the generated OCL would correspond to the or-concatenation of those lines, for each statement. For future references, we will denote those lines as 
                           condition
                           (
                           〈
                           TYPEi
                           〉
                           ,
                           〈
                           MODSi
                           〉
                           )
                        .


                        Table 2
                         shows the scheme of the invariants generated for requirements of co-occurrence of annotations. In the first case, annotation 
                           〈
                           ANN
                           〉
                         requires the occurrence of 
                           〈
                           ANN
                           1
                           〉
                         in every place where 
                           〈
                           ANN
                           〉
                         may appear. Hence, we check that every valid target of 
                           〈
                           ANN
                           〉
                         is also annotated with 
                           〈
                           ANN
                           1
                           〉
                        .

In the second case, annotation 
                           〈
                           ANN
                           1
                           〉
                         acts as a constraint on a type where the annotation 
                           〈
                           ANN
                           1
                           〉
                         can be placed. This case is direct as it is analogous to the ones we explained for modifiers in Table 1.

The third and fourth cases deal with the situation when at a certain target, one of its contained or containing elements (see Section 6 for an explanation of this distinction) should be annotated with 
                           〈
                           ANN
                           1
                           〉
                        , respectively. Specifically, we check that whenever 
                           〈
                           ANN
                           〉
                         is annotating target 
                           〈
                           TYPE
                           〉
                        , there is an occurrence of target 
                           〈
                           TYPE
                           1
                           〉
                         with the specified constraints, that is, with 
                           〈
                           MODS
                           1
                           〉
                         and annotated with 
                           〈
                           ANN
                           1
                           〉
                        . The fourth case is the converse.

Again, if there is only one possible target type, then there is no need to check the role that is not empty (because the role would have 1..1 cardinality). In our example in Listing 6, there is no need to test that the role targetEmployee is not empty in line 20. Finally, recall from Section 6 that in the presence of multiple statements in the same require, the semantics is to or-concatenate them within the same invariant.


                        Table 3
                         describes the OCL equivalent to “at” constraints (for the require case). These kinds of constraints describe structural or positional (depending on whether the target is a container or contained type, respectively) requirements or prohibitions for the targets of a given annotation (see Section 6 for more information).

The scheme of translation is similar to the one of Table 2, specially the two last cases, so for simplicity we only consider the case of a container type (the case for method and constructor, because the case of field is analogous), and the use of the all modifier. We will not consider the appearance of annotations in the statements because that case has already been treated in Table 2.

We have presented only the translation for require constraints, because the case for forbid is analogous, but it differs by using negation, and conjunction instead of disjunction when in the presence of several statements.

@&#EVALUATION@&#

In this section we evaluate two aspects of our approach. On the one hand the expressivity, usefulness and advantages of Ann by modelling a subset of the JPA annotations. On the other, we provide an evaluation of the performance and scalability of the constraint-based validation of the annotations. Finally, we discuss possible threats to validity with respect to the evaluation performed.

In order to test the Ann DSL, we have chosen a subset of the JPA annotations, namely Entity, Id, IdClass, Embeddable and EmbeddedId. This selection has been made according to their extensive use in the JPA context, given that all of them are used to describe entities and their primary keys, central concepts in database design.

The characteristics that the targets of the Entity annotation must comply with were outlined in Section 3. Given that this annotation defines an entity within a database, a corresponding primary key must also be specified within those targets. The other selected annotations are used precisely for this purpose.

There are two alternatives in JPA for representing compound primary keys. Both of them involve using a class which contains the fields that compose the primary key. In the first approach, the class can be annotated with Embeddable, in which case it represents a class whose instances are intrinsic components of the original entity. They share with it the primary key and the class is used as a field on the entity it is embedded, annotated with EmbeddedId, which marks it as primary key. Listing 7 shows an example of this alternative. 
                              Listing 7
                              Primary key with EmbeddedId. 
                                    
                                 
                              

The other approach is to use a class that represents the fields of the primary key, but is not embedded. In this case, when defining the entity we use the IdClass annotation to indicate the class that contains the fields of the compound primary key. Each of those fields is then added to the entity by using the Id annotation, as standard. Listing 8 illustrates this other alternative with an example. 
                              Listing 8
                              Primary key with IdClass. 
                                    
                                 
                              

It is important to notice that a class cannot have a field or method annotated with Id and another one annotated with EmbeddedId, since that would imply two primary keys.


                           Listing 9 shows the description of the explained annotations using the Ann DSL. 
                              Listing 9
                              Selected JPA annotations defined in Ann. 
                                    
                                 
                              

Clearly the chosen subset of annotations is very interrelated given all the respective constraints that can be noticed. For example, a class annotated with Embeddable (lines 16–24 in Listing 9) acts as a primary key for another class, in which it is embedded, and thus it must not have a primary key itself, prohibition which is expressed through lines 19–20 and 22–23 of Listing 9.

Alternatively, the annotation IdClass (lines 40–44 of Listing 9) can be used to specify the class that contains the fields which form the compound primary key. Therefore it can only be attached to classes annotated with Entity, requirement described in line 43 of the listing.

Annotations Id (lines 33–38 of Listing 9) and EmbeddedId (lines 26–31 of the same listing) mark the primary key of an entity, and thus can only annotate methods or fields (lines 34 and 27 resp.) which form part of a class annotated with Entity (lines 36–37 and 29–30 resp.).

Finally, regarding the Entity annotation (lines 1–14 of Listing 9), structural properties of the annotated classes are expressed throughout lines 4–8; and lines 10–11 establish the need of a primary key through a requirement, among other constraints.

After the definition of all the annotations and their constraints, we can check for inconsistencies using the constraint solver. The generated OCL code is shown in Appendix B. In this case, USE reported no incompatibilities. After this evaluation, the corresponding code can be generated and is ready to use in both new or existing Java projects, as we will see in the next subsection.

The generated processors are capable of detecting where a constraint is being violated and also notify the developer by means of an explanatory message.

In Fig. 11
                            the annotation Entity is being used on a class and no primary key is being specified, which is a situation not allowed in the JPA context.

Another example of misuse is the one shown in Fig. 12
                           . In this case, the annotation Id is used in a field inside a class that is not annotated as Entity, which is a situation that leads to another error. This is analogous to Fig. 13
                           , where this time the annotation IdClass is annotating a class which is not an entity.

In conclusion, we can see that, if we were to build this annotation set manually, we would have needed to: (i) create the interfaces for the annotation in Java, (ii) manually encode the integrity constraints of the annotation set in a Java annotation processor, and (iii) manually test the processor to find errors. By using Ann, steps (i) and (ii) were made with the DSL, and so there was no need to manually program the annotation processor. To provide an intuition of the effort saved, the generated processors amounted to 638 LOC. The analysis of the annotation constraints was also made in an automated way, which avoided long, tedious cycles of installing, testing and fixing the annotation processor.

Constraint solving may generally involve costly computations, therefore we conducted an experiment to evaluate the efficiency of annotation validation to check the feasibility of its use in practice, and its scalability.

For this purpose, we designed annotation sets of increasing size (from 2 to 64), and added constraints in each of them ranging from 
                           [
                           1
                           ‥
                           2
                           ]
                         constraints per annotation to 
                           [
                           2
                           ‥
                           8
                           ]
                         constraints per annotation. Constraints included both require and forbid constraints, and the former included co-occurrence constraints involving all annotations within the set. Additionally, we designed both satisfiable and unsatisfiable constraints. In the latter case, we opted for the “difficult” case, in which unsatisfiability is caused by a conflict between just two constraints. For the configuration of the search space, we used a bound of 1 to 4 instances of each annotation type.

The experiments were performed on an Intel Core i7-2600 (3.4GHz) computer with 12GB RAM, and the version of USE was 4.1.1. Each experiment was repeated 5 times and we took the average time. Fig. 14
                         shows a graphic summarising the results, where the vertical axis shows the solving time in milliseconds and in logarithmic scale. The horizontal axis depicts the increasing number of annotations (2, 4, 8, 16, 32, and 64), with six series in each annotation set. The first two series contain the results of annotation sets with up to 2 constraints per annotation. SAT-2 corresponds to an annotation set with satisfiable constraints (a correct design), while UNSAT-2 is an annotation set with unsatisfiable constraints (an incorrect design). SAT-4 and UNSAT-4 depict annotation sets with half the annotations having 2 constraints and the other half 4 constraints. Similarly SAT-8 and UNSAT-8 are sets with half the annotations having 2 constraints and the other half 8 constraints. The same results are shown in Table 4
                        .

In general, the validator showed good efficiency, solving 2 annotations in less than 100ms, while a set with 64 interrelated annotations took about 25s. We believe these are acceptable times, which for sets of about 10 to 20 interrelated annotations amounts to analysis times of less than or around 1s. For example, JPA contains 8 annotations for classes and 11 for fields. Interestingly detecting unsatisfiability is normally quicker than producing an example. Also, it can be observed that the number of annotations has a more significant impact on the solving time than the number of constraints per annotation. Even in some cases, adding more constraints resulted in lower solving times (as the search space becomes smaller).

The generalisability of the results presented in the JPA use case should be dealt with care, given that the evaluation of the expressiveness has been done over a small, albeit frequent, set of annotations. However, a huge coverage of conceptual constraints behind a set of dependent annotations is shown within this simple example. Note also that the definition of the annotation types in Listing 9 is a simplification of the original ones, since neither all the interacting annotations from the JPA framework have been considered, nor all their specification has been translated into Ann. However, we believe we have chosen a subset of the more representative and frequent constraints a JPA developer comes up with, big enough to motivate the usefulness of Ann in a real scenario.

Regarding the efficiency evaluation, the experiment is synthetic, and therefore may not emulate well the constraints within real-world annotations. However, as the bigger impact of solving time is in the number of annotations, our experiments went to a high number of annotations (64), showing acceptable times.

@&#CONCLUSIONS AND FUTURE WORK@&#

Ann makes possible the effective design of Java annotations by improving their native syntactical support and allowing the expression of integrity constraints both related to an annotation type and within a set of annotations. Thanks to the code generator, the approach can be perfectly integrated with existing Java projects. Moreover, with the use of annotation processors all the integrity constraints described with the DSL are checked at compile time, which improves both usability and efficiency. This is because it is not necessary to execute the application in order to know whether the annotations are being correctly used, hence saving much time and effort for developers. By interacting with a constraint solver, it provides feedback to the designer of the annotations while they are being constructed, in the event of inconsistencies.

Concerning future work, a large range of possibilities is available given the flexibility that a DSL provides. First, improvements can be done at the tool level, for a smoother integration with the model finder. Automated support for finding the reasons for a constraint conflict, or signalling redundant constraints is an interesting line of research. We will also consider an empirical evaluation of Ann with Java programmers. As seen in Section 2, the meta-model of Java annotations can be still improved and expanded to improve its harmony with the rest of Java elements, like, for example, its conciliation with object-oriented principles such as composition, inheritance and polymorphism, which might help to make cleaner the design of a set of annotations. We also plan to provide support for the new of Java 8 concerning annotations, like new targets for annotations (any type use). Among other considerations, this may imply using a more complete Java meta-model for the analysis, like those provided by JaMoPP
                        16
                     
                     
                        16
                        
                           http://www.jamopp.org/index.php/JaMoPP
                        
                      or Modisco.
                        17
                     
                     
                        17
                        
                           https://eclipse.org/MoDisco/
                        
                     
                  

At present two basic types of constraints are considered in Ann (requirements and prohibitions), which are enough to express common integrity constraints as it has been seen in Section 8. However, further experimentation could reveal new constraint types or combinations, which could be added to the DSL in the future, given the flexibility that a meta-model provides. Another line of work is the reverse engineering of annotation constraints from the analysis of annotated Java programs.

@&#ACKNOWLEDGEMENTS@&#

We would like to thank the reviewers for their detailed comments, which helped us in improving a previous version of this paper. This work has been partially supported by the Spanish Ministry of Economy and Competitivity with Project FLEXOR (TIN2014-52129-R) and the Community of Madrid with Project SICOMORO-CM (S2013/ICE-3006).

This appendix includes the complete textual concrete syntax of the Ann DSL in Extended Backus-Naur Form.


                        
                           
                        
                     


                        
                           
                        
                     


                        
                           
                        
                     

This appendix includes the generated USE model and OCL constraints for the JPA annotations in Listing 9. Note that, with respect to the meta-model in Fig. 9, some classes have been prefixed with “Java” (e.g., JavaClass, JavaAnnotation) to avoid name clashes with reserved words in USE.


                     
                        
                     
                  


                     
                        
                     
                  


                     
                        
                     
                  

@&#REFERENCES@&#

