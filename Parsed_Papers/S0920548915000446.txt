@&#MAIN-TITLE@&#Design and evaluation of P2P overlays for energy negotiation in smart micro-grid

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Collaborative approach for energy schedule in smart micro-grid


                        
                        
                           
                           Optimization model for short term maximization of self-consumption


                        
                        
                           
                           Global schedule computed by a P2P negotiation between consumer and producer agents


                        
                        
                           
                           Performance analysis of resolution using a prototype


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Intelligent agents

SLA

Smart grid

XMPP

SPADE

@&#ABSTRACT@&#


               
               
                  The increasing availability of distributed renewable energy sources such as photo-voltaic (PV) panels has introduced new requirements for innovative power grid infrastructures. Information technologies provide new opportunities for developing techniques to optimize the energy usage by a new generation of smart-grids. Here we investigate an original solution that aims at maximizing the self-consumption within a neighborhood based on a collaborative approach. Distributed software agents plan and enforce the optimal schedule of consuming appliances according to the prediction of energy production by PV panels, the estimated energy profile of consuming devices and the user's preferences and constraints. Finally we focus on the performance evaluation of a negotiation protocol that allows agents to find a sub-optimal solution for the global schedule, comparing results obtained by a prototype implementation and experimenting different technologies.
               
            

@&#INTRODUCTION@&#

A smart grid is a modernized electrical grid that uses information and communications technology to optimize the utilization of infrastructures and energy management. The main goal is gathering and acting on information, about the behaviors of suppliers and consumers, in an automated fashion to improve the efficiency, reliability, economics, and sustainability of the production and distribution of electricity [1].

Among the new requirements for such a smart capability there is the need to integrate decentralized renewable sources (DER), which have recently changed both demand and availability of energy. Above all it is relevant to address the amount of energy produced by photo-voltaic (PV) panels because of the irregular power profile, which is not aligned with the consumptions, and because of the growing number of installation by private users, companies, public bodies and resellers.

PV panels turn periodically consumers into distributed producers, when they are not able to consume what they produce. Unfortunately the cost of big energy storages is still not affordable for private users.

The lack of alignment between production and consumption causes peeks of energy transfers which need to be managed by over dimensioning the grid infrastructure. Another issue is the loss of energy that occurs during transfers when it is not consumed locally. Finally there is not an open market or any regulation that allows users to sell their over-production at a convenient rate.

According to NIST [2] there is an urgent need to establish protocols and standards for the Smart Grid. Without standards, there is the potential for technologies developed or implemented with sizable public and private investments to become obsolete prematurely or to be implemented without measures necessary to ensure security.

The CoSSMic project
                        1
                     
                     
                        1
                        
                           http://www.cossmic.eu.
                      investigates regulatory, organizational and technical challenges about the transition from centralized power network to distributes Smart Solar powered Micro Grids operating in deregulated energy markets, where users can negotiate and exchange energy to achieve an individual and a global benefit.

Here we define a micro-grid as a neighborhood of users which are available to share their infrastructures and the energy produced by their PV panels according to a collaborative approach. They collaborate to optimize the self-consumption of their neighborhood and get a reward according to their participation and to the produced economy.

In our scope CoSSMic will implement an autonomic platform that executes a collaborative strategy on users' behalf according to their preference and constraints.

To achieve such goal it is necessary that autonomous and distributed applications are able to interact to exchange data about the energy profiles of consuming appliances, energy storages, prediction of production, monitoring information and control messages with an increasing number of users, applications, services and information sources.

In the CoSSMic scenario software agents manage user's devices behaving as consumers and producers. They monitor in real time energy utilization, learn energy profiles of devices and use user's constraints and predictions to compute a global schedule for the consuming appliances.

Such a distributed scheduling is computed by a negotiation between consumer and producer agents. A sub-optimal solution will be searched to address the complexity of the problem. Consumer agents broker the best producer and negotiate by exchanging an SLA template.

Here we focus on the negotiation protocol and investigate its scalability using different technologies and comparing experimental results obtained running a prototype implementation under different condition.

The paper is organized as follows: Section 2 contains the related works; Section 3 describes the CoSSMic project; in Section 4 the problem is formulated as a scheduling problem; in Section 5 negotiation phase and SLA requirements are presented; the prototype we developed is presented in Section 6; Section 7 describes the experiments and presents the results; finally in Section 8 conclusions are reported.

@&#RELATED WORK@&#

Several studies have been conducted regarding the application of multi-agent system in the energy management and negotiation. Paper [3] describes an application of MAS for management of distributed energy resource. Through a software simulation authors demonstrate that is possible to apply a distributed coordination approach to coordinate distributed energy systems. In [4] and [5] a MAS, developed in JADE, is presented for generation scheduling of a microgrid. The architecture provides several types of agents. For example there is the controller agent that is associated to each device that produces energy such as photovoltaic panel or wind turbine; load controller agent represents corresponding controllable load in the system. Also in [6] is proposed an agent-based simulator, MASCEM (Multi-Agent Simulator of Competitive Electricity Markets), designed for analyzing agent market strategies. The simulation tool uses various strategies and mechanism. The system includes agents that are capable of improving their performance with their own experience, by adapting to the market conditions. The agents can interact in several different ways and may joint together to form coalitions.

CoSSMic will go beyond the simulation, by the integration of existing infrastructures with monitoring utilities and innovative ICT services. In particular CoSSMic will perform tests using trials in the Province of Caserta (Italy) and in the city of Konstanz (Germany).

In [7], a decentralized communication algorithm based on the consensus theorem is proposed. Moreover, it is proved that the agents are able to compete to achieve a global minimal operational cost for microgrids. CoSSMic approach will use a collaborative scheme rather than a competitive one.

Moreover much effort has been spent on the investigation in the field of Service Level Agreement (SLA) for Quality of Service (QoS) monitoring and coordination. SLAs have been explored in several sectors e.g. in smart cities applications [8–10] and for negotiation and brokering of computational resources in Cloud markets [11–15]. SLA@SOI [16,17] proposes a generic framework to accommodate different real-world scenarios.

A generic Composite Service is provided to one or more Business Customers. CS is implemented as a composition of several atomic Services. Services are deployed on Infrastructure Services, provided using virtualization techniques. Thus, the service hierarchy established to implement the composite service, is reflected on an equally complex SLA hierarchy, which governs top-level service consumption and propagates down to the fabric.

Paper [18] introduces different sets of service bundles (SLAs) corresponding to different selections of functional and non-functional requirements of the GWAC Interoperability Framework. In particular the GWAC Interoperability Framework described in [19] consisting of three Interoperability Categories (Technical, Informational and Organizational) and Crosscutting Issues related to nonfunctional requirements, such as Energy Efficiency (EE). Their approach of negotiating and setting up proper SLAs includes methods of deriving common ontologies among stakeholders, thereby enabling validation and maintenance of interoperability in delivering and monitoring services.

Our work also implements a SLA based negotiation without hierarchical organization, but it is exploited to solve optimization problems in a distributed way. At business level only the information about the amount of shared energy, and the flexibility of the user's policy, will be used to distribute the reward produced by the global economy.

CoSSMic (Collaborating Smart Solar-powered Micro-grids. FP7-SMART CITIES, 2013) is an ICT European project that aims at fostering a higher rate for self-consumption of decentralized renewable energy production by innovative autonomic systems for the management and control of power micro-grids on users' behalf. This will allow households to optimize consumption and power sales to the network by a collaborative strategy within a neighborhood.

In fact the increasing of the decentralized production of green energy is affecting the current energy management scheme both at the grid and at the user level. The amount of electricity used and the energy produced by photovoltaic systems varies over the course of the day, from season to season and depending on the weather conditions. On the other hand the users may not have the opportunity to turn on their appliances when the PV is producing because they do not know when or because they are outside or simply because they do not need those appliances at that time. For this reason there is not an alignment during the time between production and consumption. At the user level this limits both the optimal utilization of green energy and affects the budget spent.

The CoSSMic approach proposes an intelligent scheduling of user's consumptions within a micro-grid. A micro-grid is typically confined to a smart home or an office building, and embeds local generation and storage of solar power, and a number of power consuming devices. The main goal is to enable the collaboration among households so that the energy produced by the PVs is consumed by any available consumer in the neighborhood. An autonomic system will able to shift the loads in each neighborhood, according to users' constraints and preferences, in order to find an optimal match between consumption and production during the day, so that the use of renewable energy is maximized. Appliances (refrigerators, washing machine, drier and dishwasher, water heaters, air conditioners) equipped with intelligent controllers are represented by software agents negotiating energy exchanges according to availability, demand, user's preferences and constraints. The energy negotiation between agents will be based on rewards for local producers. To obtain the maximization of self consumption, a predictive approach can be considered, but we need to predict PV production based on the weather forecast and the parameters of the plant. Moreover the power consumed by each device must be known in advance or learned from monitoring information. Also the behavior of consuming devices can change each day according to a number of parameters (e.g. the external temperature for the refrigerator or the air conditioner, the user's needs for the electric cars or for the oven), which are often unpredictable.

The problem presented in the previous section is formulated here as a scheduling problem. The goal is to plan the time when appliances will be switched on or off, to use as much PV energy as possible during the period of production, according to users' constraints and preferences. We defined dev
                     
                        i
                      a smart device with sensing and switching capability. It can produce, or consume energy. A storage will be represented by a couple of devices, a consumer and a producer. Of course not every device can be equipped with such kind of capability or can be controlled by an autonomic system. In fact the usage of computer desktops or televisions will depend only on the user will. Moreover devices which do not absorb a relevant amount of energy or which are simply not equipped with controlling capability will be excluded.

Let us introduce also the following definition:
                        
                           •
                           
                              C, is the time series of cumulative energy consumed by the neighborhood during the day. It includes both smart and not smart devices.


                              P, is the time series of the cumulative energy produced by the all PV panels in the neighborhood.


                              ri
                               is the estimated energy profile of device i from the time it is switched on.


                              Pa
                               is the time series describing the cumulative energy consumed by those devices that will not be monitored (e.g. light bulbs) and that cannot be controlled.

The objective is the maximization of self-consumption that corresponds to the minimization of the absolute value of the objective function shown in Eq. (1) in a day. A positive value for S means that the that amount of energy will be consumed from the grid.
                        
                           (1)
                           
                              min
                              
                                 s
                              
                              =
                              min
                              
                                 
                                    
                                       ∫
                                       
                                          t
                                          0
                                       
                                       
                                          t
                                          1
                                       
                                    
                                    
                                       C
                                       +
                                       P
                                       d
                                       t
                                    
                                 
                              
                           
                        
                     where
                        
                           
                              C
                              +
                              P
                              =
                              
                                 r
                                 0
                              
                              
                                 
                                    t
                                    1
                                 
                              
                              +
                              …
                              +
                              
                                 r
                                 n
                              
                              
                                 
                                    t
                                    n
                                 
                              
                              +
                              
                                 P
                                 a
                              
                              +
                              P
                              ,
                              C
                              >
                              0
                              
                              and
                              
                              P
                              <
                              0
                           
                        
                     
                  

The values of a solution t
                     1,…,
                     t
                     
                        n
                      represent the start time of the user devices. They should eventually be within defined constraints. In fact the user will be able to choose the earliest start time or the latest start time for a device in his household. For air conditioner he will be able to set the minimal temperature. Anyway such rules will be modeled as logical condition depending on which the status of each smart device will be set on or off. When such a rule is not mandatory the user can set a preference that will be considered to take a decision about which devices should be switched on or off in an exclusive choice.

The solution that minimizes the objective function, defines the task schedule that minimizes the total energy exchanged with the grid. If the objective value is negative, it means that there is a surplus of produced energy, that can be sold to Grid. Being computationally hard to find an analytical solution for this problem, we propose a distributed approach that looks for a sub-optimum by a P2P negotiation.


                     Fig. 1
                      shows the main components of our architecture playing the CoSSMic scenario. A Graphical User Interface (GUI) allows the user to interface with the system in order to verify the performance of the consumption/production of electricity and giving the possibility to configure the system. In particular it allows users to interact with electronic devices through graphical icons and visual indicators. Thanks to the GUI, users can see, through several charts, energy consumption of all electric devices of the smart house and can set rules and policies that agents must follow for the management of energy consumption.

Devices in the home can send information about electricity consumption through wireless interfaces (for example UHF or Zigbee). Mobile devices (e.g. electric cars), instead, send information through the CoSSMic Cloud. In both cases the information, through the Mediator, reach the agent platform. The mediators integrate also a number of device drivers, which allow to send real time commands to electric devices in the smart house. For example, through device drivers the mediator APIs allow to switch on or switch off devices, when it does not violate any constraints, in order to save energy.

Agents are classified according to two categories:
                        
                           •
                           Consumers: they buy energy for passive devices. E.g. they will run in houses to manage objects that absorb energy: electric car, computers, ovens, washing machines, etc.

Producers: they can sell energy. In this category there are, for example, power generators, solar panels, wind turbines.

Those devices, which are able both to produce and consume energy such as energy storages or electric cars, will be represented by a couple of agents belonging to the two different classes defined above.

For the energy negotiation there is not a concrete marketplace, but a virtual market is implemented by a negotiation protocol that uses P2P overlay of agents.

The main objective of a negotiation is to reach an agreement between a vendor and a customer. A Service Level Agreement (SLA) defines an agreement between a provider and a client in the context of a particular service provision and can be between two (one-to-one) or more (one-to-many, or many-to-many) parties. A SLA typically consists of a number of Service Level Objectives (SLOs) that define Quality of Service (QoS) properties for the agreed upon service. These QoS properties need to be measurable and must be monitored during the provision of the service that has been agreed in the SLA. In fact when manipulating services, a service provider need to define the quality of service levels that will be offered to customers. Automated negotiation performing bargaining of Service Level Agreements (SLA) are useful to reach the QoS requirements. In general an SLA is used to develop a contract between the service provider and the service consumer.

In our scenario an energy consumer and an energy producer agree to shift the energy workloads of a device to optimize the mapping between production and consumption, but within a time period defined by the earliest start time and the latest start time defined by the user. For this reason the emergent behavior of whole multi agents system will implement a distributed scheduler that allocates consuming and producing tasks for each device within the neighborhood.

The negotiation protocol will be implemented by an overlay of agents which exchange FIPA
                        2
                     
                     
                        2
                        Foundation Intelligent Physical Agents.
                      messages using XMPP 
                        3
                     
                     
                        3
                        Extensible Messaging and Presence Protocol.
                      as transport layer. The XMPP server is used for authentication and to support communication across firewalls. Alternative server-less solution will be investigated in future works.

In Fig. 2 a sequence diagram of negotiation is shown. A consumer that intends to allocate his consuming tasks will execute the following steps:
                        
                           •
                           Connects and login to the XMPP server to join the neighborhood.

Estimates its own need of energy.

Brokers the producer that can offer the required energy

Send a proposal (SLA templates)

On the other hand, the producer will:
                        
                           •
                           Connect and login to the XMPP server

Wait for incoming proposals

Evaluate the proposal accepting or not

Send the related response

Consumers will adopt a ranking mechanism to broker the producer to be contacted. Every consumer associates a rank to each producer, that is an integer that indicates the quality of the producer. Each time the producer accepts the proposal, this number is incremented by 1. The consumer will continue to call the producer which has the highest ranking.

Each producer will try to allocate the consuming workload according to the model presented in the previous section choosing the start time for the incoming task that satisfies the user requirements, but minimizing the use of energy from grid compared to its own production profile.

The negotiation protocol is started by a consumer agent each time a new execution is planned for the handled device sending a proposal. The message body of a proposal is a machine readable SLA template.

Templates used by agents for negotiation define the energy requirements including user's preferences and constraints (e.g. start date, termination date, cost, etc.). The SLA will complement the energy requirements with the negotiation parties and actual start time.

The SLA template we are defining is composed of attribute–value pairs:
                           
                              
                                 S
                                 L
                                 A
                                 =
                                 
                                    
                                       
                                          A
                                          1
                                       
                                       =
                                       
                                          v
                                          1
                                       
                                       ,
                                       
                                          A
                                          2
                                       
                                       =
                                       
                                          v
                                          2
                                       
                                       ,
                                       …
                                       ,
                                       
                                          A
                                          k
                                       
                                       =
                                       
                                          v
                                          k
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Each attribute has a unique name or ID. Values belong to well defined data types: integer, real, date, time, boolean and String. We identified a preliminary set of attributes that support a basic negotiation between an energy consumer and an energy producer.
                           
                              
                                 AId
                              
                           
                           
                              It is a string that identifies univocally the entity that offers or asks for the energy exchange.

It is the date the exchange is valid. It can expressed by the following notation MM/DD/YYYY.

It is used to identify the appliance that needs the energy.

It identifies the run of the appliance that can be used more times in different days or in the same day.

It is a real value. It is not a real cost, but is used to control the convergence of the negotiation before the earliest start time. The consumer will be available to pay more if the latest start time is approaching. The producer will sell at a lower price the energy available in the near future.

It defines the Interaction Protocol supported by the issuer for negotiating this template. In our case it is not used.

It is the Earliest Start Time the energy will be delivered or consumed, defined as the number of second from the UNIX epoch.

It is Latest Start Time the energy will be delivered or consumed (number of second from the UNIX epoch).

It represents the penalty will be payed if the energy is not delivered or consumed according to the SLA condition. Such field has not been completely defined yet.

It includes an array of samples which describe the cumulative energy workload for the current task. Each sample is composed of two values, an integer and a real. The first value defines number of seconds from the time the device has been switched on. The second value is the number of watt-hour consumed till the sample time.

An example of SLA template is shown in Listing 1
                        .

The producer will respond providing the actual start time (AST) that must be within the time period defined by EST and LST.

We have designed and developed a prototype of the system described previously to study the scalability and assess performance for dimensioning purpose. The application is based on a multi-agent system that exploits a peer to peer platform at transport level. At application level the agents communicate by exchanging ACL
                        4
                     
                     
                        4
                        Agent Communication Language.
                      messages. ACL is a communication language based on FIPA specification (in particular on the specific SC00061G). In general, an ACL message is composed of two parts: communicative act (also known as performative) that provides a precise meaning to the type of communication and the real content. Moreover, ACL message has a number of parameters among which we find the sender, the receiver, the language to be used and the ontology.

As transport protocol we chose to use XMPP. XMPP [20,21] is an open, XML-inspired protocol for near-real-time, extensible instant messaging (IM) and presence information. It has also been used for publish–subscribe systems, signaling for VoIP, video, file transfer, gaming, and Internet of Things applications. Being a standard, agents running on different platforms can communicate and cooperate by using standard ACL messages without any modifications in the communication protocols and mechanisms. An XMPP server provides various types of services: user account registration, authentication, channel encryption, prevention of address spoofing, message relaying, etc. Nothing prevents to deploy across the network servers that can route and relay messages for workload balancing purpose. XMPP, in fact, in addition to being open, public and free, is decentralized. Therefore, it is possible to create a servers network that is independent but simultaneously interconnected and it does not depend on a central backbone. By using a decentralized client-server architecture there is an intelligent separation of concerns. In fact, in this way, client developers can focus on user experience, and server developers can focus on reliability and scalability. Finally, XMPP is scalable. In fact, the push model of information transfer used in XMPP solves serious scaling problems associated with traditional HTTP-based polling approaches. Here we evaluate the performances of a single server deployment solution.

To date there are several agent platforms. After doing a screening evaluating features, services and technologies, we decided to try JADE and SPADE in order to evaluate also two different technologies: Java and Python, whereas the first one is widely supported and the second one has been conceived for embedded hardware such as Raspberry PI that has been chosen as the target architecture to host the CoSSMic platform.

JADE [22] (Java Agent DEvelopment Framework) is a free software framework for the development of agents, distributed by Telecom Italia under the terms and conditions of the LGPL license. It is fully implemented in Java and it is totally compliant with standard FIPA specifications. A JADE-based system can be distributed across machines which may also have different OS. The configuration can be controlled via a remote GUI. JADE also provides a communication paradigm based on the exchange of messages and a yellow pages service with a mechanism for publication, subscription, and discovery.

SPADE [23] is an open source agent platform written in Python and based on the XMPP technology. SPADE is fully compliant with FIPA specifications. The FIPA-ACL messages will be embedded in XMPP messages. SPADE provides a library (SPADE Agent Library) that is a module for the Python programming language for building agents. The library contains a collection of classes, functions and tools for creating agents that can work with the SPADE Agent Platform. Currently, the SPADE Agent Library is only available for the Python programming language. SPADE implements, besides XMPP, other three types of MTPs: P2P, HTTP and SIMBA.

While for systems that implement XMPP protocol we decided to evaluate OpenFire and Tigase.

OpenFire
                           5
                        
                        
                           5
                           
                              www.igniterealtime.org/projects/openfire/.
                         is an instant messaging and groupchat server that uses XMPP. It is written in Java and licensed under the Apache License. OpenFire provides a web interface to administrate the server, which runs on the ports 9090 (HTTP) and 9091 (HTTPS) by default. Administrators can connect from anywhere and edit configuration settings. It is customizable and supports many types of plugins.

Tigase
                           6
                        
                        
                           6
                           
                              www.tigase.net.
                         is an open source project to develop an XMPP server implementation in Java. It fully supports the latest specifications: RFC 6120-XMPP CORE and RFC 6121-XMPP IM and a bunch of extensions. It is customizable and flexible. In fact, many adjustments are possible through a simple configuration option or through broad API and modularity. Moreover, Tigase supports scripting (Groovy, Python, Ruby, Scala). However, our goal is to evaluate the performance which depends not only on the technology we are going to use, but also by the load.

Energy monitoring is mandatory for learning profiles of appliances and building SLA templates. We integrated off-the-shelf devices and extended the EmonCMS 
                           7
                        
                        
                           7
                           
                              www.emoncms.org.
                         open source application to collect monitoring information and interface agents with the environment. On the other hand prediction of production using characteristics of plants, weather conditions, and historical data is necessary for producers to sell energy. However monitoring of trials, learning techniques and prediction models are out of scope here.

For preliminary experimental activities we use some historical data which publicly available and simulation models. We used these data to feed virtual devices which are handled by consumer and producer agents. Virtual devices have been developed as a web application with a REST interface that accepts and returns JSON data. Device categories include PV panels, household workloads, washing machine, clothes dryers, refrigerators and others. It is possible to create different instances of devices belonging to each available category. New instances of devices can be added to an users profile. Device instances can be configured, started, stopped or deleted. It is also possible to query the devices about their status and their current consumption and production.

Many templates of PV panels use historical data collected from the Solarlog web site.
                           8
                        
                        
                           8
                           
                              http://home.solarlogweb.it.
                         Solar-Log is a service that allows monitoring of photovoltaic systems. Power is measured every 5min and stored in a database. Other PV panel templates of trials are implemented by simulation models which accept as input historical data about irradiation, plant characteristics and information from billing reports. Templates of consuming appliances are implemented using profiles described in [24].

We have developed a number of tests to evaluate performances of our prototype.

In the first test we simply evaluate performances of SPADE and JADE agent platforms working with different XMPP implementations. The testbed is one host equipped with a 2.67GHz i5 processor, 4GB of memory amount and Windows 7 operating system. Here we evaluate the performance running a single consumer and a single producer that always accepts requests.

In Fig. 3
                         the chart shows the average time to close a transaction. It is clear that with one consumer and one producer, SPADE on OpenFire exhibits the best performance. While the Jade agent platforms worked correctly with both OpenFire and Tigase servers, we observed that with an increasing number of consumers and requests, the SPADE producer agent crashes using other XMPP implementations. For this reason we show results about SPADE execution only with its embedded XMPP server.

In Fig. 4
                         we plotted the average transaction time when there are 30, 40 and 50 consumers when we use SPADE with embedded server and JADE with OpenFire. It can be seen that the time's growth exhibits a linear behavior with the consumers' growing. In particular, we can approximate the equation of the graph for JADE and SPADE to a straight line. For JADE the equation is approximately y=6x+24.5 and for SPADE it is y=3.6x−27.5. As can be seen from the angular coefficient, the slope is greater for JADE. In fact, the mean time to close a transaction grows up of about 60ms every 10 consumers for JADE and of about 36ms for SPADE. It is symptom of good scalability with the agent community's growth.

We concluded this test replacing the producer agents that accepted each requests without any computation overhead with a new agent that makes 1.000 floating point operations to simulate the task scheduling. We have one producer that always accepts requests and 50 consumers. This experiment allowed us to compare the processing time of JADE and SPADE agents and to see how much performance results was due just to the server or even to the programming language (Python vs Java).

We noticed that in Java the time to complete the experiment is greater than SPADE. From the chart in Fig. 5
                        , we can note that in SPADE the mean time to close a transaction increases slightly, but in JADE the grows faster.

The mean time to close a transaction in JADE and SPADE, with immediate response or response after 1000 floating point operations is shown also Table 1
                        . In SPADE the same computation introduces a time overhead that is about 6%, while for JADE the overhead is about 40%. This indicates a better performance of Python than Java.

The fact that Python is lighter and offers better performance is also noticeable from the chart in Fig. 6
                         where we can see the mean time of transactions. In particular, it is known as Java at startup is much slower. In Python, instead, the times are more or less constant during the entire duration of the experiment.

This second test aimed at moving closer to a real context using three hosts connected to a local network: the first one hosting the XMPP Server, the second one running the consumers and the third one the producers. We used SPADE with its embedded XMPP server as demonstrated to be the best choice. We performed tests with 10 producers and 50 consumers.

The producer may agree to a proposal in accordance with a certain probability that represents the capacity of a producer to sell energy. Once a producer rejects a proposal, it will reject all subsequent requests. We made this choice to simulate the situation in which a producer has no more energy to sell.

In the first case a consumer used a Round Robin protocol for choosing the next producer. Each consumer has a sort of circular queue with all producers. At beginning each consumer chooses randomly the first producer to be contacted. From the second proposal onwards the consumer contacts the next producer in the queue.

In the second case we introduced a ranking mechanism. Each agent creates a vector with all active producers and a ranking is associated to each producer. The ranking is an integer initialized to zero incremented by one each time the corresponding producer accepts the proposal. The first time a consumer chooses randomly the producer to contact and it will continue to contact the same producer until a proposal will be refused.

The x-axis, in Figs. 7 and 8
                        
                        , represents time intervals of 500ms. The first and the second experiments have a duration of about 20s.

We observe in Fig. 8 peaks at the end of the experiment because all consumers are calling to the only producer that still have available energy and continues to accept proposals. This does not occur in Fig. 7 because the consumers call a different producer on each transaction.

In all cases presented so far, requests are made in sequence, while in reality they will be made only when there will need to purchase energy. To simulate this situation we introduced a delay between a request and the next one which follows a Poisson distribution. We chose this type of distribution because it should be used when an event has a probability to happen very low but the amount of repetitions of the experiment (or the sample size) is so high as to make the event probable to occur.

In Fig. 9
                         the intervals have been defined with duration of 1s because the messages are sent with different splits. The experiment completes after about 25s. There are not peaks since the requests are more delayed.

Moreover, by Fig. 10
                         it is possible to understand that with the introduction of the delay that follows a Poisson distribution (thus approaching to a more realistic case), the concurrency decreases and the response times are lower than other two experiments. Also the standard deviation is lower and this is an important result as the mean times to close a transaction are not very different from each other and so there is no agent that waits too long before it knows if there is energy available in the neighborhood to meet its needs.

@&#CONCLUSION@&#

Innovative solution are required to improve the smartness of power grid for addressing the effective exploitation of decentralized energy sources such as PV panels. Here we proposed collaborative approaches that aim at scheduling the execution of user's appliances to maximize the self consumption in a solar powered micro-grid. A global schedule is computed by a P2P negotiation between consumer and producer agents. In this paper we presented the SLA based negotiation protocol and preliminary performance evaluation of a prototype. The tests performed allowed to compare different technologies and provided encouraging results in terms of scalability when the workload starts to approximate dynamics of real systems.

Results suggest to introduce a mechanism to stop negotiation when there are no producers with available energy and to notify consumers when energy is available again. Moreover test-bed with real data, dedicated hardware and metropolitan area networks must be set. Finally learning techniques, optimization algorithm and prediction models will be investigated to evaluate the effectiveness of the energy schedule.

@&#ACKNOWLEDGMENTS@&#

This work has been supported by CoSSMic (Collaborating Smart Solar powered Micro grids—FP7 SMARTCITIES 2013—Project ID: 608806).

@&#REFERENCES@&#

