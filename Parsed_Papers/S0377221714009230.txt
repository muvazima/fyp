@&#MAIN-TITLE@&#An effective approach for scheduling coupled activities in development projects

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Focusing on determining the activity sequence with minimum total feedback time in a DSM.


                        
                        
                           
                           NP-complete optimization problem.


                        
                        
                           
                           A new formulation of the optimization problem is proposed, which allows obtaining optimal solutions in a reasonable amount of time for problems up to 40 coupled activities.


                        
                        
                           
                           Two simple rules for reducing the total feedback time, which can be conveniently used by management.


                        
                        
                           
                           A heuristic approach that is able to provide good solutions for large instances.


                        
                        
                           
                           The usefulness of the approach has been validated through case study, computer experiments and benchmark analysis.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Project management

Product development

Design structure matrix

Iteration

Concurrent engineering

@&#ABSTRACT@&#


               
               
                  One of the greatest challenges in managing product development projects is identifying an appropriate sequence of many coupled activities. The current study presents an effective approach for determining the activity sequence with minimum total feedback time in a design structure matrix (DSM). First, a new formulation of the optimization problem is proposed, which allows us to obtain optimal solutions in a reasonable amount of time for problems up to 40 coupled activities. Second, two simple rules are proposed, which can be conveniently used by management to reduce the total feedback time. We also prove that if the sequence of activities in a subproblem is altered, then the change of total feedback time in the overall problem equals to the change in the subproblem. Because the optimization problem is NP-complete, we further develop a heuristic approach that is able to provide good solutions for large instances. To illustrate its application, we apply the presented approach to the design of balancing machines in an international firm. Finally, we perform a large number of random experiments to demonstrate that the presented approach outperforms existing state-of-art heuristics.
               
            

@&#INTRODUCTION@&#

Product development projects often comprise many coupled activities (Eppinger, Whitney, Smith, & Gebala, 1994; Shaja & Sudhakar, 2010). The sequence of these activities significantly affects the project completion time and cost. The design of a balancing machine (Fig. 1
                     (a)), for example, comprises 70 activities. Among them, 31 activities are coupled, and their information dependencies are shown in Fig. 1(b), where nodes represent activities and arcs depict the information dependencies among them. Cyclic information flows are common among coupled activities. Moreover, precedence constraints among coupled activities are often unknown and subject to change (Ahmadi, Roemer, & Wang, 2001; Li & Chen, 2014). Because of the presence of information loops and uncertain precedence constraints, formal project scheduling techniques, such as program evaluation and review technique (PERT) and critical path method (CPM), are not applicable (Krishnan & Ulrich, 2001; Tripathy & Eppinger, 2011).

Some researchers (e.g., Bianco & Caramia, 2010, 2012; Chaney, Deckro, & Moore, 2013; Reyck & Herroelen, 1998; Schutt, Feydy, Stuckey, & Wallace, 2013) have relaxed the strict precedence assumption in CPM/PERT by introducing the generalized precedence relations (GPRs). GPRs specify a minimal or a maximal time lag between a pair of activities (Bianco & Caramia, 2012; Reyck & Herroelen, 1998; Weglarz, Jozefowska, Mika, & Waligora, 2011). Although the models with GPRs are useful for planning the timing and sequence of non-coupled activities, they cannot deal with cyclic information flows among coupled activities. Moreover, GPRs assume that the minimal or maximal time lag among activities are known and fixed, while in many situations, such precedence constraints among coupled activities are unknown and subject to change (Ahmadi et al. 2001). Another line of research develop the Graphical Evaluation and Review Technique (GERT), which allows for simulation-based analysis of activity networks with loops. GERT also permits for the calculation of duration distribution for some networks. However, calculating the duration distribution is very difficult even for a simple network. For a complex network, it has to resort to simulation to evaluate the project completion time (Banerjee, Carrillo, & Paul, 2007; Cho & Eppinger, 2005; Smith & Eppinger, 1997).

Recently, there has been a growing interest in applying the design structure matrix (DSM) for scheduling coupled activities (Karniel & Reich, 2009; Qian, Lin, Goh, & Xie, 2011). In a DSM, activities are listed on the left-hand side of the matrix as row headings and across the top row as column headings in the same order (Abdelsalam & Bao, 2006; Yassine, Joglekar, Braha, Eppinger, & Whitney, 2003). The sub-diagonal entries represent forward information transfer from upstream to downstream activities and the super-diagonal entries denote feedbacks from downstream to upstream activities which may force a reworking of upstream activities (Eppinger, 2001; Qian et al., 2011; Steward, 1981). For example, the coupled activities and their information dependencies in balancing machine development is clearly depicted by the DSM shown in Fig. 2
                     , where the diagonal numbers indicate the regular duration of activities, an “H” mark in row j and column i denotes a hard dependency, i.e., activity i must precede activity j, an off-diagonal number in row j and column i indicates the degree of information dependencies among activities, i.e., the percentage of activity j reworked after the completion of activity i.

The advantage of DSM over GERT lies in its tractability. It can provide a concise and clear representation of the information dependencies among coupled activities (Browning, 2001; Karniel & Reich, 2009). It is also easy and straightforward to evaluate the change of activity sequences. Therefore, since its introduction, DSM has gained increasing attention in scheduling coupled activities. In practice, DSM has been used for scheduling development activities at dozens of companies, including Boeing, General Motors, Intel, Rocketdyne, and so on (Ahmadi et al., 2001; Eppinger & Browning, 2012).

A number of models have been developed for scheduling coupled activities in DSM. A common practice is to find a sequence of coupled activities that minimizes the total feedback time (e.g., the total feedback time for the DSM shown in Fig. 2 is 54 days). We refer to such problems as feedback minimization scheduling problems (FMSP). The total feedback time, which is equivalent to the total amount of first-order rework, is a major driver for lengthy and costly product development (Ahmadi et al., 2001; Browning & Eppinger, 2002). Thus, it is accepted that in most cases, finding a sequence of coupled activities with minimum total feedback time can greatly reduces project completion time and costs. For example, Ahmadi et al. (2001) reported that the reordered activity sequence with smaller total feedback time has resulted in significant improvements in both project completion time and costs of the turbopump development at Rocketdyne. Similar findings were reported by Eppinger et al. (1994), Tang, Zheng, Li, and Zhang (2000), Eppinger (2001), Nebiyeloul-Kifle (2005), Tuholski and Tommelein (2010), Luh, Ko, and Ma (2011) and so on. Early on, Steward (1981) developed the DSM method, and suggested that coupled activities should be scheduled, such that the total feedbacks are minimized. Eppinger et al. (1994) introduced the numerical DSM, and proposed several useful strategies for organizing coupled activities in large projects. These pioneering works have greatly advanced our understanding of the DSM method, and have clearly shed light on the FMSP. However, the algorithms presented in these studies rely on human expertise and can only be executed manually.

The FMSP is NP-complete (Ahmadi et al., 2001; McCulley & Bloebaum, 1996; Meier, Yassine, & Browning, 2007); hence, the effectiveness of exact optimization methods is restricted to small instances. Several heuristic approaches have been developed to solve large instances. For example, Rogers (1989) proposed a knowledge-based tool for finding an activity sequence with minimum total feedbacks. Kusiak and Wang (1993) presented a triangularization algorithm to determine the sequence of coupled activities. Tang et al. (2000) presented an effective method for identifying coupled activities and proposed an algorithm for ordering the activities by folding the coupled activities into a single activity. Ahmadi et al. (2001) presented mathematical models for the FMSP, and proposed a block decomposition approach for solving the problem. In particular, the block decomposition approach involves two steps: (1) the coupled activities are grouped into smaller blocks to minimize the total feedbacks among blocks, and (2) the order of coupled activities within each block is optimized to minimize the total feedbacks. However, the problem in the first step is NP-hard and difficult to solve (Yu, Yassine, & Goldberg, 2007). Moreover, this algorithm is not guaranteed to give a better solution than the original one (Qian et al., 2011). More recently, Luh et al. (2011) proposed a simple heuristic for ordering coupled activities. In the heuristic, the activity with minimal ratio of information input and output is placed in front of the sequence until all the coupled activities have been scheduled. Although this algorithm obtains solutions in a relatively short time, it does not guarantee the quality of the solution. Qian et al. (2011) developed a new heuristic approach for large problem instances by exploiting the structural properties of the problem.

The current study also focuses on FMSP, but extends previous research in three important aspects. Firstly, a new formulation of the optimization problem is proposed, which allows us to obtain optimal solutions in a reasonable amount of time for problems up to 40 coupled activities. While using the formulation presented in Ahmadi et al. (2001) and Qian et al. (2011), with same settings, we can only obtain optimum solutions for problems up to 10 coupled activities (See Section 5.1 for more details). Secondly, three new properties of the problem are proposed, which can be used to reduce the total feedback time. Finally, a novel heuristic that is able to provide good solutions for large instances is developed. Computational results show that within the same running time, our approach often yields better solutions than existing state-of-art heuristic.

Assume that a product development project consists of N activities. Among them n activities are coupled. It is relatively easy to identify coupled activities in a project (Meier et al., 2007), and several effective approaches are reported in Steward (1981), Kusiak and Wang (1993), Tang et al. (2000), and so on. In this study, we focus on the more challenging issue of finding an appropriate sequence of many coupled activities.

Let ai
                      be the regular duration of activity i, that is the time needed to complete activity i when there is no rework. Following Eppinger et al. (1994), Krishnan, Eppinger, and Whitney (1997), Ahmadi et al. (2001), Browning and Eppinger (2002), and other pioneering works, we define d
                     
                        i, j
                      (0 ≤ d
                     
                        i, j
                      ≤ 1, and i ≠ j) as the degree of information dependency of activity i on j, i.e., the percentage of activity i reworked after the completion of activity j. Literature (e.g. Ahmadi et al., 2001; Browning & Eppinger, 2002; Eppinger et al., 1994; Krishnan et al., 1997; Lin, Chai, Wong, & Brombacher, 2008) shows that in practice, d
                     
                        i, j
                      can be estimated by multiplying the variability of activity j by the sensitivity of activity i to j. For instance, to quantify the information dependencies between activities 7 and 8 in Fig. 2, we may read through the company's documents and conduct interviews with the relevant designers. The criterions are as follows: if the output of activity 8 is highly (slightly) uncertain, then the variability of activity 8 tends to be large (small); if a slight (substantial) change of output of activity 8 will lead to a large (small) amount of rework in activity 7, then the sensitivity of activity 7 to 8 is large (small). Based on these criterions, the designers quantified the variability and sensitivity of activities 7 and 8 in Fig. 3
                     (a) and (b), respectively. The degree of information dependency shown in Fig. 2 is the product of them.

As demonstrated by Krishnan et al. (1997), Smith and Eppinger (1997), Browning and Eppinger (2002), Cho and Eppinger (2005), Lin, Chai, Brombacher, and Wong (2009), Lin, Qian, Cui, and Miao (2010), Lin, Qian, and Cui (2012), Qian, Xie, Goh, and Lin (2010), Eppinger and Browning (2012), Yang, Yao, Lu, and Zhang (2014) and so on, the data of variability and sensitivity are available in many companies. Thus, d
                     
                        i, j
                      can be estimated with reasonable precision. In the case that these data are not available, we may depict the information relations using a binary DSM, where d
                     
                        i, j
                      = 1 represents that activity i depends on the information input from j, and d
                     
                        i, j
                      = 0 otherwise. The model and algorithm developed in this study can be applied to either a binary DSM or a numerical DSM.

In the current study, if activity i precedes activity j, then d
                     
                        i, j
                      is in the super-diagonal region of a DSM and is regarded as a feedback. As most previous DSM-based activity sequencing models, we study the FMSP. In particular, given a set of coupled activities, assume that there are no resource constraints among them, and the objective is to find an activity sequence that minimizes the total feedback time. Note that the FMSP has some similarities with the “Orienteering Problem” (OP). In the OP, a set of vertices is given, each with a score; the time needed to travel from vertex i to j, t
                     
                        i, j
                     , is known for all vertices, and the objective is to determine a path, limited by a given time budget, that visits some vertices and maximizes the total collected score (Divsalar, Vansteenwegen, Sörensen, & Cattrysse, 2014; Feillet, Dejax, & Gendreau, 2005; Vansteenwegen, Souffriau, & Van Oudheusden, 2011). However, the FMSP differs from the OP in two main aspects. First, in the FMSP, all coupled activities should be sequenced, while in the OP, not all vertices can be visited. Second, as shown in Fig. 4
                     
                     , in determining the sequence of n coupled activities (selected vertices), the objective of FMSP is to minimize the total feedback time, 
                        
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              
                                 n
                                 −
                                 1
                              
                           
                           
                              ∑
                              
                                 j
                                 =
                                 i
                                 +
                                 1
                              
                              n
                           
                           
                              a
                              i
                           
                           
                              d
                              
                                 i
                                 ,
                                 j
                              
                           
                        
                     , while the objective of OP is to minimize the travel time, 
                        
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              
                                 n
                                 −
                                 1
                              
                           
                           
                              t
                              
                                 i
                                 ,
                                 i
                                 +
                                 1
                              
                           
                        
                     .

We define the decision variables as follows: z
                     
                        i, j
                      = 1 if activity i is done before j, z
                     
                        i, j
                      = 0 otherwise. The FMSP can be formulated as the following binary linear programming (BLP), BLP-1:

                        
                           (1)
                           
                              
                                 
                                    (
                                    
                                       BLP
                                       −
                                       1
                                    
                                    )
                                 
                                 
                                 min
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    ∑
                                    
                                       
                                          
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      j
                                                      ≠
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                    n
                                 
                                 
                                    a
                                    i
                                 
                                 
                                    d
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    s
                                    .
                                    t
                                    .
                                 
                                 
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 +
                                 
                                    z
                                    
                                       j
                                       ,
                                       i
                                    
                                 
                                 =
                                 1
                                 ,
                                 
                                 
                                 
                                 for
                                 
                                 1
                                 ≤
                                 i
                                 <
                                 j
                                 ≤
                                 
                                    n
                                    ,
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 +
                                 
                                    z
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                                 +
                                 
                                    z
                                    
                                       k
                                       ,
                                       i
                                    
                                 
                                 ≤
                                 2
                                 ,
                                 
                                 for
                                 
                                 i
                                 <
                                 j
                                 ,
                                 
                                 i
                                 <
                                 k
                                 ,
                                 
                                 and
                                 
                                 j
                                 ≠
                                 k
                                 ,
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    z
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ∈
                                 
                                    {
                                    
                                       0
                                       ,
                                       1
                                    
                                    }
                                 
                                 ,
                                 
                                 
                                 
                                 for
                                 
                                 1
                                 ≤
                                 i
                                 ,
                                 
                                 j
                                 ≤
                                 n
                                 ,
                                 
                                 i
                                 ≠
                                 j
                                 .
                              
                           
                        
                     
                  

The objective function (1) is to minimize total feedback time. It works as follows: if activity i is done before j, then z
                     
                        i, j
                      = 1, i.e., d
                     
                        i, j
                      is a feedback and is included in (1), otherwise z
                     
                        i, j
                      = 0. Constraint (2) specifies that if z
                     
                        i, j
                      = 1, then z
                     
                        j, i
                      must be 0, and vice versa. Clearly, if activity i precedes j, and activity j precedes k, then activity i should precede k. This is guaranteed by constraint (3). Constraint (4) ensures that z
                     
                        i, j
                      are binary variables.

Now define binary decision variables as follows: xim
                      = 1 if activity i is assigned to position m, xim
                      = 0 otherwise; y
                     
                        i, j
                      = 1 if activity i is done before j and d
                     
                        i, j
                      ≠ 0, y
                     
                        i, j
                      = 0 otherwise. As presented in Ahmadi et al. (2001) and Qian et al. (2011), the FMSP can also be formulated as the following BLP-2:

                        
                           (5)
                           
                              
                                 
                                    (
                                    
                                       BLP
                                       −
                                       2
                                    
                                    )
                                 
                                 min
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    ∑
                                    
                                       
                                          
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      j
                                                      ≠
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                    n
                                 
                                 
                                    a
                                    i
                                 
                                 
                                    d
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 
                                    y
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 s
                                 
                                    .
                                    t
                                 
                                 .
                                 
                                 
                                    ∑
                                    
                                       m
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       i
                                       m
                                    
                                 
                                 =
                                 1
                                 ,
                                 
                                 for
                                 
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 ,
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    x
                                    
                                       i
                                       m
                                    
                                 
                                 =
                                 1
                                 ,
                                 
                                 for
                                 
                                 m
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 ,
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    y
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ≥
                                 
                                    x
                                    
                                       i
                                       m
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       h
                                       =
                                       1
                                    
                                    
                                       m
                                       −
                                       1
                                    
                                 
                                 
                                    x
                                    
                                       j
                                       h
                                    
                                 
                                 ,
                                 
                                 
                                    for
                                    
                                    all
                                 
                                 
                                 m
                                 ,
                                 i
                                 
                                 and
                                 
                                 j
                                 
                                 satisfying
                                 
                                 
                                    d
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ≠
                                 0
                                 ,
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    x
                                    
                                       i
                                       m
                                    
                                 
                                 ∈
                                 
                                    {
                                    
                                       0
                                       ,
                                       1
                                    
                                    }
                                 
                                 ,
                                 
                                 for
                                 
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 ;
                                 
                                 m
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                                 .
                              
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    
                                       s
                                       .
                                       t
                                       .
                                    
                                 
                                 
                                 
                                    y
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ∈
                                 
                                    {
                                    
                                       0
                                       ,
                                       1
                                    
                                    }
                                 
                                 ,
                                 
                                 
                                    for
                                    
                                    all
                                 
                                 
                                 i
                                 
                                 and
                                 
                                 j
                                 
                                 satisfying
                                 
                                 
                                    d
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ≠
                                 0
                                 
                                 and
                                 
                                 i
                                 ≠
                                 j
                                 .
                              
                           
                        
                     
                  

In BLP-2, Eq. (6) states that each activity is to be assigned to one position. Eq. (7) states that in each position, exactly one activity is assigned. Eq. (8) ensures that the objective function only sums the feedback values. Constraints (9) and (10) guarantee that xim
                      and y
                     
                        i, j
                      are binary.

The afore-mentioned BLP formulations enable us to solve the FMSP optimally with commercial solvers. In Section 5.1, we will apply the CPLEX BLP-solver to examine the efficiency of BLP-1 and BLP-2.

In this section, we first prove several properties of the FMSP, and then a heuristic approach is developed to solve it.


                        
                           Theorem 1
                           
                              If aid
                              
                                 i, i + 1 > a
                              
                                 i + 1
                              d
                              
                                 i + 1, i
                              
                              , then by swapping the order of activities i and i + 1, the total feedback time can be reduced by (aid
                              
                                 i, i + 1 − a
                              
                                 i + 1
                              d
                              
                                 i + 1, i
                              ).
                           

All the proofs in this section can be found in Appendix A.


                        Theorem 1 indicates that for an initial sequence of activities, {1, 2, …, i − 1, i, i + 1, …, n}, where activity i + 1 immediately follows activity i, if aid
                        
                           i, i + 1 > a
                        
                           i + 1
                        d
                        
                           i + 1, i
                        , then the order of activities i and i + 1 should be reversed.

Next, we develop the rule of exchanging two arbitrary activities for feedback time reduction. Given a sequence of {1, 2, …, i − 1, i, i + 1, …, j − 1, j, j + 1, …, n}, define:

                           
                              (11)
                              
                                 
                                    
                                       θ
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          k
                                          =
                                          i
                                       
                                       
                                          j
                                          −
                                          1
                                       
                                    
                                    
                                       a
                                       k
                                    
                                    
                                       d
                                       
                                          k
                                          ,
                                          j
                                       
                                    
                                    +
                                    
                                       a
                                       i
                                    
                                    
                                       ∑
                                       
                                          k
                                          =
                                          i
                                          +
                                          1
                                       
                                       
                                          j
                                          −
                                          1
                                       
                                    
                                    
                                       d
                                       
                                          i
                                          ,
                                          k
                                       
                                    
                                    −
                                    
                                       ∑
                                       
                                          k
                                          =
                                          i
                                          +
                                          1
                                       
                                       j
                                    
                                    
                                       a
                                       k
                                    
                                    
                                       d
                                       
                                          k
                                          ,
                                          i
                                       
                                    
                                    −
                                    
                                       a
                                       j
                                    
                                    
                                       ∑
                                       
                                          k
                                          =
                                          i
                                          +
                                          1
                                       
                                       
                                          j
                                          −
                                          1
                                       
                                    
                                    
                                       d
                                       
                                          j
                                          ,
                                          k
                                       
                                    
                                    .
                                 
                              
                           
                        
                        
                           Theorem 2
                           
                              If θ
                              
                                 i, j
                               > 0, then by swapping the order of activity i and activity j, the total feedback time can be reduced by θ
                              
                                 i, j
                              
                              .
                           


                        Theorem 2 describes that for an initial sequence of activities, {1, 2, …, i − 1, i, i + 1, …, j − 1, j, j + 1, …, n}, if θ
                        
                           i, j
                         > 0, then the order of activities i and j should be reversed.

The DSM for the turbopump concept design at Rocketdyne, which consists of 27 activities and is constructed based on the detailed interviews with senior project managers (Ahmadi et al., 2001), is used to further illustrate the results above. For easy presentation, four activities are selected whose dependency relations are shown in Fig. 5(a), where the total feedback time is 8.7. Based on Theorem 1, by exchanging the order of activities 1 and 2, the total feedback time can be reduced to 8.1. The resulting DSM is shown in Fig. 5(b). Inspection of activities 1 and 4 in Fig. 5(a) shows that θ
                        1, 4 = 5.8. To make our statement clearer, in Fig. 5(a), the positive items in θ
                        1, 4 are highlighted in blue, and the negative items are highlighted in gray. According to Theorem 2, by swapping activities 1 and 4, the total feedback time can be reduced by 5.8. The resulting DSM is shown in Fig. 5(c).

The next result gives another important property of the FMSP. Suppose that the original sequence of coupled activities is {1, …, h − 1, h, …, i − 1, i, …, j − 1, j, …, r, r + 1, …, n}. Define a subproblem P
                        sub containing activities {h, …, i − 1, i, …, j − 1, j, …, r}.

                           Theorem 3
                           
                              If the sequence of activities in a subproblem is altered, then the change of total feedback time in the overall problem equals to the change in the subproblem.
                           

Based on the results in Section 3.1, this subsection presents an effective heuristic for the FMSP. We first define the following notation:


                        
                           
                              S
                           
                           
                              The initial activity sequence

The improved activity sequence

Total feedback time of the initial activity sequence S
                              

Total feedback time of the improved activity sequence Sim
                                 
                              

The amount of reduction of the total feedback time

The position of the first activity in a subproblem

The position of the last activity in a subproblem

The sequence of activities from position 1 to position M
                                 1 − 1

The sequence of activities from position M
                                 2 + 1 to position n
                              

The sequence of activities from position M
                                 1 to position M
                                 2
                              

A subproblem containing activities from position M
                                 1 to position M
                                 2.

The optimal sequence of activities of the subproblem

The iteration step length, where L is a positive integer and L < M
                                 2 − M
                                 1
                              


                           
                              
                                 
                                    Step 0.
                                 For an initial sequence S, calculate the total feedback time and store the result in F. Set Fim
                                     = F, Sim
                                     = S, Δf
                                     = 1, M
                                    1 = 1. Initialize M
                                    2 and L.

While Δf
                            > 0, do:

                              
                                 
                                    Step 1.
                                 Set mobile-activity i to be the first activity in S.

For the current improved sequence Sim
                                    , evaluate each activity j that follows activity i, calculate θ
                                    
                                       i, j
                                     using (11): if θ
                                    
                                       i, j
                                     > 0, exchange the sequence of activities i and j, update Sim
                                     and set Fim
                                     = Fim
                                     − θ
                                    
                                       i, j
                                    .

Set the next activity in S as a new mobile-activity, and go back to Step 2 until all the activities in S have been considered.

Set Δf
                                     = F − Fim, S = Sim, F = Fim
                                    .

While M
                           2 < n, do:

                              
                                 
                                    Step 5.
                                 Decompose S into S
                                    1, S
                                    b and S
                                    2 and construct a subproblem P
                                    sub. If M
                                    1 = 1, S
                                    1 = ∅.

Compute the optimal solution for P
                                    sub using a commercial BLP solver, and save the result in 
                                       
                                          S
                                          b
                                          *
                                       
                                    .

Concatenate S
                                    1, 
                                       
                                          S
                                          b
                                          *
                                       
                                     and S
                                    2, and save the result in S.


                                    M
                                    1 = M
                                    1 + L, M
                                    2 = M
                                    2 + L.


                           Step 0 initializes the values of the parameters. Then, based on Theorem 2, the loop from Steps 1 to 4 is executed to improve the initial sequence. Specifically, we set the first activity in S as a mobile-activity in Step 1. Then in Step 2, we check each activity j that follows activity i: if θ
                           
                              i, j
                            > 0, then swap the order of activities i and j, save the improved sequence in Sim
                            and the corresponding total feedback time in Fim
                           . Afterward, we set the next activity in S as a new mobile-activity, and go back to Step 2 until all the activities have been set as a mobile-activity. In Step 4, parameter Δf
                            is used to check whether the sequence of the activities is improved or not. If Δf
                            > 0, then the sequence is improved, and so the improved schedule S is used to restart Step 1. If Δf
                            = 0, then the sequence cannot be further improved through Steps 1 to 4.

After that, based on Theorem 3, the loop from Steps 5 to 8 is performed to further improve the sequence of activities. In particular, given the improved sequence, a subproblem P
                           sub, which contains the consecutive activities from position M
                           1 to position M
                           2 (M
                           2 > M
                           1), is constructed in Step 5. In Step 6, the subproblem P
                           sub is solved to optimality by a commercial BLP solver, whereas the other activities in S
                           1 and S
                           2 remain untouched. As indicated in Theorem 3, the change of total feedback time in the overall problem equals to the change in a subproblem. Consequently, in Step 7, an improved sequence of the overall problem is obtained by concatenating S
                           1, 
                              
                                 S
                                 b
                                 *
                              
                            and S
                           2. In Step 8, we set M
                           1 = M
                           1 + L, M
                           2 = M
                           2 + L, where L is a positive integer and L < M
                           2 − M
                           1, such that, in the next iteration, the optimal sequence of a new set of activities, including L activities in S
                           2 and (M
                           2 − M
                           1 − L + 1) activities in the previous iteration, is obtained. This process is repeated until M
                           2 reaches the last activity n (the choice of M
                           2 and L is discussed in detail in Section 5.2).

In order to illustrate the proposed approach, we apply it to the design of balancing machines in a subsidiary of a multinational corporation. The company manufactures a wide range of balancing and diagnosis machines and enjoys a high reputation for the quality of its products. Its customers include almost all major automobile manufacturers such as Volkswagen, General Motors and Ford. There are many types of balancing machines in the company, one of which is analyzed here to illustrate the proposed approach (Fig. 1).

To collect the data for our model, our first step is to read through the available project schedules and identify all the activities involved in the projects. This step is relatively easy because all the activities involved in the projects and their regular duration are well documented in the company. The company executes largely the same process for developing this type of balancing machines, and overall 70 activities are involved in this process. For each activity, we interviewed the relevant designers and asked them: “Which activities must precede your activity”, “Which activities should provide information for completing your activity”, “What is the variability of activity i”, and “What is the sensitivity of your activity to a change from activity i”. Based on these inputs, the information exchanges between the activities are established and a DSM is constructed. To ensure accurate data entries, these records were double checked by the project managers who are familiar with the projects. Note that in the company, designers usually did not know what information they should provide for other activities. Therefore, in designing the questions, it is important to focus on input rather than output. This also coincides with the findings in Eppinger (2001). After that, we apply the method presented in Kusiak and Wang (1993) to identify the coupled activities in the projects. Overall, 31 coupled activities are identified and their information dependencies are shown in Fig. 2.

Based on the DSM in Fig. 2, we apply the proposed approach. Our experimental results show that the new formulation BLP-1 allows us obtaining optimum solutions for problems up to 40 coupled activities. Thus, we set M
                     1 = 1 and M
                     2 = 31, such that the overall problem is solved to optimality. As mentioned earlier, the mark “H” in Fig. 2 represents a hard constraint. To guarantee this, we associate the hard constraints with a large positive value. It is clear that the optimal total feedback time cannot be greater than that of the initial solution. Therefore, as long as the value associated with the hard constraints is greater than the total feedback time of the initial feasible solution, activity i will always be assigned before j if d
                     
                        j, i
                      = “H”. The total feedback time of the initial feasible sequence in Fig. 2 is 54. Hence, we associated the hard dependency “H” with a positive value of 55. By applying the proposed heuristic, we obtain the optimal activity sequence in Fig. 6
                     , where the total feedback time is reduced to 16.

In this section, we first perform a large number of random experiments to examine the efficiency of BLP-1 and BLP-2, and apply the former to three real world problems. Then, we apply the proposed heuristic to a number of random instances, and benchmark the results of our approach with those obtained by existing methods. The proposed heuristic is coded in Matlab, and all the tests are performed on an Acer laptop with an Intel Core 2 Duo T7300 processor and 3 gigahertz memory.

To gain some insights into the size of the BLP-1 and BLP-2 problems that can be solved by means of a commercial solver, a number of random DSMs were generated, and then the BLP-solver of CPLEX 12.6 was applied to solve them to optimality, respectively. Specifically, the DSMs including 10, 20, 30 and 40 activities were tested, and in each DSM, the regular duration of an activity was uniformly distributed in [1,100], and the information dependencies among activities were uniformly distributed in [0,1]. Note that our program runs out of memory when we apply the BLP-solver of CPLEX 12.6 to solve the random instances with 41 activities. Thus, the maximum number of activities tested is 40. According to the literature, the density level is usually less than 0.5. Therefore, the density of a DSM, De
                        , which equals the number of non-zero d
                        
                           i, j
                         divided by n × (n − 1), was set to 0.1, 0.2, 0.3, 0.4, or 0.5.

For each pair of n and De
                        , Table 1 shows the average solution time over 100 instances, where the mark “–” indicates that some problem instances cannot be solved in 2 hours in this setting. The average solution time to BLP-1 is significantly smaller than that to BLP-2. For example, for n = 10 and De
                         = 0.4, the solution time to BLP-1 and BLP-2 is 0.007 and 1043.719 seconds, respectively. This is so because the number of decision variables in BLP-1, n × (n − 1), is smaller than that in BLP-2, [De
                         × n × (n − 1) + n
                        2]. Moreover, the number of inequality constraints in (8) grows with the density, and so the solution time to BLP-2 increases quickly with the density. For instance, for n = 10 coupled activities, when the density increase from 0.2 to 0.3, the average solution time to BLP-2 increases from 5.856 to 65.028 seconds. While in BLP-1, the density will not affect the number of inequality constraints in (3), and thus the impact of density on solution time is relatively small.
                     

To further illustrate the usefulness of BLP-1, we apply the BLP-solver of CPLEX 12.6 based on BLP-1 to three practical problems. The first one is KUSIAK’93, which consists of 7 coupled activities for the design of a vehicle and is considered by Kusiak and Wang (1993). The second one is AHMADI’01, which involves 27 activities for the concept design of turbopumps at Rocketdyne and is published in Ahmadi et al. (2001). The third one is LUH’11, which consists of 15 activities for the development of a power line communication product and is published in Luh et al. (2011). The authors of the papers proposed heuristic algorithms for solving the FMSP, and applied them to these three practical problems, respectively. The original solutions of these problems are shown in Table 2
                        .

However, based on the BLP-1 formulation proposed in this paper, we can easily obtain the optimal solutions of the three problems, which are shown in Figs. 10–12 of Appendix B. Note that in problems KUSIAK’93 and LUH’11, the authors did not take into account the regular duration of activities. Since the setting of the regular duration does not affect the efficiency of our approach, we arbitrarily set ai
                         = 1. As summarized in Table 2, for problem KUSIAK’93, the original solution is optimal. However, for problems AHMADI’01 and LUH’11, the original solutions are not optimal.

To test its performance, the proposed heuristic was applied to a number of large DSMs with 60 and 120 coupled activities. The regular duration of an activity was uniformly distributed in [1,100], the information dependencies among activities were uniformly distributed in [0, 1], and the density levels of a DSM were set to 0.1, 0.2, 0.3, 0.4 and 0.5. In each problem instance, the initial value of M
                        1 in the heuristic algorithm is set to 1, the initial value of M
                        2 is set to 25, 30, or 35, and the BLP-solver of CPLEX 12.6 was applied to solve the subproblems to optimality based on BLP-1. The iteration step length L is set to 
                           
                              
                                 L
                                 1
                              
                              =
                              
                                 
                                    
                                       M
                                       2
                                    
                                    −
                                    
                                       M
                                       1
                                    
                                 
                                 4
                              
                           
                        , 
                           
                              
                                 L
                                 2
                              
                              =
                              
                                 
                                    
                                       M
                                       2
                                    
                                    −
                                    
                                       M
                                       1
                                    
                                 
                                 2
                              
                           
                        , or 
                           
                              
                                 L
                                 3
                              
                              =
                              
                                 
                                    3
                                    (
                                    
                                       
                                          M
                                          2
                                       
                                       −
                                       
                                          M
                                          1
                                       
                                    
                                    )
                                 
                                 4
                              
                           
                        , which is the minimum integer that is larger than 
                           
                              
                                 
                                    M
                                    2
                                 
                                 −
                                 
                                    M
                                    1
                                 
                              
                              4
                           
                        , 
                           
                              
                                 
                                    M
                                    2
                                 
                                 −
                                 
                                    M
                                    1
                                 
                              
                              2
                           
                        , and 
                           
                              
                                 3
                                 (
                                 
                                    
                                       M
                                       2
                                    
                                    −
                                    
                                       M
                                       1
                                    
                                 
                                 )
                              
                              4
                           
                        , respectively. By generating 1000 random instances for each combination of problem size and density level, we tested a total of 10,000 instances.

For large problem instances, the optimal solution is unknown; hence, we use the percentage of reduction of the total feedback time, Pf
                        , to measure the performance of our approach. In particular, let F be the total feedback time of an original DSM, Fim
                         be the total feedback time of the reordered DSM using our approach, then Pf
                         = (F − Fim
                        )/F.


                        Table 3 shows that in most cases, relatively good solutions can be obtained by the proposed approach in short time. For example, for n = 60, density level of 0.2, M
                        2 = 35, and 
                           
                              L
                              =
                              
                                 L
                                 2
                              
                              =
                              
                                 ⌈
                                 
                                    
                                       
                                          M
                                          2
                                       
                                       −
                                       
                                          M
                                          1
                                       
                                    
                                    2
                                 
                                 ⌉
                              
                              ,
                           
                         the average reduction of the total feedback time Pf
                         reaches 61 percent, and the average computational time is only 1.61 seconds. Moreover, Pf
                         increases when the density level of a matrix decreases. In practice, many real DSMs are large and sparse (Eppinger, 2001; Smith & Eppinger, 1997), and the meta-heuristic methods, such as genetic algorithm, cannot effectively deal with them. The reason is that too many solutions in the search space have identical fitness values; thereby, they cannot provide guidance to the best sequence (Meier et al., 2007). The proposed approach is quite promising in solving such problem instances. For example, for the random instances with 120 coupled activities and a density level of 0.1, the average Pf
                         is greater than 62 percent, regardless of the settings of L and M
                        2.

Our computational results show that in most cases, increasing M
                        2 and/or decreasing L results in better solutions. However, the FMSP is NP-complete; thereby, if M
                        2 is too large, then it will be computationally prohibitive. Similarly, if the value of L is too small, then most activities in the subproblem of a new iteration are the same as those of the previous iteration and the total number of iterations will increase substantially. Nonetheless, the change of M
                        2 and/or L does not significantly affect the performance of the algorithm. These results indicate that the proposed heuristic is quite robust.
                     

As mentioned earlier, Qian et al. (2011) developed a new heuristic approach for large problem instances by exploiting the structural properties of the problem. Their approach involves three main steps: (1) exchanging a block of activities with its succeeding activity to reduce the total feedback; (2) constructing subproblems, i.e., selecting activities from position 1 to N
                        1 to obtain the first subproblem, folding the activities into a single activity 1′, and then selecting activity 1′ and the activities from position (N
                        1 + 1) to position (N
                        1 + N
                        2 − 1) to obtain the second problem, repeating this process until the last activity is reached; (3) solving the subproblems with commercial solvers and then concatenating the improved subproblem sequences into an improved sequence of the overall problem.

To compare the performance of our approach with their approach, we coded the procedure of Qian et al. (2011) in Matlab where the BLP-solver of CPLEX 12.6 was applied to solve the subproblems to optimality based on BLP-1. We generated a number of random DSMs with 60 and 120 coupled activities, and then applied our heuristic and the one in Qian et al. (2011) to solve them, respectively. The regular duration of an activity was uniformly distributed in [1,100], the information dependencies among activities were uniformly distributed in [0,1], the density levels of a DSM were set to 0.1, 0.2, 0.3, 0.4 or 0.5, the number of activities in each subproblem is set to 25, 30, or 35. The iteration step length L of our heuristic is set to (M
                        2 − M
                        1 − 1) such that the total number of iterations is the same as those in Qian et al. (2011). By generating 1000 random instances for each problem size and density level, we tested a total of 10,000 instances.

The computational results are shown in Table 4, where the percentage of better solutions is calculated as the number of observations where our results are better than the results derived by Qian et al. (2011), divided by 1000. The results indicate that our approach often yields better solutions than the one in Qian et al. (2011). Moreover, we can obtain even better solutions by decreasing the value of L. For instances, for n = 60, subproblem size of 30 and density levels of 0.1, 0.2, 0.3, 0.4 and 0.5, we set 
                           
                              L
                              =
                              
                                 
                                    
                                       M
                                       2
                                    
                                    −
                                    
                                       M
                                       1
                                    
                                 
                                 2
                              
                              =
                              15
                           
                        , and found that the percentages of better solutions increase to 99.9, 99.8, 99.9, 99.8, and 99.5 percent, respectively.

@&#CONCLUSION@&#

In recent years, DSM has gained increasing attention in scheduling product development projects that consist of numerous coupled activities (Banerjee et al., 2007; Browning, 2001). A common practice is to find a sequence of coupled activities that minimizes the total feedback time. However, the problem is NP-complete, and hence the effectiveness of exact optimization methods is restricted to small instances. The development of heuristic algorithms for large instances is of great importance because many product development projects often involve hundreds of coupled activities. The current study presents a new formulation of the FMSP, which allows us to obtain optimal solutions in a reasonable amount of time for problems up to 40 coupled activities. Computational experiments show that our new formulation is significantly better than the existing one. Another contribution of the current study is that it proposes two simple rules for reducing the total feedback time, and show that the total feedback time in the overall problem can be reduced by optimizing the schedule of a subproblem. Finally, based on the above results, the current study presents an effective approach that is able to provide good heuristic solutions for large instances.

To illustrate the presented approach, we first apply it to the design of balancing machines in an international firm. We show that based on the BLP-1 formulation proposed in this paper we can easily obtain the optimal solutions of the three practical problems, for which only heuristic algorithms can be applied previously. We further perform a large number of random experiments, and show that our approach is quite efficient, in that it yields much better solutions in very short time. Finally, we show that our approach often yields better solutions than the existing state-of-art heuristic.

There are several limitations of the current study. First, the study assumes that the information dependencies among coupled activities are deterministic. This assumption is commonly made in previous DSM-based sequencing models, and is proved to hold in dozens of projects, see e.g. Eppinger et al. (1994), Ahmadi et al. (2001), Eppinger (2001), Browning and Eppinger (2002), Chen and Lin (2003), Nebiyeloul-Kifle (2005), Tang, Zhu, Dai, and Zhang (2009), and Luh et al. (2011). However, there are many projects in which precise information of activity dependencies is unavailable. In a further research effort (Lin, Qian, Yassine, & Cui, 2012), we have developed a model to address uncertain activity dependencies. Second, as in most DSM-based sequencing models (e.g., Ahmadi et al., 2001; Kusiak & Wang, 1993; Luh et al., 2011; Steward, 1981; Tang et al., 2000), the current study aims to minimize the total feedback time. Although this objective is a good proxy of the main goals of project management, such as shorter project cycle time, lower development cost, and lower risk, it may be inappropriate for some projects. Therefore, other objectives of scheduling coupled activities have been proposed. For instance, based on the assumption of pure sequential iteration, Smith and Eppinger (1997) utilize a reward Markov chain approach to calculate the expected completion time for a given sequence of coupled activities. Banerjee et al. (2007) developed mathematical models for the problem, and show that it is extremely difficult to solve. Abdelsalam and Bao (2006) propose a simulated annealing approach to determine the sequence of coupled activities with the goal of minimizing iteration time. Several researchers have developed heuristics for the problem of minimizing total feedback length (see e.g., Meier et al., 2007; Lancaster & Cheng, 2008; Qian & Lin, 2014). We believe that the heuristic proposed in the current study is also applicable for these problems after appropriate modification.
                     
                     
                     
                  

@&#ACKNOWLEDGEMENTS@&#

The authors are very grateful to the anonymous referees and the Department Editor. Their valuable suggestions have helped us improve the paper significantly. This research was support in part by the National Natural Science Foundation of China (Grants 71001084, 71101115 and 71371149), and by the Fundamental Research Funds for the Central Universities (Grant sk2014043).


                     
                        Proof of Theorem 1
                        
                           Fig. 7(a) shows the original DSM, where the sequence of coupled activities are {1, 2, …, i − 1, i, i + 1, …, n}. Fig. 7(b) shows the resulting DSM after swapping the order of activities i and i + 1.

By subtracting the total feedback time in Fig. 7(a) from that in Fig. 7(b), we are left with (aid
                           
                              i, i + 1 − a
                           
                              i + 1
                           d
                           
                              i + 1, i
                           ). Thus, for an initial sequence of activities, {1, 2, …, i − 1, i, i + 1, …, n}, if aid
                           
                              i, i + 1 > a
                           
                              i + 1
                           d
                           
                              i + 1, i
                           , the total feedback time can be reduced by (aid
                           
                              i, i + 1 − a
                           
                              i + 1
                           d
                           
                              i + 1, i
                           ) after exchanging activities i and i + 1.


                     
                        Proof of Theorem 2
                        
                           Fig. 8(a) shows the original DSM, where the sequence of coupled activities is {1, 2, …, i − 1, i, i + 1, …, j − 1, j, j + 1, …, n}. Fig. 8(b) shows the resulting DSM after swapping the order of activities j and i.

Subtracting the total feedback time in Fig. 8(a) from that in Fig. 8(b), we are left with 
                              
                                 
                                    θ
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       =
                                       i
                                    
                                    
                                       j
                                       −
                                       1
                                    
                                 
                                 
                                    a
                                    k
                                 
                                 
                                    d
                                    
                                       k
                                       ,
                                       j
                                    
                                 
                                 +
                                 
                                    a
                                    i
                                 
                                 
                                    ∑
                                    
                                       k
                                       =
                                       i
                                       +
                                       1
                                    
                                    
                                       j
                                       −
                                       1
                                    
                                 
                                 
                                    d
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       k
                                       =
                                       i
                                       +
                                       1
                                    
                                    j
                                 
                                 
                                    a
                                    k
                                 
                                 
                                    d
                                    
                                       k
                                       ,
                                       i
                                    
                                 
                                 −
                                 
                                    a
                                    j
                                 
                                 
                                    ∑
                                    
                                       k
                                       =
                                       i
                                       +
                                       1
                                    
                                    
                                       j
                                       −
                                       1
                                    
                                 
                                 
                                    d
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                              
                           . Therefore, for a sequence of activities {1, 2, …, i − 1, i, i + 1, …, j − 1, j, j + 1, …, n}, if θ
                           
                              i, j
                            > 0, the total feedback time can be reduced by θ
                           
                              i, j
                            after exchanging activities i and j. To make our statement clearer, the positive items in θ
                           
                              i, j
                            are highlighted in blue and the negative items are highlighted in gray in Fig. 8(a) and (b).


                     
                        Proof of Theorem 3
                        As shown in Fig. 9(a), suppose that the original sequence of coupled activities is {1, …, h − 1, h, …, i − 1, i, …, j − 1, j, …, r, r + 1, …, n}. Define a subproblem P
                           sub containing activities {h, …, i − 1, i, …, j − 1, j, …, r}, which are highlighted in blue in Fig. 9.


                           Fig. 9(b) shows the resulting DSM after swapping the order of activities i and j in the subproblem P
                           sub. The change of total feedback time in the subproblem Sb
                            is θ
                           
                              i, j
                           . Inspection of Fig. 9(a) and (b) shows that the feedback values outside the subproblem P
                           sub are not affected by exchanging activities i and j. Therefore, the change of total feedback time in the overall problem also equals to θ
                           
                              i, j
                           .


                     
                     
                  

@&#REFERENCES@&#

