@&#MAIN-TITLE@&#Job-shop local-search move evaluation without direct consideration of the criterion’s value

@&#HIGHLIGHTS@&#


               
                  
                     
                        Highllights
                        
                           
                           We demonstrate the superiority of the makespan estimation over its exact calculation for the purpose of move evaluation.


                        
                        
                           
                           We introduce move evaluation on the basis of a surrogate value of moves’ potential.


                        
                        
                           
                           We present a practical implementation of an evaluator that relies on the introduced potential.


                        
                        
                           
                           We deliver a new upper bound on the well-known benchmark instance yn2


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Move evaluation

Local search

Job-shop

Makespan

Scheduling

@&#ABSTRACT@&#


               
               
                  This article focuses on the evaluation of moves for the local search of the job-shop problem with the makespan criterion. We reason that the omnipresent ranking of moves according to their resulting value of a criterion function makes the local search unnecessarily myopic. Consequently, we introduce an alternative evaluation that relies on a surrogate quantity of the move’s potential, which is related to, but not strongly coupled with, the bare criterion. The approach is confirmed by empirical tests, where the proposed evaluator delivers a new upper bound on the well-known benchmark test yn2. The line of the argumentation also shows that by sacrificing accuracy the established makespan estimators unintentionally improve on the move evaluation in comparison to the exact makespan calculation, in contrast to the belief that the reliance on estimation degrades the optimization results.
               
            

@&#INTRODUCTION@&#

Local search (Vaessens, Aarts, and Lenstra, 1996) is a popular method for tackling the deterministic job-shop scheduling problem with the makespan criterion (Jain and Meeran, 1999). The strength of the approach depends on the properties of the chosen neighborhood (Mattfeld, 1996), which is usually either limited to swap moves (Laarhoven, Aarts, and Lenstra, 1992; Nowicki and Smutnicki, 1996; 2005; Watson, Howe, and Whitley, 2006; Beck, Feng, and Watson, 2011) or consists of insertion moves (Dell’Amico and Trubian, 1993; Balas and Vazacopoulos, 1998; Murovec and Suhel, 2004; Fernandes and Lourenco, 2008; Zhang, Li, Rao, and Guan, 2008b; Li, Pan, and Xie, 2010). Insertion neighborhoods in job-shop scheduling are discussed in Mattfeld (1996) and Grabowski and Wodecki (2005), whereas the swap neighborhood of Nowicki and Smutnicki (1996) is analyzed in Jain, Rangaswamy, and Meeran (2000); additional discussion is given in Watson et al. (2006). Jain et al. (2000) and Li, Pan, and Xie (2010) take into consideration several critical paths of a schedule.

Besides the choice of a neighborhood, the crucial issue of any local-search implementation is the selection of moves to be applied to a schedule in the course of the optimization. The omnipresent opinion is that the best way to evaluate the moves is to consider their resulting value of a criterion function. Criterion evaluation is time consuming and may account for the majority of the optimization time (Eikelder, Aarts, Verhoeven, and Aarts, 1997), which motivated Nowicki and Smutnicki (2005) to develop a method for an exact makespan determination without any recalculation of heads, whereas Mati, Dauzère-Pérès, and Lahlou (2011) further improve on this approach. So far, these methods are only applicable to swap neighborhoods.

The use of criterion estimators (Taillard, 1994; Dell’Amico and Trubian, 1993; Balas and Vazacopoulos, 1998; Grabowski and Wodecki, 2005; Braune, Zäpfel, and Affenzeller, 2013) is another technique for boosting performance, although estimators are considered a nuisance, and algorithm designers prefer to avoid them whenever feasible. Nowicki and Smutnicki (1996); 2005) preserve a reliance on an exact makespan calculation due to the low cardinality of their neighborhood. Eikelder, Aarts, Verhoeven, and Aarts (1997) regard the loss of accuracy due to the use of an estimation as a drawback. Jain et al. (1998) combine an estimation with an exact calculation in order to alleviate the consequences of the loss of accuracy, despite their empirical tests that show a slight improvement of the estimation-obtained results in comparison to the use of an exact calculation. Similarly, Zhang, Shao, Rao, and Qiu (2008a) conclude that empirical tests fail to confirm the superiority of the exact evaluation in comparison to the estimation.

Despite the mentioned empirical hints, the belief in the superiority of an exact-criterion move evaluation remains firmly in place. In contrast, we reason that estimators in the role of move evaluators can better guide the local search into promising areas of the solution space than the exact criterion calculation does, since the former are capable of detecting certain prospects of moves, which are invisible to the latter. The situation resembles a chess game, where it is crucial not only to make moves that capture your opponent’s pieces, but longer-term merits also need to be taken good care of as well. The myopia is the main weakness of local search and makes optimization highly susceptible to entrap in dense local minima (Mattfeld, 1996). Resorting to an exact criterion for the move evaluation makes the situation as worse as possible, since in this way really only the immediate benefits of moves are taken into account.

On the other hand, the estimators are unintentionally capable of spotting at least some of the non-immediate benefits of the moves, due to the fact that they examine only a confined part of the schedule around a perturbation. Consequently, the beneficiary structural changes to a schedule have a chance of being detected, even when the isolated application of a move does not improve the criterion’s value by itself. Hence, we postulate that estimators reduce the myopic nature of a local search, at least to some extent (Section 2).

It is possible to develop the idea further and disregard the criterion’s value (exact or estimated) in favor of a move evaluation according to a surrogate value of the move’s potential, by means of which the focus of the evaluation is shifted away from a criterion delivery to a genuine detection of the beneficiary properties of moves (Section 3). Such an evaluation is expected to better guide a local search into promising regions of the solution space, which is confirmed with empirical tests (Section 4) where our evaluator delivers a new upper bound on the well-known benchmark test yn2.

Estimators have the ability to reduce the myopia of a local search in comparison to an exact criterion evaluation. Let us explain this idea with the aid of Fig. 1
                     , which presents three schedules of a sample job-shop instance. The jobs that the operations belong to are denoted by letters from a to d, whereas the operations’ processing sequences within their respective jobs are prescribed by the numbers following the letters. The operations on the selected critical path are boldfaced.


The makespan of the top schedule equals ten, which is the length of the critical path through the operations a1, a2, b1 and c2. For this schedule there is no swap or insertion move that could decrease the makespan by itself due to the existence of another critical path through the operations d1, d2, c1 and c2. The schedule is entrapped in a local minimum in the sense that the exact makespan in the role of a move evaluator cannot declare any move as being potentially improving. In order to reduce the makespan, the length of all the critical paths in the schedule must be reduced, which, in this case, cannot be done by any isolated move in any classically defined neighborhood.

On the other hand, the estimation of Taillard (1994) evaluates a swap move according to the maximum resulting path lengths through the swapped operations, whereas the rest of the schedule is ignored. The stated ignorance is precisely the beneficiary property that enhances the evaluation’s insight. Due to this property, the swap of the operations a2 and b1 in the top schedule of Fig. 1 is correctly recognized as potentially improving, since it reduces the lengths of the paths through these two critical operations.

The middle schedule in Fig. 1 shows the result of applying the discussed move to the initial schedule. The resulting makespan is still ten. Nonetheless, the new longest path through the operation b1 passes through the nodes b1, a2 and c2, and weights seven. Similarly, the new longest path through a2 goes through the nodes a1, a2 and c2, and weights eight. The result of the estimation is the longest of the two lengths (eight), which is less than the initial makespan (ten), by means of which the estimator is able to declare the move as potentially improving.

The new schedule possesses only one critical path, so now the estimation as well as the exact calculation is able to recognize the swap of operations d2 and c1 as potentially improving. The result of its application is shown at the bottom of Fig. 1, where the resulting makespan equals eight.

In the discussed example, the estimation of Taillard (1994) is able to directly guide the plain steepest-descent optimization from the initial to the final schedule. In contrast, the exact makespan calculation is entrapped in the local minimum and requires a metaheuristic mechanism to escape it. Hence, it is reasonable to conclude that the estimator of Taillard (1994) strengthens the intensification phase of the optimization by being able to remove a certain number of local minima from a solution’s landscape because of its (unintentionally) less myopic move evaluation.

Similar examples can be constructed for other neighborhoods and estimators. Specifically, the estimator lpath of Dell’Amico and Trubian (1993), which extends the idea of Taillard (1994) to also cover insertion moves, is worth discussing. This estimator is still in the spotlight, despite being fairly old, since its results are as accurate as any achievable with a computational complexity of O(n), where n is the number of operations with a changed machine processing order. Even the present job-shop set ups frequently still rely on the original idea of lpath, although certain modifications may be incorporated. For example, Braune et al. (2013) deal with the issue of a lower bound, by means of which the procedure lpath can be brought closer to the exact criterion calculation (by also increasing the computational demand).

The persistent attractiveness of the procedure lpath is primarily due to a ubiquitous belief in the superiority of move evaluation on the basis of a resulting criterion’s value. This procedure achieves a fairly good accuracy (Balas and Vazacopoulos, 1998) with a modest computational demand. Lowering the complexity of the estimator results in a significant loss of accuracy, whereas an increase in the accuracy also noticeably raises the computational demand. Hence, the underlying idea of the procedure lpath will continue to be attractive as long as the ranking of moves is based on their criterion’s value.

The previous discussion raises an interesting question: why not completely ignore the value of the criterion and evaluate the moves solely on the basis of a surrogate measure of their potential as an indicator of their beneficiary properties? Specifically, if the length of the path through a critical operation is shortened by a move, then the move is potentially improving, regardless of the resulting criterion’s value (Section 2), whereas the lengthening of the same path results in a schedule deterioration (aside from makespan, the reasoning applies to some extent to any regular criterion). Therefore, one possible definition of a move’s potential is the difference between the length of the path through a moving operation before and after the application of a move. A positive value of this quantity indicates that there is room for improvement, whereas the opposite sign means a degradation.


The pseudo code in Fig. 2
                     implements the outlined idea. The annotations Q
                     F(u, v) and Q
                     B(u, v) indicate a forward- and a backward-insertion move, respectively. The immediate job predecessor and the immediate job successor of the operation x are denoted as PJ(x) and SJ(x), respectively. Similarly, the immediate machine predecessor and the immediate machine successor of x are denoted as PM(x) and SM(x), respectively. The sum of the operation’s processing time px
                      and its head is abbreviated as ex
                      (end time), whereas the sum of the operation’s tail and its processing time is denoted as sx
                     . The makespan of a schedule is C
                     max .

The description of the algorithm for Q
                     F(u, v) is as follows. Let 
                        
                           O
                           (
                           u
                           ,
                           v
                           )
                        
                      denote the set of all the operations from u to v (inclusive) in their machine processing order. A move Q
                     F(u, v) puts the operation u immediately after the operation v in the new order. The steps from 1 to 5 estimate the new end time of the operation v. In step 1 the operation u is assigned to a working variable a. The variable e′ holds the end time of the machine predecessor of u. After step 3 is executed for the first time, variable a holds the immediate machine successor of u, which is the first operation in the set 
                        
                           O
                           (
                           u
                           ,
                           v
                           )
                           ∖
                           {
                           u
                           }
                        
                     . For this operation the new head is established in step 4 as max (e′, e
                     PJ(a)); the associated end time is obtained by adding the processing time pa
                      to the head in the same step.

Upon the second iteration of the loop, the end time of the second operation in the set 
                        
                           O
                           (
                           u
                           ,
                           v
                           )
                           ∖
                           {
                           u
                           }
                        
                      is estimated. The process repeats until the end time of v is estimated. In step 6 the end time of u is estimated and assigned to the variable e′ in the same way. Step 7 calculates the tail of u, by means of which the new longest path through u is estimated as (e′ + q′). Step 8 estimates the potential of a move by subtracting (e′ + q′) from the current makespan (C
                     max  is the current path length through u under the presumption that u is critical). Therefore, the potential is the estimated difference between the longest path through u before and after the move is applied.

Existing local-search implementations rely on the tight coupling between the value of a criterion function and the resulting value of a move evaluation. In contrast, the introduced potential at least partially decouples this relation, which raises a question about its suitability for integration into existing local-search frameworks. The issue is resolved by the following property.

                           Property
                           
                              If the moving operation of a move Q
                              F(u, v) or Q
                              B(u, v) is critical before applying the move, and the schedule is feasible before and after the move is applied, then the quantity (C
                              max  − potential) behaves as an imprecise makespan estimation and can safely substitute the established move-evaluation results (exact or estimating) in local-search algorithms.
                           

(For Q
                              F(u, v) only.) If the estimated new longest path through u is shorter than the old one, then the obtained potential is positive and its value estimates the amount of shortening. Accordingly, as far as the operation u is concerned, the makespan of a schedule could be reduced by the amount of potential. Hence, (C
                              max  − potential) is a valid (albeit imprecise) estimation of the new makespan. On the other hand, when the new path is longer than before, then u is still critical (Balas and Vazacopoulos, 1998), whereas the obtained potential is negative and its absolute value estimates the amount of the path-length increase. Consequently, the increase of the makespan is estimated to be equal to − potential, which again leads to the new makespan estimation of (C
                              max  − potential). The border case of a zero result can be regarded as a positive or negative case.□

The stated property opens up the possibility to regard the proposed evaluator as yet another makespan estimator. However, if this were its primary role, there would be little rationale in deliberately reducing the accuracy of the delivered makespans in comparison to the established estimators. On the contrary, the proposed procedure is semantically properly viewed as an indicator of the moves’ beneficiary contributions, whereas the previous property should be utilized solely as an assurance that the proposed evaluator can be directly integrated into the existing local-search frameworks.

Further, the value of C
                        max , from which the potential is subtracted in the formula (C
                        max  − potential), is merely an offset that shifts all the evaluation results within a single local-search step for the same amount, by means of which it cannot rearrange the moves’ ranking. If a (suitably adapted) local search consumes the value of the potential directly, it can rely on the sign of the delivered value for discriminating potentially improving moves from the non-improving ones. For example, a steepest-descent optimization would terminate as soon as a neighborhood did not contain any move with a positive potential.

An additional minor side benefit of our evaluator is its smaller computational demand in comparison to the reference estimator lpath of Dell’Amico and Trubian (1993), although the asymptotic complexity is 
                           
                              O
                              (
                              |
                              O
                              (
                              u
                              ,
                              v
                              )
                              |
                              )
                           
                         in both cases. The procedure lpath requires two separate iterations of the sequence 
                           
                              O
                              (
                              u
                              ,
                              v
                              )
                           
                        : one to estimate the heads and the other to estimate the tails. On the other hand, our evaluator requires only a single iteration of the same sequence. In addition, the procedure lpath needs to identify the length of the longest path among all the calculated paths, which requires one additional conditional statement per each iteration of the second loop. Consequently, our evaluator runs more than twice as fast as the reference estimator.

The proposed evaluator was tested with a genetic local search (supplementary material) that implements three move evaluators and five neighborhoods (one combination at a time). The tested evaluators are: the exact makespan calculation, the estimator of Dell’Amico and Trubian (1993), and the proposition of this paper. In the following these are denoted as 
                        
                           E
                           ,
                        
                     
                     
                        D
                      and 
                        
                           M
                           ,
                        
                      respectively. The tested neighborhoods are the ones of Nowicki and Smutnicki (1996),Laarhoven et al. (1992), the neighborhood NB of Dell’Amico and Trubian (1993),Balas and Vazacopoulos (1998), and Murovec and Suhel (2004). Their respective denotations are 
                        
                           
                              N
                              N
                           
                           ,
                        
                     
                     
                        
                           
                              N
                              L
                           
                           ,
                        
                     
                     
                        
                           
                              N
                              D
                           
                           ,
                        
                     
                     
                        
                           N
                           B
                        
                      and 
                        
                           N
                           M
                        
                     .

Each combination of the selected neighborhoods and evaluators was inputted with forty-nine well-known benchmark instances that are known to be hard and still remain open many years after they were introduced. These are abz8–abz9 (Adams, Balas, and Zawack, 1988), swv03–swv04, swv06–swv12, swv15 (Storer et al., 1992), yn1–yn4 (Yamada and Nakano, 1992), and ta11–ta13, ta15–ta16, ta18–ta30, ta32–ta34, ta40–ta50 (Taillard, 1993). In addition, the instance ft10 (Fisher and Thompson, 1963) has been added to the set because of its historical importance, although it is not considered a challenge any more.

Each combination of the selected test instances, neighborhoods and evaluation procedures was conducted five hundred times. Detailed results of the tests are rendered in Appendix  A. A significant outcome is the achievement of a new upper bound of 906 for the instance yn2 by the evaluator 
                        M
                      (Table A.8).

In the following we present an aggregated summary of the outcomes. Table 1
                     reports on the number of instances for which a certain evaluator delivered the best obtained result within the scope of the individual neighborhoods, separately for the minimal (min.) and average (avg.) makespans. The numbers outside of the parentheses (columns 2–4) count the instances for which the associated evaluator delivered the best obtained makespan; if the same makespan was achieved with several evaluators, then the success was attributed to all the winners. In contrast, the numbers in parentheses count only the occurrences where the evaluator truly outperformed the other two, by being the only one who achieved the best result.

Two important outcomes are readily seen from the data. First, the use of the exact calculation gives noticeably worse results in comparison to both of the other evaluators, regardless of the used neighborhood (column 2 in comparison to 3 and 4, as well as column 6 in comparison to 7 and 8). Specifically, the evaluator 
                        E
                      in conjunction with the neighborhood 
                        
                           N
                           L
                        
                      was able to deliver the best result for eleven instances, whereas it truly outperformed the other two evaluators in eight instances (field B2). The comparative numbers for the evaluators 
                        D
                      and 
                        M
                      within the same neighborhood are 19 (17) and 24 (20), respectively (fields B3 and B4). The figures for the evaluator 
                        E
                      are even less favorable with the other neighborhoods. The outcome confirms the line of reasoning in Section 2.

Second, the evaluator 
                        M
                      outperforms the estimator 
                        D
                      for all the tested combinations, except on the one where both evaluators are even (fields D3–D4). This confirms that our proposition better guides the local search into promising regions of the solution space.


                     Table 2
                     reports on the averaged makespan percent excesses, calculated using the following broadly-used formula, where C
                     max  denotes a resulting makespan, whereas UB is the known upper bound of an instance.

                        
                           
                              
                                 
                                    C
                                    max
                                 
                                 
                                 excess
                                 
                                 
                                    [
                                    percent
                                    ]
                                 
                                 =
                                 
                                    
                                       
                                          C
                                          max
                                       
                                       −
                                       UB
                                    
                                    UB
                                 
                                 ×
                                 100
                              
                           
                        
                     Evaluator 
                        E
                      again lags behind the other two evaluations, regardless of the used neighborhood (column 2 versus 3 and 4, as well as column 6 versus 7 and 8). In the case of average makespans, the evaluator 
                        M
                      outperforms the estimator 
                        D
                      in conjunction with all the neighborhoods (column 8 versus 7). In contrast, the estimator 
                        D
                      in conjunction with the neighborhoods 
                        
                           N
                           B
                        
                      and 
                        
                           N
                           M
                        
                      outperforms the evaluator 
                        M
                      on excesses that are related to the minimal makespans (fields D3 and E3 versus D4 and E4, respectively). The outcome is significant, since we are much more interested in the minimal than the average makespans. Despite the stated observation, we still regard the evaluator 
                        M
                      as the strongest one, since the two mentioned margins are truly small, whereas the evaluator 
                        M
                      is nonetheless able to deliver minimal makespans on more instances than the estimator 
                        D
                      
                     (Table 1). In addition, the former delivered the new upper bound on the instance yn2, whereas the latter did not achieve it.

Aside from the delivered results, the algorithms are also judged according to their speed of execution. Table 3
                     presents the sum of the average execution times for each instance in minutes (columns from 2 to 4) separately for each evaluator. The ratios between the different evaluators within the scope of each tested neighborhood are also given (columns from 6 to 8). Column 5 outlines the winning evaluator.

The evaluator 
                        E
                      is again clearly the worst performer. Its running times are from eight (neighborhood 
                        
                           N
                           N
                        
                     ; field A6) to thirty-three (neighborhood 
                        
                           N
                           M
                        
                     ; field E6) times larger than with the other two evaluators (columns 7 and 8). The evaluator 
                        M
                      outperforms the estimator 
                        
                           D
                           ,
                        
                      regardless of the used neighborhood. With neighborhood 
                        
                           
                              N
                              N
                           
                           ,
                        
                      the advantage of the former is a minuscule 1 percent (field A7), whereas with the neighborhood 
                        
                           N
                           M
                        
                      the size of the gap is 22 percent (field E7).

Neither the accelerator of Nowicki and Smutnicki (2005) nor the one of Mati et al. (2011) has been used to speedup the calculations in the case of evaluator 
                        E
                     . These speedups would narrow the gap between 
                        E
                      and the other evaluators in terms of execution speed; however, they are applicable only in conjunction with the neighborhoods 
                        
                           N
                           N
                        
                      and 
                        
                           N
                           L
                        
                     . Besides, Tables 1 and 2 clearly show that the evaluator 
                        E
                      would not be favored, even if its execution speed is on a par with the other two evaluators.

@&#CONCLUSION@&#

The paper delivers two main contributions. Firstly, it exposes the deficiency of contemporary move evaluators that strive to deliver the resulting value of a criterion function, which results in an unnecessarily myopic behavior of the local search. Secondly, in order to improve on the current state of affairs, we introduce the new evaluator, which abandons the goal of criterion delivery in favor of indicating the beneficiary properties of moves. Empirical tests confirm that within the utilized proof-of-concept test framework our evaluator better guides the optimization process in comparison to other considered evaluators. As a minor benefit, the proposition also slightly boosts the speed of the execution.


                     Tables A.4–A.8
                     
                     
                     
                     
                     render the optimization results separately for each tested neighborhood. Columns 1 and 2 list tested instances together with their known upper bounds. Columns from 3 to 5 present the minimal obtained makespans among all five hundred runs when evaluating moves with exact makespan calculation (
                        E
                     ), estimation of Dell’Amico and Trubian (
                        D
                     ) and the proposition of this article (
                        M
                     ), respectively. For the convenience of browsing, column 6 lists the winning evaluation(s). Columns from 7 to 10 report on the average obtained makespans in an identical way.

Supplementary material associated with this article can be found, in the online version, at 10.1016/j.ejor.2014.08.044.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

