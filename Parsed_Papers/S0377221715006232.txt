@&#MAIN-TITLE@&#The multiple container loading problem with preference

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We investigate a practical container loading problem that consider user preference.


                        
                        
                           
                           We show how to incorporate our formulation in real life decision making process.


                        
                        
                           
                           We statistically estimate the impact of data characteristics to SCLP performance.


                        
                        
                           
                           We consider estimated SCLP performance in the high level planning of our heuristic.


                        
                        
                           
                           We demonstrate effectiveness of our approach based on realistic test instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Packing

Decision support

Combinatorial optimization

Statistical estimation

@&#ABSTRACT@&#


               
               
                  An international audio equipment manufacturer would like to help its customers reduce unit shipping costs by adjusting order quantity according to product preference. We introduce the problem faced by the manufacturer as the Multiple Container Loading Problem with Preference (MCLPP) and propose a combinatorial formulation for the MCLPP. We develop a two-phase algorithm to solve the problem. In phase one, we estimate the most promising region of the solution space based on performance statistics of the sub-problem solver. In phase two, we find a feasible solution in the promising region by solving a series of 3D orthogonal packing problems. A unique feature of our approach is that we try to estimate the average capability of the sub-routine algorithm for the single container loading problem in phase one and take it into account in the overall planning. To obtain a useful estimate, we randomly generate a large set of single container loading problem instances that are statistically similar to the manufacturer’s historical order data. We generate a large set of test instances based on the historical data provided by the manufacturer and conduct extensive computational experiments to demonstrate the effectiveness of our approach.
               
            

@&#INTRODUCTION@&#

Our team collaborates with an international audio equipment manufacturer to solve problems that had emerged in its logistics process. The manufacturer receives hundreds of purchase orders every day from all over the world. One of our tasks is to design loading plans for each purchase order so as to minimize the per-dollar shipping cost. The per-dollar shipping cost is defined as the total shipping cost divided by the total dollar value of the items shipped. Minimizing the per-dollar shipping cost will reduce the unit cost thus the sales price of the manufacture’s products, thereby improving its competitiveness in the market.

Currently, when fulfilling a purchase order, the manufacturer loads various items into containers in a sequential manner. As a result, all containers are almost fully utilized – except the last one. With regard to the last container, the manufacturer faces two common scenarios: either this container contains a small set of items, or it is quite full, but still has room for several items. Slightly decreasing the order quantity in the first scenario and slightly increasing the order quantity in the second scenario will likely reduce the per-dollar shipping cost.

A discussion with the manufacturer’s sales team reveals that recommending adjustments in order quantity is a viable option. Firstly, customers usually determine their order quantities based on forecasts, and forecasts are not accurate anyway. Therefore, most customers are willing to adjust their orders for sound reasons. Secondly, as mentioned above, reducing per-dollar shipping cost abates the unit cost of each item in the order, which allows the customer to increase their profit and their competitive advantage. Last, but not least, customers place orders regularly, and a slight change in a given order’s quantity can always be compensated by an opposite change in the next order, if desired.

Consequently, the sales team would like to develop a decision support tool that will help their customers decide on the best order quantity to minimize their per-dollar shipping costs. The tool will be incorporated into the manufacturer’s order-taking process and will work as follows.

                        
                           •
                           
                              Step 1. The sales team receives a purchase order from a customer and produces an initial loading plan using state-of-the-art multiple container loading software. If the ordered items nicely utilize all containers, the sales team continues with the normal order-taking process (i.e., checking inventory, etc.).


                              Step 2. If one of the two scenarios for the last container occurs, the sales team runs our tool. The tool will slightly adjust the order quantity and produce an alternative loading plan so that the per-dollar shipping cost is reduced as much as possible. The sales team then sends back the adjusted order, together with the corresponding loading plan, and explains to the customer why the adjusted order is beneficial.


                              Step 3. The customer may stick to its original order, switch to the recommended order, or set certain restrictions and ask the sales team to adjust again. Once the customer decides on the order quantity, the sales team continues with the normal order-taking process.

For the decision support tool to be applicable, the adjustment must be easy to explain to the customers. A further discussion with the manufacturer sets the following criteria.


                     Unidirectional adjustment: We can either increase or decrease the order quantity, but we cannot do both at the same time. Theoretically speaking, the loading plan with the minimum per-dollar shipping cost may be obtained by increasing the quantity of some products and decreasing the quantity of other products at the same time. However, such changes cause a large deviation from the original order and, thus, are hard to explain to customers. There is a danger of the alteration being misunderstood as a move to take advantage of customers for the purpose of inventory control. In contrast, it is much easier for the alteration to be accepted if the manufacturer says, “these few items require a separate container, and we recommend you remove them to save shipping costs” or “the last container is almost full, but it has room for a few more items, so we recommend that you load more items.”


                     No piggyback: Products not in the original order will not be introduced into the adjusted order. The manufacturer produces many different products, and a customer usually orders a small subset of these products. It is very hard to predict which additional products the customer may like. Therefore, it is much safer to increase the quantity of existing products in the original order than recommend new products, which the customer may not like at all. This criterion is not as restrictive as it seems. For example, if a customer does not mind including additional products selected from a specific list, we can handle the situation by taking the list into consideration when adjusting the order quantity.


                     Bounded quantity: The quantity of each product in the adjusted order must fall within a given range. There are three reasons for setting a bound on the adjustment of product quantity. Firstly, the inventory or production capacity sets an upper bound (although, for most products, we can safely ignore this). Secondly, customers rarely accept dramatic changes, such as doubling or halving the quantity of one product, though they are willing to consider milder changes. Thirdly, the sales team does not want to reduce the order quantity by too much, since this reduces profit. However, if a slight reduction in order quantity results in a noticeable reduction in per-dollar shipping costs, the manufacturer has an incentive to help the customers in an effort to maintain a long-term relationship.


                     Preference-driven: Order quantity should be increased or decreased according to product preferences. We expect our decision support tool to be useful in various practical situations, although its primary motivation is to minimize per-dollar shipping cost. For this purpose, we use preference instead of dollar value to evaluate each product and, thus, change the objective to minimizing shipping cost per unit preference, which is defined as the total shipping cost divided by the total preference of loaded items. There are a few indicators that may determine a product’s preference, such as delivery deadline, shelf life, and dollar value. For instance, fashion products have shorter shelf lives than ordinary products, and we should make sure that fashion products are delivered as soon as possible. In this case, shelf life should be used as the preference indicator, and a high preference will be assigned to a fashion product. Furthermore, the preference of a product may be determined by different indicators in different situations. As an example, if only fashion products are being delivered, dollar value may be used as the preference indicator instead of shelf life. In more complicated situations, several indicators may be combined to determine a product’s preference.

To summarize, the manufacturer’s sales team needs a tool that adjusts order quantity according to product preferences, while satisfying certain constraints, and that generates loading plans for the adjusted order so that the shipping cost per unit preference is minimized. We name the resulting optimization problem the Multiple Container Loading Problem with Preference (MCLPP), and it is formally defined in Section 3.

In Section 4, we propose a combinatorial formulation for the MCLPP based on the concept of pattern sets. Each pattern set is a group of shipping plans with the same total shipping cost and total product preference. We further show that an optimal solution to the MCLPP must lie in one dominating pattern set. Therefore, we can focus on identifying dominating pattern sets before searching for a solution to the MCLPP.

Accordingly, a two-phase heuristic is developed for the MCLPP, as described in Section 5. In phase one, we try to quickly estimate the dominating pattern sets instead of invoking the time-consuming sub-problem solvers. The estimation is based on the performance statistics of sub-problem solvers for randomly generated MCLPP instances with similar characteristics of MCLPP instances (see Section 6.2). In phase two, we consider each of the estimated dominating pattern sets in turn and try to identify a feasible solution to the MCLPP in the pattern set’s vicinity.

We generate two classes of test data, corresponding to two different application scenarios from Section 6, based on historical data provided by the audio equipment manufacturer. We conduct extensive computational experiments to demonstrate the effectiveness of our approach.

@&#LITERATURE REVIEW@&#

To our best knowledge, there is no literature concerned with the MCLPP. However, the MCLPP can be considered an extension of the Multiple Container Loading Cost Minimization Problem (MCLCMP). In the MCLCMP, a set of small cuboids (boxes) and various large cuboids (containers) are given and the objective is to pack all boxes orthogonally into containers and minimize the total cost of used containers. It is classified as a variant of either the multiple stock-size cutting stock problem or the multiple bin-size bin packing problem, depending on the heterogeneity of the boxes, under the improved typology of cutting and packing problems proposed by Wäscher, Haußner, and Schumann (2007). The major difference between the MCLPP and the MCLCMP is that, in the MCLPP, the purchase order can be changed slightly according to product preference.

Several algorithms have been developed to solve the MCLCMP in the literature. It is first studied by Eley (2003) who developed a bottleneck assignment approach. The author proposed a set cover model for the MCLCMP and then tried to solve it using the column generation method. One important feature of this approach is that packing patterns (columns) are generated in advance using a tree search based heuristic. Che, Huang, Lim, and Zhu (2011) extended the set cover model by adding a loading factor parameter α to exploit the excess capacity of the chosen containers and performed a binary search on α. All the extended set cover formulations with different values of α were solved by the column generation method, which is similar to that in the bottleneck assignment approach. However, three fast heuristic strategies were developed for generating packing patterns. It is obvious that the quantity and quality of the pre-generated packing patterns have a great impact on the performance of the column generation method. Zhu, Huang, and Lim (2012a) presented a prototype column generation strategy, where prototype columns played similar roles as actual columns (feasible solutions to the pricing problem) in the column generation method. These prototypes were realized into feasible packing patterns using a hill-climbing single container loading algorithm only when required. Alvarez-Valdes, Parreño, and Tamarit (2013) proposed a two-phase algorithm for the MCLCMP. In the first phase, a GRASP algorithm, including a constructive procedure and a postprocessing procedure, is called to solve the MCLCMP. Then in the second phase, the best solutions generated by the GRASP algorithm are combined based on some Path Relinking strategies. The authors also proposed two simple lower bounds for the MCLCMP. Wei, Zhu, and Lim (2015) combined the prototype column generation strategy with a goal-driven approach to take advantage of the special structure of the MCLCMP solution space that would further enhance the search procedure. They also devised a post-improvement procedure to reduce the cost of feasible MCLCMP solutions by replacing existing containers with cheaper ones.

Another group of relevant literature is about the 3-Dimensional Bin Packing Problem (3D-BPP), which is a special case of the MCLCMP. In the 3D-BPP, only single type of large cuboids (bins) is available and thus the objective is reduced to minimizing the number of used bins. The 3D-BPP has been well studied in the literature (Crainic, Perboli, & Tadei, 2008, 2009; Faroe, Pisinger, & Zachariasen, 2003; Fekete & van der Veen, 2007; Lodi, Martello, & Vigo, 2002; Martello, Pisinger, & Vigo, 2000; Parreño, Alvarez-Valdes, Oliveira, & Tamarit, 2008; Verweij, 1996). However, most of the approaches developed for the 3D-BPP cannot be simply adapted to solve the MCLPP because of the adjustment criteria.

A significant feature of the MCLPP is that products are associated with preferences. Product preference is closely related to the concept of loading priority described by (Bischoff & Ratcliff, 1995; Bortfeldt & Wäscher, 2013). Loading priority may be absolute, meaning that no item of lower priority should be shipped if any item with higher priority is left behind, or it may be relative, in the sense that the loading priority simply represents the value of placing one item rather than another in a container (similar to preference, in our case). Ren, Tian, and Sawaragi (2011) studied the single container loading problem with an absolute loading priority constraint. However, as far as we know, no paper explicitly discusses the multiple container loading problem with a loading priority constraint.

Our two-phase heuristic for the MCLPP uses heuristics for the Single Container Loading Problem (SCLP) as sub-routines. Dyckhoff and Finke (1992) provided a high-quality survey for early literature concerning the SCLP. According to Pisinger (2002), the approaches for SCLP can be classified into five groups, namely wall building approaches (Bortfeldt & Gehring, 2001; Pisinger, 2002), layer building approaches (Bischoff & Ratcliff, 1995; Terno, Scheithauer, Sommerweiû, & Riehme, 2000), stack building approaches (Bischoff & Ratcliff, 1995; Gehring & Bortfeldt, 1997), block building approaches (Bortfeldt, Gehring, & Mack, 2003; Eley, 2002; Fanslau & Bortfeldt, 2010; Mack, Bortfeldt, & Gehring, 2004; Zhang, Peng, & Leung, 2012; Zhu & Lim, 2012) and guillotine cutting approaches (Morabito & Arenalest, 1994). In addition, Huang and He (2009) and He and Huang (2011) proposed heuristic methods based on the concept of caving degree.

In the MCLPP, the initial order is represented by a vector b, where bi
                      > 0 is the quantity of product i (or the number of items that are product i), 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           N
                        
                     . The preferences of these products are stored in a vector p, where pi
                      > 0 is the preference of product 
                        
                           i
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           N
                        
                     . A vector c is used to denote the costs of available containers, where ct
                      > 0 is the cost of a type t container (
                        
                           t
                           =
                           1
                           ,
                           …
                           ,
                           T
                        
                     ). As described in Section 1, we need to change the order quantity (resulting in an adjusted order) and load all items of the adjusted order into a set of containers such that the shipping cost per unit preference is minimized. The shipping cost per unit preference is defined as the total shipping cost over the total preference of loaded items, where the total shipping cost only includes the cost of the containers used.

We denote the adjusted order with y, where yi
                      is the quantity of product i. A change to the order quantity is acceptable only if the following adjustment requirements are met:

                        
                           •
                           
                              Unidirectional adjustment: Either y ≥ b or y ≤ b.


                              No piggyback: 
                                 
                                    
                                       b
                                       i
                                    
                                    =
                                    0
                                    ⇒
                                    
                                       y
                                       i
                                    
                                    =
                                    0
                                    ,
                                 
                              
                              
                                 
                                    ∀
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    N
                                 
                              .


                              Bounded quantity: There is a lower bound 
                                 b
                               
                              
                                 i
                               and an upper bound 
                                 
                                    
                                       b
                                       ¯
                                    
                                    i
                                 
                               on 
                                 
                                    
                                       y
                                       i
                                    
                                    ,
                                    ∀
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    N
                                 
                              . If all lower bounds are represented by vector 
                                 b
                               and all upper bounds are represented by 
                                 
                                    
                                       b
                                       ¯
                                    
                                    ,
                                 
                               we must have 
                                 
                                    
                                       b
                                       ̲
                                    
                                    ≤
                                    y
                                    ≤
                                    
                                       b
                                       ¯
                                    
                                 
                              .

Assume that all items are packaged in 3D rectangular boxes; thus, the terms “item” and “box” will be used interchangeably through the rest of this paper. The dimensions of a type i box are given by li, wi
                     , and hi
                     , while the dimensions of the loading space in a type t container are given by Lt, Wt
                     , and Ht
                     . Therefore, the per-item volume of type i boxes is defined as 
                        
                           
                              v
                              i
                           
                           =
                           
                              l
                              i
                           
                           
                              w
                              i
                           
                           
                              h
                              i
                           
                        
                      and the volume of a type t container is defined as 
                        
                           
                              V
                              t
                           
                           =
                           
                              L
                              t
                           
                           
                              W
                              t
                           
                           
                              H
                              t
                           
                        
                     . We use a vector 
                        
                           v
                           ∈
                           
                              R
                              +
                              N
                           
                        
                      to store all per-item volumes and a vector 
                        
                           V
                           ∈
                           
                              R
                              +
                              T
                           
                        
                      to store all container volumes. Given an order and a set of containers, we define a loading plan as a valid geometric layout for loading the items from the order into the containers. A geometric layout is valid if and only if the following loading constraints are satisfied:

                        
                           •
                           
                              No empty container: Each container must contain at least one box.


                              Containment: Each box must be fully contained by one and only one container.


                              Orthogonal placement: Each box must be placed with its edges parallel to those of the container it is in.


                              No overlap: Any two boxes inside the same container must not overlap with each other.


                              Orientation restriction: Every box must be placed in one of its allowed orientations. In reality, not all products can be freely rotated. For example, certain types of audio equipment must be placed vertically because of fragile sides. In our problem, we use three flags (
                                 
                                    
                                       f
                                       i
                                       l
                                    
                                    ,
                                 
                              
                              
                                 
                                    
                                       f
                                       i
                                       w
                                    
                                    ,
                                 
                               and 
                                 
                                    
                                       f
                                       i
                                       h
                                    
                                    ,
                                 
                               respectively) to indicate whether product i can be placed with its length, width, and height aligned with the vertical axis of a container. If 
                                 
                                    
                                       f
                                       i
                                       h
                                    
                                    =
                                    1
                                    ,
                                 
                               product i can be placed with its height aligned with the vertical axis. If all three flags are set at 1, the product can be freely rotated.

In addition, we ignore the availability of containers, which means we assume that the quantity of each type of container is infinite. This is because purchase orders normally have small sizes compared to the container capacity of typical logistics service providers.

Let y be an N-dimensional column vector, whose element yi
                      is the quantity of the i-th product in the purchase order, and let x be a T-dimensional column vector, where xt
                      is the number of type t containers, 
                        
                           t
                           =
                           1
                           ,
                           …
                           ,
                           T
                        
                     . If all products denoted by y can be loaded into the set of containers denoted by x, while respecting all the loading constraints in Section 3, we call the pair (x, y) a loading pattern and denote it with 
                        
                           L
                           (
                           x
                           ,
                           y
                           )
                        
                     . The shipping cost associated with 
                        
                           L
                           (
                           x
                           ,
                           y
                           )
                        
                      is given by c
                     
                        T
                     
                     x, and the total preference of products is given by p
                     
                        T
                     
                     y. Furthermore, we define a loading pattern 
                        
                           L
                           (
                           x
                           ,
                           y
                           )
                        
                      to be feasible for the MCLPP if y satisfies all adjustment requirements in Section 3. Then, the set of all feasible loading patterns is given by

                        
                           
                              
                                 F
                                 =
                                 {
                                 
                                 L
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 
                                 |
                                 
                                 b
                                 ≤
                                 y
                                 ≤
                                 
                                    b
                                    ¯
                                 
                                 ∨
                                 
                                    b
                                    ̲
                                 
                                 ≤
                                 y
                                 ≤
                                 b
                                 ,
                                 
                                 x
                                 ∈
                                 
                                    Z
                                    
                                       +
                                    
                                    T
                                 
                                 ,
                                 
                                 y
                                 ∈
                                 
                                    Z
                                    
                                       +
                                    
                                    N
                                 
                                 
                                 }
                              
                           
                        
                     
                  

We group loading patterns with the same shipping costs and total preferences into a pattern set as follows:

                        
                           
                              
                                 S
                                 
                                    (
                                    C
                                    ,
                                    P
                                    )
                                 
                                 =
                                 {
                                 
                                 L
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 
                                 |
                                 
                                 C
                                 =
                                 
                                    c
                                    T
                                 
                                 x
                                 ,
                                 
                                 P
                                 =
                                 
                                    p
                                    T
                                 
                                 y
                                 ,
                                 
                                 x
                                 ∈
                                 
                                    Z
                                    
                                       +
                                    
                                    T
                                 
                                 ,
                                 
                                 y
                                 ∈
                                 
                                    Z
                                    
                                       +
                                    
                                    N
                                 
                                 
                                 }
                              
                           
                        
                     We say a pattern set is feasible if it contains at least one feasible loading pattern (i.e., 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                           ∩
                           F
                           ≠
                           ∅
                        
                     ). Therefore, given a feasible pattern set 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                           ,
                        
                      we must have 
                        
                           C
                           ∈
                           C
                        
                      and 
                        
                           P
                           ∈
                           P
                        
                      where

                        
                           
                              
                                 
                                    
                                       C
                                    
                                    
                                       =
                                    
                                    
                                       
                                          {
                                          
                                          C
                                          
                                          |
                                          
                                          C
                                          =
                                          
                                             c
                                             T
                                          
                                          
                                             α
                                          
                                          ,
                                          
                                          
                                             α
                                          
                                          ∈
                                          
                                             Z
                                             
                                                +
                                             
                                             T
                                          
                                          
                                          }
                                       
                                    
                                 
                                 
                                    
                                       P
                                    
                                    
                                       =
                                    
                                    
                                       
                                          {
                                          
                                          P
                                          
                                          |
                                          
                                          
                                             p
                                             T
                                          
                                          
                                             b
                                             ̲
                                          
                                          ≤
                                          P
                                          ≤
                                          
                                             p
                                             T
                                          
                                          
                                             b
                                             ¯
                                          
                                          ,
                                          
                                          P
                                          =
                                          
                                             p
                                             T
                                          
                                          
                                             β
                                          
                                          ,
                                          
                                          
                                             β
                                          
                                          ∈
                                          
                                             Z
                                             
                                                +
                                             
                                             N
                                          
                                          
                                          }
                                       
                                    
                                 
                              
                           
                        
                     
                  

Obviously, every feasible solution to the MCLPP corresponds to some feasible loading pattern 
                        
                           L
                           (
                           x
                           ,
                           y
                           )
                        
                      that lies in some feasible pattern set 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                        
                     . Therefore, the objective value of an optimal solution to the MCLPP can be found by solving the following constrained minimization problem:

                        
                           
                              
                                 
                                    
                                       
                                          MCLPP
                                          
                                          
                                          :
                                          
                                          Minimize
                                          
                                       
                                    
                                    
                                       
                                          C
                                          P
                                       
                                    
                                 
                                 
                                    
                                       
                                          Subject
                                          
                                          to
                                          
                                       
                                    
                                    
                                       
                                          S
                                          (
                                          C
                                          ,
                                          P
                                          )
                                          ∩
                                          F
                                          ≠
                                          ∅
                                       
                                    
                                 
                              
                           
                        
                     
                  

We proceed to analyze the feasible region of model MCLPP. Suppose a nonempty pattern set 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                        
                      can be represented by a circle centered at point (C, P) of a preference-cost plane. Then, all feasible pattern sets lie in the shaded area of Fig. 1
                     . Given a feasible pattern set 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                           ,
                        
                      we must have 
                        
                           P
                           ∈
                           P
                        
                     . Thus, the left and right boundaries of the shaded area are given by the vertical lines 
                        
                           P
                           =
                           
                              
                                 p
                                 T
                              
                              
                                 b
                                 ̲
                              
                           
                        
                      and 
                        
                           P
                           =
                           
                              
                                 p
                                 T
                              
                              
                                 b
                                 ¯
                              
                           
                           ,
                        
                      respectively.

The bottom boundary of the shaded area is a staircase determined by the dominating pattern sets (grey circles), which are defined as follows:

                        Definition 1
                        A feasible pattern set 
                              
                                 S
                                 (
                                 C
                                 ,
                                 P
                                 )
                              
                            
                           dominates another feasible pattern set 
                              
                                 S
                                 (
                                 
                                    C
                                    ′
                                 
                                 ,
                                 
                                    P
                                    ′
                                 
                                 )
                              
                            if C ≤ C′∧P ≥ P′ and at least one inequality is strict. A feasible pattern set that is not dominated by any other feasible pattern set is called a dominating pattern set.

Let 
                        C
                      and 
                        
                           C
                           ¯
                        
                      be the minimum total costs of containers that can accommodate all products denoted by 
                        
                           y
                           =
                           
                              b
                              ̲
                           
                        
                      and 
                        
                           y
                           =
                           
                              b
                              ¯
                           
                           ,
                        
                      respectively. It is clear from Fig. 1 that no feasible pattern set lies below the horizontal line 
                        
                           C
                           =
                           
                              C
                              ̲
                           
                        
                      and that all feasible pattern sets above the horizontal line 
                        
                           C
                           =
                           
                              C
                              ¯
                           
                        
                      are dominated. Therefore, all dominating sets lie between line 
                        
                           C
                           =
                           
                              C
                              ̲
                           
                        
                      and line 
                        
                           C
                           =
                           
                              C
                              ¯
                           
                        
                     .

It is easy to verify that every optimal solution to the MCLPP must lie in one of the dominating pattern sets. Correspondingly, it is sufficient to explore only the dominating pattern sets to identify an optimal solution to the MCLPP. This observation forms the basis of our heuristic algorithm, which is described in the next section.

The main challenge in solving the MCLPP is determining whether a pattern set 
                        
                           S
                           (
                           C
                           ,
                           P
                           )
                        
                      contains feasible solutions. If we can quickly determine whether a pattern set is feasible, we can enumerate the dominating pattern sets quickly and rank them in ascending order of 
                        
                           C
                           P
                        
                     . Searching for an optimal solution to the MCLPP is then reduced to searching for a feasible solution in the dominating pattern set with the smallest 
                        
                           C
                           P
                        
                     .

Determining whether a pattern set contains a feasible solution is a very hard decision problem. It contains the sub-problem of determining feasible 3D geometric layouts of products inside containers. We therefore propose a two-phase heuristic for the MCLPP. In the first phase, we try to estimate the lower boundary of the shaded area in Fig. 1. That is to say, we employ a heuristic to identify pattern sets that are likely to be dominating. In the second phase, we search for a best feasible solution in the vicinity of those pattern sets by solving a series of 3D orthogonal packing sub-problems.

From Fig. 1, we can see that a dominating pattern set must be the right-most circle in the row 
                           
                              C
                              ∈
                              C
                              ∩
                              [
                              
                                 C
                                 ̲
                              
                              ,
                              
                                 C
                                 ¯
                              
                              ]
                           
                        . Therefore, we estimate dominating pattern sets in two steps: 1) enumerate all rows between the lines 
                           
                              C
                              =
                              
                                 C
                                 ̲
                              
                           
                         and 
                           
                              C
                              =
                              
                                 C
                                 ¯
                              
                           
                        ; 2) estimate the right-most circle in each row found in step 1.

Firstly, we need to calculate the exact value of 
                              C
                            and 
                              
                                 C
                                 ¯
                              
                            which is equivalent to solving two Multiple Container Loading Cost Minimization Problems (MCLCMP). However, no exact solution approach for the MCLPP exists that can solve realistic problem instances in reasonable time (Eley (2003)). Therefore, we find a lower bound of 
                              C
                           , denoted as 
                              C
                            
                           
                              e
                           , and an upper bound of 
                              
                                 
                                    C
                                    ¯
                                 
                                 ,
                              
                            denoted as 
                              
                                 
                                    
                                       C
                                       ¯
                                    
                                    e
                                 
                                 ,
                              
                            such that 
                              
                                 
                                    [
                                    
                                       C
                                       ̲
                                    
                                    ,
                                    
                                       C
                                       ¯
                                    
                                    ]
                                 
                                 ⊂
                                 
                                    [
                                    
                                       
                                          C
                                          ̲
                                       
                                       e
                                    
                                    ,
                                    
                                       
                                          C
                                          ¯
                                       
                                       e
                                    
                                    ]
                                 
                              
                           . Then, all C in 
                              
                                 C
                                 ∩
                                 [
                                 
                                    C
                                    ̲
                                 
                                 ,
                                 
                                    C
                                    ¯
                                 
                                 ]
                              
                            can be found by enumerating all C in 
                              
                                 C
                                 ∩
                                 [
                                 
                                    
                                       C
                                       ̲
                                    
                                    e
                                 
                                 ,
                                 
                                    
                                       C
                                       ¯
                                    
                                    e
                                 
                                 ]
                              
                           .

To find a lower bound of 
                              C
                           , we reduce the MCLCMP to a 1-Dimensional Bin Packing Problem which is modeled as follows:

                              
                                 (1)
                                 
                                    
                                       
                                          
                                             
                                                _
                                                l
                                                b
                                                a
                                                EC
                                                _
                                                lb
                                                :
                                                
                                                Minimize
                                                
                                             
                                          
                                          
                                             
                                                C
                                                =
                                                
                                                   c
                                                   T
                                                
                                                x
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (2)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                Subject
                                                
                                                to
                                                
                                             
                                          
                                          
                                             
                                                
                                                   V
                                                   T
                                                
                                                x
                                                ≥
                                                
                                                   v
                                                   T
                                                
                                                
                                                   b
                                                   ̲
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                             
                                          
                                          
                                             
                                                x
                                                ∈
                                                
                                                   Z
                                                   
                                                      +
                                                   
                                                   T
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Constraint (2) requires that the total volume of selected containers is larger than the total volume of products denoted by 
                              b
                           . However, the geometric layout of items in each container is ignored in the model which means the items represented by 
                              b
                            may not be fully loaded into the containers represented by the optimal solution of EC_lb. Therefore, the optimal objective value of EC_lb is a lower bound of 
                              C
                            .

We find an upper bound of 
                              C
                            by solving the following minimization problem:

                              
                                 (4)
                                 
                                    
                                       
                                          
                                             
                                                _
                                                u
                                                b
                                                a
                                                EC
                                                _
                                                ub
                                                
                                                
                                                :
                                                
                                                Minimize
                                                
                                             
                                          
                                          
                                             
                                                C
                                                =
                                                
                                                   ∑
                                                   
                                                      t
                                                      =
                                                      1
                                                   
                                                   T
                                                
                                                
                                                   c
                                                   t
                                                
                                                
                                                   x
                                                   t
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                Subject
                                                
                                                to
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      t
                                                      =
                                                      1
                                                   
                                                   T
                                                
                                                
                                                   m
                                                   
                                                      t
                                                      i
                                                   
                                                
                                                
                                                   z
                                                   
                                                      t
                                                      i
                                                   
                                                
                                                ≥
                                                
                                                   
                                                      b
                                                      i
                                                   
                                                   ¯
                                                
                                                ,
                                                
                                                ∀
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                N
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (6)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   z
                                                   
                                                      t
                                                      i
                                                   
                                                
                                                =
                                                
                                                   x
                                                   t
                                                
                                                ,
                                                
                                                ∀
                                                t
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                T
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (7)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   x
                                                   t
                                                
                                                ∈
                                                
                                                   Z
                                                   +
                                                
                                                ,
                                                
                                                ∀
                                                t
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                T
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (8)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   z
                                                   
                                                      t
                                                      i
                                                   
                                                
                                                ∈
                                                
                                                   Z
                                                   +
                                                
                                                ,
                                                
                                                ∀
                                                t
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                T
                                                ,
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                N
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Constant mti
                            equals to 
                              
                                 
                                    ⌊
                                    
                                       
                                          L
                                          t
                                       
                                       
                                          l
                                          i
                                       
                                    
                                    ⌋
                                 
                                 ×
                                 
                                    ⌊
                                    
                                       
                                          W
                                          t
                                       
                                       
                                          w
                                          i
                                       
                                    
                                    ⌋
                                 
                                 ×
                                 
                                    ⌊
                                    
                                       
                                          H
                                          t
                                       
                                       
                                          h
                                          i
                                       
                                    
                                    ⌋
                                 
                                 ,
                              
                            which is the minimum number of type i products that can be loaded into a type t container with a fixed orientation. Variable zti
                            is equal to 1 if a type t container is loaded with type i products; otherwise, it is equal to 0. Therefore, Constraint (5) guarantees that all products represented by 
                              
                                 b
                                 ¯
                              
                            can be loaded into the selected containers. However, the optimal solution of EC_ub may not be the cheapest containers to load all items represented by 
                              
                                 b
                                 ¯
                              
                           . Therefore, the optimal objective value of EC_ub is an upper bound of 
                              
                                 C
                                 ¯
                              
                           .

When we obtain the value of 
                              C
                            
                           
                              e
                            and 
                              
                                 
                                    C
                                    ¯
                                 
                                 e
                              
                            by solving EC_lb and EC_ub, respectively, we enumerate all C in 
                              
                                 C
                                 ∩
                                 [
                                 
                                    
                                       C
                                       ̲
                                    
                                    e
                                 
                                 ,
                                 
                                    
                                       C
                                       ¯
                                    
                                    e
                                 
                                 ]
                              
                            by adapting a dynamic programming algorithm for the knapsack problem (Martello & Toth (1990)) which runs in pseudo-polynomial time (see Algorithm 1
                           ).

The right-most circle of a row 
                              
                                 C
                                 ∈
                                 C
                                 ∩
                                 [
                                 
                                    
                                       C
                                       ̲
                                    
                                    e
                                 
                                 ,
                                 
                                    
                                       C
                                       ¯
                                    
                                    e
                                 
                                 ]
                              
                            can be located by searching for the items with maximum total preference that can be loaded into containers with total cost C. The difficulties are: 1) given a set of containers, finding the maximum total preference that can be loaded is a generalization of the NP-hard Single Container Loading Problem (SCLP); 2) there may be several sets of containers with the same total cost C.

We therefore develop a heuristic (Algorithm 2
                           ) to estimate the right-most circle of a row 
                              
                                 C
                                 ∈
                                 C
                                 ∩
                                 [
                                 
                                    
                                       C
                                       ̲
                                    
                                    e
                                 
                                 ,
                                 
                                    
                                       C
                                       ¯
                                    
                                    e
                                 
                                 ]
                              
                           .


                           EP(
                              
                                 C
                                 ,
                                 u
                                 ,
                                 
                                    d
                                    ̲
                                 
                                 ,
                                 
                                    d
                                    ¯
                                 
                              
                           ) is defined as follows:

                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                a
                                                EP
                                                (
                                                C
                                                ,
                                                u
                                                ,
                                                
                                                   d
                                                   ̲
                                                
                                                ,
                                                
                                                   d
                                                   ¯
                                                
                                                )
                                                
                                                
                                                :
                                                
                                                Maximize
                                                
                                             
                                          
                                          
                                             
                                                P
                                                =
                                                
                                                   p
                                                   T
                                                
                                                y
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (10)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                
                                                Subject
                                                
                                                to
                                                
                                             
                                          
                                          
                                             
                                                
                                                   c
                                                   T
                                                
                                                x
                                                =
                                                C
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (11)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                
                                             
                                          
                                          
                                             
                                                
                                                   u
                                                   T
                                                
                                                x
                                                ≥
                                                
                                                   v
                                                   T
                                                
                                                y
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (12)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                
                                             
                                          
                                          
                                             
                                                
                                                   d
                                                   ̲
                                                
                                                ≤
                                                y
                                                ≤
                                                
                                                   d
                                                   ¯
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (13)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                
                                             
                                          
                                          
                                             
                                                x
                                                ∈
                                                
                                                   Z
                                                   
                                                      +
                                                   
                                                   T
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (14)
                                 
                                    
                                       
                                          
                                             
                                                
                                                
                                                
                                                
                                             
                                          
                                          
                                             
                                                y
                                                ∈
                                                
                                                   Z
                                                   
                                                      +
                                                   
                                                   N
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In this model, variable x denotes a set of containers and variable y denotes a set of items. Parameter u is a T-dimensional column vector, whose element ut
                            represents the usable volume of a type t container. We define that the usable volume of a type t container (ut
                           ) is the maximum total volume of items that can be loaded into the container. In most situations, ut
                            is smaller than Vt
                           , 
                              
                                 ∀
                                 t
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 T
                              
                           . Take the well-known Single Container Loading Problem (SCLP) as an example. The state-of-the-art SCLP algorithm, ID-GLTS (Zhu & Lim, 2012), is only capable of finding solutions with an average volume utilization below 94%. We will describe how we calculate 
                              
                                 
                                    u
                                    t
                                 
                                 ,
                                 ∀
                                 t
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 T
                              
                            in Section 6.2.

Constraint (10) requires that the costs of selected containers sum up to C. Constraint (11) requires that the total usable volume of selected containers be larger than the total volume of products so that the set of products has a good chance of being loaded into the selected container. Constraint 12 ensures that y can vary between 
                              d
                            and 
                              
                                 d
                                 ¯
                              
                           . Since we are allowed to adjust the initial customer order either upwards or downwards, the range 
                              
                                 [
                                 
                                    d
                                    ̲
                                 
                                 ,
                                 
                                    d
                                    ¯
                                 
                                 ]
                              
                            is equal to either 
                              
                                 [
                                 b
                                 ,
                                 
                                    b
                                    ¯
                                 
                                 ]
                              
                            or [
                              b, b].

The problem EP(
                              
                                 C
                                 ,
                                 u
                                 ,
                                 
                                    d
                                    ̲
                                 
                                 ,
                                 
                                    d
                                    ¯
                                 
                              
                           ) is solved to find the items with maximum total preference (denoted as 
                              
                                 
                                    y
                                    *
                                 
                                 ,
                                 
                                    y
                                    *
                                 
                                 ∈
                                 
                                    [
                                    
                                       d
                                       ̲
                                    
                                    ,
                                    
                                       d
                                       ¯
                                    
                                    ]
                                 
                              
                           ) that can be loaded into a set of containers with total cost C (denoted as x
                           *) while the shapes of the items and the layout of items in each container are ignored. It is possible that we cannot load all items denoted by y
                           * into containers denoted by x
                           *; therefore, the solution to EP
                           
                              
                                 (
                                 C
                                 ,
                                 u
                                 ,
                                 
                                    d
                                    ̲
                                 
                                 ,
                                 
                                    d
                                    ¯
                                 
                                 )
                              
                            can serve only as an estimation.

Accordingly, our phase-one heuristic is summarized in Algorithm 3
                           .

                              Remark
                              It is obvious from Fig. 1 that a dominating pattern set also corresponds to the bottom-most circle in a column. Therefore, an alternative approach is to enumerate them row-wise. That is, we try to estimate the minimal cost of containers that can accommodate products with the total preference 
                                    
                                       P
                                       ∈
                                       P
                                    
                                 . It is reasonable to assume its difficulty is similar to that of EP. The main reason that we prefer row-wise enumeration over column-wise enumeration is that there are much fewer rows than columns in an MCLPP instance.

By the end of phase one, we have identified a list of pairs (x
                        *, y
                        *), each representing a pattern set 
                           
                              S
                              (
                              C
                              ,
                              P
                              )
                           
                         with 
                           
                              C
                              =
                              
                                 c
                                 T
                              
                              
                                 x
                                 *
                              
                           
                         and 
                           
                              P
                              =
                              
                                 p
                                 T
                              
                              
                                 y
                                 *
                              
                           
                        . Each pattern set is likely to contain a feasible solution to the MCLPP. The pattern sets are sorted in ascending order of 
                           
                              C
                              P
                           
                        . In phase two, we consider the first K pattern sets 
                           
                              S
                              (
                              C
                              ,
                              P
                              )
                           
                         in the ordered list. For each pattern set 
                           
                              S
                              (
                              C
                              ,
                              P
                              )
                              ,
                           
                         we try to identify a feasible solution using a heuristic.

There may be several container combinations with the same total cost C, and there may be many product combinations with the same total preference P. Among all container combinations, the one with the largest usable volume dominates others, in the sense that this combination is more likely to accommodate more products and, hence, increase total preference. Similarly, among all product combinations, the one with the least total volume dominates the others in the sense that this combination is most likely to be accommodated by a given set of containers. Therefore, in the process of searching for a feasible solution, we tend to pick the set of containers with the largest total usable volume and the set of products with the smallest total volume.

It is reasonable to use (x
                        *, y
                        *) as our initial guess and to search for a best order y that can be accommodated in the containers x
                        *. We apply a binary search to the total box volume to determine an order y (see Algorithm 4
                        ). The problem SO is defined as follows:

                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                             a
                                             SO
                                             (
                                             V
                                             ,
                                             
                                                d
                                                ̲
                                             
                                             ,
                                             
                                                d
                                                ¯
                                             
                                             )
                                             
                                             
                                             :
                                             
                                             Maximize
                                             
                                          
                                       
                                       
                                          
                                             
                                                p
                                                T
                                             
                                             y
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             Subject
                                             
                                             to
                                             
                                          
                                       
                                       
                                          
                                             
                                                v
                                                T
                                             
                                             y
                                             ≤
                                             V
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                             
                                             &
                                             
                                                d
                                                ̲
                                             
                                             ≤
                                             y
                                             ≤
                                             
                                                d
                                                ¯
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                          
                                       
                                       
                                          
                                             y
                                             ∈
                                             
                                                Z
                                                
                                                   +
                                                
                                                N
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           d
                         and 
                           
                              d
                              ¯
                           
                         define the allowed range for an order. An optimal solution to SO is an order y with a total box volume not exceeding V that maximizes total preference.

To check whether an order y can be loaded into a set of containers x, we invoke sub-routine GreedyLoad. It loads the containers one at a time in a greedy manner and returns a vector representing the set of products loaded. The single container loading algorithm SCLP used in GreedyLoad is adapted from the Iterative-Doubling Greedy 1-step Lookahead Algorithm (ID-G1LA) proposed by Zhu and Lim (2012). The only difference between our SCLP and ID-G1LA is that we evaluate a (partial) solution using the total preference of boxes loaded instead of total volume. We briefly introduce the ID-G1LA. For complete details, we refer the readers to Zhu and Lim (2012). The ID-G1LA is a block-building approach; that is, the boxes are first arranged into compact blocks, and then packing solutions are constructed by loading blocks instead of individual boxes. Beginning with an empty container and a list of candidate blocks, a block is selected and placed at one of the corners of the container in each step. The remaining free space in the container is represented as a list of cuboids called residual spaces. In the subsequent steps, a residual space and one of the available blocks are selected, and the selected block is placed at a corner of the selected space. After this, the list of residual spaces and candidate blocks are updated. This process is repeated until the list of residual spaces is empty, whereupon a feasible loading plan is found, or the time limit τ is reached. A tree search procedure is used to generate several feasible loading plans, and the one maximizing the objective function is returned.

Our phase two heuristic is summarized in Algorithm 5
                        . Given a pattern set 
                           
                              S
                              (
                              C
                              ,
                              P
                              )
                           
                         with 
                           
                              C
                              =
                              
                                 u
                                 T
                              
                              
                                 x
                                 *
                              
                           
                         and 
                           
                              P
                              =
                              
                                 p
                                 T
                              
                              
                                 y
                                 *
                              
                              ,
                           
                         we will invoke binary search, at most, twice to search for a feasible solution x
                        *, y. When the estimated order y
                        * in phase one is larger than the initial order b, we search for an order in the range between b and 
                           
                              
                                 b
                                 ¯
                              
                              ,
                           
                         starting at y
                        * (line 6). If we fail to find a feasible solution, we try to search for an order in the range between 
                           b
                         and b, starting at the middle point (line 10). When the estimated order y
                        * is smaller than the initial order b, we only search in the range between 
                           b
                         and b, starting at the middle point (line 11).

Our two-phase heuristic approach was implemented as a sequential algorithm in Java (JDK 7 updated 21, 64-bit edition), and no multi-threading was explicitly used. All experiments described in this section were conducted on a personal computer equipped with an Intel Core(TM) i7-3770 CPU clocked at 3.40 gigahertz and an 8 Gigabyte RAM, running a Windows 7 (64-bit) operating system. The commercial integer linear programming solver used was the IBM ILog CPLEX Optimization Studio 12.2 (64-bit) with its default settings.

Since there is no standard benchmark, we generated 10 sets of MCLPP instances based on the historical data provided by a manufacturer. The data-generation details are presented in Section 6.1.

In the first phase of our algorithm, we estimate the dominating pattern sets. Parameter u in problem EP(
                        
                           C
                           ,
                           u
                           ,
                           
                              d
                              ̲
                           
                           ,
                           
                              d
                              ¯
                           
                        
                     ) affects the accuracy of our estimation. Therefore, we present how we decide the value of u in Section 6.2. There are two important parameters in the second phase of our algorithm (Algorithm 5): K and τ, which influence the quality of the solution and the total execution time of our algorithm. Thus, we show how we calibrate K and τ in Section 6.3. We demonstrate the performance of our approach on all MCLPP instances in Section 6.4. In order to further investigate our approach, we run the two-phase heuristic algorithm on new instances transformed from the benchmark MCLCMP instances. The experimental results are reported in Section 6.5.

We collected 12-month purchase orders from a company in Hong Kong. Most of these orders consist of N types of products, with N coming from the set {3, 5, 8, 13, 15, 16, 17, 19, 25, 26}. Currently, three types of containers are used to fulfill the orders, namely, the 20-foot standard (20S), 40-foot standard (40S), and 40-foot high cube (40H) containers. Their dimensions are given in Table 1
                        .

For privacy reasons, the following information is not provided: the products’ preference (p), the order quantity adjustment range (
                           
                              [
                              
                                 b
                                 ̲
                              
                              ,
                              
                                 b
                                 ¯
                              
                              ]
                           
                        ), and the containers’ price (c). However, the logistic officer of the company suggests that the preference of each product could be proportional to its order quantity: 
                           
                              
                                 p
                                 i
                              
                              =
                              
                                 b
                                 i
                              
                              /
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 N
                              
                              
                                 b
                                 i
                              
                           
                         and the order quantity adjustment range could be 
                           
                              [
                              b
                              (
                              1
                              −
                              20
                              %
                              )
                              ,
                              b
                              (
                              1
                              +
                              20
                              %
                              )
                              ]
                           
                        . We also collected the price of each container from Che et al. (2011).

Based on the above information, we generated 10 sets of instances. Each instance set is named as QBP-
                        N where QBP is short for Quantity-Based Preference and N is one element of the set {3, 5, 8, 13, 15, 16, 17, 19, 25, 26}. There are 50 randomly generated instances in each instance set. An instance of set QBP-
                        N is generated as follows: 1) we set a target V for the total volume of products in the instance. V is a value uniformly randomly selected from the set 
                           
                              {
                              5
                              
                                 V
                                 
                                    20
                                    S
                                 
                              
                              ,
                              6
                              
                                 V
                                 
                                    20
                                    S
                                 
                              
                              ,
                              …
                              ,
                              20
                              
                                 V
                                 
                                    20
                                    S
                                 
                              
                              }
                           
                         where V
                        20S
                         is the volume of a 20-foot standard container; 2) we uniformly randomly select N products from a list of 2187 products provided by the company and initialize their quantities to 1; 3) we uniformly randomly select 1 out of the N products and increase its quantity by 1. We repeatedly select a product and increase its quantity until the total volume of all products in the instance exceeds the target volume V; 4) we calculate the products’ preference and the order quantity adjustment range as suggested by the company. Furthermore, we assume that all products can be freely rotated.

Before conducting experiments on the test data, we need to decide the value of the important parameters in the algorithm.

In the first phase of our algorithm, we estimate the dominating pattern sets. Containers’ usable volume u in problem EP(
                           
                              C
                              ,
                              u
                              ,
                              
                                 d
                                 ̲
                              
                              ,
                              
                                 d
                                 ¯
                              
                           
                        ) affects the accuracy of our estimation. Therefore, we present how we decide the value of u in this section.

The concept of usable volume is also used in (Che et al., 2011; Wei et al., 2015; Zhu et al., 2012a). The authors in these papers set the usable volume of each container to be a fixed value (e.g., 99% of the container’s volume in Wei et al. (2015)). However, our domain knowledge in packing suggests that usable volume of each container is closely related to product heterogeneity and the capability of the packing algorithm. For example, Fig. 2
                         (plotted based on Table 2
                         in Zhu and Lim (2012)) summarizes the performance of leading SCLP algorithms on benchmark test data (i.e., BR1 to BR15). GRASP is the Greedy Randomized Adaptive Search Procedure (Moura & Oliveira (2005)), FDA is the Fit Degree Algorithm (He & Huang (2011)), VNS is the Variable Neighborhood Search algorithm (Parreño, Alvarez-Valdés, Oliveira, & Tamarit (2010)), CLTRS is the Tree Search algorithm for Container Loading (Fanslau & Bortfeldt (2010)), G2LA is the Greedy 2-step LookAhead algorithm (Zhu, Oon, Lim, & Weng (2012b)), and ID-GLTS is the Iterative Doubling Greedy Lookahead Tree Search algorithm (Zhu & Lim (2012)). Each point in Fig. 2 represents the percentage of utilized volume in a container averaged over 100 instances.


                        Fig. 2 shows the average volume utilization produced by each algorithm decreases as the box heterogeneity increases from 5 types of boxes per instance in BR2 to 100 type of boxes per instance in BR15. It also shows that algorithms with different capabilities will produce different volume utilization for each container.

Therefore, it is reasonable to estimate the usable volume of each container in the MCLPP based on the product heterogeneity of each instance and the capability of the packing algorithm. In our two-phase heuristic method, the packing algorithm that will affect the containers’ usable volume is the single container loading algorithm SCLP (Section 5.2). The capability of SCLP is determined by the search time limit τ. Accordingly, we did the following experiments before estimating the usable volume of each container listed in Table 1.

First, we generate 3 classes of SCLP instances, one for each container type t ∈ {20S, 40S, 40H}. In each class, there are 10 sets of instances, one for each N ∈ {3, 5, 8, 13, 15, 16, 17, 19, 25, 26}. Each test set is named as “t-N”, for example, 20S-26. We randomly generate 50 instances for each test set following procedures 1 to 3 in Section 6.1. Each instance in test set t-N consists of N types of products and one type t container. We should emphasize that the product heterogeneity of instances in set t-N is the same as that of the instances in set QBP-N
                        .

Next, we solve the 1500 SCLP instances using the single container loading algorithm (SCLP) and set its search time limit τ to 2, 4, 8 and 16 seconds, respectively. For each instance, we record the volume utilization found by SCLP. For each test set t-N, we calculate two statistics: the average of the volume utilization of 50 instance avg(t, N, τ) and the standard deviation std(t, N, τ). Table 2 shows the results with 
                           
                              τ
                              =
                              4
                              s
                           
                        . The other results are summarized in Tables A.6, A.7, and A.8 in Appendix A.

We observe from Tables 2, A.6, A.7, and A.8: in general, the average volume utilization of each type of container decreases as the product heterogeneity increases and it increases as the capability of the packing algorithm SCLP (represented by τ) increases. Given the above experimental results, we estimate the usable volume of a type t container in the MCLPP as

                           
                              (19)
                              
                                 
                                    
                                       u
                                       t
                                    
                                    =
                                    
                                       (
                                       a
                                       v
                                       g
                                       
                                          (
                                          t
                                          ,
                                          N
                                          ,
                                          τ
                                          )
                                       
                                       +
                                       s
                                       t
                                       d
                                       
                                          (
                                          t
                                          ,
                                          N
                                          ,
                                          τ
                                          )
                                       
                                       )
                                    
                                    ×
                                    
                                       V
                                       t
                                    
                                 
                              
                           
                        which shows that ut
                         is related to both the product heterogeneity of an instance (N) and the packing algorithm’s capability (τ). We choose 
                           
                              
                                 (
                                 a
                                 v
                                 g
                                 
                                    (
                                    t
                                    ,
                                    N
                                    ,
                                    τ
                                    )
                                 
                                 +
                                 s
                                 t
                                 d
                                 
                                    (
                                    t
                                    ,
                                    N
                                    ,
                                    τ
                                    )
                                 
                                 )
                              
                              ×
                              
                                 V
                                 t
                              
                           
                         instead of avg(t, N, τ) × Vt
                         to be the usable volume of a type t container in the MCLPP based on the following analysis. For an MCLPP instance with N types of products, each container in the solution may be loaded with less than N types of products. Therefore, the usable volume of a container in an MCLPP instance with N types of products should be larger than that in an SCLP instance with N types of products.

It should be pointed out that given any company we can collect the types of containers used by it and the product heterogeneity of its orders. Then, we need to conduct the above experiments as pre-processing to estimate the usable volume of each container.

The total execution time and the solution quality of our approach is determined primarily by two parameters: K, the number of rows to be explored in phase two, and τ, the time limit for solving one SCLP instance in the binary search in phase two. We try to determine the best value for K and τ through extensive computational experiments.

We choose the first 5 instances of each data set QBP-N
                         to form a small test bed consisting of 50 instances. We vary K from 1 to 10 and τ from 21 to 24 seconds. For each combination of K and τ, we execute our algorithm on the small test bed.

For each instance, we record the computation time and the unit shipping cost per preference corresponding to the best solution. For each pair of K and τ, we report the average computation time and the average unit cost over 50 instances in a block in Table 3
                        
                        . The blocks are arranged by K into rows and by τ into column groups.

From Table 3, we see that, for each fixed τ, increasing K will lead to an improved solution when K is small. When K is large enough (say K > 5), further increasing K does not improve the overall solution. This is because, for the 50 instances, our estimated ranking of all rows (R in Algorithm 3) is pretty close to the true ranking. On the other hand, we know that we should consider at least two rows from our algorithm to reduce the chance of missing a good solution. Therefore, the value for parameter K should be chosen from the set {2, 3, 4, 5}. We also observe the following simple trend in Table 3: the computation time is roughly proportional to K when τ is fixed (see columns of the table) and proportional to τ when K is fixed (see rows of the table). Therefore, we cannot determine values for K and τ independently.

To investigate the best values for the pair K and τ, we plot Table 3 in Fig. 3. The horizontal axis gives the computation time (in the unit of 100 seconds), and the vertical axis gives the unit cost. Each line in Fig. 3 corresponds to a block in Table 3 so each line is named after the title of the block (i.e., 
                           
                              τ
                              =
                           
                        2 seconds, 4 seconds, 8 seconds, and 16 seconds). The coordinates of each point K in the line τ show the corresponding average computation time and average unit cost in Table 3. Remember that we only consider the points with 
                           
                              K
                              =
                              2
                           
                         to 
                           
                              K
                              =
                              5
                           
                        . We can see that the average computation time under different settings of K and τ can be as large as 3400 seconds (
                           
                              K
                              =
                              5
                              ,
                              τ
                              =
                              16
                           
                        ) and as small as 200 seconds (
                           
                              K
                              =
                              2
                              ,
                              τ
                              =
                              2
                           
                        ). Within 3400 seconds, the pair 
                           
                              K
                              =
                              5
                              ,
                              τ
                              =
                              16
                           
                         produces better solutions (smaller average unit cost); within 2200 seconds, the pair 
                           
                              K
                              =
                              3
                              ,
                              τ
                              =
                              16
                           
                         produces better solutions, while within 1000 seconds, the pairs 
                           
                              K
                              =
                              4
                              ,
                              τ
                              =
                              4
                           
                         and 
                           
                              K
                              =
                              5
                              ,
                              τ
                              =
                              4
                           
                         produces better solutions. In summary, the best values for the pair K and τ depend on the computation time we set for each instance. For the benchmark data we generate, we decide to set 
                           
                              K
                              =
                              4
                              ,
                              τ
                              =
                              4
                           
                         to run the experiments in expectation that the average computation time is around 1000 seconds which is more acceptable compared with the maximum 3400 seconds.

Based on the analyses in Section 6.2 and 6.3, we set 
                           
                              K
                              =
                              4
                              ,
                           
                        
                        
                           
                              τ
                              =
                              4
                              ,
                           
                         and 
                           
                              
                                 u
                                 t
                              
                              =
                              
                                 (
                                 a
                                 v
                                 g
                                 
                                    (
                                    t
                                    ,
                                    N
                                    ,
                                    τ
                                    )
                                 
                                 +
                                 s
                                 t
                                 d
                                 
                                    (
                                    t
                                    ,
                                    N
                                    ,
                                    τ
                                    )
                                 
                                 )
                              
                              ×
                              
                                 V
                                 t
                              
                              ,
                           
                         where avg(t, N, τ) and std(t, N, τ) are values in Table 2. Then, we run the heuristic method on the 10 sets of MCLPP instances we generated. Table 4
                         summarizes the experimental results. The figures in each row of the table is an average value over 50 instances of each instance set QBP-
                        N. Column “time (s)” shows the average execution time (seconds). Column “unit cost” stores the average unit shipping cost per preference. Column “total preference” presents the average total preference of loaded items. Column “total cost” presents the average total cost of used containers. Detailed solution files and test data are available from our website: http://www.computational-logistics.org/orlib/MCLPP.

In Section 6.3, we discussed how to decide the values of K and τ. We stated that we decide to set 
                           
                              K
                              =
                              4
                              ,
                              τ
                              =
                              4
                           
                         to run the experiments in expectation that the average computation time is around 1000 seconds. Table 4 shows that the average computation time per instance set falls within the range from 697.4 seconds to 1371.84 seconds, which is close to what we expected.

From Table 4, we see that the “total costs” are similar to each other while the “total preferences” decrease tremendously as the product heterogeneity (N) increases from 3 to 26. Consequently, the “unit costs” increase largely as N increases, which is also shown in Table 4. The total costs are similar to each other because 1) the total cost of containers is closely related to the total volume of items to be loaded; and 2) the total volume of items (V, as described in Section 6.1) of one MCLPP instance is at most 3 times larger than that of another MCLPP instance. The total preferences decrease tremendously as N increases because in each instance of the data set with larger N the quantity of each product (bi
                        ) and the preference of each product (
                           
                              
                                 p
                                 i
                              
                              =
                              
                                 b
                                 i
                              
                              /
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 N
                              
                              
                                 b
                                 i
                              
                           
                        ) are much smaller than those in an instance of the data set with smaller N.

As mentioned in Section 2, the MCLPP is an extension to the Multiple Container Loading Cost Minimization Problem (MCLCMP). The major difference between the MCLPP and the MCLCMP is that, in the MCLPP, the purchase order can be changed within an adjustment range according to product preference. In order to further investigate our approach, we generate new MCLPP instances based on the benchmark MCLCMP instances introduced by Che et al. (2011) (known as mtc instances) and run our two-phase heuristic algorithm on the new instances.

The mtc instances are grouped into 7 sets: mtc3, mtc4,
                           
                              …
                              ,
                           
                         and mtc9. Each set consists of 50 instances. In each instance of the set “mtcn”, there are n types of boxes and the box quantities (b) are given. To transform an instance of mtcn into an MCLPP instance, we need to add box preferences (p) and order quantity adjustment range (
                           
                              [
                              
                                 b
                                 ̲
                              
                              ,
                              
                                 b
                                 ¯
                              
                              ]
                           
                        ) into the mtc instance. The preference of a type i box is calculated as 
                           
                              
                                 p
                                 i
                              
                              =
                              
                                 b
                                 i
                              
                              /
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 n
                              
                              
                                 b
                                 i
                              
                              ,
                           
                        
                        
                           
                              ∀
                              i
                              =
                              1
                              ,
                              …
                              ,
                              n
                              ,
                           
                         and the adjustment range is set as 
                           
                              [
                              b
                              (
                              1
                              −
                              20
                              %
                              )
                              ,
                              b
                              (
                              1
                              +
                              20
                              %
                              )
                              ]
                           
                        . We name each new data set as QBPmtc-
                        n with n equal to 3, 4, …, and 9, respectively.

We cannot use the statistical method described in Section 6.2 to determine the usable volume of each container in the QBPmtc instances because the boxes composing each QBPmtc instance are not uniformly randomly selected (for details, please refer to Che et al. (2011)). Therefore, we adopt the value used by Wei et al. (2015) to estimate the usable volume of a type t container: 
                           
                              
                                 u
                                 t
                              
                              =
                              0.99
                              
                                 V
                                 t
                              
                           
                         where Vt
                         is the volume of a type t container.

Based on the analysis in Section 6.3, we set 
                           
                              K
                              =
                              4
                           
                         and 
                           
                              τ
                              =
                              4
                           
                         to conduct experiments on the QBPmtc instances because the average computation time under the setting 
                           
                              K
                              =
                              4
                              ,
                              τ
                              =
                              4
                           
                         is moderate compared with those under other settings.

The computational results obtained by running our approach on the QBPmtc instances are summarized in Table 5
                        . The column “time (s)” stores the average computation time over 50 instances of each QBPmtc data set. Similarly, the column “unit cost” stores the average unit cost per preference, the column “total preference” presents the average total preference of loaded items, and the column “total cost” shows the average total cost of used containers. Detailed solution files and test data are available from our website: http://www.computational-logistics.org/orlib/MCLPP.

@&#CONCLUSION@&#

We investigated a new variant of multiple container loading problem inspired by the requirements of an international audio equipment manufacturer in Hong Kong. The manufacturer would like to help its customers reduce unit shipping costs by adjusting order quantity according to product preference. We proposed a combinatorial formulation to capture the exact requirements. We analyzed the solution space of our formulation and proposed an effective two-phase heuristic approach to solve the problem.

We exploited the fact that most companies offer a relatively stable catalog of products and that most customer orders are also relatively stable. This enables us to better estimate the capability of the SCLP sub-routine based on statistical information regarding historical data. The high-level planning can take advantage of this information and search for better solutions in a short overall computing time.

We generated comprehensive test data based on both the actual order data from one of our industrial partners and the benchmark MCLCMP instances. The solutions found by our approach were reported for further reference.

@&#ACKNOWLEDGMENT@&#

This work was supported by the National Nature Science Foundation of China (Grant no. 71401065).


                     
                     
                     
                  

@&#REFERENCES@&#

