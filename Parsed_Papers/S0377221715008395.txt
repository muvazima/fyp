@&#MAIN-TITLE@&#The vehicle-routing problem with time windows and driver-specific times

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We study a VRPTW with driver-specific times to reflect the knowledge of the drivers.


                        
                        
                           
                           We propose a tabu search and a comprehensive set of new benchmark instances.


                        
                        
                           
                           Stronger familiarity of drivers changes the costs and structure of vehicle routes.


                        
                        
                           
                           Increased benefits occur if the familiar customers are geographically contiguous.


                        
                        
                           
                           The proposed tabu search shows good results on the Solomon VRPTW instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing

Time windows

Driver-specific times

Routing consistency

Metaheuristics

@&#ABSTRACT@&#


               
               
                  This paper proposes a tabu search algorithm for the vehicle-routing problem with time windows and driver-specific times (VRPTWDST), a variant of the classical VRPTW that uses driver-specific travel and service times to model the familiarity of the different drivers with the customers to visit. We carry out a systematic investigation of the problem on a comprehensive set of newly generated benchmark instances. We find that consideration of driver knowledge in the route planning clearly improves the efficiency of vehicle routes, an effect that intensifies for higher familiarity levels of the drivers. Increased benefits are produced if the familiar customers of drivers are geographically contiguous. Moreover, a higher number of drivers that are familiar with the same (larger) region provides higher benefits compared to a scenario where each driver is only familiar with a dedicated (smaller) region. Finally, our tabu search is able to prove its performance on the Solomon test instances of the closely related VRPTW, yielding high-quality solutions in short time.
               
            

@&#INTRODUCTION@&#

Small package shipping (SPS) is a fast-growing market strongly driven by the expanding e-commerce sector. Besides the highly competitive market situation, rising fuel and labor costs constantly decrease the players’ profit margins per delivered package. In general, SPS companies perform last-mile deliveries from a set of local depots (see, e.g., Zhong, Hall, & Dessouky, 2007) and the associated pickup and delivery costs are estimated to amount to 35–60 percent of the total transportation cost (Wasner & Zäpfel, 2004). To render their local pickup and delivery operations profitable and to gain advantage over their competitors, SPS companies pay more and more attention to effective workforce management practices (Smilowitz, Nowak, & Jiang, 2012). An effective utilization of drivers can be achieved by employing drivers to serve the customers and regions that they are most familiar with. For example, experienced drivers use shortcuts, know about traffic light intervals, anticipate road or traffic problems, find parking space more easily and know alternative delivery possibilities in case a customer is absent. This leads to reduced travel and service times. In addition, a high service consistency is achieved, i.e., customers are often served by the same driver, leading to increased customer satisfaction and a stronger bond between company and customer.

To effectively manage local delivery tasks, operations research techniques are applied, where route planning is generally represented as vehicle-routing problem (VRP; Toth & Vigo, 2014). Because customers with time-definite delivery requirements are very common in the SPS sector and constitute up to 60 percent of the total delivery volume (Campbell & Thomas, 2009), the VRP with time windows (VRPTW) lies at the heart of the local delivery operations of an SPS company. It incorporates the most important practical constraints, namely a limited freight capacity of vehicles and the requirement that each customer can only be visited within a given time window (for a recent survey on the VRPTW, see, e.g., Desaulniers, Røpke, & Madsen, 2014). To be more precise, the VRPTW calls for the determination of a cost-minimal set of routes carried out by a set of identical vehicles located at a single depot. Each route starts and ends at the depot within a given scheduling horizon and the cumulative demand of the customers visited on a route does not exceed vehicle capacity. Each customer is served by exactly one vehicle within its given time window. The VRPTW is an NP-hard problem of which only small to medium-sized instances can be solved within acceptable computation times by means of exact solution methods (Baldacci, Mingozzi, & Roberti, 2012). Consequently, a huge number of metaheuristic solution methods have been proposed (see Bräysy & Gendreau, 2005b; Gendreau, Potvin, Bräysy, Hasle, & Løkketangen, 2008; Gendreau & Tarantilis, 2010).

This paper addresses a variant of the VRPTW that incorporates the workforce management decision of employing drivers in the most beneficial manner, i.e., the route planning model aims at generating efficient routes based on different extents of driver knowledge. The familiarity of the different drivers with the customers to visit is modeled by means of driver-specific travel and service times. Thus, the resulting VRP with time windows and driver-specific times (VRPTWDST) additionally asks for the best assignment of drivers to their familiar customers (regions), which is a prerequisite for generating overall efficient vehicle routes. The driver specific times are expressed by so called familiarity factors, which give the reduction of the time requirement of the familiar driver as ratio of the time requirement of a completely unfamiliar driver. For example, a familiarity factor of 0.1 states that the time of a familiar driver reduces to 90 percent of the original time of an unfamiliar driver.

Note that vehicle-dependent travel times have already been proposed some time ago (see, e.g., Cordeau, Desaulniers, Desrosiers, Solomon, & Soumis, 2002) and are sometimes included in heterogeneous fleet VRP (HFVRP) models. In this sense, VRPTWDST may be seen as a variant of the HFVRP with time windows (HFVRPTW; Liu & Shen, 1999), in which the capacity and cost of all vehicles are identical and travel costs are vehicle-specific. We refrain from this nomenclature for two reasons. First, existing works on HFVRPTW have their main focus on the different characteristics of the employed vehicles (vehicle capacity and cost) while in our problem a homogeneous vehicle fleet is considered. Second, the vast majority of HFVRPTW papers does not cover vehicle-specific times, and the regularly used LS168 benchmark of Liu and Shen (1999) does not include them. The few works that consider vehicle-specific times only address them in the presented mathematical models but not in the algorithm design or in the numerical studies (for details, see the literature review in Section 2).

The idea of using driver-specific cost to represent different levels of driver familiarity was originally introduced by Zhong et al. (2007) and is also used in Schneider, Doppstadt, Sand, Stenger, and Schwind (2010a) and Schneider, Doppstadt, Stenger, and Schwind (2010b). However, to the best of our knowledge, no work systematically investigating driver-specific times has been presented yet. The contribution of our paper lies in this area. Because VRPTWDST extends the VRPTW, the high complexity of the problem renders exact solution methods inadequate for solving realistically sized problem instances within fast computation times. Therefore, we develop a tabu search (TS), called TS-DST, to address the problem. We generate a comprehensive set of VRPTWDST test instances and conduct numerical experiments to investigate the effect of (i) different geographical distributions of the familiar customers, (ii) different levels of driver familiarity (expressed by different familiarity factors), and (iii) different distributions of familiarity among the drivers, on the resulting routing quality. We further use the well-known Solomon benchmark of the closely related VRPTW to prove the general ability of our algorithm to address hard-to-solve routing problems with time windows.

Many SPS routing approaches generate consistent vehicle routes based on the fixed assignment of service territories to drivers (see, e.g., Schneider, Stenger, Schwahn, & Vigo, 2014; Zhong et al., 2007) or based on template routes (see, e.g., Groër, Golden, & Wasil, 2009; Sungur, Ren, Ordóñez, Dessouky, & Zhong, 2010). In this way, driver learning is promoted, and once drivers are familiar with their customers/region, they are basically always used for serving their familiar customers. Contrary to such approaches, VRPTWDST works on the assumption that driver learning has already taken place in the past and different extents of familiarity exist among the drivers. Then, VRPTWDST aims at employing these drivers in the best possible fashion, which as a side effect will also use them for serving their familiar customers because of shorter travel and service time. Thus, delivery consistency is encouraged without enforcing it by means of fixed service territories or template routes, and routing flexibility is maintained. The latter is vital for generating efficient routes, especially if time windows are considered, because then flexibility is not only needed to achieve distance-efficient route configurations but also to fulfill time requirements (Schneider, Stenger, Schwahn, & Vigo, 2014).

Note that the VRPTWDST model and our solution method are not suitable to provide insights about the optimal tradeoff between routing consistency and routing efficiency, because VRPTWDST does not consider the costs for establishing the familiarity of the drivers, e.g., in the form of reduced routing efficiency or route feasibility (see Haughton, 2008; Smilowitz et al., 2012; Schneider, Stenger, Schwahn, & Vigo, 2014). However, VRPTWDST might be used to also consider the learning phase of drivers if applied in conjunction with a learning model that describes the reduction of travel and service times in dependence of the number of visits to each customer. This presents an interesting opportunity for future research. Finally, note that the contribution of this paper is not restricted to the SPS industry but is relevant for all routing operations in which (i) drivers exhibit different degrees of familiarity with regards to the customers, and (ii) where exploiting this familiarity is worthwhile.

The paper is organized as follows. Section 2 gives an overview of the related literature. Section 3 provides the mathematical formulation of the VRPTWDST. TS-DST is detailed in Section 4. The performance of the proposed method and the effects of driver-specific times are investigated in extensive numerical studies in Section 5. Finally, we give a short summary and conclusions in Section 6.

As described above, the VRPTWDST is closely related to the VRPTW and the HFVRP. Moreover, approaches addressing the familiarity of drivers with customers and workforce management in vehicle routing are of relevance. An overview of the literature concerning these topics is presented in the following.

The VRPTW is one of the most important and widely studied variants of the classical VRP, with hundreds of published papers (Gendreau & Tarantilis, 2010). Cordeau et al. (2002) and Desaulniers et al. (2014) provide comprehensive overviews of exact and heuristic methods for the VRPTW. A detailed description of the heuristic literature is given in the two-part review of Bräysy and Gendreau (2005a, 2005b), which is updated in Gendreau et al. (2008). Gendreau and Tarantilis (2010) provide an overview and analysis of advanced heuristics for solving large-scale VRPTW. A recent survey on exact algorithms is given by Baldacci et al. (2012). The best-performing metaheuristics for solving the VRPTW currently are memetic algorithms (Nagata, Bräysy, & Dullaert, 2010; Vidal, Crainic, Gendreau, & Prins, 2013), large neighborhood search (Bent & Hentenryck, 2004; Pisinger & Røpke, 2007; Prescott-Gagnon, Desaulniers, & Rousseau, 2009), iterated local search (Hashimoto, Yagiura, & Ibaraki, 2008), and multi-start local search (Lim & Zhang, 2007).

In the strand of HFVRP (for surveys, see Baldacci, Battarra, & Vigo, 2008; Irnich, Schneider, & Vigo, 2014), the following problems similar to the VRPTWDST have been studied. Ferland and Michelon (1988) address a vehicle scheduling problem accounting for vehicles of different types with varying travel and service times. They show how to extend some heuristic and exact methods for the standard vehicle scheduling problem to be able to deal with several vehicle types. No computational experiments are reported. Dondo and Cerdá (2006) study a dynamic VRPTW and later a multi-depot VRPTW with heterogeneous fleet (Dondo & Cerdá, 2007). Both problem formulations account for vehicle-specific times, however, all tests are conducted on problem instances with identical times for all vehicles. Goel and Gruhn (2008) study a rich HFVRP with time windows, vehicle-specific travel times, travel costs and capacities including several additional practical requirements like, e.g., a load acceptance decision. The authors propose a reduced variable neighborhood search and a large neighborhood search for the problem and compare the algorithms on a set of self-generated instances, which do not feature vehicle-specific times. As described in Section 1, the vast majority of methods proposed for HFVRPTW do not consider vehicle-specific times (see, e.g., Dell’Amico, Monaci, Pagani, & Vigo, 2007; Bräysy, Porkka, Dullaert, Repoussis, & Tarantilis, 2009; Repoussis & Tarantilis, 2010; Bettinelli, Ceselli, & Righini, 2011).

Approaches integrating workforce management aspects into routing models are often applied in the context of SPS. To find a tradeoff between achieving service consistency and maintaining routing flexibility, some recent scientific approaches present VRP models that explicitly integrate consistency requirements and are solved without fixing service territories (see Groër et al., 2009; Sungur et al., 2010; Smilowitz et al., 2012; Kovacs, Golden, Hartl, & Parragh, 2014a). On the other hand, approaches based on fixed territories are rendered more flexible, e.g., by excluding a percentage of customers from being assigned to fixed territories as done at UPS and described in Zhong et al. (2007). Here, the authors also integrate driver knowledge aspects by means of driver-specific costs. Their cell routing heuristic estimates the cost of inserting a cell into a specific driver’s route by means of a learn factor that describes the driver’s performance level for the considered cell. We refer the reader to Kovacs, Hartl, Parragh, and Golden (2014b) for a comprehensive survey of VRPs with consistency considerations.

One important issue when investigating VRPs with driver-specific times is the above described familiarity factor, i.e., the time reduction gained by a familiar driver in comparison to a completely unfamiliar driver. To the best of our knowledge, no empirical quantification of the learning effect on travel and service times is available. The values used in this paper are motivated from a personal communication with an industry partner from the SPS industry, who estimated the effect at a 40 percent time reduction for the familiar driver. The benchmark instances generated in this work use a maximal familiarity factor of 0.5, because we consider this value adequate for covering the maximal learning case.

In this section, we present a mathematical formulation of the VRPTWDST. Note that the VRPTWDST is a special case of the general VRP for which a model is given in Goel and Gruhn (2008).

Let 
                        
                           V
                           =
                           {
                           1
                           ,
                           …
                           ,
                           N
                           }
                        
                      denote the set of N customers. Vertices 0 and 
                        
                           N
                           
                           +
                           
                           1
                        
                      denote instances of the depot. Further, let the indices 0 and 
                        
                           N
                           
                           +
                           
                           1
                        
                      indicate that a set contains the respective instance of the depot, e.g., 
                        
                           
                              V
                              0
                           
                           =
                           V
                           ∪
                           
                              {
                              0
                              }
                           
                        
                     . VRPTWDST is defined on a complete directed graph 
                        
                           G
                           =
                           (
                           
                              V
                              
                                 0
                                 ,
                                 N
                                 +
                                 1
                              
                           
                           ,
                           A
                           )
                           ,
                        
                      with 
                        
                           A
                           =
                           {
                           
                              (
                              i
                              ,
                              j
                              )
                           
                           ∣
                           i
                           ,
                           j
                           ∈
                           
                              V
                              
                                 0
                                 ,
                                 N
                                 +
                                 1
                              
                           
                           ,
                           i
                           ≠
                           j
                           }
                        
                      denoting the arc set. Identical vehicles with a maximal capacity of C are assumed to be stationed at the depot. Thus, a set K of driver/vehicle pairs is available that can uniquely be identified by the driver as is done in the following. With each vertex 
                        
                           i
                           ∈
                           
                              V
                              
                                 0
                                 ,
                                 N
                                 +
                                 1
                              
                           
                        
                      are associated a nonnegative demand qi
                      (
                        
                           
                              q
                              0
                           
                           =
                           
                              q
                              
                                 N
                                 +
                                 1
                              
                           
                           =
                           0
                        
                     ), a time window [ei, li
                     ] (the time window of the depot 
                        
                           
                              [
                              
                                 e
                                 0
                              
                              ,
                              
                                 l
                                 0
                              
                              ]
                           
                           =
                           
                              [
                              
                                 e
                                 
                                    N
                                    +
                                    1
                                 
                              
                              ,
                              
                                 l
                                 
                                    N
                                    +
                                    1
                                 
                              
                              ]
                           
                        
                      corresponds to the scheduling horizon of the problem), and nonnegative service times sik
                      that depend on the driver k ∈ K visiting the vertex (
                        
                           
                              s
                              
                                 0
                                 k
                              
                           
                           =
                           
                              s
                              
                                 N
                                 +
                                 1
                                 k
                              
                           
                           =
                           0
                           ,
                           k
                           ∈
                           K
                        
                     ). Associated with each arc (i, j) is a distance dij
                      and travel times tijk
                      which denote the time driver k takes to travel the arc. The binary decision variable xijk
                      equals 1 if driver k visits vertex j after i, and 0 otherwise. Variable τik
                      specifies the start of service of driver k at vertex i.

We study hierarchical objective functions for the VRPTWDST, first minimizing the number of vehicles and only considering a secondary objective in case of ties. We independently address two alternative secondary objectives: (i) minimize traveled distance, and (iii) minimize working duration, which are detailed in the following. Using a hierarchical objective function is inspired by heuristic works on the closely related VRPTW, however, the vast majority of works on VRPTW only consider the minimization of traveled distance as secondary objective.

                        
                           1.
                           Minimize traveled distance (TD):

                                 
                                    
                                       
                                          min
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                          
                                             ∑
                                             
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                A
                                             
                                          
                                          
                                             d
                                             
                                                i
                                                j
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                j
                                                k
                                             
                                          
                                       
                                    
                                 
                              Driver-specific times only indirectly influence TD, and potentially different routes with respect to the time window constraints are possible. This can lead to a reduced number of vehicles (because a higher number of customers can be served on routes) and to reduced traveled distances. Thus, this objective is suitable to analyze the benefits that can be achieved by being able to better meet time windows.

Minimize working duration (WD):

                                 
                                    
                                       
                                          min
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                          
                                             (
                                             
                                                τ
                                                
                                                   N
                                                   +
                                                   1
                                                   k
                                                
                                             
                                             −
                                             
                                                τ
                                                
                                                   0
                                                   k
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              WD is defined as the difference between the start and end time of the routes. It can alternatively be described as the sum of travel, service and waiting times of a solution. In addition to the benefits that can be gained by being more flexible with regards to time windows, this objective includes the time gains achieved by using arcs with reduced travel times and visiting customers with reduced service times. Here, the driver-specific times influence the objective function value in a direct fashion. This objective is interesting to study because in general payment of drivers is based on this value.

The constraints of the VRPTWDST are as follows:

                        
                           (1)
                           
                              
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       
                                          V
                                          
                                             N
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                       k
                                    
                                 
                                 =
                                 1
                                 
                                 ∀
                                 i
                                 ∈
                                 V
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       
                                          V
                                          
                                             N
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 
                                    x
                                    
                                       0
                                       j
                                       k
                                    
                                 
                                 =
                                 1
                                 
                                 ∀
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          V
                                          0
                                       
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                       k
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          V
                                          
                                             N
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                       k
                                    
                                 
                                 =
                                 0
                                 
                                 ∀
                                 j
                                 ∈
                                 V
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    x
                                    
                                       i
                                       j
                                       k
                                    
                                 
                                 
                                    (
                                    
                                       τ
                                       
                                          i
                                          k
                                       
                                    
                                    +
                                    
                                       s
                                       
                                          i
                                          k
                                       
                                    
                                    +
                                    
                                       t
                                       
                                          i
                                          j
                                          k
                                       
                                    
                                    −
                                    
                                       τ
                                       
                                          j
                                          k
                                       
                                    
                                    )
                                 
                                 ≤
                                 0
                                 
                                 ∀
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ∈
                                 A
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    e
                                    i
                                 
                                 ≤
                                 
                                    τ
                                    
                                       i
                                       k
                                    
                                 
                                 ≤
                                 
                                    l
                                    i
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 
                                    V
                                    
                                       0
                                       ,
                                       N
                                       +
                                       1
                                    
                                 
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    ∑
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       ∈
                                       A
                                    
                                 
                                 
                                    q
                                    i
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                       k
                                    
                                 
                                 ≤
                                 C
                                 
                                 ∀
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    x
                                    
                                       i
                                       j
                                       k
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 
                                 ∀
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ∈
                                 A
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                  

Constraints (1) state that each customer is visited by exactly one vehicle. Constraints (2) require each vehicle to start from the depot. Flow conservation constraints are given in (3). Time window and capacity restrictions are enforced by constraints (4)–(6). Binary variables are defined in constraints (7).

TS is a local-search-based metaheuristic whose principles were first proposed in Glover (1986). In each iteration, the search considers the neighborhood 
                        
                           N
                           (
                           S
                           )
                        
                      of the current solution S. In general, the neighborhood is implicitly defined by means of neighborhood operators, which describe modifications to the current solution. In order to be able to escape from low-quality local optima, TS selects the best neighbor of the current solution at each iteration, even if it is of lower quality. In addition, recently visited solutions or attributes of the solutions are stored in a tabu list and are prohibited for some iterations called the tabu tenure. In this way, short term cycling of the search process is avoided. TS has successfully been applied to various combinatorial optimization problems providing near-optimal solutions in reasonable computing times. For a detailed description of TS and its extensions, we refer to Gendreau and Potvin (2010).

Our TS-DST for addressing the VRPTWDST applies some ideas similar to the ones presented in the TS methods of Toth and Vigo (2003), Cordeau, Gendreau, and Laporte (1997), and Cordeau, Laporte, and Mercier (2001). An overview of the algorithm is given in pseudocode in Fig. 1
                     . After eliminating infeasible arcs in a preprocessing step as described in Section 4.1, the initial solution is generated with an adapted version of the I1 heuristic presented by Solomon (1987) (Section 4.2). The initial solution and the solutions during the TS phase are allowed to be infeasible. They are evaluated by means of a generalized cost function that penalizes infeasible solutions based on the amount of capacity and time window violation (Section 4.3). In each iteration of TS-DST, a set of neighborhood operators are applied to the current solution S to generate the composite neighborhood 
                        
                           N
                           (
                           S
                           )
                        
                      (Section 4.4).

Each possible move is evaluated and the best non-tabu move is performed. However, if the algorithm carries out a so-called probabilistic phase for diversification, a random of the best ξ non-tabu moves is selected. A move is superior if it either reduces the number of employed vehicles or, in case of ties, has a better objective function value according to the generalized cost function described in Section 4.3. After executing the move, the tabu list, the best overall solution and the penalties are updated and the algorithm decides whether a probabilistic phase is started, continued or ended as described in Section 4.5. Besides probabilistic phases, we apply further search diversification techniques like, e.g., shaking the solution. The respective techniques, described in Section 4.5, are applied if the search has not improved the best found solution for a certain number of iterations. Finally, the termination criterion of the search depends on the mode of the TS-DST run, i.e., whether it is searching for a feasible solution with a given number of vehicles or minimizing the secondary objective (see Section 4.6 for details).

As often done for VRPs, we use a preprocessing step to remove those arcs from the solution graph that cannot belong to a feasible solution. An arc can either be infeasible due to time window or due to capacity constraints. To identify these arcs, we use the following rules and remove all arcs (v, w) ∈ A for which one of the following conditions holds:

                           
                              (8)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                q
                                                v
                                             
                                             +
                                             
                                                q
                                                w
                                             
                                             ≥
                                             C
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                min
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                (
                                                
                                                   e
                                                   v
                                                
                                                +
                                                
                                                   s
                                                   
                                                      v
                                                      k
                                                   
                                                
                                                +
                                                
                                                   t
                                                   
                                                      v
                                                      w
                                                      k
                                                   
                                                
                                                )
                                             
                                             ≥
                                             
                                                l
                                                w
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                min
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                (
                                                
                                                   e
                                                   v
                                                
                                                +
                                                
                                                   s
                                                   
                                                      v
                                                      k
                                                   
                                                
                                                +
                                                
                                                   t
                                                   
                                                      v
                                                      w
                                                      k
                                                   
                                                
                                                +
                                                
                                                   s
                                                   
                                                      w
                                                      k
                                                   
                                                
                                                +
                                                
                                                   t
                                                   
                                                      w
                                                      N
                                                      +
                                                      1
                                                      k
                                                   
                                                
                                                )
                                             
                                             ≥
                                             
                                                l
                                                
                                                   N
                                                   +
                                                   1
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Eq. (8) describes capacity violations that occur if the cumulative demand of two customers exceeds the vehicle capacity. Eqs. (9) and (10) adapt well-known preprocessing steps based on time window violations to VRPTWDST. Eq. (9) states that an arc can be removed if even the driver with the minimum travel and service time on this arc is not able to reach w within the given time window when starting service at v at the earliest possible time. Eq. (10) is similar but considers the depot deadline. If the driver with the minimum travel and service times is not able to return to the depot in time after consecutively visiting customers v and w, the arc (v, w) is infeasible.

Because the majority of the overall run-time of TS-DST is spent on the evaluation of local search moves, the impact of the preprocessing step on the run-time of the algorithm is determined by the percentage of arcs that can be eliminated in the problem instances. In Appendix A, we report the respective values for the newly generated VRPTWDST benchmark instances described in Section 5.2.

To generate an initial solution, we use a slight modification of the insertion heuristic I1 introduced by Solomon (1987). Our algorithm creates a potentially infeasible solution with a given number of vehicles m instead of a feasible solution with an open number of vehicles as in the original version. We define a vehicle route r as a sequence of customers 
                           
                              〈
                              
                                 v
                                 0
                              
                              ,
                              
                                 v
                                 1
                              
                              ,
                              …
                              ,
                              
                                 v
                                 n
                              
                              ,
                              
                                 v
                                 
                                    n
                                    +
                                    1
                                 
                              
                              〉
                              ,
                           
                         with v
                        0 and 
                           
                              v
                              
                                 n
                                 +
                                 1
                              
                           
                         representing the depot. A solution S to a VRPTWDST instance is defined as a set containing m(S) routes, i.e., 
                           
                              S
                              =
                              {
                              
                                 r
                                 k
                              
                              ,
                              k
                              =
                              1
                              ,
                              …
                              ,
                              m
                              
                                 (
                                 S
                                 )
                              
                              }
                           
                        . The initialization procedure in pseudocode is shown in Fig. 2
                        .

To be able to use the approach in the presence of driver-specific times, we calculate average travel and service times over the different drivers, thus transforming a VRPTWDST problem instance into a VRPTW instance. For the secondary objective of minimizing working duration, we solve an assignment problem afterwards (using IBM ILOG CPLEX Optimizer 12.1) to find the cost-optimal assignment of available drivers to the routes of the initial solution.

Our insertion heuristic sequentially opens routes and fills them with customers according to specific criteria until no more customers can be feasibly inserted. To open a new route, the procedure selects the unrouted customer farthest from the depot v
                        seed and generates a new route 
                           
                              r
                              =
                              〈
                              
                                 v
                                 0
                              
                              ,
                              
                                 v
                                 seed
                              
                              ,
                              
                                 v
                                 
                                    n
                                    +
                                    1
                                 
                              
                              〉
                           
                        . In the next step, for each of the still unrouted customers v ∈ V
                        unrouted the best insertion position p*(v) between two consecutive customers in r is determined according to criterion c
                        1 in Eq. (11):

                           
                              (11)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                p
                                                *
                                             
                                             
                                                (
                                                v
                                                )
                                             
                                             =
                                             
                                                arg min
                                                
                                                   p
                                                   =
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   n
                                                
                                             
                                             
                                                (
                                                
                                                   c
                                                   1
                                                
                                                
                                                   (
                                                   
                                                      v
                                                      
                                                         p
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   v
                                                   ,
                                                   
                                                      v
                                                      p
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                c
                                                1
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                             =
                                             
                                                ϵ
                                                1
                                             
                                             ·
                                             
                                                c
                                                11
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                             +
                                             
                                                ϵ
                                                2
                                             
                                             ·
                                             
                                                c
                                                12
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                c
                                                11
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                             =
                                             
                                                d
                                                
                                                   x
                                                   y
                                                
                                             
                                             +
                                             
                                                d
                                                
                                                   y
                                                   z
                                                
                                             
                                             −
                                             ι
                                             ·
                                             
                                                d
                                                
                                                   x
                                                   z
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                c
                                                12
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                             =
                                             
                                                a
                                                z
                                             
                                             −
                                             
                                                a
                                                z
                                                old
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             with
                                             
                                             ι
                                             ≥
                                             0
                                             ,
                                             
                                             
                                                ϵ
                                                1
                                             
                                             +
                                             
                                                ϵ
                                                2
                                             
                                             =
                                             1
                                             ,
                                             
                                             
                                                ϵ
                                                1
                                             
                                             ≥
                                             0
                                             ,
                                             
                                             
                                                ϵ
                                                2
                                             
                                             ≥
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Eq. (12) considers the increase in traveled distance due to the insertion of the customer (calculated in Eq. (13)) and the increase of the arrival time at the successive customer (given in Eq. (14), here 
                           
                              a
                              z
                              old
                           
                         denotes the arrival time before the insertion of the customer, 
                           
                              a
                              z
                              
                           
                         after the insertion). ϵ1, ϵ2 and ι are parameters for evaluating the cost of insertion of a customer.

Subsequently, the customer v* that can be feasibly inserted and that maximizes Solomon’s c
                        2 criterion is added to the route at its best insertion position (parameter ν is used for weighting the distance from the depot):

                           
                              
                                 
                                    
                                       
                                          
                                             v
                                             *
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                arg max
                                                
                                                   v
                                                   ∈
                                                   
                                                      V
                                                      unrouted
                                                   
                                                   ∧
                                                   feasibleInsert
                                                   
                                                      (
                                                      v
                                                      )
                                                   
                                                
                                             
                                             
                                                (
                                                
                                                   c
                                                   2
                                                
                                                
                                                   (
                                                   
                                                      v
                                                      
                                                         
                                                            p
                                                            *
                                                         
                                                         
                                                         
                                                            (
                                                            v
                                                            )
                                                         
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                   v
                                                   ,
                                                   
                                                      v
                                                      
                                                         
                                                            p
                                                            *
                                                         
                                                         
                                                         
                                                            (
                                                            v
                                                            )
                                                         
                                                      
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                c
                                                2
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             ν
                                             ·
                                             
                                                d
                                                
                                                   0
                                                   y
                                                
                                             
                                             −
                                             
                                                c
                                                1
                                             
                                             
                                                (
                                                x
                                                ,
                                                y
                                                ,
                                                z
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                          ν
                                       
                                       
                                          ≥
                                       
                                       
                                          0
                                       
                                    
                                 
                              
                           
                        These steps are repeated as long as a customer can be inserted into the route without violating constraints. If this is no longer possible, the route is closed, added to the solution S and the procedure continues with the next route until either m routes are created or each customer is routed. After m routes have been created, any customers that are still unrouted are added to the routes at the best insertion position according to the generalized cost function f
                        gen described in the following section.

We permit capacity and time window violations during the initialization and improvement phase using the generalized cost function 
                           
                              
                                 f
                                 gen
                              
                              
                                 (
                                 S
                                 )
                              
                              =
                              f
                              
                                 (
                                 S
                                 )
                              
                              +
                              α
                              ·
                              
                                 P
                                 c
                              
                              
                                 (
                                 S
                                 )
                              
                              +
                              β
                              ·
                              
                                 P
                                 tw
                              
                              
                                 (
                                 S
                                 )
                              
                              ,
                           
                         where f(S) denotes the original objective function value of solution S, i.e., traveled distance or working duration, and Pc
                        (S) and P
                        tw(S) are the total capacity and time window violations of S, which are weighted by the penalty factors α and β. The latter are dynamically updated during the search to allow for more diversification if the current solution is feasible and, in the contrary case, to guide the algorithm to a feasible solution (see, e.g., Gendreau, Hertz, & Laporte, 1994). The time window or capacity violation penalty factor is multiplied by a factor δ after the respective constraint is violated for η
                        penalty iterations. If the constraint is met for η
                        penalty iterations, the respective penalty factor is divided by δ. The penalty factors are restricted to the interval [α
                        min, α
                        max] and [β
                        min, β
                        max] respectively.

TS-DST uses the neighborhood operators Relocate, Exchange and 2-opt* (see Section 4.4). Consequently, the capacity penalty Pc
                        (S) of a solution S can be computed in 
                           
                              O
                              (
                              1
                              )
                           
                         time (see, e.g. Kindervater & Savelsbergh, 1997). To determine time window penalties, we adapt the time travel approach, proposed by Nagata et al. (2010) for computing time window violations for the VRPTW, to the VRPTWDST. Summarizing this technique, if a time window violation occurs at a certain customer, a penalty of the actual arrival time minus the latest feasible arrival time is assigned to the route. However, the calculation of violations for the following customers is executed as if a travel back in time to the latest feasible arrival time had taken place. In this way, none of the subsequent customer visits are affected by the actual delay at the customer. This approach has two important advantages compared to the traditional approach of propagating time window violations along the route. First, it allows to evaluate potential time window violations for inter-route moves in constant time 
                           
                              O
                              (
                              1
                              )
                           
                         for the conventional neighborhood operators, which significantly speeds up the calculation compared to the traditional approach. Second, the approach penalizes time window violations only at the customers where they originate and feasible parts of routes are no longer penalized by earlier time window violations.

Empirical investigations on the Solomon VRPTW instances have shown that the time travel approach provides superior solution quality compared to traditional time window handling techniques (see Vidal, Crainic, Gendreau, & Prins, 2015). Note that this may clearly be different for VRPTW instances with different characteristics or other VRPs with time window constraints like the VRPTWDST. Another possible disadvantage of the time travel approach is that the amount of time travel is not limited, i.e., it is possible to travel back in time to an extent that the adjusted start time of service at a violating customer lies before the start time of service at the preceding customer. However, the results in Vidal et al. (2015) suggest that this drawback has only minor influence on solution quality.

We use a straightforward adaption of the time travel approach: we determine all time window handling related variables of a route based on the driver-specific times of the driver currently assigned to the route. In this way, penalties for the Relocate and Exchange operator can be computed in constant time by applying the original rule for merging partial paths given in Nagata et al. (2010) and the corrected rule for inserting a vertex between partial paths presented in Schneider, Sand, and Stenger (2013). The reason is that for Relocate and Exchange both partial paths “belong” to the same driver and thus all time window handling related variables are available for the partial paths. However, this is not true if the rule for merging partial paths is applied for calculating the time window penalty of a 2-opt* move. Here, the first and the second partial path to be merged belong to different routes, which are carried out by different drivers. Therefore, the variables for the second partial path are not adequate for the driver performing the first partial path and vice versa and thus recalculations are necessary.

TS-DST combines several neighborhood operators to build a composite neighborhood:

                           
                              
                                 Relocate is used for both inter and intra-route moves. The operator removes one vertex from a route and inserts it into another route at an arbitrary position (inter-route) or into the same route at a different position (intra-route), see Savelsbergh (1992).


                                 Exchange is also used in inter and intra-route fashion and swaps the position of two vertices (Savelsbergh, 1992).


                                 2-opt*
                                  is only used for inter-route moves. The operator removes one arc from each route and reconnects the first part of the first route with the second part of the second route and vice versa (Potvin & Rousseau, 1995).

The neighborhood in each iteration of TS-DST is generated by applying the above neighborhood operators for each arc of the list of generator arcs. Using arcs as move generators was originally introduced in Toth and Vigo (2003). The so-called generator arc (v, w) modifies the solution in a manner that after application of the move, vertex v is followed by vertex w. In this way, all other arcs to be removed and added are specified for a given operator. A more detailed description of the utilized neighborhood operators and their implementation via generator arcs can be found in Toth and Vigo (2003).

Concerning the implementation of the tabu list, it is well known that saving complete solutions in a tabu list is inefficient concerning storage and comparison effort. Therefore, attributes of a solution like, e.g., the presence of a certain object in the solution, or of a solution transition, e.g., the exchange of an object by another object, are stored, and moves are tabu if they induce these attributes. This also leads to a more extensive exploration of the search space as it helps the search to move away from previously visited parts of the search space. We follow the approach of Toth and Vigo (2003) and consider a move tabu if it reinserts an arc that was removed in one of the previous ϑ iterations, where ϑ denotes the tabu tenure. It is set to a random value in [ϑmin, ϑmax] as proposed by Gendreau et al. (1994). As aspiration criterion, we allow the execution of a tabu move if it leads to a new overall best solution.

Local-search-based heuristics tend to be too local in the sense that the search focuses on small regions of the search space. Therefore, the incorporation of diversification mechanisms, which aim at guiding the heuristic into previously unvisited regions of the solution space, is crucial in the design of efficient solution methods for complex combinatorial optimization problems like the VRPTWDST (Soriano & Gendreau, 1996). We apply several such mechanisms in TS-DST, which are described in the following.

Continuous diversification constantly tries to guide the search into previously unexplored regions of the solution space by adding a diversification penalty P
                           div(S) to the cost of a solution S. The diversification penalty used in TS-DST is similar to the one given in Cordeau et al. (2001) but has to be defined for our two different objective functions. If a move leads to an inferior solution S′, a diversification penalty P
                           div(S′) is added, which is computed as follows:

                              
                                 
                                    
                                       
                                          P
                                          div
                                       
                                       
                                          (
                                          
                                             S
                                             ′
                                          
                                          )
                                       
                                       =
                                       
                                          λ
                                          div
                                       
                                       ·
                                       f
                                       
                                          (
                                          
                                             S
                                             ′
                                          
                                          )
                                       
                                       ·
                                       
                                          
                                             |
                                             V
                                             |
                                             
                                             m
                                             (
                                             
                                                S
                                                ′
                                             
                                             )
                                          
                                       
                                       ·
                                       
                                          ∑
                                          
                                             
                                                (
                                                v
                                                ,
                                                k
                                                )
                                             
                                             ∈
                                             B
                                             
                                                (
                                                
                                                   S
                                                   ′
                                                
                                                )
                                             
                                          
                                       
                                       
                                          ϱ
                                          
                                             v
                                             k
                                          
                                       
                                       ,
                                    
                                 
                              
                           with the attribute set 
                              
                                 B
                                 
                                    (
                                    
                                       S
                                       ′
                                    
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       (
                                       v
                                       ,
                                       k
                                       )
                                    
                                    :
                                    customer
                                    
                                    v
                                    
                                    is
                                    
                                    served
                                    
                                    by
                                    driver
                                    
                                    k
                                    
                                    in
                                    
                                    solution
                                    
                                    
                                       S
                                       ′
                                    
                                    }
                                 
                                 ,
                              
                            the occurrence frequency ϱ
                              vk
                            of attribute (v, k), the diversification factor λ
                           div and the secondary objective function f.

To further diversify the search, we use probabilistic phases, in which not the best solution is chosen in each iteration but a random one is picked from the list of the best ξ solutions. Once started, a probabilistic phase runs for at most η
                           endProb iterations or is stopped if a new best overall solution is found. The probabilistic phase is initialized as soon as one of the following two criteria is satisfied:

                              
                                 1.
                                 If the search has not improved the best overall solution S
                                    * for η
                                    startProb iterations.

If the time window violation P
                                    tw of the current solution has not changed for η
                                    tw iterations. This criterion helps to diversify if the search gets stuck with a certain (generally small) time window violation and is neither able to find a feasible solution nor to move away due to an ever increasing time window penalty factor that prohibits solutions with a higher time window violation.

To increase the diversification effect of the probabilistic phase, the tabu length ϑ is randomly chosen from a wider interval [ϑminProb, ϑmaxProb] during this phase.

After TS-DST has not found a solution improving the best overall solution for η
                           startRand iterations, we apply a sequence of φ random moves to the current solution (cf. Tan, Lee, Zhu, & Ou, 2001; Nagata & Bräysy, 2009). Furthermore, if TS-DST has not improved S
                           * for η
                           reset iterations, the search is restarted from S
                           *. Due to different tabu list entries and penalties, the search is very likely to take a different path than before.

Although inter-route Relocate and 2-opt* moves are able to reduce the number of vehicle routes in a solution, TS-DST is not designed to minimize the number of vehicles. As the literature on VRPTW shows, very specialized additional techniques are often necessary to achieve competitive results concerning the reduction of the number of employed vehicles (see, e.g., Nagata & Bräysy, 2009). An approach commonly applied for heuristic VRPTW methods is to set the number of vehicles m equal to the number of routes of the best known solution reported in the literature (see, e.g., Taillard, Badeau, Gendreau, Guertin, & Potvin, 1997; Cordeau et al., 2001; Ibaraki, Imahori, Kubo, Masuda, Uno, & Yagiura, 2005).

From a practical viewpoint, starting the search with a given number of vehicles can be justified by the fact that in most real-life applications of VRPTW variants, the number of vehicles is given as exogenous parameter determined by the available fleet size and workforce (Ibaraki et al., 2005). If the number of vehicles is not known, the search has to be applied for various values of m. Here, the assumption is made that in practical situations the range of the number of vehicles can be appropriately restricted.

For TS-DST, we distinguish the following cases:

                           
                              1.
                              In case m is fixed, e.g., due to practical considerations, TS-DST can be adjusted to determine the best possible solution concerning the secondary objectives and employing exactly m vehicles. This is achieved by prohibiting inter-route moves reducing the number of vehicles.

If the number of routes of the best known solution m
                                 best is available, e.g., from the literature, we proceed as follows. We initially set 
                                    
                                       m
                                       =
                                       
                                          m
                                          best
                                       
                                       ,
                                    
                                  and TS-DST tries to find a feasible solution for η
                                 feas iterations. In case a feasible solution is found, the number of vehicles is further reduced until no feasible solution can be found anymore. In contrast, if TS-DST does not succeed, m is increased by one until a feasible solution is found. Up to this point, the search evaluates solutions based on the traveled distance independent of the secondary objective because extensive tests showed that this metric is best suited to find a feasible solution with a restricted number of vehicles. From there, the search continues by optimizing the secondary objective until no improvement has been found for η
                                 stop iterations.

If m is restricted by an interval [m
                                 min, m
                                 max], for example by some real-life requirement, we apply a binary search approach that uses the so-called fast mode of TS-DST to minimize the number of vehicles. For the number of vehicles given by the search step, the fast mode tries to find a feasible solution for η
                                 fast iterations, again evaluating solutions based on the traveled distance. Depending on the success of the run, the next input value is determined by the binary search until a tentative minimum number of vehicles is found. This number is reduced by one and used as input m
                                 best of the procedure described for case 2 to potentially further reduce the number of employed vehicles.

If no restrictions for m are available like in the case of the newly designed problem instances described in the following section, we determine bounds to constrain the search to an interval for which the binary search described in case 3 can be applied. As lower bound, the number of vehicles defined by capacity restrictions of the VRPTWDST instance is used. To determine the upper bound (UB), this number is multiplied by a factor δm
                                  until the fast mode of the search finds a feasible solution.

This section describes the numerical experiments to assess the performance of TS-DST and to study the influence of different problem parameters. First, we explain the parameter setting of TS-DST and the experimental environment in Section 5.1. Because no adequate benchmark instances are available for VRPTWDST in the literature, we describe the generation of a comprehensive set of benchmark instances in Section 5.2. Section 5.3 reports the results of TS-DST on the newly generated instances and investigates the influence of different levels of driver familiarity (expressed by different familiarity factors), different geographical distributions of the familiar customers, and different distributions of familiarity among the drivers. To assess the performance of TS-DST, we conduct tests on the Solomon benchmark for the closely related VRPTW and compare the results to the best-performing VRPTW metaheuristics from the literature (Section 5.4). As described in Section 1, benchmark instances and comparison methods proposed for HFVRPTW are not suitable for benchmarking our algorithm: even if vehicle-specific times are included, the benchmarks contain additional features of heterogeneity that are not in the focus of this work.

To determine the parameter setting of TS-DST, we carry out a series of pretests on a selection of the generated VRPTWDST benchmark instances. We start from a reasonable parameter setting that was found during the development of the method. Using this setting, we tune one parameter at a time, while keeping all other parameters fixed as proposed in Røpke and Pisinger (2006). We conduct 10 runs of TS-DST with each parameter setting and then choose the setting that produces the best average results. This process is repeated with the next parameter until all parameters are tuned once. This procedure resulted in the setting reported in the overview in Table 1
                        .

The initialization described in Section 4.2 uses parameters 
                           
                              
                                 ϵ
                                 1
                              
                              =
                              
                                 ϵ
                                 2
                              
                              =
                              0.5
                           
                         and 
                           
                              ν
                              =
                              ι
                              =
                              1.0
                           
                         to evaluate the insertion cost of a customer. For inserting the remaining infeasible customers into the open routes, the generalized cost function with penalty factors 
                           
                              
                                 α
                                 init
                              
                              =
                              1
                           
                         and 
                           
                              
                                 β
                                 init
                              
                              =
                              5
                           
                         is evaluated. TS-DST is run for a maximum of 
                           
                              
                                 η
                                 feas
                              
                              =
                              25
                              ,
                              000
                           
                         iterations to find a feasible solution with a given number of vehicles and continues to minimize the secondary objective until no improvement has been found for 
                           
                              
                                 η
                                 stop
                              
                              =
                              2500
                           
                         iterations. If the fast mode is used for minimizing the number of vehicles as described in Section 4.6, TS-DST is run for 
                           
                              
                                 η
                                 fast
                              
                              =
                              2500
                           
                         iterations. The tabu tenure ϑ is drawn from the interval [10, 25].

Concerning the penalty factors of the generalized cost function, we achieved the best results by starting with initial values 
                           
                              
                                 α
                                 0
                              
                              =
                              1
                           
                         and 
                           
                              
                                 β
                                 0
                              
                              =
                              200
                           
                         and updating these factors by multiplying or dividing by factor 
                           
                              δ
                              =
                              1.2
                           
                         every 
                           
                              
                                 η
                                 penalty
                              
                              =
                              10
                           
                         iterations. The values are restricted to the interval [1, 6400]. For calculating the diversification penalty, we use a factor 
                           
                              
                                 λ
                                 div
                              
                              =
                              2.0
                           
                        .

After 
                           
                              
                                 η
                                 tw
                              
                              =
                              100
                           
                         iterations without a change in the time window violation of the selected solution and after 
                           
                              
                                 η
                                 startProb
                              
                              =
                              200
                           
                         iterations without improving the overall best solution, a probabilistic phase is executed for a maximum of 
                           
                              
                                 η
                                 endProb
                              
                              =
                              50
                           
                         iterations or until a new best overall solution has been found. The list of solutions considered in each iteration of the phase contains the 
                           
                              ξ
                              =
                              250
                           
                         best solutions. During this phase, the tabu tenure is drawn from the interval [100, 200]. If the best overall solution has not improved for 
                           
                              
                                 η
                                 startRand
                              
                              =
                              1000
                           
                         iterations, we perform 
                           
                              φ
                              =
                              100
                           
                         random moves to diversify the search. After 
                           
                              
                                 η
                                 reset
                              
                              =
                              2500
                           
                         iterations without improvement, we reset to the best overall solution.

TS-DST is coded in C++. Studies on the VRPTW instances and a small part of the experiments on the generated VRPTWDST benchmark are performed on a standard desktop computer PC with an Intel Core i7 870 processor at 2.93 gigahertz, 8 gigabytes of RAM, running Windows 7 Professional. In this way, we are able to assess computation times of the proposed method. Due to the high number of generated VRPTWDST instances and the two different objective functions considered, we conduct the remaining tests on a computing cluster. For these tests, run-times are not comparable due to variations in the allocation of resources.

As described in the introduction, no benchmark instances that allow to systematically investigate driver-specific times are available from the literature. We generate VRPTWDST instances based on the well-known 100-customer VRPTW instances of Solomon (1987). The Solomon benchmark consists of 56 instances divided into six instance groups, which are based on different geographical distributions of the customer locations—uniformly random (R), clustered (C), and a combination of clustered and uniformly random (RC)—and different scheduling horizons of the depot 
                           
                              
                                 l
                                 0
                              
                              −
                              
                                 e
                                 0
                              
                           
                         and capacities of vehicles. Groups C1, R1 and RC1 have a relatively short scheduling horizon and low-capacity vehicles, generally resulting in solutions with a high number of short routes containing only few customers. Groups C2, R2, RC2 have a considerably longer scheduling horizon and high-capacity vehicles, resulting in solutions with a comparatively low vehicle number performing longer routes containing a higher number of customers. Moreover, the instances within a group differ in terms of time window density, i.e., the percentage of customers with a time window (0.25, 0.5, 0.75, 1.0), and time window width, which is defined as the average width of 
                           
                              (
                              
                                 l
                                 v
                              
                              −
                              
                                 e
                                 v
                              
                              )
                           
                         across all customers v in the problem instance.

We define the driver-specific travel and service times of a VRPTWDST instance based on the original distance and service time values of the associated Solomon instance. More precisely, the time tvwk
                         of driver k ∈ K for traveling arc (v, w) ∈ A is defined as 
                           
                              
                                 t
                                 
                                    v
                                    w
                                    k
                                 
                              
                              =
                              
                                 d
                                 
                                    v
                                    w
                                 
                              
                              ·
                              
                                 (
                                 1
                                 −
                                 
                                    γ
                                    
                                       v
                                       w
                                       k
                                    
                                 
                                 )
                              
                              ,
                           
                         where γvwk
                         is the familiarity factor of the driver on this arc. In the same manner, the service time svk
                         for driver k at customer v is computed as 
                           
                              
                                 s
                                 
                                    v
                                    k
                                 
                              
                              =
                              
                                 s
                                 v
                              
                              ·
                              
                                 (
                                 1
                                 −
                                 
                                    γ
                                    
                                       v
                                       k
                                    
                                 
                                 )
                              
                           
                         with γvk
                         denoting the familiarity factor of the driver for serving this customer. The value of the familiarity factor is 0 if the driver is unfamiliar with the respective arc or vertex. If the driver is familiar with the arc or vertex, the familiarity factor takes a value in ]0.0, 0.5] depending on the degree of familiarity (the higher the value, the higher the familiarity of the driver). This setting is motivated by the assumption of a maximal familiarity gain of 50 percent as explained in Section 2. For a given driver, customers and arcs with a familiarity factor > 0 are referred to as familiar customers and respectively familiar arcs of the driver.

Thus, a VRPTWDST problem instance is implemented by extending the standard VRPTW instance file with the customer familiarity factors γvk, v ∈ V and the arc familiarity factors 
                           
                              
                                 γ
                                 
                                    v
                                    w
                                    k
                                 
                              
                              ,
                              v
                              ∈
                              
                                 V
                                 0
                              
                              ,
                              w
                              ∈
                              
                                 V
                                 
                                    N
                                    +
                                    1
                                 
                              
                           
                         for each driver k ∈ K. The number of available drivers |K| is set to the best-known number of vehicles m
                        best for the associated Solomon instance (e.g., reported in Nagata et al., 2010). Note that this value is an UB on the number of required drivers to solve the VRPTWDST instance because the associated VRPTW instance corresponds to a VRPTWDST instance with only unfamiliar customers and arcs.

In order to study the impact of different familiarity configurations, we generate:

                           
                              •
                              A base benchmark set in which the sets of familiar customers are disjoint for all drivers (Section 5.2.1).

A second set in which the familiar regions of different drivers overlap in a controlled fashion (Section 5.2.2).

A third set in which drivers are heterogeneous concerning their familiarity with customers, i.e., there are drivers that are familiar with larger regions while other drivers are completely unfamiliar with the delivery area (Section 5.2.3).

In this setting, for any customer there is exactly one familiar driver, i.e., the set of customers is partitioned among the drivers. The resulting subsets are chosen to be of approximately equal size, containing |V|/m
                           best customers. If |V| is not divisible by m
                           best, some arbitrary subsets are chosen to be larger by one. Subset Vk
                            directly defines the familiar customers of driver k. To allow for a systematic study of the impact of the familiarity level of the drivers, we set the familiarity factors of the familiar customers of all drivers to a prespecified value Γ, i.e., 
                              
                                 
                                    γ
                                    
                                       v
                                       k
                                    
                                 
                                 =
                                 Γ
                                 ,
                                 v
                                 ∈
                                 
                                    V
                                    k
                                 
                                 ,
                                 k
                                 ∈
                                 K
                              
                           . We generate test instances with Γ ∈ {0.1, 0.2, 0.3, 0.4, 0.5}. The familiar arcs of driver k are defined as all arcs starting or ending at a familiar customer. In case of an arc connecting two customers, the familiarity factor of the arc corresponds to the mean value of the familiarity factors of the two customers: 
                              
                                 
                                    γ
                                    
                                       v
                                       w
                                       k
                                    
                                 
                                 =
                                 
                                    
                                       
                                          γ
                                          
                                             v
                                             k
                                          
                                       
                                       +
                                       
                                          γ
                                          
                                             w
                                             k
                                          
                                       
                                    
                                    2
                                 
                              
                           . In case of a depot arc, the familiarity factor of the arc is equal to that of the connected customer.

To determine the subsets Vk
                           , we use two different partitioning mechanisms, called Random and Cluster, which divide the customer set V(x) into a number of disjoint subsets 
                              
                                 
                                    V
                                    k
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 ,
                                 k
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 
                                    m
                                    best
                                 
                                 
                                    (
                                    x
                                    )
                                 
                              
                            given a Solomon instance x.

The Random mechanism selects the customer subsets in a random fashion, resulting in a geographically dispersed distribution of familiar customers for each driver. Although it is difficult to imagine a practical application with such a distribution, we use this mechanism to generate benchmark instances that are hard to tackle since it is difficult to generate routes that exploit familiarity benefits. Therefore, we expect familiarity gains to be rather low on this type of instances. Fig. 3a and c show the distribution of familiar customers obtained with the Random mechanism for a geographically clustered (C105) and a uniformly distributed (R201) Solomon instance. To indicate the familiar customers of each driver, we use different symbols with the following meaning: one driver is familiar with all customers marked by a star, another driver with all those marked by a filled triangle, etc.

The 
                           Cluster mechanism is inspired by the real-world situation in which familiar customers are likely to appear in clusters that a driver became familiar with when serving his territory. Therefore, Cluster selects the familiar customers of a driver to be geographically close to one another. Consequently, we expect higher familiarity gains if this partitioning mechanism is used because it is easier to generate routes that exploit reduced travel and service times. The Cluster mechanism works in a fashion similar to the sweep heuristic of Gillett and Miller (1974): A line centered at the depot is rotated to partition the customers according to their polar angle into subsets of the desired size. The goal of the Cluster mechanism is to achieve a partitioning into subsets of familiar customers that matches the geographical distribution of the customers as close as possible, i.e., we want to avoid situations in which the familiar customers of certain drivers are distributed over two or more different geographical clusters. Fig. 3b depicts the results of the Cluster mechanism for the Solomon instance C105, which shows a sound matching of the familiarity clusters and the geographical clusters. In Fig. 3d, the result of applying the Cluster mechanism on Solomon instance R201 is depicted.

To achieve such a good matching, we restart the sweep procedure |V| times using each of the customers to define the zero degree line with the depot. In this way, |V| different partitionings are generated, whose fit with the geographical distribution is evaluated in the next step: For each of the |V| partitionings, we determine for each subset the central customer, which is defined as the customer with the minimum cumulative distance to all other customers of the subset. The cumulative distance of the central customer to the other customers in the subset is used as an indicator of the subset’s compliance with the geographical distribution. Obviously, the measure increases if the familiar customers are distributed over different geographical clusters. Therefore, the partitioning with the minimum cumulative distance over all subsets is finally selected.

For each of the original 56 Solomon instances, we generate VRPTWDST instances with Γ ∈ {0.1, 0.2, 0.3, 0.4, 0.5} using both partitioning mechanisms (Random and Cluster). This results in a total of 
                              
                                 56
                                 ×
                                 5
                                 ×
                                 2
                                 =
                                 560
                              
                            instances in the base benchmark set.

The second set of instances is generated to investigate the effect of having a higher number of drivers that are familiar with the same larger customer set. We start from the 
                              
                                 56
                                 ×
                                 5
                                 =
                                 280
                              
                            instances of the base set that are created with the Cluster mechanism, and we generate instances in which ξ ∈ {2, 3, 4} drivers are familiar with the same (larger) customer set. The larger set is composed of the original sets of familiar customers of the ξ drivers. To decide which drivers shall be grouped together, we start from the zero degree line of the sweep that generated the final Cluster instance, and we repeatedly merge ξ neighboring subsets in sweep-like fashion as long as we do not exceed the number of available subsets (i.e., number of vehicles) m
                           best. If m
                           best is not dividable by ξ, the b < ξ remaining sets are merged into a larger set and the remaining b drivers are familiar with this last set.

In the described fashion, we generate 
                              
                                 3
                                 ×
                                 280
                                 =
                                 840
                              
                            instances with overlapping sets of familiar customers. Based on the value of ξ, the instances are grouped into sets Overlap-2, Overlap-3, and Overlap-4. Fig. 4 shows the distribution of familiar customers as obtained with 
                              
                                 ξ
                                 =
                                 2
                              
                            on Solomon instance C105 and with 
                              
                                 ξ
                                 =
                                 3
                              
                            on Solomon instance R201. In Fig. 4a, two drivers are familiar with each of the customer sets indicated by the same symbol. In Fig. 4b, three drivers are familiar with the customer set indicated by the triangles, the one remaining driver is familiar with the customers indicated by the circles.

Finally, we generate instances to study the effect of having drivers that are heterogeneous concerning their familiarity with customers. We generate two types of instances. For the first type, we start from the 280 Overlap-2 instances. We imagine the extreme case, in which one of the drivers of each two-driver-cluster is familiar with all customers in the cluster, and the other driver is not familiar with any customer. In this way, we generate 280 instances and denote the resulting set as Heterogeneous-1.

For the second type, for each Solomon instance and familiarity factor, we generate an instance in which ⌈m
                           best/2⌉ of the drivers are familiar with all customers, while the remaining drivers are completely unfamiliar with the entire delivery area. The second group also consists of 280 instances and is denoted as Heterogeneous-2.

In this section, we first present and analyze the results of TS-DST on the base VRPTWDST instance set (Section 5.3.1). Here, special emphasis is put on the influence of the level of driver familiarity (expressed by the familiarity factor) and the distribution of familiar customers (Section 5.3.2), and the impact of the geographical distribution of customers (Section 5.3.3). Subsequently, the impact of a higher number of familiar drivers per region is investigated by means of the Overlap sets (Section 5.3.4). Finally, the impact of a heterogeneous distribution of familiarity among the drivers is studied on the Heterogeneous sets (Section 5.3.5).

We conduct 10 runs of TS-DST on each of the 560 VRPTWDST instances of the base set, using two different objective functions. Both are hierarchical and minimize the number of vehicles first, one minimizes traveled distance (TD) as secondary objective, the other working duration (WD).


                           Table 2 gives an aggregate view on the obtained results for different instance groups. The instance groups are identified by the partitioning mechanism (Random, Cluster) and the familiarity factor (
                              
                                 Γ
                                 =
                                 0.1
                                 ,
                                 0.2
                                 ,
                                 0.3
                                 ,
                                 0.4
                                 ,
                                 0.5
                              
                           ). For each instance group, we report the cumulative number of vehicles (CNV) and the cumulative value of the secondary objective (CTD, CWD) based on the best solution found in the 10 TS-DST runs. For the secondary objective TD, we report the average run-times because the experiments were conducted on our desktop PC. Due to the large number of problem instances and test runs, the studies with the secondary objective WD were carried out on the computing cluster and no run-times are reported (the same is true for the studies in the following sections). However, several pretests with smaller problem sets have shown that no systematic change in the run-times is to be expected because of a different objective function. The complete results on an instance basis for all objective functions are reported in Appendix B as comparison values for potential methods addressing the VRPTWDST in the future.

To better assess the obtained solution quality, we use the following UB for the solution of a given VRPTWDST instance x. It is determined from the vehicle routes that our TS produces if driver-specific times are ignored, i.e., the familiarity factors of all drivers are set to 0 for all customers. These routes correspond to the VRPTW solution of the original Solomon instance that is associated with the given VRPTWDST instance. We interpret these routes as VRPTWDST solution: If the secondary objective is the minimization of traveled distance, the solution value of this VRPTW solution can be directly used as solution value of the VRPTWDST instance because the assignment of drivers to routes does not influence the traveled distance. However, in case of minimizing working duration, the assignment of drivers to routes affects the objective function value because the routes are evaluated with the driver-specific times of the given VRPTWDST instance. Therefore, we solve an assignment problem that assigns the drivers of the VRPTWDST instance to the constructed routes in the manner that minimizes the working duration. In the following, let 
                              
                                 S
                                 x
                                 UB
                              
                            denote the VRPTWDST solution built from the constructed routes.

The described procedure is performed for all instances of an instance group G, and the solution values of the UB are cumulated to 
                              
                                 F
                                 
                                    (
                                    UB
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       x
                                       ∈
                                       G
                                    
                                 
                                 F
                                 
                                    (
                                    
                                       S
                                       x
                                       UB
                                    
                                    )
                                 
                                 ,
                              
                            where F denotes either the number of vehicles (summing up to CNV), the traveled distance (summing up to CTD) or the working duration (summing up to CWD). Let Sx
                            denote the real VRPTWDST solution of instance x, i.e., the solution that TS-DST finds if driver-specific times are considered. Then, the gap of the cumulative objective value 
                              
                                 F
                                 
                                    (
                                    VRPTWDST
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       x
                                       ∈
                                       G
                                    
                                 
                                 F
                                 
                                    (
                                    
                                       S
                                       x
                                    
                                    )
                                 
                              
                            to the described cumulative UB is reported in Table 2 as

                              
                                 
                                    
                                       Δ
                                       UB
                                       =
                                       
                                          
                                             F
                                             (
                                             VRPTWDST
                                             )
                                             −
                                             F
                                             (
                                             UB
                                             )
                                          
                                          
                                             F
                                             (
                                             UB
                                             )
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

The following sections provide a detailed analysis of the TS-DST results.

To illustrate the combined influence of different levels of familiarity (expressed by the familiarity factors) and different distributions of the familiar customers (Cluster and Random) on the number of employed vehicles, Fig. 5
                            depicts the gap of the CNV values obtained for the different instance groups to the CNV values of the UB solutions.

Higher familiarity factors lead to a decrease of the number of vehicles because the reduced travel and service times allow to generate routes with fewer vehicles that are nevertheless able to fulfill all time window requirements. TS-DST is able to assign the drivers to their familiar customers and thus exploits the reduced times. The number of vehicles also shows consistent behavior concerning the influence of the partitioning mechanism: For each familiarity factor, the number of vehicles in the Random generated instance set is higher than in the Cluster set. This could be expected, as it is possible to gather more familiarity benefits if the reduced times of a driver occur in a clustered region, but it again shows the ability of our algorithm to generate solutions in which drivers are assigned to the right regions and customers. Consequently, the best solution is obtained for a Cluster partitioning and a familiarity factor 
                              
                                 Γ
                                 =
                                 0.5
                                 ,
                              
                            reducing the CNV by 13.83 percent compared to the UB.

As discussed in Section 1, it is not possible to derive statements about the optimal level of driver familiarity, i.e., the optimal familiarity factor, from these results because we do not consider the cost of driver learning. However, it can be noted that for the Cluster partitioning, the gains caused by increasing familiarity factors are not equally distributed: most gains are achieved by increasing the familiarity factor from 0.1 to 0.3, while the increase from 0.3 to 0.5 provides notably less gains. In contrast, for the Random partitioning, the gains of higher familiarity factors are more linearly distributed: the gains for increasing the familiarity factor from 0.1 to 0.3 are roughly equal to the gains for increasing from 0.3 to 0.5.

For the secondary objective of minimizing traveled distance, Table 2 shows that no clear trend can be found for the influence of the familiarity factor. The gap sometimes grows for higher familiarity factors and even becomes positive for the Random partitioning. These results can be explained by the interdependency of the first and secondary objectives. It is not necessarily possible to obtain a solution with a reduced traveled distance when employing fewer vehicles. The more consistent behavior for the Cluster partitioning may be explained as follows: for Cluster instances, well-formed, petal-like routes are often sufficient to harvest familiarity benefits in terms of a reduced number of vehicles, thus also leading to reduced traveled distances. For the Random instances less compact, zig-zag-like routes are often necessary to reduce the number of vehicles, thus leading to increased traveled distances.

Although minimizing working duration is also only considered as secondary objective, strong familiarity benefits can be observed. This can be explained by the fact that the reduced times directly influence the objective function value. Moreover, the working duration shows entirely consistent behavior: the negative gaps to UB increase (in absolute terms) for higher values of the familiarity factor for both partitioning mechanisms, although the considered solutions employ fewer vehicles than UB. For all considered values of the familiarity factor, the value of ΔUB for the Cluster set is clearly below that of the Random set because reduced times can better be exploited in the Cluster sets. Finally, we observe that the working duration gains caused by higher familiarity factors behave in a roughly linear fashion for Cluster and Random. Therefore, for both partitioning mechanisms, the “optimal” familiarity factor with regards to working duration is only determined by the preferences of the decision maker (note again that VRPTWDST does not include the cost for achieving higher familiarity factors).

To illustrate the influence of the characteristics of the underlying Solomon instances on the obtained VRPTWDST solutions, Table 3 shows the percentage gaps of the CNV and CTD to the respective value of the UB solutions according to the different Solomon groups. For groups C1 and C2, no reduction of the number of vehicles is possible because all instances in these two groups are generated in a way that the number of vehicles is only bounded by the capacity constraint. Time windows in C1 and C2 are positioned around the arrival times at customers obtained by a solution to the problem without time windows. Therefore, reduced times do not allow to generate notably more efficient routes in terms of traveled distance.

A reduction of the number of vehicles is only possible for R and RC instances. Reductions are on average higher for groups R2 and RC2, i.e., the problems with a longer scheduling horizon. One explanation might be that solutions to these instances employ a very low number of vehicles so that reductions lead to high percentage improvements. On the other hand, this characteristic seems to lead to an increase in traveled distance for most cases.

Finally, note that all Solomon groups individually behave in accordance to the above described trend for the influence of familiarity factors and partitioning mechanism on the CNV: the number of vehicles is decreasing with higher familiarity factors for both Cluster and Random, and the reduction for Cluster is always equal or higher than for Random.

Next, we consider the scenario in which the familiar regions of drivers overlap, i.e., where several drivers are familiar with the same region that consists of the original familiar regions of the drivers. We conduct 10 runs of TS-DST on each of the instances in the Overlap sets and use the best of the 10 runs to determine the CNV and the cumulative secondary objectives CTD and CWD.


                           Table 4
                           
                            presents the cumulative solution values for ξ ∈ {2, 3, 4} different familiar drivers per region, i.e., for the sets Overlap-2, Overlap-3, and Overlap-4. The values are given as percentage gaps to those obtained with 
                              
                                 ξ
                                 =
                                 1
                              
                            familiar driver per region, i.e., the associated Cluster instance from the base set. Fig. 6
                            illustrates the behavior for the primary objective of minimizing the number of employed vehicles.

We observe that a higher number of familiar drivers per region allows to reduce the number of employed vehicles compared to the scenario with one driver per region. On average, the higher the number of familiar drivers per region, the stronger the reduction. However, we find that the gain is relatively small even for four familiar drivers per region ( < 5 percent). Note that increasing the familiarity factor does not lead to a stronger reduction. Considering that the gaps are relative to the Cluster solution with the same familiarity factor, this result is reasonable.

Concerning the traveled distance, meaningful statements are not possible due to the above described interdependency of this objective and the primary objective of minimizing the number of vehicles. However, for the objective of minimizing working duration, fundamental gains can be observed, which consistently increase with the number of drivers per region and with increasing familiarity factors. Therefore, using several familiar drivers to serve the same (or strongly overlapping) regions seems most recommendable if working duration is in the focus of the decision maker.

To study the effect of a heterogenous distribution of driver familiarity, we determine the best of 10 runs of TS-DST for each instance in the sets Heterogeneous-1 and Heterogeneous-2. Table 5 reports the cumulative solution values on the instances where driver familiarity is heterogeneously distributed as gap to the solution values of the corresponding instances with homogeneously distributed familiarity. More precisely, a Heterogeneous-1 instance with familiarity factor Γ is compared to the respective Overlap-2 instance with 
                              
                                 
                                    Γ
                                    base
                                 
                                 =
                                 
                                    Γ
                                    2
                                 
                              
                           . For example, this means that if in a Heterogeneous-1 instance, one driver is familiar with two clusters with a familiarity factor of 
                              
                                 Γ
                                 =
                                 0.5
                              
                            and his counterpart is unfamiliar with both clusters (
                              
                                 Γ
                                 =
                                 0
                              
                           ), then we compare with the Overlap-2 instance where both drivers are familiar with both clusters with a familiarity factor of 
                              
                                 
                                    Γ
                                    base
                                 
                                 =
                                 
                                    Γ
                                    2
                                 
                                 =
                                 0.25
                              
                           . The same principle is used for the Heterogeneous-2 instances. Here, the comparison value is the associated base instance in which all drivers are familiar with all customers with a familiarity factor of 
                              
                                 
                                    Γ
                                    base
                                 
                                 =
                                 
                                    Γ
                                    2
                                 
                                 ,
                              
                            where Γ denotes the familiarity factor of the drivers that are familiar with all customers in the Heterogeneous-2 instance.

Interestingly, we find that heterogeneous distributions of familiarity do not have a negative influence on solution quality compared to homogeneous distributions. On the contrary: for Heterogeneous-1, improvements with regard to the working duration can be observed, and for Heterogeneous-2 considerable improvements in the number of employed vehicles and the working duration can be found, which consistently grow with higher familiarity factors. We conclude that as long as no balancing constraints between driver routes or strict maximal route duration constraints exist, there is no incentive to opt for completely homogeneously distributed driver knowledge. However, given the rather extreme assumptions on the distribution of familiarity in the Heterogeneous-1 instances and the relatively small resulting improvements, having a heterogeneous distribution should not be considered as a means to increase efficiency. The same holds for the Heterogeneous-2 instances: although stronger improvements can be observed here, having drivers that are familiar with the entire delivery area will not be a viable option in most practical situations.

To be able to assess the solution quality and run-time of TS-DST, we run tests on the Solomon VRPTW instances. In this way, we are able to compare our results to those of the VRPTW methods presented in the literature. TS-DST is run 10 times for each problem instance, starting from the best-known vehicle number reported in the literature for the respective instance as described above.

In Table 6
                        , we
                        
                        
                        
                         present the results of TS-DST, in comparison to the best-performing metaheuristics from the literature. For each method, the solution quality in terms of the number of vehicles and traveled distance is reported. We follow the common procedure and give averages over the problem classes C, R and RC and the CNV and the CTD. For TS-DST, we report the best solution found in the 10 runs. As comparison methods, we use HY (Hashimoto & Yagiura, 2008), LCK (Le Bouthillier, Crainic, & Kropf, 2005), BVH (Bent & Hentenryck, 2004), PGDR (Prescott-Gagnon, Desaulniers, & Rousseau, 2009), HYI (Hashimoto, Yagiura, & Ibaraki, 2008), LZ (Lim & Zhang, 2007), PR (Pisinger & Røpke, 2007), RTI (Repoussis, Tarantilis, & Ioannou, 2009), NBD (Nagata, Bräysy, & Dullaert, 2010), B (Bräysy, 2003), and VCGP (Vidal, Crainic, Gendreau, & Prins, 2013).

To allow for a fair comparison of the run-times of the different methods, we follow the approach of Gendreau and Tarantilis (2010) and approximately translate the different hardware used in the tests into a comparable time measure. They derive a relative estimated speed compared to a Pentium 4 2.8 gigahertz processor for each of the used machines based on the performance indicators of Dongarra (2014). We use their reported values and estimate our Intel Core i7 processor at 2.93 gigahertz with a speed factor of 1.74 in comparison to their Pentium 4 after running the LINPACK benchmark used in Dongarra (2014) on our machine. Clearly, this technique for comparing the run-times of the different methods is not exact, but it provides a good indication about the speed of the heuristics. To translate into the common time measure, the relative speed factor, the number of employed processors, the number of executed runs and the run-time in minutes are multiplied. All necessary values are reported in Table 6.

TS-DST achieves the best-known CNV of 405 and a CTD of 57, 662. Concerning the traveled distance, TS-DST ranks 11th among the 12 best performing VRPTW heuristics with only small differences to the CTD found by the best methods: The gap to the CTD of Nagata et al. (2010) is 0.8 percent. This seems a convincing result because TS-DST was designed as solution method for VRPTWDST and the (rather basic) parameter tuning was carried out on VRPTWDST instances. TS-DST is the only TS able to solve the Solomon VRPTW benchmark with a CNV of 405 vehicles and thus the best-performing TS for the VRPTW proposed in the literature. The formerly best-performing TS heuristics for VRPTW are Taillard et al. (1997) with a CNV of 410 and a CTD of 57, 523 and Cordeau et al. (2001) with a CNV of 407 and a CTD of 57, 556.

Concerning run-time, our approach needs on average 24 seconds to solve each instance. This translates to a value of 6.96 for the common time measure and thus, TS-DST is the second fastest of the methods presented in the table. Run-times to the formerly best TSs are not comparable as Taillard et al. (1997) and Cordeau et al. (2001) do not report the necessary values in their papers. In comparison to the results of the VRPTWDST test sets, a reduction of the run-times for VRPTW can be noticed. This can be explained by the additional calculations necessary to apply the time travel approach for time window handling in a driver-specific manner.

This paper investigates the VRPTWDST, a routing problem that integrates different extents of available driver knowledge by means of driver-specific times. We present TS-DST as metaheuristic solution method. We generate a comprehensive set of VRPTWDST benchmark instances covering different familiarity levels and customer arrangements in order to carry out a systematic investigation of the problem. We find that consideration of driver knowledge in the route planning clearly increases the efficiency of vehicle routes, an effect that intensifies for higher familiarity levels. Moreover, increased familiarity benefits are produced if the customers, that drivers are familiar with, are geographically contiguous. A higher number of drivers that is familiar with the same (larger) region provides increased benefits compared to a scenario where each driver is only familiar with a dedicated (smaller) region.

TS-DST is able to prove its performance on Solomon test instances of the closely related VRPTW, yielding high-quality solutions in short time. By accomplishing a CNV of 405 vehicles, TS-DST is the most successful TS method proposed for the VRPTW. The presented TS-DST shows how a simple metaheuristic method can be enhanced with diversification methods to accomplish a very good solution quality for the intensively studied VRPTW, nearly competing with sophisticated approaches. TS-DST can consequently provide well-founded decision support for any logistics company whose routing operations have to take driver knowledge effects into account.

@&#ACKNOWLEDGMENTS@&#

The author would like to thank Kai-Fabian Henning for his help in coding an earlier version of the algorithm, and Hermann-Josef Kruse, Andreas Stenger and the anonymous referees for their constructive comments on the paper.

In this section, we investigate the effect of applying the preprocessing rules presented in Section 4.1. To this end, we determine for each problem instance in the base set the percentage of arcs that can be removed due to these rules. As comparison value, the percentage of arcs that can be removed from the underlying Solomon VRPTW instance is also provided. Table 7 presents the results in percent averaged over the instance groups.

The results show that the percentage of infeasible arcs is strongly dependent on the geographical distribution and scheduling horizon of the underlying Solomon group. The existence of driver-specific times only shows a small impact on the percentage: for higher familiarity factors, the percentage of infeasible arcs decreases slightly. This is because some arcs become feasible due to reduced travel and service times. No significant difference between the Cluster and Random instances can be observed.

We present detailed results of TS-DST on the base VRPTWDST benchmark set described in Section 5.2.1. TS-DST is run 10 times for each problem instance and we report the number of vehicles (m) and the value of the secondary objective function (traveled distance TD, and working duration WD) of the best solution found. Furthermore, averages over the problem classes C, R and RC and the CNV and the cumulative secondary objective function values (CTD, CWD) are given.

For the secondary objective of minimizing the traveled distance, the results can be found in Table 8 for the instance sets generated with the Random mechanism and in Table 9 for the sets generated with the Cluster mechanism. Here, we also report CPU times in seconds as the tests were conducted on our desktop PC. For the secondary objective of minimizing working duration, the results are given in Tables 10 and 11. No run-times are reported as the tests were conducted on the computing cluster.

@&#REFERENCES@&#

