@&#MAIN-TITLE@&#SCPN modeling and comparative performance evaluation of bussed and crossbar-based switched fabric CAN

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           SCPN models of Switched Fabric and Bussed CAN Network are presented using timed colored Petri nets.


                        
                        
                           
                           We evaluate and verify Switched Fabric and Bussed CAN Network using CPNTools.


                        
                        
                           
                           We compare Switched Fabric and Bussed CAN Network models to extract network performance metrics.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Switched-fabric CAN network

CAN controller

Switch fabric

Network performance metrics

Comparison

CPN Tools

@&#ABSTRACT@&#


               
               
                  In recent years, there has been a growth in a category of performance-critical distributed embedded systems and applications. These systems gain complexity when they are equipped with many microcontrollers which oversee many electronic control units (ECU). High performance and predictability are the main criteria of choice for any large-scale networked system dependent on real-time data processing and analysis. Switched-fabric networks can provide fast and highly scalable hardware solutions and are now being increasingly used in distributed systems.
                  In this paper, SCPN models of switched fabric and bussed CAN network are presented using timed colored Petri nets. These models are then evaluated and verified for the desired properties using CPN Tools. Comparison is then applied to both of the models to extract information on network performance metrics.
               
            

@&#INTRODUCTION@&#

The demand for sophisticated embedded systems requires the use of different communicating entities (nodes) interact with each other. The growth of these systems requires more and more complex interaction [1]. A dedicated network bus is used for connecting sensors, actuators in vehicles, humanoid robots, networking fields, manufacture plants, etc… Many serial buses were developed by car makers like MOST, J1850, SAE J1708, Byteflight, LIN and CAN (controller area network)[2]. Most of them are specific to manufacturers and are not standardized. It is widely known that control area network (CAN) is one of the most popular field buses [3] used in real-time [4], distributed and parallel processing [5,6].

More than 400million nodes were sold worldwide. It is used in those applications that require fast and reliable communication [7]. Nowadays, more sophisticated buses offer higher speed to satisfy the high bandwidth required for modern vehicles, suitable for x-by-wire application. They are concurrent to CAN networks like FlexRay [8], which recently appeared, and RTethernet. In contrast the usage of FlexRay [9] is not widely used due to its complex specification and high cost. Current parallel bus-based [10] solutions present some problems. In fact, it's known that the physical separation of cards is limited to usually less than 3ft. There are also limited bandwidths, throughput, high protocol overhead and no deterministic performance. To reduce system life-cycle cost to ease system upgrades, the current solutions require the re-architecturing of the software. The need for the availability (redundant buses, cards or entirely redundant systems) requires complex failover logistics and expensive hardware duplication. The use of switch fabric [11] provides new “net-centric” distributed systems that are much easier to scale, make fault-tolerant and upgrade.

@&#RELATED WORKS@&#

Some related new works can be found in the literature. These works [5,6] concentrate on access technique and the correspondent latency time which are the key elements of the CAN bus. In [5], a model of the CAN arbitration scheme is provided using determinist stochastic Petri nets. Other works [7] focus on modeling the CAN transceiver using VHDL-AMS. The coupling of the throughput and the latency time is one of the works [24] interested in evaluating the CAN bus. In addition scheduling algorithms are proposed in many papers to compute performance evaluation based on CAN networks. Our approach is to translate FSMs from a real CAN controller implementation to a stochastic and colored Petri nets.

A switched-fabric bus is unique in that it allows all CAN controllers on a bus to logically interconnect with all CAN controllers on the bus (Fig. 1
                           ). Each node (CAN controller) is physically connected to one or more switches. CAN controllers may be connected to each other.

The limitations of a bussed network are eliminated with the crossbar switch network. Fig. 1 shows four CAN controllers around a central crossbar switch. Crossbar switches are widely used because of their simplicity and their high-performances which promise to greatly simplify efforts and to add better capability and availability.

In fact, the switching fabric is the physical connection within a switch between the input and output ports; it can be proved that all switches need a crossbar inside their switching fabric which allow them to operate at very high speed (hundreds of Gbps) [12]. Crossbar switch can support simultaneously multiple messages. This greatly increases the aggregate bandwidth of the system. Because of the broadcast nature of the CAN protocol (i.e.: messages are not sent to a specific destination address, but rather as a broadcast). The chosen crossbar switch (as it is shown in Fig. 2
                           ) is configured by closing all its crosspoints to ensure that the CAN message will be sent at the same time for all outputs nodes as it is defined in the CAN protocol.

Furthermore, when short-term overloading occurs, the sum of input rates for a single output port exceeds the outgoing link rate and several buffered solutions are required to scale the crossbar switch performances [13]. Buffering (queueing) characterizes all kinds of switches. Several queueing architectures can be used such as “Input Queueing (IQ)”, “Output Queueing (OQ)” and Combined Input Output Queueing (CIOQ — Internal Speedup), “Shared Buffer”, “Block Crosspoint Queueing and Crosspoint Queueing (CQ)”. For the proposed architecture (see Fig. 2), we use the Combined Input Output Queueing (CIOQ) with VOQs [14] as queuing architecture that is internally non-blocking.

In our work, we modeled the bussed and the switched fabric CAN network using stochastic and colored Petri nets. Then, we evaluated and compared both of the models using CPN Tools. Our major contribution is the study of the proposed architecture performance to raise the lack of the bus solutions. In fact, we demonstrated that CAN based networks using crossbar switched fabric [15] have yet enough period before its replacement and it can compete with the new sophisticated buses.

Our paper is organized as follows:
                              
                                 •
                                 
                                    Section 2 gives a short overview of colored Petri nets and details the SCPN models of the most important bussed and switched fabric CAN modules.

Based on our modeling of both architectures by stochastic and colored Petri nets (SCPN) [16], we present, in the last section, some experiments which are applied to the described models. Three important parameters were measured and compared the throughput, latency time and the loss probability. This comparison is used to demonstrate that the proposed architecture has better performance values than the classical one. In the fourth section we give some conclusions of our work.

In this section, we focus on the main classes and categories of Petri nets which are used to support a variety of systems — ranging from simple to complex — and software requirement engineering processes. Some of the net models could be used to give adequate descriptions [17] of certain systems. In fact, they can be used to describe, test, verify rigorously and determine critical performance issues related to time and failure. Every Petri net class or category has its own particular use to solve a particular problem. However, having a large variety of different net models [17] creates issues as to how to choose the best Petri net type or class for a particular problem. We begin with the classical type of Petri nets, called place/transition net (PT-net). In spite of its easiness of use and simplicity of implementation, it often turned out that this net model was of too low level to cope with the real-world applications added to the fact that we can't differentiate between tokens. Consequently, we can't make a difference between the different CAN message types. To overcome this problem, the first version of non-hierarchical colored Petri nets was defined. Colored Petri nets have been developed by K. Jensen in the course of his PhD thesis to expand the modeling possibilities of classical Petri nets. Like other forms of Petri nets a CPN consists of places, tokens, transitions and arcs. The primary feature unique to CPNs is the inclusion of evolved data structures into tokens [18–20]. These data structures are called colorsets and resemble data structures in high level programming languages; they can range from simple data types such as integers to complex structures like structures or unions in C/C++. Similar to programming languages it is possible to define variables associated with these colorsets such as linked list and queue.

However, complex and hierarchical systems are very difficult to specify correctly using the non-hierarchical CP-nets. For this reason it is important that many different sub-classes and sub-models are solved in detail and then gathered in one model. To solve this problem, hierarchical CP-nets were first presented in [21] and it should be understood that this was the very first successful attempt to create a set of hierarchy concepts for a class of high-level Petri nets. Many industrial applications are described using hierarchical CP-nets. In these models, individual CP-nets [21], called pages, are related in five different ways, known as the five hierarchy constructs: substitution of transitions, substitution of places, invocation of transitions, fusion of places and fusion of transitions [22].

CPN Tools is a high level Petri net tool used for editing, simulating, and analyzing colored Petri nets. CPN Tools was developed in Denmark at Aarhus University by the CPN Group and maintained now by the IS group at Netherlands' Eindhoven University of Technology. It is widely used and provides a strong tool for working with high-level Petri nets in both academic and industrial settings all over the world (over ten thousand licensees in one hundred and forty three countries). CPN Tools supports the basic, timed and colored Petri nets [18–20]. It provides a simulator and a state space analysis tool in addition to a strong user interface performing simple simulation and modification of CPN models.

In order to facilitate modeling of bussed and switched CAN controllers, the CPN models are built following a hierarchical and modular architecture.

Nodes in CAN are identified by their identifier (in both models, colorset Id is a list of 29 bits). The colorsets and variables used in these models are shown in Fig. 4
                        
                        . (See Fig. 3.)

The variables (CAN_msg, CAN_msg1 and CAN_msg2) are of the type of the colorset CAN_message. This variable models the messages which cross the different sub-models.

This colorset is a record of the colorset Id that designates the message priority and the colorset data which represent the data field to be transmitted and the colorset TS for saving the time stamp for the birth of the message.

The CPN CAN controller model mainly focuses on the access mechanism.

Since the communication in CAN is based on bitwise contention, a gain of the bus has to be established before starting data transmission.

The CAN network model shown in Fig. 5
                           , is composed of three nodes. Each node is represented by a substitution transition and three places. The transition called Request_Send_MSG_i (i∈[0:2]) is a hierarchical transition which describes the message generation within the node, how the messages are stored in buffer and how the request to send message is submitted. The place Buffer_Node_i is used to store the messages already generated. This place is configured with colorset CAN_messages which is a list of colorset CAN messages. The place Request_bus_i is used to notify the controller that at least one message is ready to send over network. When a token is present in Request_bus_i place, a message is ready for sending. The place antirequest_bus_i is used to replace the usage of inhibitor arc. All the requests are submitted to the hierarchical transition Synch_send_MSG. This last transition ensures that if a request is asserted and the CAN bus is free (State idle) then the message(s) for that/those node(s) is/are capable to start send the message and get the bus (message synchronization).

The originated message is split in three places (Fig. 5), one for the ID named ID_i, the second for the data named Data_i and the third for saving the time stamp for the birth of it named TS_i. The places anti_ID_i shown in Fig. 5 serve for handling the priority of simultaneous enabled transitions and inhibitor arcs to make the model determinist. Initially the places ID_i, Data_i, TS_i are empty, so the presence of token on those places means that a request is disserted (message present with the availability of the network) and the message(s) is/are being transmitted. Once the message is split, the hierarchical SEND_MSG transition ensures that the message is sent to the CAN bus using the bitwise contention property.

The most important part in this model consists of ID_transmit_i (i∈[0:2]) and CAN_bus_arb. The CAN_bus_arb transition models the bit wise contention in CAN network.

On the ID_transmit_0 transition the information in ID_0 place is important and decides if the data present in place Data_0 can be sent later or not (see Fig. 6
                           ).

The place Bit_NB is used to count the bits, belonging to ID field, which are sent over network. The places Send_ID_bit_0 and Send_ID_bit_int hold token of colorset bit. The first is used as an entry for the CAN bus (to calculate the real CAN bit on the network) while the second is used locally on the node 0 and will be used later for comparison between the real bit existing on the network and the sent one. In fact, the transition send_bit_started is responsible for the comparison described above. It removes the token from place Send_ID_bit_int and compares it to what exists on the place CAN_bit. Upon this comparison, the node knows if it can send the next bit or should wait for the next message.

The next important part of the model is the CAN_bus_arb hierarchical transition which is intended to calculate the CAN bit value across network.

As shown in Fig. 7
                           , this sub-model is composed of three transitions in which two of them are hierarchical and are as follows: arb_three_nodes, arb_two_nodes and arb_One_node_alone. The first illustrates the case that the three nodes start sending the message concurrently (when the bus was idle and all the three nodes have pending messages). The second transition labeled arb_two_nodes is a hierarchical transition. It illustrates the case that only two nodes are sending concurrently. This transition can happen either if three nodes are initially transmitting simultaneously and one of them loses arbitration so two remain on the bus or only two nodes have a message when the bus was free. The last transition called arb_One_node_alone fires if only one node is being transmitting on the network. We can obtain this case if initially two nodes were sending and one of them loses arbitration so the one having the lowest ID value resides in the network.

As we can see from Fig. 7, the places Send_ID_bit_i (i∈[0:2]) as well as anti_Send_ID_bit_i and CAN_bit places are connected to the all transitions.

The Send_ID_bit_i represents the bit that node i puts on the bus. The anti_ID_i (i∈[0: 2]) are used as a part for inhibitor arcs to distinguish when actually one or two nodes are on the bus. Thus, the two hierarchical transitions use these places to distinguish when a node hasn't a message.

The root of the hierarchical representation of the model is shown in Fig. 8
                           .

The switched fabric CAN 3×3 whose activity is modeled by the transition Switched_Fabric transmits the CAN messages via the switch fabric. The places IN_i and OUT_i (i can be a value between 0:2) play the role of inputs/outputs for sub-models.

Messages sent through the switched fabric CAN are represented by tokens of the colorset CAN_message. This variable models the messages which cross the different sub-models of Fig. 9
                            (Node_i, Broadcast_i, FiFo_i_j and Scheduler_i). The switched CAN network model in Fig. 9 is composed of three nodes. Each node is represented by a transition and two places. The transition called Node_i (i can be a value between 0:2) is a hierarchical transition which describes the message generation within the node and how the messages are stored in buffer.

The place Buffer_Node_i is used to store the messages already generated. It represents message buffer, size of 4.

This place is configured with colorset CAN_messages which is a list of colorset CAN_message. When a token is present in this place (Length CAN_msgs >0) a message is ready for sending. This last fires the hierarchical transition Broadcast_i.
                        

The originated message is duplicated in three places, one for each output port of the switch fabric. According to the priority which is associated to the messages (defined by their ID), the messages are stored in the corresponding FIFO queue (there is as many queues as of priorities). In this model, three levels of priority are defined: 0: high level of priority; 1: medium priority and 2: low priority. FiFo_i_j is a substitution transition which presents the queue of input_i for the output_j. It processes the messages in the order of their arrival. Its main function is to concatenate incoming message (CAN_msgi) to the CAN_msgs list (Buffer_i_j). Finally, the scheduler processes the different messages according to its scheduling policy.

The most important part in this model consists of Broadcast_i and scheduler_i transitions (i∈[0:2]). In fact, the set of broadcasting message is represented by the model described in Fig. 10
                           .

Transition Liberate models a message coming from Buffer_node_i.

The Buffer_node_i place is a list of CAN_Message. When the list length is not null (i.e. there is at least a message to send) and if the line is free (there is a token in Line_Free place), the liberate transition can be fired. Otherwise, message coming from Node_i has to be delayed Transfer_Data_Delay until the previous message will be liberated.

If the message is liberated, the server token will be moved from the place Line_Free to Line_Busy. Then the messages will be duplicated in the right places (queues) according to their priorities.

For example, a message of medium priority (CAN_msg1) will be routed to the places m1_0, m1_1 and m1_2. The CAN message m1_i will be queued in the queue 1 of the output port i (OUT_i).

The next important part of the model is the Scheduler_i transitions (i∈[0: 2]).

The model in Fig. 11
                            describes the behavior of a static priority scheduling. The type of messages is classified in three groups:
                              
                                 –
                                 High priority messages: These messages are generated by Node_0 and are modeled in the place Buffer_i_0 as a list of CAN_Message (CAN_msgs) in the Scheduler of the output port i (OUT_i) (i∈[0:2]).

Medium priority message: Those are generated by Node_1 and are modeled in the place Buffer_i_1 as a list of CAN_Message (CAN_msgs1) in the Scheduler_i (i∈[0:2]).

Low priority message; those are generated by Node_2 and are modeled in the place Buffer_i_2 as a list of CAN_Message (CAN_msgs2) in the Scheduler_i (i∈[0:2]).

A message with lowest priorities can be delayed by the other packets due to the non-preemptive characteristics of this kind of message scheduling algorithm [23].

For example, in the case of Scheduler_0, the messages of Buffer_0_2 (low priority messages) has to wait until the messages of Buffer_0_0 and Buffer_0_1 (high and medium priority messages) are fully transmitted. Then, the messages of Buffer_0_1 (medium priority messages) has to wait until the messages of Buffer_0_0 (high priority messages) are fully transmitted.

This scheduling policy is modeled using bidirectional arcs between buffer places and the transitions T1 and T2. These arcs are inhibitor arcs [20].

When there is at least a message to transmit, the Ti transition can be fired if the server is free; what it means is that there is a token in the Free_server place. Otherwise, the following message (according to the algorithm described above) have to be delayed Time_Sched_Delay until the previous message is fully transmitted. After the transmission of the message, the server token will be moved from the place Busy_sereri to Free_server. The static priority scheduling algorithm is used to respect the CAN specification.

The objective of this part is to simulate switched fabric CAN and to compare it with the traditional bus-based CAN. To analyze different traffic experiments and to have a correct and right comparison, the simulation environment should be the same for both models: the nodes in both models (switched and bussed) are configurable as follows:
                        
                           –
                           The duration of Data bursts (measured in clock cycles) to be transmitted is equal to Total_byte
                              ×8×
                              Bit_Delay in the bus case and it is equal to Transfer_Data_Delay in the switched fabric case. (Total_bytex8xBit_Delay
                              =
                              Transfer_Data_Delay).

The average delay between two successive requests for sending a message is lambda_i for each node i.

Each node represents a class of message object: node 0 is the class of high priority messages denoted by two dominant bits Dom, Dom at the beginning of its ID. The second node 1 is the class for medium priority messages starting with Res, Dom or Dom, Res on its ID field. The last node 2 is for low priority messages denoted by Res, Res value at the beginning of its ID field.

Performance metrics obtained for the SCPN models are the number of requests sent, throughput, latency and loss probability. The number of requests sent is measured by the addition of counting the times the transitions Generate and FIFO_FULL are fired (in Node_i substitution transition). The throughput is the total messages sent divided by the total messages generated in the time spent [24]. Latency in this case, corresponds to the average time spent from the birth time of the message (saved in the TS variable) until its full transmission.

Loss probability is the total message lost (due to full FIFO in input buffer or output buffer) divided by the total message requested. In CPN Tools, there are monitor tools which provide statistics measurement on either places or transitions [19].

A group of monitors called NB_MSG_i_G and NB_MSG_i_Not_load (i is in 0..2) are used to measure the occurrence transitions of Generate and FIFO_FULL for each node. The total number of those occurrences represents the total message generated by the application layer. Another group monitor denoted by Delay_to_S_msg is used for calculating the average delay that a message takes from generation at Generate transition to the transition Transmitted_i_i. This group is a data collector monitor and the observer function ensures the calculation of the time that a message spends using the information on the TS place (in FiFo_i_j substitution transition).

The average of this monitor is in fact the latency delay. A group of monitors named NB_MSG_LOST counts the occurrence transitions of FiFo_Full_sched_i for node1 and node2. In the context of network performance, analysis experiments have been conducted with the SCPN model.

The experiments are defined as the following: the total inter-arrival time for all nodes is increased from 10packets/s to 100,000packets/s. The load varies in all nodes with the same proportion by the following manner:
                        
                           (E. 1)
                           
                              
                                 λ
                                 0
                                 =
                                 λ
                                 
                                 r
                                 0
                              
                           
                        
                     
                     
                        
                           (E. 2)
                           
                              
                                 λ
                                 1
                                 =
                                 λ
                                 
                                 r
                                 1
                              
                           
                        
                     
                     
                        
                           (E. 3)
                           
                              
                                 λ
                                 2
                                 =
                                 λ
                                 
                                 r
                                 2
                                 .
                              
                           
                        
                     
                  

For the three equations (E. 1, E. 2 and E. 3) r0, r1and r2 are chosen to ensure that the higher priority always guarantees the lowest latency. It is well known that the condition r0≤r1≤r2 must be respected to demonstrate that the impact of lowest priority on the higher one. In fact, the number of high priority messages must be less than the low priority messages (inter arrival time of msg_0 has to be greater than the inter arrival time of msg_1 and msg_2).

In our experiment, we have chosen r0=0.2, r1=0.3 and r2=0.5. The experiment treats the influence of low priority nodes on the highest nodes and focuses on the impact of high priority nodes on the low priority nodes.

CPN Tools does not support non-terminating simulation to investigate the steady state of the modeled system. However, a group monitor is used to detect network stability. In fact, such condition uses a complicated algorithm not yet supported by the tool. Using the available monitor features of CPN Tools, we create conditions to know when the network is stable. The basic idea was to compare the last latency delay with its average. When it is too close to it, we increment a counter. If the counter reaches a threshold, we stop the simulation. The stop condition must be checked for all the nodes of the network. The group monitor Steady_Network ensures the stop condition of the simulation. It consists of seven monitors and it is as follows: two for each node, one for calculating the difference of the last latency delay to the average; the second, msg_i_c, checks if the difference is less than the threshold (chosen 10μs). When the condition is true, this monitor returns to one. Otherwise, it returns to zero. The monitor Stop_steady_Network is a breakpoint monitor which checks if for each node we collect a satisfied count number (chosen 1000) of the msg_i_c. To collect statistically reliable date, we run 5 simulation replications using the function CPN'Replications.nreplications 5 (see Fig. 8).


                        Fig. 12
                         shows the throughput of the nodes versus the total requested load. We can see in both cases (switched fabric and bussed CAN) that the node 0's achieve full throughput (100%) until 3×104
                        packets/s and it is not affected at all values by the requested load. In fact, node 0 is a high priority node so its message will always win the bus (bussed CAN) and has a high priority for the scheduler (switched fabric CAN) even if the requested total load increases. However, the other nodes cannot achieve the requested throughput due to an increase of high priority messages. In the case of the bus, the impact of the high priority message on the other nodes is clear especially in Fig. 12. The node 1's throughput is affected by the presence of higher message priority from the load of 2000packets/s. The influence is more important for the lowest priority messages (node 2). We note that at 5000packet/s, the throughputs of node 1 and node 2 are affected and they achieve 95.78 and 90.26% respectively. In addition, at 104
                        packet/s, we notice that the throughputs of node 1 and node 2 are more affected and cannot exceed the 88.47 and 68.67% respectively.

However, in the case of the switched fabric, we note that, at 5000packet/s, the throughput of node 1 and node 2 is not affected and it is almost fully achieved (nearly 100%). The same with 3×104
                        packet/s, we see that the throughputs of node 1 and node 2 are respectively 98.43 and 97.3%.

Consequently, we conclude that the switched fabric CAN throughput measures are better than the CAN bus performance. Because of its access mechanism, the bus has limited throughput which has been resolved by the switch fabric.

In both models, 93μs is the minimum time delay needed to transfer a packet over the bus and the switch fabric.

In the case of the bus, Fig. 13
                         shows that the latency (for all nodes) starts to be constant (93μs) from 10packets/s till 1000packets/s. But when the requested total load exceeds the 1000packets/s, the latency delay of both nodes 1 and 2 is higher than the one of node 0 because of the higher priority messages generated by node 0.

At 5000packets/s, the latencies of node 0, node 1 and node 2 reach 115.25, 115.79 and 116.09μs respectively, in the case of the bus. But at 2×104
                        packets/s, the latency is very high and it can reach 256μs for node 2. However, in the case of the switched fabric, we note that at 5000packet/s, the latency does not exceed the average of 98μs for all the nodes and it is 111.71, 121.17 and 151.53μs respectively for node 0, node 1 and node 2 at 2×104
                        packets/s. We can also notice that the switched fabric CAN has less latency delay compared to the bussed CAN due to the parallelism.


                        Fig. 14
                         presents the global loss probability on CAN bus and the different message classes. We can see that the loss probability increases when the node has the lowest priority. In fact, node 2 and node 1 lost easily their messages with the presence of higher priority messages produced by node 0.

In the case of the bus, the figure above shows that the global loss probability increases from the load of 3000packets/s. In fact, it reaches 6.16% at 5000packets/s distributed between medium and low priority nodes: 1.26% for node 1 and 4.84% for node 2. In addition, at the 104
                        packet/s load, the global loss is approximately 20%.

However, In the case of the switched fabric, Fig. 19 shows that the global loss probability doesn't increase before the load of 2×104
                        packets/s. We note also, that at this load value, the global loss is approximately 0.5% and it can reach 5% only after the load is at least 3×104
                        packets/s.

Taking previous findings into account, we note that the crossbar-based switched fabric is more reliable than the bus for the CAN protocol and we can argue that switched fabric CAN networks guarantee reliability with its low loss probability and real-time constraints with its short time latency. Besides, it has been shown that the proposed CAN exceeds in throughput performance.

@&#CONCLUSION@&#

In this paper, two CAN controllers with different architectures (bussed and switched fabric) have been modeled using stochastic and colored Petri nets.

Performance evaluation was then applied to the models to extract information on network performance metrics and to compare those using CPN Tools.

We concluded that the designed crossbar-based switch fabric CAN strive for an efficient and high-performance network. CAN will last for a long period before its replacement and it can compete the new sophisticated buses when they join a switch fabric to it.

In future works, other scheduling policies such as WRR policy, I-SLIP and earliest deadline first (EDF) can be studied and compared to implement a very performing switched fabric CAN with 32 nodes using 32×32 crossbar-based switched fabric.

@&#REFERENCES@&#

