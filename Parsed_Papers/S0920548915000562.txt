@&#MAIN-TITLE@&#VGPM: Using business process modeling for videogame modeling and code generation in multiple platforms

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Apply BPM and its features to the modeling of the game loop of a videogame


                        
                        
                           
                           Work in collaboration with a videogame design tool


                        
                        
                           
                           Use the process models generated by the domain experts to generate a videogame


                        
                        
                           
                           Reduce the cost of developing a videogame


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Business process modeling

Modeling tools

Code generation

Videogames

@&#ABSTRACT@&#


               
               
                  Lately, the use of mobile applications in Smartphones has grown considerably. One of the most popular types of applications is videogames. As classic videogame development is a costly process several editors and tools to make this process quicker and easier have appeared. Although these editors allow the definition of various aspects of the videogame they do not include, in general, capabilities for modeling the logic of the game loop. In this research we propose VGPM, a specific notation based in the BPMN approach to define several important characteristics of the game logic, trying to reduce the cost of traditional videogame development.
               
            

@&#INTRODUCTION@&#

The requirements engineering phase of a software project is the first task of the software development process. As it states the needs and constraints of the program that is going to be created, it is a very important part of the development cycle. However, the ambiguous nature of the natural language and the ignorance of the problem's domain shown by the computer experts make this task error prone [1]. As the cost of the errors that appear during this initial phase of the software development process is really high, the Object Management Group (OMG) contributed to the creation of the Business Process Management Initiative (BPMI), which promoted the use of graphical notations that lie between the problem's domain and technical knowledge.

During the last few years several languages or notations for business process modeling have been defined. The most widely known is BPMN [13,37], which is the standard notation proposed by the OMG and has currently more than 70 implementations. Despite the initial objectives [2], the standardization process that BPMN is involved in makes the notation grow in size and complexity to the point where non-technical computer experts may need to undergo training programs to use the notation correctly [8]. Due to this circumstance several simplifications of the standard notation have been appearing, like jPDL, UML Activity Diagrams [4] and SBPMN [6,14] for example. These simplifications try to reduce the difficulties shown by the experts when using BPMN and, thus, reduce the number of errors found in the process models. Despite these technical difficulties, business process modeling notations like the ones mentioned have been used to model different types of systems, like public administration processes [10] and automotive industry related processes [9]. However, the main area of focus for this type of systems is the generation applications to give support for these processes.

Some works included in previous numbers of this same journal address the adaptation of a notation to increase its efficiency in given domains or scenarios; for example, [13] states how BPMN can be adapted in order to reduce its complexity and make it more efficient for modeling simple business processes. This journal also contains investigations regarding another type of approach when dealing with this type of notations: the creation of specific languages or methods for given domains. Despite the fact that the techniques and principles included in these types of works like the PoEML [38] and XSDyM [39] proposals are interesting and can be exported to similar investigation efforts, journal audiences can find the domains where they focus as unattractive.

During these last few years there has been a great increase in popularity of a sector inside information technology: videogames. This popularity has grown to the point where the videogame industry has managed to create more benefits than other very popular industries like music and cinema. This situation has been favored by two circumstances: the introduction of videogame playing in modern mobile devices like smartphones and tablets and the appearance of videogame design tools intended for videogame players and designer to create games.

When talking about videogames, the requirements specification of the game can be found in the business logic behind the game loop. The game loop is a representation of each of the actions that need to be done per cycle of execution during the game. For example, a simple game loop could be: move the character, simulate the artificial intelligence and refresh the interface. These three actions represent how the videogame works and they need to be executed a fixed number of times per second, as the animation of the images representing the videogame's elements must be done repeatedly. Despite the existence of the mentioned tools, videogame creation remains difficult for non-technical designers, as some programming knowledge is needed to define the business logic behind the game loop.

With this current scenario, our main goal is to enable the definition of the videogame's game loop using the bases of the BPMN standard. We will define a language that contains a set of specific elements based on BPMN principles. These set of elements allows users to model game loops with high level of personalization and without the need for programming skills. The users will use the proposal to define their own game loop logic using a graphical editor for modeling it and the editor will automatically generate a specific model that contains the game loop process, a model which will meet the BPMN standard. This graphical editor will include only those elements defined in the proposal, instead of all BPMN generic elements. The users can use in their design a set of defined elements, elements that can be combined in concrete ways applying some restrictions and evaluations. The generated models are fully compatible with tools based on BPMN standards.

BPMN is used in many situations to provide a working environment that allows non-technical domain experts to define and model the logic of a business process. BPMN is a generic language contrived to model many different types of process. BPMN models use generic elements like Event, Activity, Gateway, etc., which are not linked to any concrete business area like, for example, e-commerce, e learning, etc. Users must use these generic BPMN elements in the best way, trying to adapt them to their own business areas. But it is not possible for the BPMN editor to apply the specific rules that a concrete business area has; for example, the BPMN editor cannot “understand” that Activity B depends on other Activity C, or that there cannot be more than two instances of the Activity E in the same process.

Designing a language based on the BPMN bases and centered in a concrete business area we will achieve to reduce the level of complexity of model designing. The user will use a closed set of elements closely related with the business domain to create the models, elements that can only be used in a specific way depending on the restrictions and validations that form the business domain. In this way the design of a model is closer to the real domain of the problem than to the BPMN bases.

The design of such a proposal requires a meticulous analysis of the business model, defining all the significant elements and relations that can allow users to design a BPMN model that fully meets the requirements of the business domain. Another key issue is how to represent the concrete business domain with BPMN bases, as it is necessary to obtain the adequate level of expressiveness and power. Besides, tools that allow users to design these models in an easy way must be defined and built. These tools must generate BPMN models that ensure interoperability with BPMN technologies and tools. Using the resulting models it is possible to develop a set of rules and a transformation engine that would be able to transform each element of the model in a source code fragment. In this way a user without programing-skills but with strong domain knowledge will be able to design and generate a functional software artifact.

We have explored different approaches for creating specific languages based on the adaptation of BPMN to concrete business logic. Our previous work included the designing of a simple BPMN language that can be used to design product catalog applications for mobile devices. In this way the language allowed non-technical users to develop a model using a specific platform composed by a graphical editor and a transformation engine. The model developed by the user in the graphical editor represents the functionality of the product catalog. Also we defined a set of transformation rules that can transform the elements of the generated model in functional source code, specifically Android applications.

In this evolution we propose a much more ambitious challenge that consists in the definition of a language that can be used to define the game loop logic of videogames. A graphical editor and a transformation engine, able to generate functional source code, will support the language. The game loop is an important and complex part of videogames, as its logic can affect all of the game and the personalization of this element can be become a powerful tool to game developers. Enabling the configuration and personalization of the game loop logic in a graphical way is an ambitious task, so much that currently none of the commercial videogame editors support this feature. Our approach consist in the design of a specific language based on BPMN that would enable users to model the game loop logic and include these tools as a part of the GADE4ALL game editor [18], a videogame design tool that is currently under development at our research group. This tool is capable of generating natively coded videogames for the following platforms: iOS, Android and HTML5. We must clearly state that the GADE4ALL tool is designed to edit the contents (graphics, scenario, etc.) of videogames but like other game editors currently does not allow managing or editing the game loop logic.

The rest of this paper will be divided into the following sections. Section 2 will introduce the user to the actual videogame market, including statistics measuring the growth this industry has experienced in the last few years and a videogame family definition. Once the background has been introduced, Section 3 will showcase the possibilities BPM brings, in our opinion, to the modeling of videogames inside the different families previously defined. This third section will also present to the reader the complete videogame generation process, explaining in detail some of the phases. Section 4 will be focused on the evaluation of the tools presented and the code they generate. Section 5 will be dedicated to the conclusions obtained during our work and, lastly, Section 6 will present the future work we intend to complete for the improvement of the tools and the videogames.

@&#BACKGROUND@&#

In order to introduce the audience to the domain being addressed in this work, we must begin by talking about the figures that represent videogames in society right now. The videogame industry has become one of the most important and profitable industries around the world during the last few years [16], reaching nearly 68 billion dollars in sales in the year 2012 [17]. With these results, the videogame industry has not only become greater than the music and movie industry in the United States of America but is also greater than the music industry in the UK since the year 2008.

With this current usage scenario, videogames have had a great impact the commercial software industry. Due to this gain in importance, videogame development has evolved and now offers two main alternatives: videogame editors capable of modeling the elements and their behavior and the use of specific videogames frameworks. Nowadays, there are several computer tools that allow users with some programming background to design and create their own videogames through the definition of the game's elements and their behavior. Three of the most widely used tools are: GameMaker: Studio [20], GameSalad [21] and Stencyl [22].


                        Studio is a videogame design and development tool intended both for novice and expert videogame creators. It allows the creation of games for a variety of platforms, including the following: iOS, Android and PC. GameMaker Studio is based on a custom, interpreted language based on scripts called Game Maker Language or GML. This language is focused on the videogame experts. This tool uses the drag and drop functionality for the configuration of the interactions and the relationships between the objects included in the game. This functionality tries to simplify the creation of the game's elements and minimizes code writing.


                        GameSalad is a videogame design tool that allows users to create games for the following platforms: Android, HTML5 and Mac (both iOS and Mac OS X). GameSalad divides the videogame creation effort into scenes, the different screens of the game, and actors, objects involved in the game. For the definition of the actors, the user is able to configure parameters like appearance, behavior and associated sounds. Once the actors have been designed the user needs to configure a series of rules for them, which can be extracted from the library contained in the tool, customized by modifying the existing rules or created by the user from scratch.


                        Stencyl is a videogame design tool created by the company named StencylWorks. It includes the capability of exporting games for Mac (both iOS and Mac OS X included), Windows and Android. The tool was launched in 2011 and has been used by a great number of users, reaching a significant level of popularity. It is worth noting that some of the games created with this tool have, at some point, been in the top rankings of the application stores for each platform. Stencyl conceives videogames in the same way as GameSalad and so, divides its creation in scenes and actors. The actors can be any type of element with graphic representation in the game, regardless of the existence or absence of any behavior throughout the games execution. The creation environment offered by Stencyl is fairly similar to the environments provided by some of the most popular design tools existing nowadays. However, intensive use of this tool requires certain programming and algorithm knowledge, as changes in the videogame's behavior are done in a pseudo-code styled flow chart.

As it can be seen, all of these tools offer a similar range of functionalities and operations. They allow the definition of all of the elements that participate in the videogame through a series of parameters and rules, and these elements can then be used for the definition of the levels. This approach gives the tools a high configuration power but also introduces some difficulty, as the behavior is defined with a kind of pseudo-code. Furthermore, the similarities in functionality also mean there are similar limitations. In first place it is worth noting that all of them ignore the creation of the menus and configuration screens that are present in most of the games; they focus only in the creation of the screens representing the game's levels. Other of the existing problems is the need of programming skills for the definition of the actors' functionality, which is present, to a lesser or greater extent, in the three tools. It is also very important that the output of all of these tools is a functional packed videogame, which means that the files for the code and the designed levels remain inaccessible for the designer. This second limitation is directly related with the proposal that will be introduced in the next section, as access to the actual code is needed in order to include the game's behavior using the process model created with the BPLOM methodology.

The other existing alternative for the development of videogames is the use of frameworks like Cocos2d [23] and Unity [24], for example. These are specifically designed to easily manage recurring tasks that need to be accomplished repeatedly through the code that makes up a videogame. For example, the creation of the graphical representation of a character in a videogame can be reduced to making a call to a single method. The main drawback for the use of these frameworks in our current target scenario is the low level of abstraction experienced by the users, as all of these frameworks must be used by writing native code for the desired platform.

There are many researchers focused on the design of tools or platforms for game modeling, mainly serious games but also entertainment software. Serious games are games that possess educational value and can be used for learning and other educational purposes [25].

Most of these solutions raise systems to reduce the complexity of the game's development in many different ways. For example, creating specific frameworks that simplify the development task [26,27]. Other proposals raises platforms that avoid the need to write code or avoid the specification of special technical features related with the devices executing the games. Many proposals defend that the use of specific tools for modeling videogames can make game development accessible for non-technical people.

Game Technology Model (GTM) [28] uses the Model Drive Engineering (MDE) to define a high-level authoring tool for serious games targeted at non-domain experts. The proposal defines an abstract representation of the game that is independent from the implementation, and allows the definition of a lot of presentation and functionality elements included in the game. The proposal uses a fixed structure for the main game loop, based on the typical structure for this type of element. This proposal has many similarities with the first version of the Gade4all tool that is also considered an assistant application to define many of the elements in the game, but neither the Game Technology Model proposal nor the Gade4all initial version offer a specific interface or tool to allow the user to modify the structure of the game loop.

NICE-GAME [29] is a platform that allows the generation of educational games based on integrating learning objects inside a game scenario. The editor is mainly focused on the contents of the game's videos and images. These games are not very complex from the technological point of view because they are simple games conceived to run inside of a LMS. They are considered as a new type of learning object that presents the course's contents to the students in a dynamic and interactive way.

Other proposals do not use classical graphical editors or tools; they are based on novel methods to define the content of the game. For example, [30] analyzes a text/story introduced by the user and selects the key words to generate a virtual world (RPG-game). Some platforms or tools allow their user to design very specific games, focused on very specific domains, for example market simulators [31,32]. In the case of these very specific games the need of personalization for the more technical features of the game is usually much lower.

Mobile games popularity has increased in the recent years and few mobile platforms allow users without technical skills to design mobile video games, as most of these platforms are centered in the definition of the game content (characters, scenarios) and do not allow the definition of an important set of technical features. The game editors and generators are a good alternative for people without technical skills and for enterprises that want to reduce the development times using automated processes.

For a game designer, platforms that allow defining the game's technical aspects are too complex. These platforms commonly require the definition of several transformation processes to transform a game specification (graphical/text) into functional source code. Other of the big advantages of these platforms is that they can generate source code for more than one platform (Android, iOS, Windows Phone, etc.) using only one game specification. Many developers choose to use cross platform to get in a faster way source code for more than one mobile platform [33], but these platforms are only a valid option for people with technical skills.

Some proposals like EDGE (Easy Design tool of Game Event for rapid game Development) or [34] allow users to define some game features and elements without programing, but in many cases this type of proposals are only focused in few game features, for example the sprites or the effects. These proposals do not allow modifying some complex game features but they have other advantages: for example, they allow the rapid game development. Other proposals allow scene edition, allowing designing scenes without programing skills and with a platform independent scenario [35].

The tool [34] is mainly focused on the design of paths for racing games, raising a specific editor that can be used in an easy way to accomplish this task. In this case, the users do not need technical skills because the proposed tool does not require programing knowledge. In a similar way to some of the other proposals it allows the scene/word edition using specific editors which allow users to design game scenes without programming. This is a faster method than designing for independent of the platform [35]. The tool [36] allows the user to model the intelligence of the enemies in a graphic way using a drop down editor. Users can define the enemy behavior linking boxes that represent different behaviors and reasoning.

One of the motivations of our proposal is related to the previous analyzed proposal [34]. Some types of games are very complex because they involve the use of a lot of different components and technical aspects. When researchers rise to create a platform that allows users to define and generate videogames they find a lot of challenges. The design and implementation of this kind of platforms is probably very complex, and the resulting platform may not be appropriate for people with non-technical skills. The level of abstraction and the quality of the editing tools are very important factors in this type of platforms, therefore many researchers choose to design specific tool for modeling specific aspects of the game instead of the whole of the game.

As it was mentioned in the introduction of this research work, the main focus point is the creation of a specific graphic modeling language to allow users to model the game loop logic. In order to meet this objective we are going to design a domain specific language based on the BPMN standard. BPMN is a powerful modeling language for defining any kind business process and a wide range of tools support it. BPMN models use generic elements like Event, Activity, Gateway, etc. These elements are not linked to any specific business area, for example e-commerce, so it can be difficult for the user to model a concrete e-commerce process because BPMN does not contain specific activities for this area and does not include restrictions or checks applicable to this business area. The same happens with the game loop logic, BPMN bases can be a very good start point to model the process of a game loop, but this task will not be easy for users if we let them use BPMN in a generic way.

In this research work we define a novel language based on BPMN that will be specifically created to model the game loop logic. The defined language will include a set of specific elements which can be used in a given way to apply some restrictions and validations that belong to the concrete business domain: videogames. To design the language we have used the years of experience that our group has in game development and also we conducted some interviews with other videogames developers. As a result of this analysis process we obtained a set of elements and functionalities that are very important in the development of the game loop process. Then we merged this knowledge with a process that aims to offer a way to model videogames using the defined key elements in a BPMN based editor, which include specific elements of the videogame domain instead of generic elements. This greatly facilitates the user's task in the game loop modeling and also narrows the user changes in a controlled and logic framework. The processes that users generate are based on BPMN standards so they are interoperable with other BPMN tools. We also developed a generation engine that transforms the elements included in the model into source code, and this source code combined with the editor GADE4ALL enables to generate full functionally videogames with a game logic that was configured by the user in a graphical way.

The proposed set of entities and relationships is based on the basic element set that forms the BPLOM methodology and adapted, through the collaboration of these experts, to the needs of the given domain. Thus, depending on the domain the entity set can end up being completely different. This collaboration process is fundamental because it brings together the technical knowledge of computer experts with the domain comprehension of the business experts. But BPLOM is not only focused on the creation of specific modeling systems and languages that allow experts to define their models. Another of the key objectives included in the BPLOM proposal is to transform the process models created by the experts into source code or working software artifacts, in such a way that the development processes in several domains can be simplified and shortened.

The BPLOM methodology was previously used in the commercial mobile application domain for the creation of mobile apps that showcased product catalogs. Working together, the BPLOM expert group and the mobile applications development team defined a set of important elements for the product catalog domain, elements based on the basic entities of the BPM approach. This set of elements was suitable for experts to correctly define product catalogs and in combination with a set of transformations defined by the technical experts the models were converted into the source code for the catalog applications.

In this research work we will be using BPLOM to define the business logic of videogames: the game loop. With this approach we intend to allow non-technical domain experts to define, with an adequate level of detail, this relatively complex element of a videogame. A team formed by domain experts with great videogame development experience and a group of modeling experts with knowledge in the creation of tools based on the BPM approach, models and transformation motors will be working together to achieve the creation of a system focused on two objectives: the modeling of the business logic behind the game loop with a high level of detail and the transformation of the model into the source code of a multiplatform videogame.

A summary of the structure of the proposed used scenario is shown in Fig. 1
                     , where the whole modeling and code generation structure can be overviewed. As it is shown in this scenario, videogame experts will be able to model the game loop logic and also model the game data using the GADE4ALL editor. The model that contains the game loop business logic meets the BPMN standards and uses a set of specific elements to define the functionality of the game logic. The model that contains the videogame data defines the appearance and parameters of the game elements, like players, enemies, scenarios, etc. Both models will be inputs of the generator tool, which takes the game templates and completes them with the videogame data defined by the user. Then the generator analyzes every element and relation contained in the model that defines the game loop logic: for every element the generator contains a transformation rule and can transform the BPMN element into a specific snippet of source code. When the generator finalizes the processing of the model, it outputs a full snippet of code that can be inserted in the game template. This source code will replace the default game logic source code that the template contains. The full code generation can be done, at this moment, for three different platforms (iOS, Android and HTML5) that allow the generated videogames to be available for the majority of mobile devices and, at the same time, for web systems.

In order to apply the code template and code generation functionality in a more efficient and organized way, the GADE4ALL development team decided to classify the videogames into typologies or families. These families or typologies were chosen based on the kind of games that obtain greater interest rates not only from the player's points of view but also from the developer's standpoint. The current supported typologies are the following:
                           
                              •
                              
                                 Touch: This type of game, also known as endless runner, is based on a main character that runs through a level full of enemies and collectible objects or items.


                                 Strategy: This typology represents a classical turn-based strategy game.


                                 Trivial: Trivial games are composed by a number of levels containing sets of questions.


                                 Platforms: Platforms is another of the most played and developed videogame families. The main difference of this type of game is that the map can be bigger than the device's screen and the character is able to scroll through the map freely.


                                 Puzzle: Puzzle games are based on a series of colored pieces that are fired onto the screen with the objective of joining a given number of pieces of the same color in order for them to explode.

Further explanation about each of the presented families and videogame examples can be found in the previous work published about the GADE4ALL project [18].

Despite the existence of several business process modeling languages or notations like BPMN, jPDL, UML Activity Diagrams and others, there are several recurring problems for they use. As the reviewed literature points out [3,5,7], these problems can be grouped into two different but closely related topics: the high level of complexity due to the great number of symbols available for the modeling and the low level of usage and user comprehension that some of the symbols possess. For example, the standardization process that BPMN underwent made the notation's complexity rise to the point where, as pointed out by Wahl and Sindre [5], some users need to undergo a training procedure in order to use its features correctly. There are other publications that refer to the low use experienced by some of the BPMN symbols.

Our research group has focused, with some of its past work, in the creation of a simplified notation that would be suitable for domain experts with little or no technical knowledge. The first effort related with this was Simple BPMN (SBPMN) [6,14], which promoted the reduction of the BPMN's symbol set as a way of reducing the errors made by business experts when modeling their processes. SBPMN offered the user 18 symbols divided into the following categories: gateways, events, tasks, data objects and sub processes. During the testing procedure, SBPMN was capable of reducing the errors made by the business experts when modeling their processes in comparison with BPMN: the standard notation obtained a rate of more than 50% of errors while SBPMN obtained an error rate of less than 20%.

Based on the good results obtained by SBPMN and encouraged by the complexity issues, we decided to go a step further and define the modeling notation with the most reduced entity set possible: BPMN MUSIM [11,19]. It offers 5 symbols for process modeling and it is targeted at business domain experts with none or little technological knowledge. In order to test the suitability of this approach for real use, we introduced our notation in a Spanish enterprise throughout the use of a custom model tool supporting the notation [12]. As the results for BPMN MUSIM show [15,19], the notation obtained good results in the following areas: the easy understanding of the symbols in comparison to those found in the standard modeling notation, the lack of need for more symbols in order to model business process completely and a reduction in the effort needed for the development of custom applications.

However, the expressive power of BPMN MUSIM remains very low when compared with the other notations mentioned in this paper. Due to this circumstance we decided to define a business process modeling methodology that divides the symbols available for process modeling into sets or groups with increasing expressivity and complexity levels, promoting the adaptation of the symbol set to the knowledge and expertise of the business expert. We called this methodology BPLOM [15]. Using BPMN MUSIM as the initial and basic level (level 0), the symbol set available for process modeling is increased by adding other symbols throughout the following levels:
                           
                              •
                              
                                 Level 1, the decision extension. This level adds the parallel decision, the inclusive decision and the join entities.


                                 Level 2, the event extension. It includes the following events: incoming and outgoing messages, time, error, cancelation and signal.


                                 Level 3, the activity extension. This extension includes the following types of activities: call activities, sub processes and event triggered sub processes.


                                 Level 4, the data extension. The last level of the methodology offers the following data handling entities: data object, object collection and warehouse.

When BPLOM's highest level is used, the user has 20 symbols or constructions available for modeling his process, conferring the methodology a similar expressive power to that of SBPMN [6].

Throughout the interviews with the domain experts and based on our long experience in the game development we can define the elements that are more relevant for the definition of the game loop flow. These elements are going to be transformed into elements of the notation language and may belong to one of each 5 levels, as this way the new language will be adapted to the BPMN basics which are too the BPLOM bases.

The proposed language uses a set of a specific tasks like: start interaction, load the game elements (Characters, Map, Enemy, Items, etc.), move enemies, check different states of the game, etc. Depending on the game's typology (Strategy, Puzzle, Trivia, Touch, Platforms) the graphical editor will use the set of tasks that adapts to the typology's fundamentals. In this way the user can model the game loop functionality using BPMN in a non-generic way and achieving the following benefits: faster modeling with less workload and in a controlled environment where it is difficult for the user to make mistakes.


                        Fig. 2
                         shows the game loop of a turn-based strategy videogame when using the five levels that make up BPLOM. As it can be seen, the first part of the model represents the loading of the data that makes up the elements of the game: characters, enemies and map. After all of the details are loaded, the interactive part of the model starts; after refreshing the interface, the game waits for the user to select a character to move or to attack one of the enemies. Once the interaction is done, the game checks in first place if the game has ended with this interaction and afterwards if the user's turn is over. In case the turn is over, the artificial intelligence of the game simulates the enemy's turn and then returns the execution to the interface refreshing activity. If, on the contrary, the game has ended with the user's interaction, the game loop is ended and the corresponding message is shown to the user.

BPLevel Modeler is a business process-modeling tool that supports the BPM Level Oriented Methodology proposed in another publication [15] and briefly explained in the previous section of this paper. Despite the platform independency of the methodology, this tool has been developed under the .NET platform, as Windows Workflow Foundation offers an attractive scenario for developing highly configurable business process modeling tools. This decision has no effect on the methodology's platform independency, as the modeled processes are stored in enriched XML files that, as will be shown later, can be transformed into native code for different platforms.

The graphical user interface of BPLevel Modeler is shown in Fig. 3
                        , where a simple process model is shown. As it can be seen, BPLevel Modeler has been kept as simple as possible in order to adapt to non-technical experts' computer skill levels. Due to this need for simplicity BPLevel Modeler has only one screen, which has been divided into three different areas:

The entity section, on the left hand side of the screen, contains the different entities that can be used during process modeling. This section has been divided into five different categories, basic activities and decision and extension sections for decisions, events, activities and data. The modeling section takes the center of the interface and is intended for the definition of the business process. It is closely related to the entity section, as the components in it can be dragged into the modeling section to define the desired business process. The property section, situated on the right hand side of the tool's screen, contains the property view of the elements. The contents of this section depend on the element selected in the modeling section.

BPLevel Modeler must also adapt to the skill level presented by the user. In order to do so, when the tool is executed it will ask the user his knowledge level and based on the expert's choice the entity section will be adapted to show only the corresponding elements. Fig. 3 shows the graphical editor during the modeling of a game loop.

The GADE4ALL videogame editor [18] is the tool we have created as an alternative to the commercial videogame designing tools introduced in a preceding section of this paper. This videogame editor supports the definition of all of the videogame components: menu screens, actors (character, enemies and items) and levels. As the GADE4ALL tool has been designed after a study of some of tools previously presented, its design and functionality are fairly similar to those of the mentioned tools. These similarities include the existence of similar interfaces for the definition of the graphical appearance of the elements and the inclusion of the drag and drop functionality for the introduction of the elements in the levels.


                        Fig. 4
                         shows the graphical user interface of GADE4ALL character definition screen, where the user can define both the graphical aspect of the character and its behavior inside the game. The main difference with the other tools mentioned in this paper is how the behavior of the elements is defined. As it can be seen, the user is able to select the behavior that will be associated to the element through a drop list that includes a textual description of the possibilities. This approach removes the need to define it through a pseudo-code flow chart like in the commercial tools previously presented. Obviously, this configuration has a reduced expressive power compared to that of the commercial tools, as the behavior is limited to the possibilities included in the code templates. However, this reduction manages to increase the abstraction level experienced by the user when defining his videogames and reduces the need for programming skills.

BPLevel Generator is a code generation application that analyzes the game loop process files built with BPLevel Modeler and generates the corresponding multiplatform videogames. In this case, BPLevel Generator is used for videogame generation but in other usage scenarios [12,15] it can also generate other types of applications. Despite the fact that this tool is intended for computer experts, its interface has also been kept as simple as possible.

BPLevel Generator is the tool intended for the generation of the code representing the videogame modeled with BPLevel Modeler and designed with the GADE4ALL tool. This tool requires the user to introduce several pieces of information:
                           
                              •
                              The BPLevel Modeler file that represents the process that is going to be used as the basis for the code generation.

The path where the generated videogame(s) are going to be stored. Depending on how many generation platforms are selected, one or more games will be generated.

The route where the output of the GADE4ALL tool has been stored, as the generation process needs to have access to the definition of the game made with this tool.

The type of application that is going to be generated and the platform or platforms the application is going to be generated for. As it has already been pointed out, for the current scenario the type of application will always be videogame and the destination platforms can only be iOS, Android and HTML5. The family or typology of the game also needs to be specified and should match the kind of game created with the GADE4ALL tool.


                        Fig. 5
                         shows the insights of the proposed code generation phase, including some operative detail regarding BPLevel Generator. As it can be seen on the diagram, BPLevel Generator is based on the completing of three different but closely related tasks.
                           
                              1
                              When the user pushes the button that makes the generation process begin, BPLevel Generator begins its work by creating the folder structure needed in the path designated by the user as the destiny location for the generated code. In order to complete this task it looks at the platforms the user selected in the graphical interface and copies the needed templates into the destiny path specified by the user. When this copying is done, the destiny path will contain one code template structure for each generation platform that has been selected.

Once the directory structure has been successfully created, the next step is to copy the needed resources into the different templates. As the templates represent videogames there are three types of resources: images, sounds and level files. The images correspond not only to the resources used to create the backgrounds and buttons used in the different screens of the app but also to the graphical representation of each element (character, enemy, object, etc.) defined with the GADE4ALL tool introduced earlier in this work. Sounds are related to the background music and the different sound effects that can be included in the game and the level files correspond to the internal representation of the game's levels, which were graphically designed with the GADE4ALL videogame editor.

The last operation of the generation process includes the analysis of the process model that defines the videogame's game loop and the code generation task, in this order. The analysis of the model is based on the study of the process model to identify the order in which the operations are done in the game loop, as a way of adapting the template's functionality to match the defined process. This first proceeding is based on code injection, as custom activities and entities used in the model contain the code that needs to be introduced in the template. Thus, at this point, this code is injected into the template in the order established in the process model.

Once the model analysis and code injection operations are over, the last step of BPLevel Generator is to substitute into the template the values representing the configuration of all the screens' elements (backgrounds, buttons and rest of components) included in the game. These values include the following information: the image representing the element, the horizontal and vertical coordinates where the element is located, the width and height values of the element when represented in the screen and, if needed, the color of the text included in the element. As all of these details are extracted from only one file (DSL.xml) of the videogame definition structure created by the GADE4ALL videogame editor, the videogame templates were also designed to contain all of this data in only one file (DSL file). Thus, the substitution of these values in the generated videogame and the expansion of the graphical composition of the template are much simpler.

The substitution process is done as explained in Fig. 6
                                 , where images of the iOS code and the xml file resulting from the videogame definition exemplify the proceeding. In this case, the figure shows only the parts relative to the play button in the main screen of the games, as the rest of the components are configured in the same way. The first part of the image shows how the template is configured in first place, with specific tags in each place where the values from the GADE4ALL editor have to be included, and then shows the content of the xml file outputted by the GADE4ALL editor where the same tags can be seen. The values included in the xml for these elements are then substituted into the template, leaving the code as seen in the third fragment of the figure; as it can be seen, BPLevel Generator searches for each of the tags included in the xml file and then substitutes the tag with the corresponding value. The values of these properties are then used to create the objects that are shown in the device's screen as seen in the last element of the figure, where the code to create a button in the iOS platform is shown.

Once the proposal has been introduced, the next step is to showcase how the whole videogame definition is done using it. In this case, the presented tools will be used to define and generate the turn-base strategy videogame defined by the process model seen in Fig. 2. Once the videogame functionality is modeled with BPLevel Modeler and stored in the computer, the GADE4ALL tool will be used to define the menus and elements of the videogame. In this case, the designed videogame will have the following elements: one type of character, one type of enemy, one type of obstacle and two types of tiles for the definition of the level. The existence of all these elements can be witnessed in Fig. 7
                     , where the level definition screen can be seen. This is the screen of the GADE4ALL tool that enables the user to define the composition of each of the levels included in the game. In the center of the interface the grid for the configuration of the game's levels can be seen and on the left hand side there is a list showing the available elements for this level's definition.

Once all the levels that form the videogame have been defined, the user can finish his interaction with the GADE4ALL tool. The next step is to use BPLevel Generator to create the code projects for each of the platforms the game is going to be deployed on. Once all the data required has been introduced in the interface of the generator tool, the user is able to press the generate button and begin the generation process. This process, previously described in detail and showcased in Fig. 5, produces a code project for each of the target deployment platforms selected by the user. In this case, the game will be deployed on the Android and iOS platforms, so two code projects are created in the corresponding directory of the computer.

In order to see the result of the generation operation done by BPLevel Modeler the user must import the generated projects into the corresponding integrated development environment, also known as IDE. In this case, as the target platforms are Android and iOS, the IDEs where the projects must be imported are Eclipse and XCode, respectively. When the projects have been imported there are two possible ways to execute them and check their behavior: using the emulators included with the development environments or attaching a physical device to the computer and deploying the videogames on it. In this case Fig. 8 and Fig. 9
                     
                      show two screenshots of the videogames being executed by the emulators provided by each platform. As it can be seen, both games have almost identical aspect in the two platforms, which is due to the substitution process designed to include some of the graphical details of the videogame in the project.

@&#CONCLUSIONS@&#

In this paper we present a novel proposal that allows users to model the game loop logic of the game: a specific language based on BPMN standards. The proposed language was designed using our own methodology that was refined by our research group with new iterations and use cases. We used this methodology to obtain information from the domain experts and detect that are the base elements and fundaments of the game loop and how these elements can be related between them. With the obtained info we were able to design an editor that is based on BPMN but which allows to model generic processes to define game loops logic. The elements of the language that can be handled in the editor are specific elements adapted to the current business area; these elements include restrictions and specific configuration properties. The specific language and the editor is the selected way to allow users without technical knowledge model easily a process that defines the logic of the game loop.

The definition process of the game loop logic is based on the combination of a set of elements that we have defined in the editor. The set of elements is the result of the first step of our research and these elements enable the definition of: logic decisions, game events, game activities and management data. The expressiveness and possibilities of the proposed language are significant and cover the majority of the most typical requirements in the game loop logic definition, but the language is not as powerful as other programming languages used in the videogame development industry like C++ or Java. The use of a concrete set of elements with well-defined combinations establishes some limitations in the definition of the game logic in comparison with these programming languages. Simultaneously, the use of these set of elements and rules allow non-programming users to define the game loop logic in an easy way and with a good level of expression and customization.

We integrated the proposal in the GADE4ALL editor to increase notably the functionality of this editor and the range of videogames that it can define and generate; making an evolution of the generic language BPMN directed towards game loop processes. We have designed a language that can be used to define, in a powerful way, the game logic using a set of specific modeling elements. As we demonstrated, the proposal was used to define in a graphical way some game loops processes that were transformed into fully functional games.

Several cases have shown in the past months that a quick response to the political, social or sporting events taking place around the world in the form of a videogame could mean a great sell success. This situation can be directly linked with the rapid app generation that can be achieved with our proposal. At the moment we offer code templates for five different types or families of games. These videogame families, in combination with the GADE4ALL editor and BPLevel Modeler, result in the creation of simple videogames in a short amount of time by a videogame expert with no programming experience. Thus, our approach is capable of reducing the complexity that non-technical domain experts experience when they design and create a videogame and also of improving the efficiency rates of traditional videogame development.

@&#FUTURE WORK@&#

The future work regarding this investigation is divided in the following areas:
                        
                           •
                           Continue defining videogame families or typologies in order to be able to generate a greater variety of videogames.

Include new platforms for videogame generation. The current range of supported platforms (Android, iOS and HTML5) was selected due to the broad audience it targets. However, other platforms like Windows Phone have appeared and should be considered as an alternative in newer versions of the proposed structure.

Add validation features to the XAML files representing the game loops of the defined videogames. With this validation we reduce the possibility of error appearance in the modeled videogame game loops.

Create a library of business processes representing commonly used game loops. These could be used as given or be used as the basis for a custom game loop. With these predefined game loops we could enable quicker videogame generation.

@&#ACKNOWLEDGMENTS@&#

This work has been partially funded by the Ministry of Industry, Energy and Tourism of Spain, by the Avanza2 plan and by the European Regional Development Fund through the project “GADE4ALL: Plataforma genérica para facilitar el desarrollo de videojuegos y software de entretenimiento multiplataforma”. The code for the project is MITC-11-TSI-090302-2011-11.

@&#REFERENCES@&#

